{
  "name": "Example 2",
  "createVersion": "2017-08-12",
  "description": "New Project",
  "lastModified": "2019-09-08T23:02:42.449Z",
  "created": "2019-09-08T23:02:42.449Z",
  "meta": {
    "projectTypeName": "NUCLEO-L476RG",
    "projectTypeId": "STM32L476RGNucleo"
  },
  "planes": {
    "NUCLEO-L476RG": {
      "type": "stm32",
      "compilerVersion": "latest",
      "variants": [
        "stm32l4",
        "STM32L476RGNucleo"
      ],
      "meta": {},
      "elements": [
        {
          "name": "GPIOPin",
          "type": "EmbeddedGPIOPin",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_GPIO_Config_t config;\n\tconfig.pinMode = ATMO_PROPERTY(GPIOPin, mode);\n\tconfig.initialState = ATMO_PROPERTY(GPIOPin, state);\n\tATMO_GPIO_SetPinConfiguration(ATMO_PROPERTY(GPIOPin, instance), ATMO_PROPERTY(GPIOPin, pin), &config);\n\n\t#if ATMO_PROPERTY(GPIOPin, interruptEnabled) == true\n\t\tATMO_GPIO_RegisterInterruptCallback(\n\t\t\tATMO_PROPERTY(GPIOPin, instance), \n\t\t\tATMO_PROPERTY(GPIOPin, pin), \n\t\t\tATMO_PROPERTY(GPIOPin, interruptMode), \n\t\t\tATMO_INTERRUPT(GPIOPin, interrupt));\n\t#endif\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setState": "\n\tATMO_BOOL_t state;\n\tATMO_GetBool(in, &state);\n\tATMO_GPIO_SetPinState(ATMO_PROPERTY(GPIOPin, instance), ATMO_PROPERTY(GPIOPin, pin), (ATMO_GPIO_PinState_t)state);\n\treturn ATMO_Status_Success;\n\t",
              "setPinHigh": "\n\tATMO_GPIO_SetPinState(ATMO_PROPERTY(GPIOPin, instance), ATMO_PROPERTY(GPIOPin, pin), ATMO_GPIO_PinState_High);\n\treturn ATMO_Status_Success;\n\t",
              "setPinLow": "\n\tATMO_GPIO_SetPinState(ATMO_PROPERTY(GPIOPin, instance), ATMO_PROPERTY(GPIOPin, pin), ATMO_GPIO_PinState_Low);\n\treturn ATMO_Status_Success;\n\t",
              "read": "\n\tATMO_CreateValueBool(out, ATMO_GPIO_Read(ATMO_PROPERTY(GPIOPin, instance), ATMO_PROPERTY(GPIOPin, pin)));\n\treturn ATMO_Status_Success;\n\t",
              "toggle": "\n\tATMO_GPIO_Toggle(ATMO_PROPERTY(GPIOPin, instance), ATMO_PROPERTY(GPIOPin, pin));\n\treturn ATMO_Status_Success;\n\t",
              "interrupt": "\n\tATMO_CreateValueCopy(out, in);\n\treturn ATMO_Status_Success;\n\t"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "setState": false,
              "setPinHigh": false,
              "setPinLow": false,
              "read": false,
              "toggle": false,
              "interrupt": false
            },
            "instance": "ATMO_DRIVERINSTANCE_GPIO_GPIO1",
            "pin": "D13",
            "mode": "ATMO_GPIO_PinMode_Output_PushPull",
            "state": "ATMO_GPIO_PinState_High",
            "interruptEnabled": false,
            "interruptMode": "ATMO_GPIO_InterruptTrigger_None"
          },
          "meta": {
            "editorX": 128,
            "editorY": 23,
            "lastTrigger": "interrupt"
          },
          "triggers": {
            "triggered": [],
            "stateSet": [],
            "read": [],
            "toggled": [],
            "interrupt": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setState": false,
            "setPinHigh": false,
            "setPinLow": false,
            "read": false,
            "toggle": false,
            "interrupt": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setState",
              "triggers": [
                "stateSet"
              ]
            },
            {
              "name": "setPinHigh",
              "triggers": [
                "stateSet"
              ]
            },
            {
              "name": "setPinLow",
              "triggers": [
                "stateSet"
              ]
            },
            {
              "name": "read",
              "triggers": [
                "read"
              ]
            },
            {
              "name": "toggle",
              "triggers": [
                "toggled"
              ]
            },
            {
              "name": "interrupt",
              "triggers": [
                "interrupt"
              ]
            }
          ]
        },
        {
          "name": "BlueNRG",
          "type": "EmbeddedBlueNRG",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "BLUENRG_Config_t config;\r\nconfig.intPin = ATMO_PROPERTY(BlueNRG, intPin);\r\nconfig.rstPin = ATMO_PROPERTY(BlueNRG, rstPin);\r\nconfig.csPin = ATMO_PROPERTY(BlueNRG, csPin);\r\nconfig.gpioHandle = ATMO_PROPERTY(BlueNRG, gpioDriverInstance);\r\nconfig.spiHandle = ATMO_PROPERTY(BlueNRG, spiDriverInstance);\r\nBLUENRG_Init(&config, &ATMO_INSTANCE(BlueNRG, BLE));\r\nreturn ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false
            },
            "gpioDriverInstance": "ATMO_DRIVERINSTANCE_GPIO_GPIO1",
            "spiDriverInstance": "ATMO_DRIVERINSTANCE_SPI_SPI1",
            "rstPin": "D7",
            "intPin": "A0",
            "csPin": "A1"
          },
          "meta": {
            "editorX": 27,
            "editorY": 110,
            "lastTrigger": "setup"
          },
          "triggers": {
            "triggered": [],
            "setup": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false
          },
          "implements": [
            "ble"
          ],
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": [
                "setup"
              ]
            }
          ]
        },
        {
          "name": "BLECharacteristicCustom",
          "type": "EmbeddedBLECharacteristicCustom",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(BLECharacteristicCustom, instance),\n\t\t&ATMO_VARIABLE(BLECharacteristicCustom, bleServiceHandle), \n\t\tATMO_PROPERTY(BLECharacteristicCustom, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(BLECharacteristicCustom, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(BLECharacteristicCustom, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(BLECharacteristicCustom, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(BLECharacteristicCustom, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(BLECharacteristicCustom, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(BLECharacteristicCustom, writeDataType), ATMO_PROPERTY(BLECharacteristicCustom, readDataType), ATMO_PROPERTY(BLECharacteristicCustom, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(BLECharacteristicCustom, instance),\n\t\t&ATMO_VARIABLE(BLECharacteristicCustom, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(BLECharacteristicCustom, bleServiceHandle), \n\t\tATMO_PROPERTY(BLECharacteristicCustom, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(BLECharacteristicCustom, instance),\n\t\tATMO_VARIABLE(BLECharacteristicCustom, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(BLECharacteristicCustom, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(BLECharacteristicCustom, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(BLECharacteristicCustom, instance),\n\t\tATMO_VARIABLE(BLECharacteristicCustom, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(BLECharacteristicCustom, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "ATMO_DRIVERINSTANCE_BLE_BlueNRG",
            "bleServiceUuid": "49cb301f-1a13-4f28-994d-bb6e0b5330cb",
            "bleCharacteristicUuid": "49cb301f-1a13-4f28-994d-bb6e0b5330cc",
            "read": true,
            "write": true,
            "notify": false,
            "readDataType": "ATMO_DATATYPE_VOID",
            "writeDataType": "ATMO_DATATYPE_VOID",
            "notifyDataType": "ATMO_DATATYPE_VOID"
          },
          "meta": {
            "editorX": 26,
            "editorY": 23,
            "lastTrigger": "written"
          },
          "triggers": {
            "triggered": [],
            "written": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "GPIOPin",
                "targetAbility": "toggle"
              }
            ],
            "subscibed": [],
            "unsubscribed": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setValue": "valueSet",
            "written": false,
            "subscibed": false,
            "unsubscribed": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setValue",
              "triggers": []
            },
            {
              "name": "written",
              "triggers": [
                "written"
              ]
            },
            {
              "name": "subscibed",
              "triggers": [
                "subscibed"
              ]
            },
            {
              "name": "unsubscribed",
              "triggers": [
                "unsubscribed"
              ]
            }
          ]
        }
      ],
      "libraries": {
        "bluenrg": {
          "libName": "bluenrg",
          "manufacturer": "STMicroelectronics",
          "description": "BlueNRG BLE Controller",
          "type": "BLE Board",
          "icon": "",
          "image": "",
          "version": "",
          "eelVersion": "3",
          "shoppingCartLinks": {
            "digikey": {
              "links": {
                "info": "https://www.digikey.com/short/pm2nhr"
              },
              "cartData": {
                "part": "497-15948-ND",
                "source": "dkstudio",
                "qty": "1"
              }
            }
          },
          "requires": [
            "embedded",
            "gpio",
            "spi"
          ],
          "elements": [
            {
              "name": "BlueNRG",
              "type": "EmbeddedBlueNRG",
              "icon": "EmbeddedBLEConnection.svg",
              "implements": [
                "ble"
              ],
              "defaultAbility": "setup",
              "defaultTrigger": "setup",
              "hidden": false,
              "abilities": [
                {
                  "name": "setup",
                  "triggers": [
                    "setup"
                  ],
                  "hidden": true,
                  "code": "BLUENRG_Config_t config;\r\nconfig.intPin = ATMO_PROPERTY(undefined, intPin);\r\nconfig.rstPin = ATMO_PROPERTY(undefined, rstPin);\r\nconfig.csPin = ATMO_PROPERTY(undefined, csPin);\r\nconfig.gpioHandle = ATMO_PROPERTY(undefined, gpioDriverInstance);\r\nconfig.spiHandle = ATMO_PROPERTY(undefined, spiDriverInstance);\r\nBLUENRG_Init(&config, &ATMO_INSTANCE(undefined, BLE));\r\nreturn ATMO_Status_Success;"
                }
              ],
              "properties": [
                {
                  "name": "gpioDriverInstance",
                  "input": "driverInstance",
                  "driverType": "gpio"
                },
                {
                  "name": "spiDriverInstance",
                  "input": "driverInstance",
                  "driverType": "spi"
                },
                {
                  "name": "rstPin",
                  "input": "number",
                  "value": 0
                },
                {
                  "name": "intPin",
                  "input": "number",
                  "value": 0
                },
                {
                  "name": "csPin",
                  "input": "number",
                  "value": 0
                }
              ],
              "triggers": [],
              "variables": [],
              "language": {
                "en-US": {
                  "EmbeddedBlueNRG": "BlueNRG BLE",
                  "gpioDriverInstance": "GPIO Driver Instance",
                  "spiDriverInstance": "SPI Driver Instance",
                  "setup": "Setup",
                  "rstPin": "Reset Pin",
                  "intPin": "Interrupt Pin",
                  "csPin": "Chip Select Pin"
                }
              }
            }
          ],
          "files": {
            "common": {
              "headers": {
                "bluenrg.h": "#ifndef __BLUENRG_H_\n#define __BLUENRG_H_\n\n#include \"../app_src/atmosphere_platform.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n    ATMO_DriverInstanceHandle_t spiHandle;\n    ATMO_DriverInstanceHandle_t gpioHandle;\n    ATMO_GPIO_Device_Pin_t csPin;\n    ATMO_GPIO_Device_Pin_t rstPin;\n    ATMO_GPIO_Device_Pin_t intPin;\n} BLUENRG_Config_t;\n\nATMO_BOOL_t BLUENRG_Init(const BLUENRG_Config_t *config, ATMO_DriverInstanceHandle_t *bleInstance);\n\nBLUENRG_Config_t *BLUENRG_GetConfig();\n\n\nATMO_Status_t BLUENRG_BLE_AddDriverInstance( ATMO_DriverInstanceHandle_t *instanceNumber );\n\nATMO_BLE_Status_t BLUENRG_BLE_PeripheralInit( ATMO_DriverInstanceData_t *instance );\n\nATMO_BLE_Status_t BLUENRG_BLE_PeripheralDeInit( ATMO_DriverInstanceData_t *instance );\n\nATMO_BLE_Status_t BLUENRG_BLE_SetEnabled( ATMO_DriverInstanceData_t *instance, bool enabled );\n\nATMO_BLE_Status_t BLUENRG_BLE_GetEnabled( ATMO_DriverInstanceData_t *instance, bool *enabled );\n\nATMO_BLE_Status_t BLUENRG_BLE_GetMacAddress( ATMO_DriverInstanceData_t *instance, ATMO_BLE_MacAddress_t *address );\n\nATMO_BLE_Status_t BLUENRG_BLE_GAPSetDeviceName( ATMO_DriverInstanceData_t *instance, const char *name );\n\nATMO_BLE_Status_t BLUENRG_BLE_GAPAdvertisingStart( ATMO_DriverInstanceData_t *instance, ATMO_BLE_AdvertisingParams_t *params );\n\nATMO_BLE_Status_t BLUENRG_BLE_GAPAdvertisingStop( ATMO_DriverInstanceData_t *instance );\n\nATMO_BLE_Status_t BLUENRG_BLE_GAPSetAdvertisedServiceUUID( ATMO_DriverInstanceData_t *instance, const char *uuid );\n\nATMO_BLE_Status_t BLUENRG_BLE_GAPAdverertisingSetManufacturerData( ATMO_DriverInstanceData_t *instance, ATMO_BLE_AdvertisingData_t *data );\n\nATMO_BLE_Status_t BLUENRG_BLE_GAPPairingCfg( ATMO_DriverInstanceData_t *instance, ATMO_BLE_PairingCfg_t *config );\n\nATMO_BLE_Status_t BLUENRG_BLE_GAPDisconnect( ATMO_DriverInstanceData_t *instance );\n\nATMO_BLE_Status_t BLUENRG_BLE_GATTSAddService( ATMO_DriverInstanceData_t *instance, ATMO_BLE_Handle_t *handle, const char *serviceUUID );\n\nATMO_BLE_Status_t BLUENRG_BLE_GATTSAddCharacteristic( ATMO_DriverInstanceData_t *instance, ATMO_BLE_Handle_t *handle, ATMO_BLE_Handle_t serviceHandle, const char *characteristicUUID, uint8_t properties, uint8_t permissions, uint32_t maxLen );\n\nATMO_BLE_Status_t BLUENRG_BLE_GATTSGetCharacteristicValue( ATMO_DriverInstanceData_t *instance, ATMO_BLE_Handle_t handle, uint8_t *valueBuf, uint32_t valueBufLen, uint32_t *valueLen );\n\nATMO_BLE_Status_t BLUENRG_BLE_GATTSRegisterCharacteristicCallback( ATMO_DriverInstanceData_t *instance, ATMO_BLE_Handle_t handle, ATMO_BLE_Characteristic_Event_t event, ATMO_Callback_t cbFunc );\n\nATMO_BLE_Status_t BLUENRG_BLE_GATTSRegisterCharacteristicAbilityHandle( ATMO_DriverInstanceData_t *instance, ATMO_BLE_Handle_t handle, ATMO_BLE_Characteristic_Event_t event, unsigned int abilityHandler );\n\nATMO_BLE_Status_t BLUENRG_BLE_GATTSSetCharacteristic( ATMO_DriverInstanceData_t *instance, ATMO_BLE_Handle_t handle, uint16_t length, uint8_t *value, ATMO_BLE_CharProperties_t *properties );\n\nATMO_BLE_Status_t BLUENRG_BLE_GATTSWriteDescriptor( ATMO_DriverInstanceData_t *instance, ATMO_BLE_Handle_t handle, uint16_t length, uint8_t *value, ATMO_BLE_CharProperties_t *properties );\n\nATMO_BLE_Status_t BLUENRG_BLE_GATTSSendIndicate( ATMO_DriverInstanceData_t *instance, ATMO_BLE_Handle_t handle, uint16_t size, uint8_t *value );\n\nATMO_BLE_Status_t BLUENRG_BLE_GATTSSendNotify( ATMO_DriverInstanceData_t *instance, ATMO_BLE_Handle_t handle, uint16_t size, uint8_t *value );\n\nATMO_BLE_Status_t BLUENRG_BLE_RegisterEventCallback( ATMO_DriverInstanceData_t *instance, ATMO_BLE_Event_t event, ATMO_Callback_t cb );\n\nATMO_BLE_Status_t BLUENRG_BLE_RegisterEventAbilityHandle( ATMO_DriverInstanceData_t *instance, ATMO_BLE_Event_t event, unsigned int abilityHandle );\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif"
              },
              "objects": {
                "ble_list.c": "/******************** (C) COPYRIGHT 2012 STMicroelectronics ********************\n* File Name          : ble_list.c\n* Author             : AMS - HEA&RF BU\n* Version            : V1.0.0\n* Date               : 19-July-2012\n* Description        : Circular Linked List Implementation.\n********************************************************************************\n* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\n* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.\n* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,\n* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE\n* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING\n* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\n*******************************************************************************/\n\n/******************************************************************************\n * Include Files\n******************************************************************************/\n#include \"ble_list.h\"\n#include <stdio.h>\n\n#include \"ble_list_utils.h\"\n\n/******************************************************************************\n * Function Definitions\n******************************************************************************/\nvoid list_init_head ( tListNode *listHead )\n{\n\tlistHead->next = listHead;\n\tlistHead->prev = listHead;\n}\n\nuint8_t list_is_empty ( tListNode *listHead )\n{\n\tuint8_t return_value;\n\n#ifdef STM32L476xx\n\tuint32_t uwPRIMASK_Bit;\n\tuwPRIMASK_Bit = __get_PRIMASK();  /**< backup PRIMASK bit */\n\t__disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/\n#endif\n\n\tif ( listHead->next == listHead )\n\t{\n\t\treturn_value = 1;\n\t}\n\telse\n\t{\n\t\treturn_value = 0;\n\t}\n\n#ifdef STM32L476xx\n\t__set_PRIMASK( uwPRIMASK_Bit );   /**< Restore PRIMASK bit*/\n#endif\n\n\treturn return_value;\n}\n\nvoid list_insert_head ( tListNode *listHead, tListNode *node )\n{\n#ifdef STM32L476xx\n\tuint32_t uwPRIMASK_Bit;\n\tuwPRIMASK_Bit = __get_PRIMASK();  /**< backup PRIMASK bit */\n\t__disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/\n#endif\n\n\tnode->next = listHead->next;\n\tnode->prev = listHead;\n\tlistHead->next = node;\n\t( node->next )->prev = node;\n\n#ifdef STM32L476xx\n\t__set_PRIMASK( uwPRIMASK_Bit );   /**< Restore PRIMASK bit*/\n#endif\n}\n\nvoid list_insert_tail ( tListNode *listHead, tListNode *node )\n{\n#ifdef STM32L476xx\n\tuint32_t uwPRIMASK_Bit;\n\tuwPRIMASK_Bit = __get_PRIMASK();  /**< backup PRIMASK bit */\n\t__disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/\n#endif\n\n\tnode->next = listHead;\n\tnode->prev = listHead->prev;\n\tlistHead->prev = node;\n\t( node->prev )->next = node;\n\n#ifdef STM32L476xx\n\t__set_PRIMASK( uwPRIMASK_Bit );   /**< Restore PRIMASK bit*/\n#endif\n}\n\nvoid list_remove_node ( tListNode *node )\n{\n#ifdef STM32L476xx\n\tuint32_t uwPRIMASK_Bit;\n\tuwPRIMASK_Bit = __get_PRIMASK();  /**< backup PRIMASK bit */\n\t__disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/\n#endif\n\n\t( node->prev )->next = node->next;\n\t( node->next )->prev = node->prev;\n\n#ifdef STM32L476xx\n\t__set_PRIMASK( uwPRIMASK_Bit );   /**< Restore PRIMASK bit*/\n#endif\n}\n\nvoid list_remove_head ( tListNode *listHead, tListNode **node )\n{\n#ifdef STM32L476xx\n\tuint32_t uwPRIMASK_Bit;\n\tuwPRIMASK_Bit = __get_PRIMASK();  /**< backup PRIMASK bit */\n\t__disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/\n#endif\n\n\t*node = listHead->next;\n\tlist_remove_node ( listHead->next );\n\t( *node )->next = NULL;\n\t( *node )->prev = NULL;\n\n#ifdef STM32L476xx\n\t__set_PRIMASK( uwPRIMASK_Bit );   /**< Restore PRIMASK bit*/\n#endif\n}\n\nvoid list_remove_tail ( tListNode *listHead, tListNode **node )\n{\n#ifdef STM32L476xx\n\tuint32_t uwPRIMASK_Bit;\n\tuwPRIMASK_Bit = __get_PRIMASK();  /**< backup PRIMASK bit */\n\t__disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/\n#endif\n\n\t*node = listHead->prev;\n\tlist_remove_node ( listHead->prev );\n\t( *node )->next = NULL;\n\t( *node )->prev = NULL;\n\n#ifdef STM32L476xx\n\t__set_PRIMASK( uwPRIMASK_Bit );   /**< Restore PRIMASK bit*/\n#endif\n}\n\nvoid list_insert_node_after ( tListNode *node, tListNode *ref_node )\n{\n#ifdef STM32L476xx\n\tuint32_t uwPRIMASK_Bit;\n\tuwPRIMASK_Bit = __get_PRIMASK();  /**< backup PRIMASK bit */\n\t__disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/\n#endif\n\n\tnode->next = ref_node->next;\n\tnode->prev = ref_node;\n\tref_node->next = node;\n\t( node->next )->prev = node;\n\n#ifdef STM32L476xx\n\t__set_PRIMASK( uwPRIMASK_Bit );   /**< Restore PRIMASK bit*/\n#endif\n}\n\nvoid list_insert_node_before ( tListNode *node, tListNode *ref_node )\n{\n#ifdef STM32L476xx\n\tuint32_t uwPRIMASK_Bit;\n\tuwPRIMASK_Bit = __get_PRIMASK();  /**< backup PRIMASK bit */\n\t__disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/\n#endif\n\n\tnode->next = ref_node;\n\tnode->prev = ref_node->prev;\n\tref_node->prev = node;\n\t( node->prev )->next = node;\n\n#ifdef STM32L476xx\n\t__set_PRIMASK( uwPRIMASK_Bit );   /**< Restore PRIMASK bit*/\n#endif\n}\n\nint list_get_size ( tListNode *listHead )\n{\n\tint size = 0;\n\ttListNode *temp;\n\n#ifdef STM32L476xx\n\tuint32_t uwPRIMASK_Bit;\n\tuwPRIMASK_Bit = __get_PRIMASK();  /**< backup PRIMASK bit */\n\t__disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/\n#endif\n\n\ttemp = listHead->next;\n\n\twhile ( temp != listHead )\n\t{\n\t\tsize++;\n\t\ttemp = temp->next;\n\t}\n\n#ifdef STM32L476xx\n\t__set_PRIMASK( uwPRIMASK_Bit );   /**< Restore PRIMASK bit*/\n#endif\n\n\treturn ( size );\n}\n\nvoid list_get_next_node ( tListNode *ref_node, tListNode **node )\n{\n#ifdef STM32L476xx\n\tuint32_t uwPRIMASK_Bit;\n\tuwPRIMASK_Bit = __get_PRIMASK();  /**< backup PRIMASK bit */\n\t__disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/\n#endif\n\n\t*node = ref_node->next;\n\n#ifdef STM32L476xx\n\t__set_PRIMASK( uwPRIMASK_Bit );   /**< Restore PRIMASK bit*/\n#endif\n}\n\nvoid list_get_prev_node ( tListNode *ref_node, tListNode **node )\n{\n#ifdef STM32L476xx\n\tuint32_t uwPRIMASK_Bit;\n\tuwPRIMASK_Bit = __get_PRIMASK();  /**< backup PRIMASK bit */\n\t__disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/\n#endif\n\n\t*node = ref_node->prev;\n\n#ifdef STM32L476xx\n\t__set_PRIMASK( uwPRIMASK_Bit );   /**< Restore PRIMASK bit*/\n#endif\n}\n\n",
                "ble_list.h": "/******************** (C) COPYRIGHT 2012 STMicroelectronics ********************\n* File Name          : ble_list.h\n* Author             : AMS - HEA&RF BU\n* Version            : V1.0.0\n* Date               : 19-July-2012\n* Description        : Header file for linked list library.\n********************************************************************************\n* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\n* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.\n* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,\n* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE\n* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING\n* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\n*******************************************************************************/\n#ifndef __BLE_LIST_H_\n#define __BLE_LIST_H_\n\n#include <stdint.h>\n\ntypedef struct _tListNode {\n  struct _tListNode * next;\n  struct _tListNode * prev;\n} tListNode, *pListNode;\n\nvoid list_init_head (tListNode * listHead);\n\nuint8_t list_is_empty (tListNode * listHead);\n\nvoid list_insert_head (tListNode * listHead, tListNode * node);\n\nvoid list_insert_tail (tListNode * listHead, tListNode * node);\n\nvoid list_remove_node (tListNode * node);\n\nvoid list_remove_head (tListNode * listHead, tListNode ** node );\n\nvoid list_remove_tail (tListNode * listHead, tListNode ** node );\n\nvoid list_insert_node_after (tListNode * node, tListNode * ref_node);\n\nvoid list_insert_node_before (tListNode * node, tListNode * ref_node);\n\nint list_get_size (tListNode * listHead);\n\nvoid list_get_next_node (tListNode * ref_node, tListNode ** node);\n\nvoid list_get_prev_node (tListNode * ref_node, tListNode ** node);\n\n#endif /* __BLE_LIST_H_ */\n",
                "ble_list_utils.h": "/**\n ******************************************************************************\n * File Name ble_list_utils.h\n * @author   CL\n * @version  V1.0.0\n * @date     12-Oct-2018\n * @brief \n ******************************************************************************\n  * @attention\n  *\n  * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.\n  * All rights reserved.</center></h2>\n  *\n  * This software component is licensed by ST under Ultimate Liberty license\n  * SLA0044, the \"License\"; You may not use this file except in compliance with\n  * the License. You may obtain a copy of the License at:\n  *                             www.st.com/SLA0044\n  *\n ******************************************************************************\n */\n\n/* Define to prevent recursive inclusion -------------------------------------*/\n#ifndef BLE_LIST_UTILS_H\n#define BLE_LIST_UTILS_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Includes ------------------------------------------------------------------*/\n#include \"../app_src/atmosphere_platform.h\"\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* BLE_LIST_UTILS_H */\n\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\n",
                "bluenrg.c": "#include \"bluenrg.h\"\n#include \"hci_tl.h\"\n#include \"link_layer.h\"\n#include \"bluenrg_utils.h\"\n#include \"bluenrg_gatt_server.h\"\n#include \"bluenrg_gap_aci.h\"\n#include \"bluenrg_gatt_aci.h\"\n#include \"bluenrg_hal_aci.h\"\n#include \"hci_const.h\"\n#include \"bluenrg_aci.h\"\n#include \"bluenrg_gap.h\"\n#include \"bluenrg_types.h\"\n#include \"sm.h\"\n\nstatic BLUENRG_Config_t _BLUENRG_PrivConfig;\n\nconst ATMO_BLE_DriverInstance_t sensortileBleDriverInstance =\n{\n\tBLUENRG_BLE_PeripheralInit,\n\tBLUENRG_BLE_PeripheralDeInit,\n\tBLUENRG_BLE_SetEnabled,\n\tBLUENRG_BLE_GetEnabled,\n\tBLUENRG_BLE_GetMacAddress,\n\tBLUENRG_BLE_GAPSetDeviceName,\n\tBLUENRG_BLE_GAPAdvertisingStart,\n\tBLUENRG_BLE_GAPAdvertisingStop,\n\tBLUENRG_BLE_GAPSetAdvertisedServiceUUID,\n\tBLUENRG_BLE_GAPAdverertisingSetManufacturerData,\n\tBLUENRG_BLE_GAPPairingCfg,\n\tBLUENRG_BLE_GAPDisconnect,\n\tBLUENRG_BLE_GATTSAddService,\n\tBLUENRG_BLE_GATTSAddCharacteristic,\n\tBLUENRG_BLE_GATTSGetCharacteristicValue,\n\tBLUENRG_BLE_GATTSRegisterCharacteristicCallback,\n\tBLUENRG_BLE_GATTSRegisterCharacteristicAbilityHandle,\n\tBLUENRG_BLE_GATTSSetCharacteristic,\n\tBLUENRG_BLE_GATTSWriteDescriptor,\n\tBLUENRG_BLE_GATTSSendIndicate,\n\tBLUENRG_BLE_GATTSSendNotify,\n\tBLUENRG_BLE_RegisterEventCallback,\n\tBLUENRG_BLE_RegisterEventAbilityHandle\n};\n\n/**\n * @brief Advertising configuration\n *\n */\ntypedef struct\n{\n\tchar shortLocalName[8];\n\tuint8_t primaryServiceUuid[16];\n\tuint8_t appearance;\n\tATMO_BLE_AdvertisingParams_t params;\n} _BLUENRG_BLE_AdvConfig_t;\n\n/**\n * @brief General BLE configuration\n *\n */\ntypedef struct\n{\n\t_BLUENRG_BLE_AdvConfig_t advConfig;\n\tATMO_Callback_t eventCb[ATMO_BLE_EVENT_NumEvents];\n\tunsigned int abilityHandle[ATMO_BLE_EVENT_NumEvents];\n\tbool abilityHandleRegistered[ATMO_BLE_EVENT_NumEvents];\n\tATMO_BLE_PairingCfg_t pairingCfg;\n} _BLUENRG_BLE_Config_t;\n\n/**\n * @brief Container for service handles\n *\n */\ntypedef struct\n{\n\tuint16_t sensorTileHandle;\n\tATMO_UUID_t uuid;\n} BLUENRG_ServiceRecord_t;\n\n#define BLUENRG_MaxServices (64)\n#define BLUENRG_MaxCharacteristics (128)\n\nstatic BLUENRG_ServiceRecord_t _BLUENRG_ServiceHandle[BLUENRG_MaxServices];\nstatic unsigned int _BLUENRG_NumServices = 0;\n\n/**\n * @brief Container for characteristic data\n *\n */\ntypedef struct\n{\n\tATMO_BLE_Handle_t atmoHandle;\n\tuint16_t sensorTileHandle;\n\tuint16_t sensorTileServiceHandle;\n\tATMO_Callback_t eventCb[ATMO_BLE_Characteristic_NumEvents];\n\tATMO_AbilityHandle_t abilityHandle[ATMO_BLE_Characteristic_NumEvents];\n\tbool abilityHandleRegistered[ATMO_BLE_Characteristic_NumEvents];\n} _BLUENRG_Characteristic_t;\n\nstatic _BLUENRG_Characteristic_t _BLUENRG_Characteristic[BLUENRG_MaxCharacteristics];\nstatic uint8_t _BLUENRG_NumCharacteristics = 0;\nstatic _BLUENRG_BLE_Config_t _BLUENRG_BleConfig;\n\nstatic _BLUENRG_Characteristic_t *_BLUENRG_BLE_ToAtmoHandle( uint16_t handle )\n{\n\tunsigned int i = 0;\n\tfor ( i = 0; i < _BLUENRG_NumCharacteristics; i++ )\n\t{\n\t\tif ( _BLUENRG_Characteristic[i].sensorTileHandle == handle )\n\t\t{\n\t\t\treturn &_BLUENRG_Characteristic[i];\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n\nstatic uint8_t bdaddr[6] = {0};\n\nstatic void _BLUENRG_BLE_DispatchBleEvent( ATMO_BLE_Event_t event, ATMO_Value_t *value )\n{\n\tif ( _BLUENRG_BleConfig.abilityHandleRegistered[event] )\n\t{\n\t\tATMO_AddAbilityExecute( _BLUENRG_BleConfig.abilityHandle[event], value );\n\t}\n\n\tif ( _BLUENRG_BleConfig.eventCb[event] != NULL )\n\t{\n\t\tATMO_AddCallbackExecute( _BLUENRG_BleConfig.eventCb[event], value );\n\t}\n}\n\nstatic void _BLUENRG_BLE_DispatchBleCharEvent( ATMO_BLE_Characteristic_Event_t event, ATMO_BLE_Handle_t handle, ATMO_Value_t *value )\n{\n\tif ( _BLUENRG_Characteristic[handle].abilityHandleRegistered[event] )\n\t{\n\t\tATMO_AddAbilityExecute( _BLUENRG_Characteristic[handle].abilityHandle[event], value );\n\t}\n\n\tif ( _BLUENRG_Characteristic[handle].eventCb[event] != NULL )\n\t{\n\t\tATMO_AddCallbackExecute( _BLUENRG_Characteristic[handle].eventCb[event], value );\n\t}\n}\n\n/**\n * @brief  This function is called whenever there is an ACI event to be processed.\n * @note   Inside this function each event must be identified and correctly\n *         parsed.\n * @param  void *pckt Pointer to the ACI packet\n * @retval None\n */\n\nstatic void HCI_Event_CB( void *pckt )\n{\n\thci_uart_pckt *hci_pckt = pckt;\n\thci_event_pckt *event_pckt = ( hci_event_pckt * )hci_pckt->data;\n\n\tif ( hci_pckt->type != HCI_EVENT_PKT )\n\t{\n\t\treturn;\n\t}\n\n\n\tswitch ( event_pckt->evt )\n\t{\n\n\t\tcase EVT_DISCONN_COMPLETE:\n\t\t{\n\t\t\t//GAP_DisconnectionComplete_CB();\n\t\t\t_BLUENRG_BLE_DispatchBleEvent( ATMO_BLE_EVENT_Disconnected, NULL );\n\t\t}\n\t\tbreak;\n\n\t\tcase EVT_LE_META_EVENT:\n\t\t{\n\t\t\tevt_le_meta_event *evt = ( void * )event_pckt->data;\n\n\t\t\tswitch ( evt->subevent )\n\t\t\t{\n\t\t\t\tcase EVT_LE_CONN_COMPLETE:\n\t\t\t\t{\n\t\t\t\t\tevt_le_connection_complete *cc = ( void * )evt->data;\n\t\t\t\t\t_BLUENRG_BLE_DispatchBleEvent( ATMO_BLE_EVENT_Connected, NULL );\n\t\t\t\t\t//GAP_ConnectionComplete_CB(cc->peer_bdaddr, cc->handle);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase EVT_VENDOR:\n\t\t{\n\t\t\tevt_blue_aci *blue_evt = ( void * )event_pckt->data;\n\n\t\t\tswitch ( blue_evt->ecode )\n\t\t\t{\n\t\t\t\tcase EVT_BLUE_GAP_PASS_KEY_REQUEST:\n\t\t\t\t{\n\t\t\t\t\tevt_gap_pass_key_req *evt = ( evt_gap_pass_key_req * )blue_evt->data;\n\t\t\t\t\t// Gen random number\n\t\t\t\t\tuint32_t randomKey = 0x1234; // TODO nick how to get random from inside EEL?\n\n\t\t\t\t\tATMO_Value_t keyVal;\n\t\t\t\t\tATMO_InitValue( &keyVal );\n\t\t\t\t\tATMO_CreateValueUnsignedInt( &keyVal, randomKey );\n\t\t\t\t\t_BLUENRG_BLE_DispatchBleEvent( ATMO_BLE_EVENT_PairingRequested, &keyVal );\n\t\t\t\t\tATMO_Free( &keyVal );\n\t\t\t\t\taci_gap_pass_key_response( evt->conn_handle, randomKey );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase EVT_BLUE_GAP_PAIRING_CMPLT:\n\t\t\t\t{\n\t\t\t\t\tevt_gap_pairing_cmplt *evt = ( evt_gap_pairing_cmplt * ) blue_evt->data;\n\n\t\t\t\t\tif ( evt->status == 0x00 )\n\t\t\t\t\t{\n\t\t\t\t\t\t_BLUENRG_BLE_DispatchBleEvent( ATMO_BLE_EVENT_PairingSuccess, NULL );\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t_BLUENRG_BLE_DispatchBleEvent( ATMO_BLE_EVENT_PairingFailed, NULL );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcase EVT_BLUE_GATT_READ_PERMIT_REQ:\n\t\t\t\t{\n\t\t\t\t\tevt_gatt_read_permit_req *pr = ( void * )blue_evt->data;\n\t\t\t\t\t//Attribute_Read_CB(pr->attr_handle);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase EVT_BLUE_GATT_ATTRIBUTE_MODIFIED:\n\t\t\t\t{\n\t\t\t\t\tevt_gatt_attr_modified_IDB05A1 *evt = ( evt_gatt_attr_modified_IDB05A1 * )blue_evt->data;\n\n\t\t\t\t\t// Not sure why\n\t\t\t\t\t// The handle we are given is one more than the handle we were given when we added the char to the gatt db\n\t\t\t\t\t_BLUENRG_Characteristic_t *characteristic = NULL;\n\n\t\t\t\t\tcharacteristic = _BLUENRG_BLE_ToAtmoHandle( evt->attr_handle - 1 );\n\n\t\t\t\t\t// Value was written\n\t\t\t\t\tif ( characteristic != NULL )\n\t\t\t\t\t{\n\t\t\t\t\t\tATMO_Value_t val;\n\t\t\t\t\t\tATMO_InitValue( &val );\n\t\t\t\t\t\tATMO_CreateValueBinary( &val, evt->att_data, evt->data_length );\n\t\t\t\t\t\t_BLUENRG_BLE_DispatchBleCharEvent( ATMO_BLE_Characteristic_Written, characteristic->atmoHandle, &val );\n\t\t\t\t\t\tATMO_FreeValue( &val );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcharacteristic = _BLUENRG_BLE_ToAtmoHandle( evt->attr_handle - 2 );\n\n\t\t\t\t\t// This means that the descriptor was written\n\t\t\t\t\tif ( characteristic != NULL )\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( evt->att_data[0] == 0x0 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_BLUENRG_BLE_DispatchBleCharEvent( ATMO_BLE_Characteristic_Unsubscribed, characteristic->atmoHandle, NULL );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_BLUENRG_BLE_DispatchBleCharEvent( ATMO_BLE_Characteristic_Subscribed, characteristic->atmoHandle, NULL );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n}\n\nATMO_Status_t BLUENRG_BLE_AddDriverInstance( ATMO_DriverInstanceHandle_t *instanceNumber )\n{\n\tstatic ATMO_DriverInstanceData_t driverInstanceData;\n\n\tdriverInstanceData.name = \"BLUENRG BLE\";\n\tdriverInstanceData.initialized = false;\n\tdriverInstanceData.instanceNumber = 0;\n\tdriverInstanceData.argument = NULL;\n\n\treturn ATMO_BLE_AddDriverInstance( &sensortileBleDriverInstance, &driverInstanceData, instanceNumber );\n}\n\nstatic void BLUENRG_TickCb( void *data )\n{\n\thci_user_evt_proc();\n}\n\nATMO_BLE_Status_t BLUENRG_BLE_PeripheralInit( ATMO_DriverInstanceData_t *instance )\n{\n\tstatic bool _BLUENRG_BLE_Initialized = false;\n\n\tif ( !_BLUENRG_BLE_Initialized )\n\t{\n\t\tmemset( &_BLUENRG_BleConfig, 0, sizeof( _BLUENRG_BleConfig ) );\n\t\tmemset( &_BLUENRG_Characteristic, 0, sizeof( _BLUENRG_Characteristic ) );\n\n\t\t_BLUENRG_BleConfig.pairingCfg.type = ATMO_BLE_PairingType_JustWorks;\n\n\t\tBLUENRG_BLE_GAPPairingCfg( NULL, &_BLUENRG_BleConfig.pairingCfg );\n\t}\n\n\tATMO_AddTickCallback( BLUENRG_TickCb );\n\n\t_BLUENRG_BLE_Initialized = true;\n\treturn ATMO_BLE_Status_Success;\n}\n\n\nATMO_BLE_Status_t BLUENRG_BLE_SetEnabled( ATMO_DriverInstanceData_t *instance, bool enabled )\n{\n\treturn ATMO_BLE_Status_NotSupported;\n}\n\nATMO_BLE_Status_t BLUENRG_BLE_GetEnabled( ATMO_DriverInstanceData_t *instance, bool *enabled )\n{\n\treturn ATMO_BLE_Status_NotSupported;\n}\n\nATMO_BLE_Status_t BLUENRG_BLE_PeripheralDeInit( ATMO_DriverInstanceData_t *instance )\n{\n\treturn ATMO_BLE_Status_Success;\n}\n\nATMO_BLE_Status_t BLUENRG_BLE_GetMacAddress( ATMO_DriverInstanceData_t *instance, ATMO_BLE_MacAddress_t *address )\n{\n\tuint8_t bdAddrBigEndian[6] = {bdaddr[5], bdaddr[4], bdaddr[3], bdaddr[2], bdaddr[1], bdaddr[0]};\n\n\tmemcpy( address->data, bdAddrBigEndian, 6 );\n\n\treturn ATMO_BLE_Status_Success;\n}\n\n\nATMO_BLE_Status_t BLUENRG_BLE_GAPSetDeviceName( ATMO_DriverInstanceData_t *instance, const char *name )\n{\n\t_BLUENRG_BLE_Config_t *config = &_BLUENRG_BleConfig;\n\tstrncpy( config->advConfig.shortLocalName, name, 7 );\n\treturn ATMO_BLE_Status_Success;\n}\n\nATMO_BLE_Status_t BLUENRG_BLE_GAPAdvertisingStart( ATMO_DriverInstanceData_t *instance, ATMO_BLE_AdvertisingParams_t *params )\n{\n\t_BLUENRG_BLE_Config_t *config = &_BLUENRG_BleConfig;\n\t/* disable scan response */\n\thci_le_set_scan_resp_data( 0, NULL );\n\n\tuint8_t servUuid[17];\n\tservUuid[0] = AD_TYPE_128_BIT_SERV_UUID;\n\n\tuint8_t localName[8] = {0};\n\tlocalName[0] = AD_TYPE_SHORTENED_LOCAL_NAME;\n\tstrncpy( &localName[1], config->advConfig.shortLocalName, 7 );\n\tmemcpy( &servUuid[1], config->advConfig.primaryServiceUuid, 16 );\n\n\n\ttBleStatus ret = aci_gap_set_discoverable( 0x0,  // Allow scan/connect from any\n\t                 0x20, // Min adv interval. Docs say this is the minimum\n\t                 0x800, // Max adv interval. This is about 1 second\n\t                 0x1, // Use random public address\n\t                 0x0, // No filtering\n\t                 strlen( config->advConfig.shortLocalName ) + 1, localName, 17, servUuid, 0, 0 );\n\n\treturn ( ret == 0 ) ? ATMO_BLE_Status_Success : ATMO_BLE_Status_Fail;\n}\n\nATMO_BLE_Status_t BLUENRG_BLE_GAPAdvertisingStop( ATMO_DriverInstanceData_t *instance )\n{\n\taci_gap_set_non_discoverable();\n\treturn ATMO_BLE_Status_NotSupported;\n}\n\nATMO_BLE_Status_t BLUENRG_BLE_GAPSetAdvertisedServiceUUID( ATMO_DriverInstanceData_t *instance, const char *uuid )\n{\n\tATMO_UUID_t uuidBin;\n\n\tATMO_StringToUuid( uuid, &uuidBin, ATMO_ENDIAN_Type_Little );\n\n\t_BLUENRG_BLE_Config_t *config = &_BLUENRG_BleConfig;\n\n\tmemcpy( config->advConfig.primaryServiceUuid, uuidBin.data, 16 );\n\n\treturn ATMO_BLE_Status_Success;\n}\n\nATMO_BLE_Status_t BLUENRG_BLE_GAPAdverertisingSetManufacturerData( ATMO_DriverInstanceData_t *instance, ATMO_BLE_AdvertisingData_t *data )\n{\n\treturn ATMO_BLE_Status_NotSupported;\n}\n\nATMO_BLE_Status_t BLUENRG_BLE_GAPPairingCfg( ATMO_DriverInstanceData_t *instance, ATMO_BLE_PairingCfg_t *config )\n{\n\tswitch ( config->type )\n\t{\n\t\tcase ATMO_BLE_PairingType_JustWorks:\n\t\t{\n\t\t\taci_gap_set_io_capability( IO_CAP_NO_INPUT_NO_OUTPUT );\n\t\t\taci_gap_set_auth_requirement( MITM_PROTECTION_NOT_REQUIRED,\n\t\t\t                              OOB_AUTH_DATA_ABSENT,\n\t\t\t                              NULL, 7, 16,\n\t\t\t                              USE_FIXED_PIN_FOR_PAIRING, 123456,\n\t\t\t                              BONDING );\n\t\t\tbreak;\n\t\t}\n\n\t\tcase ATMO_BLE_PairingType_RandomKey:\n\t\t{\n\t\t\taci_gap_set_io_capability( IO_CAP_DISPLAY_ONLY );\n\t\t\taci_gap_set_auth_requirement( MITM_PROTECTION_REQUIRED,\n\t\t\t                              OOB_AUTH_DATA_ABSENT,\n\t\t\t                              NULL, 7, 16,\n\t\t\t                              DONOT_USE_FIXED_PIN_FOR_PAIRING, 0,\n\t\t\t                              BONDING );\n\t\t\tbreak;\n\t\t}\n\n\t\tcase ATMO_BLE_PairingType_UserKey:\n\t\t{\n\t\t\taci_gap_set_io_capability( IO_CAP_DISPLAY_ONLY );\n\t\t\taci_gap_set_auth_requirement( MITM_PROTECTION_REQUIRED,\n\t\t\t                              OOB_AUTH_DATA_ABSENT,\n\t\t\t                              NULL, 7, 16,\n\t\t\t                              USE_FIXED_PIN_FOR_PAIRING, config->pairingKey,\n\t\t\t                              BONDING );\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ATMO_BLE_Status_Success;\n}\n\nATMO_BLE_Status_t BLUENRG_BLE_GAPDisconnect( ATMO_DriverInstanceData_t *instance )\n{\n\treturn ATMO_BLE_Status_NotSupported;\n}\n\n\nATMO_BLE_Status_t BLUENRG_BLE_GATTSAddService( ATMO_DriverInstanceData_t *instance, ATMO_BLE_Handle_t *handle, const char *serviceUUID )\n{\n\n\tif ( _BLUENRG_NumServices >= BLUENRG_MaxServices )\n\t{\n\t\treturn ATMO_BLE_Status_Fail;\n\t}\n\n\tATMO_UUID_t uuidBin;\n\tATMO_StringToUuid( serviceUUID, &uuidBin, ATMO_ENDIAN_Type_Little );\n\n\tbool serviceExists = false;\n\n\t// Check to see if service is already added\n\tunsigned int i = 0;\n\tfor ( i = 0; i < _BLUENRG_NumServices; i++ )\n\t{\n\t\tif ( memcmp( &_BLUENRG_ServiceHandle[i].uuid, &uuidBin, sizeof( uuidBin ) ) == 0 )\n\t\t{\n\t\t\tserviceExists = true;\n\t\t\t*handle = i;\n\t\t\treturn ATMO_BLE_Status_Success;\n\t\t}\n\t}\n\n\n\ttBleStatus ret = aci_gatt_add_serv( UUID_TYPE_128,  uuidBin.data, PRIMARY_SERVICE,\n\t                                    10,\n\t                                    &_BLUENRG_ServiceHandle[_BLUENRG_NumServices].sensorTileHandle );\n\n\tif ( ret == 0 )\n\t{\n\t\tmemcpy( &_BLUENRG_ServiceHandle[_BLUENRG_NumServices].uuid, &uuidBin, sizeof( uuidBin ) );\n\t\t*handle = _BLUENRG_NumServices++;\n\n\t\treturn ATMO_BLE_Status_Success;\n\t}\n\n\t*handle = 0;\n\treturn ATMO_BLE_Status_Fail;\n}\n\nATMO_BLE_Status_t BLUENRG_BLE_GATTSAddCharacteristic( ATMO_DriverInstanceData_t *instance, ATMO_BLE_Handle_t *handle, ATMO_BLE_Handle_t serviceHandle, const char *characteristicUUID, uint8_t properties, uint8_t permissions, uint32_t maxLen )\n{\n\tif ( _BLUENRG_NumCharacteristics >= BLUENRG_MaxCharacteristics )\n\t{\n\t\treturn ATMO_BLE_Status_Fail;\n\t}\n\n\tATMO_UUID_t uuidBin;\n\tATMO_StringToUuid( characteristicUUID, &uuidBin, ATMO_ENDIAN_Type_Little );\n\n\n\ttBleStatus ret =  aci_gatt_add_char( _BLUENRG_ServiceHandle[serviceHandle].sensorTileHandle, UUID_TYPE_128, uuidBin.data, maxLen,\n\t                                     properties,\n\t                                     0,\n\t                                     ( properties & ATMO_BLE_Property_Write ) ? GATT_NOTIFY_ATTRIBUTE_WRITE : 0,\n\t                                     16, 1, &_BLUENRG_Characteristic[_BLUENRG_NumCharacteristics].sensorTileHandle );\n\n\tif ( ret == 0 )\n\t{\n\t\t_BLUENRG_Characteristic[_BLUENRG_NumCharacteristics].atmoHandle = _BLUENRG_NumCharacteristics;\n\t\t_BLUENRG_Characteristic[_BLUENRG_NumCharacteristics].sensorTileServiceHandle = _BLUENRG_ServiceHandle[serviceHandle].sensorTileHandle;\n\t\t*handle = _BLUENRG_NumCharacteristics++;\n\t\treturn ATMO_BLE_Status_Success;\n\t}\n\n\t*handle = 0;\n\treturn ATMO_BLE_Status_Fail;\n}\n\nATMO_BLE_Status_t BLUENRG_BLE_GATTSGetCharacteristicValue( ATMO_DriverInstanceData_t *instance, ATMO_BLE_Handle_t handle, uint8_t *valueBuf, uint32_t valueBufLen, uint32_t *valueLen )\n{\n\treturn ATMO_BLE_Status_NotSupported;\n}\n\nATMO_BLE_Status_t BLUENRG_BLE_GATTSRegisterCharacteristicCallback( ATMO_DriverInstanceData_t *instance,  ATMO_BLE_Handle_t handle, ATMO_BLE_Characteristic_Event_t event, ATMO_Callback_t cbFunc )\n{\n\t_BLUENRG_Characteristic[handle].eventCb[event] = cbFunc;\n\treturn ATMO_BLE_Status_Success;\n}\n\nATMO_BLE_Status_t BLUENRG_BLE_GATTSRegisterCharacteristicAbilityHandle( ATMO_DriverInstanceData_t *instance, ATMO_BLE_Handle_t handle, ATMO_BLE_Characteristic_Event_t event, unsigned int abilityHandler )\n{\n\t_BLUENRG_Characteristic[handle].abilityHandle[event] = abilityHandler;\n\t_BLUENRG_Characteristic[handle].abilityHandleRegistered[event] = true;\n\treturn ATMO_BLE_Status_Success;\n}\n\nATMO_BLE_Status_t BLUENRG_BLE_GATTSSetCharacteristic( ATMO_DriverInstanceData_t *instance, ATMO_BLE_Handle_t handle, uint16_t length, uint8_t *value, ATMO_BLE_CharProperties_t *properties )\n{\n\ttBleStatus ret = aci_gatt_update_char_value( _BLUENRG_Characteristic[handle].sensorTileServiceHandle, _BLUENRG_Characteristic[handle].sensorTileHandle,\n\t                 0, length, value );\n\n\treturn ( ret == 0 ) ? ATMO_BLE_Status_Success : ATMO_BLE_Status_Fail;\n}\n\nATMO_BLE_Status_t BLUENRG_BLE_GATTSWriteDescriptor( ATMO_DriverInstanceData_t *instance, ATMO_BLE_Handle_t handle, uint16_t length, uint8_t *value, ATMO_BLE_CharProperties_t *properties )\n{\n\treturn ATMO_BLE_Status_NotSupported;\n}\n\nATMO_BLE_Status_t BLUENRG_BLE_GATTSSendIndicate( ATMO_DriverInstanceData_t *instance, ATMO_BLE_Handle_t handle, uint16_t size, uint8_t *value )\n{\n\treturn ATMO_BLE_Status_NotSupported;\n}\n\nATMO_BLE_Status_t BLUENRG_BLE_GATTSSendNotify( ATMO_DriverInstanceData_t *instance, ATMO_BLE_Handle_t handle, uint16_t size, uint8_t *value )\n{\n\treturn BLUENRG_BLE_GATTSSetCharacteristic( instance, handle, size, value, NULL );\n}\n\nATMO_BLE_Status_t BLUENRG_BLE_RegisterEventCallback( ATMO_DriverInstanceData_t *instance, ATMO_BLE_Event_t event, ATMO_Callback_t cb )\n{\n\t_BLUENRG_BLE_Config_t *config = &_BLUENRG_BleConfig;\n\tconfig->eventCb[event] = cb;\n\treturn ATMO_BLE_Status_Success;\n}\n\nATMO_BLE_Status_t BLUENRG_BLE_RegisterEventAbilityHandle( ATMO_DriverInstanceData_t *instance, ATMO_BLE_Event_t event, unsigned int abilityHandle )\n{\n\t_BLUENRG_BLE_Config_t *config = &_BLUENRG_BleConfig;\n\tconfig->abilityHandle[event] = abilityHandle;\n\tconfig->abilityHandleRegistered[event] = true;\n\treturn ATMO_BLE_Status_Success;\n}\n\n\nATMO_BOOL_t BLUENRG_Init( const BLUENRG_Config_t *config, ATMO_DriverInstanceHandle_t *bleInstance )\n{\n\tmemcpy( &_BLUENRG_PrivConfig, config, sizeof( _BLUENRG_PrivConfig ) );\n\n\tconst char BoardName[8] = \"ATMO\";\n\tuint16_t service_handle, dev_name_char_handle, appearance_char_handle;\n\tint ret;\n\tuint8_t  hwVersion;\n\tuint16_t fwVersion;\n\n\t/* Initialize the BlueNRG HCI */\n\thci_init( HCI_Event_CB, NULL );\n\n\t/* Reset BlueNRG hardware */\n\thci_reset();\n\n\t/* get the BlueNRG HW and FW versions */\n\tgetBlueNRGVersion( &hwVersion, &fwVersion );\n\n\t/*\n\t * Reset BlueNRG again otherwise it will fail.\n\t */\n\thci_reset();\n\n\tret = aci_gatt_init();\n\n\tif ( ret )\n\t{\n\t\tATMO_PLATFORM_DebugPrint( \"\\r\\nGATT_Init failed\\r\\n\" );\n\t\tgoto fail;\n\t}\n\n\n\tret = aci_gap_init_IDB05A1( GAP_PERIPHERAL_ROLE_IDB05A1, 0, 0x07, &service_handle, &dev_name_char_handle, &appearance_char_handle );\n\n\tif ( ret != BLE_STATUS_SUCCESS )\n\t{\n\t\tATMO_PLATFORM_DebugPrint( \"\\r\\nGAP_Init failed\\r\\n\" );\n\t\tgoto fail;\n\t}\n\n\tret = aci_gatt_update_char_value( service_handle, dev_name_char_handle, 0,\n\t                                  7/*strlen(BoardName)*/, ( uint8_t * )BoardName );\n\n\tif ( ret )\n\t{\n\t\tATMO_PLATFORM_DebugPrint( \"\\r\\naci_gatt_update_char_value failed\\r\\n\" );\n\n\t\twhile ( 1 );\n\t}\n\n\t// Get MAC address\n\tuint8_t macAddrLenOut = 0;\n\tret = aci_hal_read_config_data( 0x80, 6, &macAddrLenOut, bdaddr );\n\n\tif ( ret )\n\t{\n\t\tATMO_PLATFORM_DebugPrint( \"Error Getting MAC Address\\r\\n\" );\n\t}\n\n\tATMO_PLATFORM_DebugPrint( \"SERVER: BLE Stack Initialized \\r\\n\"\n\t                          \"\\t\\tBoard type=%s HWver=%d, FWver=%d.%d.%c\\r\\n\"\n\t                          \"\\t\\tBoardName= %s\\r\\n\"\n\t                          \"\\t\\tBoardMAC = %x:%x:%x:%x:%x:%x\\r\\n\\n\",\n\t                          \"SensorTile\",\n\t                          hwVersion,\n\t                          fwVersion >> 8,\n\t                          ( fwVersion >> 4 ) & 0xF,\n\t                          ( hwVersion > 0x30 ) ? ( 'a' + ( fwVersion & 0xF ) - 1 ) : 'a',\n\t                          BoardName,\n\t                          bdaddr[5], bdaddr[4], bdaddr[3], bdaddr[2], bdaddr[1], bdaddr[0] );\n\n\t/* Set output power level */\n\taci_hal_set_tx_power_level( 1, 4 );\n\n\tBLUENRG_BLE_AddDriverInstance( bleInstance );\n\tATMO_BLE_PeripheralInit( *bleInstance );\n\n\tATMO_DriverInstanceHandle_t cloudInstance;\n\tATMO_CLOUD_BLE_AddDriverInstance( &cloudInstance, *bleInstance );\n\tATMO_CLOUD_Init( cloudInstance, true ); // Provisioning interface\n\n\treturn;\n\nfail:\n\treturn;\n}\n\nBLUENRG_Config_t *BLUENRG_GetConfig()\n{\n\treturn &_BLUENRG_PrivConfig;\n}",
                "bluenrg_IFR.c": "\n#include \"bluenrg_types.h\"\n#include \"bluenrg_def.h\"\n#include \"bluenrg_updater_aci.h\"\n#include \"bluenrg_utils.h\"\n\n/************** Do not change this define section ************/\n\n#define BLUENRG_32_MHZ          1\n#define BLUENRG_32_MHZ_RO       2\n#define BLUENRG_16_MHZ          3\n#define BLUENRG_16_MHZ_RO       4\n#define BLUENRG_CUSTOM_CONFIG   5\n\n#define MASTER_SCA_500ppm       0 // 251 ppm to 500 ppm\n#define MASTER_SCA_250ppm       1 // 151 ppm to 250 ppm\n#define MASTER_SCA_150ppm       2 // 101 ppm to 150 ppm\n#define MASTER_SCA_100ppm       3 // 76 ppm to 100 ppm\n#define MASTER_SCA_75ppm        4 // 51 ppm to 75 ppm\n#define MASTER_SCA_50ppm        5 // 31 ppm to 50 ppm\n#define MASTER_SCA_30ppm        6 // 21 ppm to 30 ppm\n#define MASTER_SCA_20ppm        7 // 0 ppm to 20 ppm\n\n#define SMPS_4MHz               0\n#define SMPS_8MHz               1\n\n#ifndef SMPS_FREQUENCY\n#define SMPS_FREQUENCY          SMPS_4MHz\n#endif\n\n#if !BLUENRG_MS && (SMPS_FREQUENCY == SMPS_8MHz)\n#error Unsupported SMPS_FREQUENCY\n#endif\n\n/************************************************************/\n\n\n/************** Definitions that can be changed. ************/\n\n#define STACK_MODE              2\n#define SLAVE_SCA_PPM           100\n#define MASTER_SCA              MASTER_SCA_100ppm\n#define HS_STARTUP_TIME_US      800\n#define DAY                     13\n#define MONTH                   06\n#define YEAR                    16\n/************************************************************/\n\n/*\n * IMPORTANT!\n * This IFR configurations are only for BlueNRG Firmware v6.4 and 7.x.\n */\n\n#if BLUENRG_CONFIG == BLUENRG_32_MHZ\n\nconst IFR_config_TypeDef IFR_config = {\n#if BLUENRG_MS\n#if SMPS_FREQUENCY == SMPS_4MHz\n  0x02,0x3A,0x44,0x02,\n  0x34,0x5B,0x02,0x39,\n  0xA2,0x02,0x3C,0x20,\n  0x00,0xFF,0xFF,0xFF,\n#elif SMPS_FREQUENCY == SMPS_8MHz\n  0x02,0x3A,0x44,0x02,\n  0x34,0x5B,0x02,0x39,\n  0xAE,0x00,0xFF,0xFF,\n  0x00,0xFF,0xFF,0xFF,\n#else\n#error Incorrect SMPS_FREQUENCY\n#endif /* SMPS_FREQUENCY */\n#else\n  0x02,0x3A,0x5C,0x02,\n  0x39,0xA2,0x02,0x34,\n  0x5B,0x00,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n#endif /* BLUENRG_MS */\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  \n  0x02,0x1C,0x43,0x02,\n  0x20,0xEC,0x02,0x1F,\n  0xAF,0x00,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  \n  STACK_MODE,\n  0xFF,0xFF,0xFF,\n  0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,\n  0xFFFFFFFF,\n  htobl(0x00190000),\n  htobl(0x0028F5C2),\n  htobs(SLAVE_SCA_PPM),\n  MASTER_SCA,\n  0xFF,\n  htobs(FROM_US_TO_SYS_TIME(HS_STARTUP_TIME_US)),\n  0xFF,0xFF,\n  0xFFFFFFFF,\n  0xFF,   \n  INT_TO_BCD(YEAR),INT_TO_BCD(MONTH),INT_TO_BCD(DAY),\n  0xFFFFFFFF,  \n  0xFFFFFFFF,\n  0xFFFFFFFF,\n  0xFFFFFFFF,\n  0xFFFFFFFF\n};\n\n#elif BLUENRG_CONFIG == BLUENRG_32_MHZ_RO\n\nconst IFR_config_TypeDef IFR_config = {\n#if BLUENRG_MS\n#if SMPS_FREQUENCY == SMPS_4MHz\n  0x02,0x3A,0x44,0x02,\n  0x34,0x1B,0x02,0x39,\n  0xA2,0x02,0x3C,0x20,\n  0x00,0xFF,0xFF,0xFF,\n#elif SMPS_FREQUENCY == SMPS_8MHz\n  0x02,0x3A,0x44,0x02,\n  0x34,0x1B,0x02,0x39,\n  0xAE,0x00,0xFF,0xFF,\n  0x00,0xFF,0xFF,0xFF,\n#else\n#error Incorrect SMPS_FREQUENCY\n#endif /* SMPS_FREQUENCY */  \n#else\n  0x02,0x3A,0x5C,0x02,\n  0x39,0xA2,0x02,0x34,\n  0x1B,0x00,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n#endif /* BLUENRG_MS */\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  \n  0x02,0x1C,0x43,0x02,\n  0x20,0xEC,0x02,0x1F,\n  0xAF,0x00,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  \n  STACK_MODE,\n  0xFF,0xFF,0xFF,\n  0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,\n  0xFFFFFFFF,\n  0xFFFFFFFF,\n  0xFFFFFFFF,\n  htobs(0x01F4), \n  0x00,\n  0xFF,\n  htobs(FROM_US_TO_SYS_TIME(HS_STARTUP_TIME_US)),\n  0xFF,0xFF,\n  0xFFFFFFFF,\n  0xFF,   \n  INT_TO_BCD(YEAR),INT_TO_BCD(MONTH),INT_TO_BCD(DAY),\n  0xFFFFFFFF,  \n  0xFFFFFFFF,\n  0xFFFFFFFF,\n  0xFFFFFFFF,\n  0xFFFFFFFF  \n};\n\n#elif BLUENRG_CONFIG == BLUENRG_16_MHZ\n\nconst IFR_config_TypeDef IFR_config = {\n#if BLUENRG_MS\n#if SMPS_FREQUENCY == SMPS_4MHz\n  0x02,0x3A,0x40,0x02,\n  0x34,0x5B,0x02,0x39,\n  0xA2,0x02,0x3C,0x20,\n  0x00,0xFF,0xFF,0xFF,\n#elif SMPS_FREQUENCY == SMPS_8MHz\n  0x02,0x3A,0x40,0x02,\n  0x34,0x5B,0x02,0x39,\n  0xAE,0x00,0xFF,0xFF,\n  0x00,0xFF,0xFF,0xFF,\n#else\n#error Incorrect SMPS_FREQUENCY\n#endif /* SMPS_FREQUENCY */    \n#else\n  0x02,0x3A,0x58,0x02,\n  0x39,0xA2,0x02,0x34,\n  0x5B,0x00,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n#endif /* BLUENRG_MS */\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  \n  0x02,0x1C,0x43,0x02,\n  0x20,0xEC,0x02,0x1F,\n  0xAF,0x00,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  \n  STACK_MODE,\n  0xFF,0xFF,0xFF,\n  0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,\n  0xFFFFFFFF,\n  htobl(0x00190000),\n  htobl(0x0028F5C2),\n  htobs(SLAVE_SCA_PPM), \n  MASTER_SCA,\n  0xFF,\n  htobs(FROM_US_TO_SYS_TIME(HS_STARTUP_TIME_US)),\n  0xFF,0xFF,\n  0xFFFFFFFF,\n  0xFF,   \n  INT_TO_BCD(YEAR),INT_TO_BCD(MONTH),INT_TO_BCD(DAY),\n  0xFFFFFFFF,  \n  0xFFFFFFFF,\n  0xFFFFFFFF,\n  0xFFFFFFFF,\n  0xFFFFFFFF\n\n};\n\n#elif BLUENRG_CONFIG == BLUENRG_16_MHZ_RO\n\nconst IFR_config_TypeDef IFR_config = {\n#if BLUENRG_MS\n#if SMPS_FREQUENCY == SMPS_4MHz\n  0x02,0x3A,0x40,0x02,\n  0x34,0x1B,0x02,0x39,\n  0xA2,0x02,0x3C,0x20,\n  0x00,0xFF,0xFF,0xFF,\n#elif SMPS_FREQUENCY == SMPS_8MHz\n  0x02,0x3A,0x40,0x02,\n  0x34,0x1B,0x02,0x39,\n  0xAE,0x00,0xFF,0xFF,\n  0x00,0xFF,0xFF,0xFF,\n#else\n#error Incorrect SMPS_FREQUENCY\n#endif /* SMPS_FREQUENCY */    \n#else\n  0x02,0x3A,0x58,0x02,\n  0x39,0xA2,0x02,0x34,\n  0x1B,0x00,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n#endif /* BLUENRG_MS */\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  \n  0x02,0x1C,0x43,0x02,\n  0x20,0xEC,0x02,0x1F,\n  0xAF,0x00,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  0xFF,0xFF,0xFF,0xFF,\n  \n  STACK_MODE,\n  0xFF,0xFF,0xFF,\n  0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,\n  0xFFFFFFFF,\n  0xFFFFFFFF,\n  0xFFFFFFFF,\n  htobs(0x01F4), \n  0x00,\n  0xFF,\n  htobs(FROM_US_TO_SYS_TIME(HS_STARTUP_TIME_US)),\n  0xFF,0xFF,\n  0xFFFFFFFF,\n  0xFF,   \n  INT_TO_BCD(YEAR),INT_TO_BCD(MONTH),INT_TO_BCD(DAY),\n  0xFFFFFFFF,  \n  0xFFFFFFFF,\n  0xFFFFFFFF,\n  0xFFFFFFFF,\n  0xFFFFFFFF  \n};\n\n#elif BLUENRG_CONFIG == BLUENRG_CUSTOM_CONFIG\n/* Copy and paste here your custom IFR_config structure. It can be generated\n * with BlueNRG GUI.\n */\n#else\n#warning BLUENRG_CONFIG not valid\n#endif\n\n",
                "bluenrg_aci.h": "/******************** (C) COPYRIGHT 2014 STMicroelectronics ********************\n* File Name          : bluenrg_aci.h\n* Author             : AMS - AAS\n* Version            : V1.0.0\n* Date               : 26-Jun-2014\n* Description        : Header file that includes commands and events for BlueNRG\n*                      FW6.3.\n********************************************************************************\n* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\n* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.\n* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,\n* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE\n* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING\n* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\n*******************************************************************************/\n\n#ifndef __BLUENRG_ACI_H__\n#define __BLUENRG_ACI_H__\n\n#include \"bluenrg_aci_const.h\"\n#include \"bluenrg_gap_aci.h\"\n#include \"bluenrg_gatt_aci.h\"\n#include \"bluenrg_l2cap_aci.h\"\n#include \"bluenrg_hal_aci.h\"\n#include \"bluenrg_updater_aci.h\"\n\n#endif /* __BLUENRG_ACI_H__ */\n",
                "bluenrg_aci_const.h": "/******************** (C) COPYRIGHT 2014 STMicroelectronics ********************\n* File Name          : bluenrg_aci_const.h\n* Author             : AMS - AAS\n* Version            : V1.0.0\n* Date               : 26-Jun-2014\n* Description        : Header file with ACI definitions for BlueNRG\n********************************************************************************\n* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\n* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.\n* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,\n* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE\n* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING\n* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\n*******************************************************************************/\n\n#ifndef __BLUENRG_ACI_CONST_H_\n#define __BLUENRG_ACI_CONST_H_\n\n#include \"link_layer.h\"\n#include \"hci_const.h\"\n#include \"bluenrg_gatt_server.h\"\n#include \"bluenrg_conf.h\"\n\n#ifndef DOXYGEN_SHOULD_SKIP_THIS\n\n#define OCF_HAL_GET_FW_BUILD_NUMBER         0x0000\ntypedef __packed struct _hal_get_fw_build_number_rp{\n  uint8_t       status;\n  uint16_t      build_number;\n} PACKED hal_get_fw_build_number_rp;\n#define HAL_GET_FW_BUILD_NUMBER_RP_SIZE 3\n#define OCF_HAL_WRITE_CONFIG_DATA   0x000C\n#define OCF_HAL_READ_CONFIG_DATA            0x000D\ntypedef __packed struct _hal_read_config_data_cp{\n  uint8_t     offset;\n} PACKED hal_read_config_data_cp;\n#define HAL_READ_CONFIG_DATA_RP_SIZE 1\ntypedef __packed struct _hal_read_config_data_rp{\n  uint8_t\t\tstatus;\n  uint8_t\t\tdata[HCI_MAX_PAYLOAD_SIZE-HAL_READ_CONFIG_DATA_RP_SIZE];\n} PACKED hal_read_config_data_rp;\n\n#define OCF_HAL_SET_TX_POWER_LEVEL          0x000F\ntypedef __packed struct _hal_set_tx_power_level_cp{\n\tuint8_t\ten_high_power;\n    uint8_t pa_level;\n} PACKED hal_set_tx_power_level_cp;\n#define HAL_SET_TX_POWER_LEVEL_CP_SIZE 2\n\n#define OCF_HAL_DEVICE_STANDBY          0x0013\n#define OCF_HAL_LE_TX_TEST_PACKET_NUMBER    0x0014\ntypedef __packed struct _hal_le_tx_test_packet_number_rp{\n  uint8_t status;\n  uint32_t number_of_packets;\n} PACKED hal_le_tx_test_packet_number_rp;\n\n#define OCF_HAL_TONE_START                  0x0015\ntypedef __packed struct _hal_tone_start_cp{\n\tuint8_t\trf_channel;\n} PACKED hal_tone_start_cp;\n#define HAL_TONE_START_CP_SIZE 1\n\n#define OCF_HAL_TONE_STOP                   0x0016\n#define OCF_HAL_GET_LINK_STATUS             0x0017\ntypedef __packed struct _hal_get_link_status_rp{\n  uint8_t       status;\n  uint8_t       link_status[8];\n  uint16_t      conn_handle[8];\n} PACKED hal_get_link_status_rp;\n\n#define OCF_HAL_GET_ANCHOR_PERIOD           0x0019\ntypedef __packed struct _hal_get_anchor_period_rp{\n  uint8_t  status;\n  uint32_t anchor_period;\n  uint32_t max_free_slot;\n} PACKED hal_get_anchor_period_rp;\n\n#define OCF_UPDATER_START                   0x0020\n#define OCF_UPDATER_REBOOT                  0x0021\n\n#define OCF_GET_UPDATER_VERSION                 0x0022\ntypedef __packed struct _get_updater_version_rp{\n    uint8_t\t\t    status;\n\tuint8_t\t\t    version;\n} PACKED get_updater_version_rp;\n#define GET_UPDATER_VERSION_RP_SIZE 2\n\n#define OCF_GET_UPDATER_BUFSIZE             0x0023\ntypedef __packed struct _get_updater_bufsize_rp{\n    uint8_t\t\t    status;\n\tuint8_t\t\t    buffer_size;\n} PACKED get_updater_bufsize_rp;\n#define GET_UPDATER_BUFSIZE_RP_SIZE 2\n\n#define OCF_UPDATER_ERASE_BLUE_FLAG         0x0024\n\n#define OCF_UPDATER_RESET_BLUE_FLAG         0x0025\n\n#define OCF_UPDATER_ERASE_SECTOR            0x0026\ntypedef __packed struct _updater_erase_sector_cp{\n\tuint32_t\taddress;\n} PACKED updater_erase_sector_cp;\n#define UPDATER_ERASE_SECTOR_CP_SIZE 4\n\n#define OCF_UPDATER_PROG_DATA_BLOCK         0x0027\n#define UPDATER_PROG_DATA_BLOCK_CP_SIZE     6\ntypedef __packed struct _updater_prog_data_block_cp{\n\tuint32_t\taddress;\n    uint16_t    data_len;\n    uint8_t\t\tdata[HCI_MAX_PAYLOAD_SIZE-UPDATER_PROG_DATA_BLOCK_CP_SIZE];\n} PACKED updater_prog_data_block_cp;\n\n#define OCF_UPDATER_READ_DATA_BLOCK         0x0028\ntypedef __packed struct _updater_read_data_block_cp{\n\tuint32_t\taddress;\n    uint16_t    data_len;\n} PACKED updater_read_data_block_cp;\n#define UPDATER_READ_DATA_BLOCK_CP_SIZE 6\ntypedef __packed struct _updater_read_data_block_rp{\n    uint8_t\t\t    status;\n\tuint8_t\t\t    data[VARIABLE_SIZE];\n} PACKED updater_read_data_block_rp;\n#define GET_UPDATER_BUFSIZE_RP_SIZE 2\n\n#define OCF_UPDATER_CALC_CRC                0x0029\ntypedef __packed struct _updater_calc_crc_cp{\n\tuint32_t\taddress;\n    uint8_t    num_sectors;\n} PACKED updater_calc_crc_cp;\n#define UPDATER_CALC_CRC_CP_SIZE 5\ntypedef __packed struct _updater_calc_crc_rp{\n    uint8_t\t\t    status;\n\tuint32_t\t\tcrc;\n} PACKED updater_calc_crc_rp;\n#define UPDATER_CALC_CRC_RP_SIZE 5\n\n#define OCF_UPDATER_HW_VERSION              0x002A\ntypedef __packed struct _updater_hw_version_rp{\n    uint8_t\t\t    status;\n\tuint8_t\t\t    version;\n} PACKED updater_hw_version_rp;\n#define UPDATER_HW_VERSION_RP_SIZE 2\n\n#define OCF_GAP_SET_NON_DISCOVERABLE\t    0x0081\n\n#define OCF_GAP_SET_LIMITED_DISCOVERABLE\t0x0082\n\n#define OCF_GAP_SET_DISCOVERABLE\t        0x0083\n\n#define OCF_GAP_SET_DIRECT_CONNECTABLE      0x0084\ntypedef __packed struct _gap_set_direct_conectable_cp_IDB05A1{\n    uint8_t\t\town_bdaddr_type;\n    uint8_t\t\tdirected_adv_type;\n    uint8_t\t\tdirect_bdaddr_type;\n    tBDAddr\t\tdirect_bdaddr;\n    uint16_t            adv_interv_min;\n    uint16_t            adv_interv_max;\n} PACKED gap_set_direct_conectable_cp_IDB05A1;\n\ntypedef __packed struct _gap_set_direct_conectable_cp_IDB04A1{\n    uint8_t\t\town_bdaddr_type;\n    uint8_t\t\tdirect_bdaddr_type;\n    tBDAddr\t\tdirect_bdaddr;\n} PACKED gap_set_direct_conectable_cp_IDB04A1;\n\n#define OCF_GAP_SET_IO_CAPABILITY      0x0085\ntypedef __packed struct _gap_set_io_capability_cp{\n    uint8_t\t\tio_capability;\n} PACKED gap_set_io_capability_cp;\n#define GAP_SET_IO_CAPABILITY_CP_SIZE 1\n\n#define OCF_GAP_SET_AUTH_REQUIREMENT      0x0086\ntypedef __packed struct _gap_set_auth_requirement_cp{\n    uint8_t\tmitm_mode;\n    uint8_t     oob_enable;\n    uint8_t     oob_data[16];\n    uint8_t     min_encryption_key_size;\n    uint8_t     max_encryption_key_size;\n    uint8_t     use_fixed_pin;\n    uint32_t    fixed_pin;\n    uint8_t     bonding_mode;\n} PACKED gap_set_auth_requirement_cp;\n#define GAP_SET_AUTH_REQUIREMENT_CP_SIZE 26\n\n#define OCF_GAP_SET_AUTHOR_REQUIREMENT      0x0087\ntypedef __packed struct _gap_set_author_requirement_cp{\n  uint16_t      conn_handle;\n  uint8_t       authorization_enable;\n} PACKED gap_set_author_requirement_cp;\n#define GAP_SET_AUTHOR_REQUIREMENT_CP_SIZE 3\n\n#define OCF_GAP_PASSKEY_RESPONSE      0x0088\ntypedef __packed struct _gap_passkey_response_cp{\n  uint16_t conn_handle;\n  uint32_t passkey;\n} PACKED gap_passkey_response_cp;\n#define GAP_PASSKEY_RESPONSE_CP_SIZE 6\n\n#define OCF_GAP_AUTHORIZATION_RESPONSE      0x0089\ntypedef __packed struct _gap_authorization_response_cp{\n  uint16_t conn_handle;\n  uint8_t  authorize;\n} PACKED gap_authorization_response_cp;\n#define GAP_AUTHORIZATION_RESPONSE_CP_SIZE 3\n\n#define OCF_GAP_INIT\t\t        0x008A\n\ntypedef __packed struct _gap_init_cp_IDB05A1{\n    uint8_t\trole;\n    uint8_t\tprivacy_enabled;\n    uint8_t device_name_char_len; \n} PACKED gap_init_cp_IDB05A1;\n#define GAP_INIT_CP_SIZE_IDB05A1 3\n\ntypedef __packed struct _gap_init_cp_IDB04A1{\n\tuint8_t\trole;\n} PACKED gap_init_cp_IDB04A1;\n#define GAP_INIT_CP_SIZE_IDB04A1 1\n\ntypedef __packed struct _gap_init_rp{\n    uint8_t\t\t    status;\n\tuint16_t\t\tservice_handle;\n    uint16_t\t\tdev_name_char_handle;\n    uint16_t\t\tappearance_char_handle;\n} PACKED gap_init_rp;\n#define GAP_INIT_RP_SIZE 7\n\n#define OCF_GAP_SET_NON_CONNECTABLE      0x008B\ntypedef __packed struct _gap_set_non_connectable_cp_IDB05A1{\n    uint8_t\tadvertising_event_type;\n    uint8_t\town_address_type;\n#endif\n} PACKED gap_set_non_connectable_cp_IDB05A1;\n\ntypedef __packed struct _gap_set_non_connectable_cp_IDB04A1{\n    uint8_t\tadvertising_event_type;\n} PACKED gap_set_non_connectable_cp_IDB04A1;\n\n#define OCF_GAP_SET_UNDIRECTED_CONNECTABLE      0x008C\ntypedef __packed struct _gap_set_undirected_connectable_cp{\n    uint8_t\tadv_filter_policy;\n    uint8_t\town_addr_type;\n} PACKED gap_set_undirected_connectable_cp;\n#define GAP_SET_UNDIRECTED_CONNECTABLE_CP_SIZE 2\n\n#define OCF_GAP_SLAVE_SECURITY_REQUEST      0x008D\ntypedef __packed struct _gap_slave_security_request_cp{\n  uint16_t conn_handle;\n  uint8_t  bonding;\n  uint8_t  mitm_protection;\n} PACKED gap_slave_security_request_cp;\n#define GAP_SLAVE_SECURITY_REQUEST_CP_SIZE 4\n\n#define OCF_GAP_UPDATE_ADV_DATA      0x008E\n\n#define OCF_GAP_DELETE_AD_TYPE      0x008F\ntypedef __packed struct _gap_delete_ad_type_cp{\n    uint8_t\tad_type;\n} PACKED gap_delete_ad_type_cp;\n#define GAP_DELETE_AD_TYPE_CP_SIZE 1\n\n#define OCF_GAP_GET_SECURITY_LEVEL      0x0090\ntypedef __packed struct _gap_get_security_level_rp{\n    uint8_t\t\t    status;\n\tuint8_t\t\t    mitm_protection;\n    uint8_t\t\t    bonding;\n    uint8_t\t\t    oob_data;\n    uint8_t         passkey_required;\n} PACKED gap_get_security_level_rp;\n#define GAP_GET_SECURITY_LEVEL_RP_SIZE 5\n\n#define OCF_GAP_SET_EVT_MASK      0x0091\ntypedef __packed struct _gap_set_evt_mask_cp{\n    uint16_t\tevt_mask;\n} PACKED gap_set_evt_mask_cp;\n#define GAP_SET_EVT_MASK_CP_SIZE 2\n\n#define OCF_GAP_CONFIGURE_WHITELIST   0x0092\n\n#define OCF_GAP_TERMINATE      0x0093\ntypedef __packed struct _gap_terminate_cp{\n  uint16_t handle;\n  uint8_t  reason;\n} PACKED gap_terminate_cp;\n#define GAP_TERMINATE_CP_SIZE 3\n\n#define OCF_GAP_CLEAR_SECURITY_DB   0x0094\n\n#define OCF_GAP_ALLOW_REBOND_DB     0x0095\n\ntypedef __packed struct _gap_allow_rebond_cp_IDB05A1{\n  uint16_t conn_handle;\n} PACKED gap_allow_rebond_cp_IDB05A1;\n\n#define OCF_GAP_START_LIMITED_DISCOVERY_PROC   0x0096\ntypedef __packed struct _gap_start_limited_discovery_proc_cp{\n  uint16_t scanInterval;\n  uint16_t scanWindow;\n  uint8_t  own_address_type;\n  uint8_t  filterDuplicates;\n} PACKED gap_start_limited_discovery_proc_cp;\n#define GAP_START_LIMITED_DISCOVERY_PROC_CP_SIZE 6\n\n#define OCF_GAP_START_GENERAL_DISCOVERY_PROC   0x0097\ntypedef __packed struct _gap_start_general_discovery_proc_cp{\n  uint16_t scanInterval;\n  uint16_t scanWindow;\n  uint8_t  own_address_type;\n  uint8_t  filterDuplicates;\n} PACKED gap_start_general_discovery_proc_cp;\n#define GAP_START_GENERAL_DISCOVERY_PROC_CP_SIZE 6\n\n#define OCF_GAP_START_NAME_DISCOVERY_PROC   0x0098\ntypedef __packed struct _gap_start_name_discovery_proc_cp{\n  uint16_t scanInterval;\n  uint16_t scanWindow;\n  uint8_t peer_bdaddr_type;\n  tBDAddr peer_bdaddr;\n  uint8_t own_bdaddr_type;\n  uint16_t conn_min_interval;\n  uint16_t conn_max_interval;\n  uint16_t conn_latency;\n  uint16_t supervision_timeout;\n  uint16_t min_conn_length;\n  uint16_t max_conn_length;\n} PACKED gap_start_name_discovery_proc_cp;\n#define GAP_START_NAME_DISCOVERY_PROC_CP_SIZE 24\n\n#define OCF_GAP_START_AUTO_CONN_ESTABLISH_PROC  0x0099\n\n#define OCF_GAP_START_GENERAL_CONN_ESTABLISH_PROC  0x009A\n\ntypedef __packed struct _gap_start_general_conn_establish_proc_cp_IDB05A1{\n  uint8_t  scan_type;\n  uint16_t scan_interval;\n  uint16_t scan_window;\n  uint8_t  own_address_type;\n  uint8_t  filter_duplicates;\n} PACKED gap_start_general_conn_establish_proc_cp_IDB05A1;\n\ntypedef __packed struct _gap_start_general_conn_establish_proc_cp_IDB04A1{\n  uint8_t  scan_type;\n  uint16_t scan_interval;\n  uint16_t scan_window;\n  uint8_t  own_address_type;\n  uint8_t  filter_duplicates;\n  uint8_t  use_reconn_addr;\n  tBDAddr  reconn_addr;\n} PACKED gap_start_general_conn_establish_proc_cp_IDB04A1;\n\n#define OCF_GAP_START_SELECTIVE_CONN_ESTABLISH_PROC  0x009B\n#define GAP_START_SELECTIVE_CONN_ESTABLISH_PROC_CP_SIZE 8\ntypedef __packed struct _gap_start_selective_conn_establish_proc_cp{\n  uint8_t scan_type;\n  uint16_t scan_interval;\n  uint16_t scan_window;\n  uint8_t own_address_type;\n  uint8_t filter_duplicates;\n  uint8_t num_whitelist_entries;\n  uint8_t addr_array[HCI_MAX_PAYLOAD_SIZE-GAP_START_SELECTIVE_CONN_ESTABLISH_PROC_CP_SIZE];\n} PACKED gap_start_selective_conn_establish_proc_cp;\n\n#define OCF_GAP_CREATE_CONNECTION      0x009C\ntypedef __packed struct _gap_create_connection_cp{\n  uint16_t scanInterval;\n  uint16_t scanWindow;\n  uint8_t peer_bdaddr_type;\n  tBDAddr peer_bdaddr;\n  uint8_t own_bdaddr_type;\n  uint16_t conn_min_interval;\n  uint16_t conn_max_interval;\n  uint16_t conn_latency;\n  uint16_t supervision_timeout;\n  uint16_t min_conn_length;\n  uint16_t max_conn_length;\n} PACKED gap_create_connection_cp;\n#define GAP_CREATE_CONNECTION_CP_SIZE 24\n\n#define OCF_GAP_TERMINATE_GAP_PROCEDURE      0x009D\n\n#define OCF_GAP_START_CONNECTION_UPDATE      0x009E\ntypedef __packed struct _gap_start_connection_update_cp{\n  uint16_t conn_handle;\n  uint16_t conn_min_interval;\n  uint16_t conn_max_interval;\n  uint16_t conn_latency;\n  uint16_t supervision_timeout;\n  uint16_t min_conn_length;\n  uint16_t max_conn_length;\n} PACKED gap_start_connection_update_cp;\n#define GAP_START_CONNECTION_UPDATE_CP_SIZE 14\n\n#define OCF_GAP_SEND_PAIRING_REQUEST      0x009F\ntypedef __packed struct _gap_send_pairing_request_cp{\n  uint16_t conn_handle;\n  uint8_t  force_rebond;\n} PACKED gap_send_pairing_request_cp;\n#define GAP_GAP_SEND_PAIRING_REQUEST_CP_SIZE 3\n\n#define OCF_GAP_RESOLVE_PRIVATE_ADDRESS   0x00A0\ntypedef __packed struct _gap_resolve_private_address_cp{\n  tBDAddr address;\n} PACKED gap_resolve_private_address_cp;\n#define GAP_RESOLVE_PRIVATE_ADDRESS_CP_SIZE 6\n\ntypedef __packed struct _gap_resolve_private_address_rp{\n  uint8_t status;\n  tBDAddr address;\n} PACKED gap_resolve_private_address_rp;\n  \n#define OCF_GAP_SET_BROADCAST_MODE   0x00A1\n#define GAP_SET_BROADCAST_MODE_CP_SIZE 6\ntypedef __packed struct _gap_set_broadcast_mode_cp{\n  uint16_t adv_interv_min;\n  uint16_t adv_interv_max;\n  uint8_t adv_type;\n  uint8_t own_addr_type;\n  uint8_t var_len_data[HCI_MAX_PAYLOAD_SIZE-GAP_SET_BROADCAST_MODE_CP_SIZE];\n} PACKED gap_set_broadcast_mode_cp;\n\n#define OCF_GAP_START_OBSERVATION_PROC   0x00A2\ntypedef __packed struct _gap_start_observation_proc_cp{\n  uint16_t scan_interval;\n  uint16_t scan_window;\n  uint8_t  scan_type;\n  uint8_t  own_address_type;\n  uint8_t  filter_duplicates;\n} PACKED gap_start_observation_proc_cp;\n\n#define OCF_GAP_GET_BONDED_DEVICES   0x00A3\ntypedef __packed struct _gap_get_bonded_devices_rp{\n    uint8_t\t\tstatus;\n    uint8_t\t\tnum_addr;\n\tuint8_t\t\tdev_list[HCI_MAX_PAYLOAD_SIZE-HCI_EVENT_HDR_SIZE-EVT_CMD_COMPLETE_SIZE-1];\n} PACKED gap_get_bonded_devices_rp;\n\n#define OCF_GAP_IS_DEVICE_BONDED   0x00A4\ntypedef __packed struct _gap_is_device_bonded_cp{\n  uint8_t peer_address_type;\n  tBDAddr peer_address;\n} PACKED gap_is_device_bonded_cp;\n\n\n#define OCF_GATT_INIT\t\t        0x0101\n\n#define OCF_GATT_ADD_SERV\t\t    0x0102\ntypedef __packed struct _gatt_add_serv_rp{\n    uint8_t\t\t    status;\n\tuint16_t\t\thandle;\n} PACKED gatt_add_serv_rp;\n#define GATT_ADD_SERV_RP_SIZE 3\n\n#define OCF_GATT_INCLUDE_SERV\t\t0x0103\ntypedef __packed struct _gatt_include_serv_rp{\n\tuint8_t\t\t    status;\n    uint16_t\t\thandle;    \n} PACKED gatt_include_serv_rp;\n#define GATT_INCLUDE_SERV_RP_SIZE 3\n\n#define OCF_GATT_ADD_CHAR\t\t    0x0104\ntypedef __packed struct _gatt_add_char_rp{\n    uint8_t\t\t    status;\n\tuint16_t\t\thandle;\n} PACKED gatt_add_char_rp;\n#define GATT_ADD_CHAR_RP_SIZE 3\n\n#define OCF_GATT_ADD_CHAR_DESC\t    0x0105\ntypedef __packed struct _gatt_add_char_desc_rp{\n    uint8_t\t\t    status;\n\tuint16_t\t\thandle;\n} PACKED gatt_add_char_desc_rp;\n#define GATT_ADD_CHAR_DESC_RP_SIZE 3\n\n#define OCF_GATT_UPD_CHAR_VAL\t\t0x0106\n\n#define OCF_GATT_DEL_CHAR   \t\t0x0107\ntypedef __packed struct _gatt_del_char_cp{\n\tuint16_t\tservice_handle;\n\tuint16_t\tchar_handle;\n} PACKED gatt_del_char_cp;\n#define GATT_DEL_CHAR_CP_SIZE 4\n\n#define OCF_GATT_DEL_SERV   \t\t0x0108\ntypedef __packed struct _gatt_del_serv_cp{\n\tuint16_t\tservice_handle;\n} PACKED gatt_del_serv_cp;\n#define GATT_DEL_SERV_CP_SIZE 2\n\n#define OCF_GATT_DEL_INC_SERV   \t0x0109\ntypedef __packed struct _gatt_del_inc_serv_cp{\n\tuint16_t\tservice_handle;\n    uint16_t\tinc_serv_handle;\n} PACKED gatt_del_inc_serv_cp;\n#define GATT_DEL_INC_SERV_CP_SIZE 4\n\n#define OCF_GATT_SET_EVT_MASK      0x010A\ntypedef __packed struct _gatt_set_evt_mask_cp{\n    uint32_t\tevt_mask;\n} PACKED gatt_set_evt_mask_cp;\n#define GATT_SET_EVT_MASK_CP_SIZE 4\n\n#define OCF_GATT_EXCHANGE_CONFIG      0x010B\ntypedef __packed struct _gatt_exchange_config_cp{\n    uint16_t\tconn_handle;\n} PACKED gatt_exchange_config_cp;\n#define GATT_EXCHANGE_CONFIG_CP_SIZE 2\n\n#define OCF_ATT_FIND_INFO_REQ      0x010C\ntypedef __packed struct _att_find_info_req_cp{\n    uint16_t\tconn_handle;\n    uint16_t\tstart_handle;\n    uint16_t\tend_handle;\n} PACKED att_find_info_req_cp;\n#define ATT_FIND_INFO_REQ_CP_SIZE 6\n\n#define OCF_ATT_FIND_BY_TYPE_VALUE_REQ  0x010D\n#define ATT_FIND_BY_TYPE_VALUE_REQ_CP_SIZE 9\ntypedef __packed struct _att_find_by_type_value_req_cp{\n    uint16_t\tconn_handle;\n    uint16_t\tstart_handle;\n    uint16_t\tend_handle;\n    uint8_t     uuid[2];\n    uint8_t     attr_val_len;\n    uint8_t     attr_val[ATT_MTU - 7];\n} PACKED att_find_by_type_value_req_cp;\n\n#define OCF_ATT_READ_BY_TYPE_REQ  0x010E\n#define ATT_READ_BY_TYPE_REQ_CP_SIZE 7  // without UUID\ntypedef __packed struct _att_read_by_type_req_cp{\n    uint16_t\tconn_handle;\n    uint16_t\tstart_handle;\n    uint16_t\tend_handle;\n    uint8_t     uuid_type;\n    uint8_t     uuid[16];\n} PACKED att_read_by_type_req_cp;\n\n#define OCF_ATT_READ_BY_GROUP_TYPE_REQ  0x010F\n#define ATT_READ_BY_GROUP_TYPE_REQ_CP_SIZE 7  // without UUID\ntypedef __packed struct _att_read_by_group_type_req_cp{\n    uint16_t\tconn_handle;\n    uint16_t\tstart_handle;\n    uint16_t\tend_handle;\n    uint8_t     uuid_type;\n    uint8_t     uuid[16];\n} PACKED att_read_by_group_type_req_cp;\n\n#define OCF_ATT_PREPARE_WRITE_REQ  0x0110\n#define ATT_PREPARE_WRITE_REQ_CP_SIZE 7  // without attr_val\ntypedef __packed struct _att_prepare_write_req_cp{\n    uint16_t\tconn_handle;\n    uint16_t\tattr_handle;\n    uint16_t\tvalue_offset;\n    uint8_t     attr_val_len;\n    uint8_t     attr_val[ATT_MTU-5];\n} PACKED att_prepare_write_req_cp;\n\n#define OCF_ATT_EXECUTE_WRITE_REQ  0x0111\ntypedef __packed struct _att_execute_write_req_cp{\n    uint16_t\tconn_handle;\n    uint8_t     execute;\n} PACKED att_execute_write_req_cp;\n#define ATT_EXECUTE_WRITE_REQ_CP_SIZE 3\n\n#define OCF_GATT_DISC_ALL_PRIM_SERVICES 0X0112\ntypedef __packed struct _gatt_disc_all_prim_serivces_cp{\n  uint16_t conn_handle;\n} PACKED gatt_disc_all_prim_services_cp;\n#define GATT_DISC_ALL_PRIM_SERVICES_CP_SIZE 2\n\n#define OCF_GATT_DISC_PRIM_SERVICE_BY_UUID 0x0113\ntypedef __packed struct _gatt_disc_prim_service_by_uuid_cp{\n  uint16_t    conn_handle;\n  uint8_t     uuid_type;\n  uint8_t     uuid[16];\n} PACKED gatt_disc_prim_service_by_uuid_cp;\n#define GATT_DISC_PRIM_SERVICE_BY_UUID_CP_SIZE 3 // Without uuid\n\n#define OCF_GATT_FIND_INCLUDED_SERVICES 0X0114\ntypedef __packed struct _gatt_disc_find_included_services_cp{\n  uint16_t conn_handle;\n  uint16_t start_handle;\n  uint16_t end_handle;\n} PACKED gatt_find_included_services_cp;\n#define GATT_FIND_INCLUDED_SERVICES_CP_SIZE 6\n\n#define OCF_GATT_DISC_ALL_CHARAC_OF_SERV 0X0115\ntypedef __packed struct _gatt_disc_all_charac_of_serv_cp{\n  uint16_t conn_handle;\n  uint16_t start_attr_handle;\n  uint16_t end_attr_handle;\n} PACKED gatt_disc_all_charac_of_serv_cp;\n#define GATT_DISC_ALL_CHARAC_OF_SERV_CP_SIZE 6\n\n#define OCF_GATT_DISC_CHARAC_BY_UUID 0X0116\n\n#define OCF_GATT_DISC_ALL_CHARAC_DESCRIPTORS 0X0117\ntypedef __packed struct _gatt_disc_all_charac_descriptors_cp{\n  uint16_t conn_handle;\n  uint16_t char_val_handle;\n  uint16_t char_end_handle;\n} PACKED gatt_disc_all_charac_descriptors_cp;\n#define GATT_DISC_ALL_CHARAC_DESCRIPTORS_CP_SIZE 6\n\n#define OCF_GATT_READ_CHARAC_VAL   0x0118\ntypedef __packed struct _gatt_read_charac_val_cp{\n  uint16_t conn_handle;\n  uint16_t attr_handle;\n} PACKED gatt_read_charac_val_cp;\n#define GATT_READ_CHARAC_VAL_CP_SIZE 4\n\n#define OCF_GATT_READ_USING_CHARAC_UUID  0x0109\ntypedef __packed struct _gatt_read_using_charac_uuid_cp{\n    uint16_t\tconn_handle;\n    uint16_t\tstart_handle;\n    uint16_t\tend_handle;\n    uint8_t     uuid_type;\n    uint8_t     uuid[16];\n} PACKED gatt_read_using_charac_uuid_cp;\n#define GATT_READ_USING_CHARAC_UUID_CP_SIZE 7  // without UUID\n\n#define OCF_GATT_READ_LONG_CHARAC_VAL   0x011A\ntypedef __packed struct _gatt_read_long_charac_val_cp{\n  uint16_t conn_handle;\n  uint16_t attr_handle;\n  uint16_t val_offset;\n} PACKED gatt_read_long_charac_val_cp;\n#define GATT_READ_LONG_CHARAC_VAL_CP_SIZE 6\n\n#define OCF_GATT_READ_MULTIPLE_CHARAC_VAL   0x011B\n#define GATT_READ_MULTIPLE_CHARAC_VAL_CP_SIZE 3  // without set_of_handles\ntypedef __packed struct _gatt_read_multiple_charac_val_cp{\n  uint16_t conn_handle;\n  uint8_t num_handles;\n  uint8_t  set_of_handles[HCI_MAX_PAYLOAD_SIZE-GATT_READ_MULTIPLE_CHARAC_VAL_CP_SIZE];\n} PACKED gatt_read_multiple_charac_val_cp;\n\n#define OCF_GATT_WRITE_CHAR_VALUE   0x011C\n\n#define OCF_GATT_WRITE_LONG_CHARAC_VAL   0x011D\n#define GATT_WRITE_LONG_CHARAC_VAL_CP_SIZE 7  // without set_of_handles\ntypedef __packed struct _gatt_write_long_charac_val_cp{\n  uint16_t conn_handle;\n  uint16_t attr_handle;\n  uint16_t val_offset;\n  uint8_t  val_len;\n  uint8_t  attr_val[HCI_MAX_PAYLOAD_SIZE-GATT_WRITE_LONG_CHARAC_VAL_CP_SIZE];\n} PACKED gatt_write_long_charac_val_cp;\n\n#define OCF_GATT_WRITE_CHARAC_RELIABLE   0x011E\n#define GATT_WRITE_CHARAC_RELIABLE_CP_SIZE 7  // without set_of_handles\ntypedef __packed struct _gatt_write_charac_reliable_cp{\n  uint16_t conn_handle;\n  uint16_t attr_handle;\n  uint16_t val_offset;\n  uint8_t  val_len;\n  uint8_t  attr_val[HCI_MAX_PAYLOAD_SIZE-GATT_WRITE_CHARAC_RELIABLE_CP_SIZE];\n} PACKED gatt_write_charac_reliable_cp;\n\n#define OCF_GATT_WRITE_LONG_CHARAC_DESC   0x011F\n#define GATT_WRITE_LONG_CHARAC_DESC_CP_SIZE 7  // without set_of_handles\ntypedef __packed struct _gatt_write_long_charac_desc_cp{\n  uint16_t conn_handle;\n  uint16_t attr_handle;\n  uint16_t val_offset;\n  uint8_t  val_len;\n  uint8_t  attr_val[HCI_MAX_PAYLOAD_SIZE-GATT_WRITE_LONG_CHARAC_DESC_CP_SIZE];\n} PACKED gatt_write_long_charac_desc_cp;\n\n#define OCF_GATT_READ_LONG_CHARAC_DESC   0x0120\ntypedef __packed struct _gatt_read_long_charac_desc_cp{\n  uint16_t conn_handle;\n  uint16_t attr_handle;\n  uint16_t val_offset;\n} PACKED gatt_read_long_charac_desc_cp;\n#define GATT_READ_LONG_CHARAC_DESC_CP_SIZE 6\n\n#define OCF_GATT_WRITE_CHAR_DESCRIPTOR      0x0121\n\n#define OCF_GATT_READ_CHAR_DESCRIPTOR       0x0122\ntypedef __packed struct _gatt_read_charac_desc_cp{\n  uint16_t conn_handle;\n  uint16_t attr_handle;\n} PACKED gatt_read_charac_desc_cp;\n#define GATT_READ_CHAR_DESCRIPTOR_CP_SIZE 4\n\n#define OCF_GATT_WRITE_WITHOUT_RESPONSE     0x0123\n#define GATT_WRITE_WITHOUT_RESPONSE_CP_SIZE 5  // without attr_val\ntypedef __packed struct _gatt_write_without_resp_cp{\n  uint16_t conn_handle;\n  uint16_t attr_handle;\n  uint8_t  val_len;\n  uint8_t  attr_val[ATT_MTU - 3];\n} PACKED gatt_write_without_resp_cp;\n\n#define OCF_GATT_SIGNED_WRITE_WITHOUT_RESPONSE     0x0124\n#define GATT_SIGNED_WRITE_WITHOUT_RESPONSE_CP_SIZE 5  // without attr_val\ntypedef __packed struct _gatt_signed_write_without_resp_cp{\n  uint16_t conn_handle;\n  uint16_t attr_handle;\n  uint8_t  val_len;\n  uint8_t  attr_val[ATT_MTU - 13];\n} PACKED gatt_signed_write_without_resp_cp;\n\n#define OCF_GATT_CONFIRM_INDICATION                0x0125\ntypedef __packed struct _gatt_confirm_indication_cp{\n\tuint16_t\tconn_handle;\n} PACKED gatt_confirm_indication_cp;\n#define GATT_CONFIRM_INDICATION_CP_SIZE 2\n\n#define OCF_GATT_WRITE_RESPONSE                    0x0126\n\n#define OCF_GATT_ALLOW_READ\t\t    0x0127\ntypedef __packed struct _gatt_allow_read_cp{\n\tuint16_t\tconn_handle;\n} PACKED gatt_allow_read_cp;\n#define GATT_ALLOW_READ_CP_SIZE 2\n\n#define OCF_GATT_SET_SECURITY_PERMISSION\t\t    0x0128\ntypedef __packed struct _gatt_set_security_permission_cp{\n\tuint16_t\tservice_handle;\n    uint16_t\tattr_handle;\n    uint8_t\t    security_permission;\n} PACKED gatt_set_security_permission_cp;\n#define GATT_GATT_SET_SECURITY_PERMISSION_CP_SIZE 5\n\n#define OCF_GATT_SET_DESC_VAL\t\t0x0129\n\n#define OCF_GATT_READ_HANDLE_VALUE      0x012A\ntypedef __packed struct _gatt_read_handle_val_cp{\n\tuint16_t\tattr_handle;\n} PACKED gatt_read_handle_val_cp;\n#define GATT_READ_HANDLE_VALUE_RP_SIZE 3\ntypedef __packed struct _gatt_read_handle_val_rp{\n    uint8_t\t\tstatus;\n    uint16_t\tvalue_len;\n\tuint8_t\t\tvalue[HCI_MAX_PAYLOAD_SIZE-GATT_READ_HANDLE_VALUE_RP_SIZE];\n} PACKED gatt_read_handle_val_rp;\n\n#define OCF_GATT_READ_HANDLE_VALUE_OFFSET      0x012B\ntypedef __packed struct _gatt_read_handle_val_offset_cp{\n\tuint16_t\tattr_handle;\n    uint8_t     offset;\n} PACKED gatt_read_handle_val_offset_cp;\n#define GATT_READ_HANDLE_VALUE_OFFSET_RP_SIZE 2\ntypedef __packed struct _gatt_read_handle_val_offset_rp{\n    uint8_t\t\tstatus;\n    uint8_t\t\tvalue_len;\n\tuint8_t\t\tvalue[HCI_MAX_PAYLOAD_SIZE-GATT_READ_HANDLE_VALUE_OFFSET_RP_SIZE];\n} PACKED gatt_read_handle_val_offset_rp;\n\n#define OCF_GATT_UPD_CHAR_VAL_EXT\t\t        0x012C\n#define GATT_UPD_CHAR_VAL_EXT_CP_SIZE 10  // without value\ntypedef __packed struct _gatt_upd_char_val_ext_cp{\n  uint16_t service_handle;\n  uint16_t char_handle;\n  uint8_t  update_type;\n  uint16_t char_length;\n  uint16_t value_offset;\n  uint8_t  value_length;\n  uint8_t  value[HCI_MAX_PAYLOAD_SIZE-GATT_UPD_CHAR_VAL_EXT_CP_SIZE];\n} PACKED gatt_upd_char_val_ext_cp;\n\n#define OCF_L2CAP_CONN_PARAM_UPDATE_REQ  0x0181\ntypedef __packed struct _l2cap_conn_param_update_req_cp{\n  uint16_t conn_handle;\n  uint16_t interval_min;\n  uint16_t interval_max;\n  uint16_t slave_latency;\n  uint16_t timeout_multiplier;\n} PACKED l2cap_conn_param_update_req_cp;\n#define L2CAP_CONN_PARAM_UPDATE_REQ_CP_SIZE 10\n\n#define OCF_L2CAP_CONN_PARAM_UPDATE_RESP  0x0182\n\ntypedef __packed struct _l2cap_conn_param_update_resp_cp_IDB05A1{\n  uint16_t conn_handle;\n  uint16_t interval_min;\n  uint16_t interval_max;\n  uint16_t slave_latency;\n  uint16_t timeout_multiplier;\n  uint16_t min_ce_length;\n  uint16_t max_ce_length;\n  uint8_t id;\n  uint8_t accept;\n} PACKED l2cap_conn_param_update_resp_cp_IDB05A1;\n\ntypedef __packed struct _l2cap_conn_param_update_resp_cp_IDB04A1{\n  uint16_t conn_handle;\n  uint16_t interval_min;\n  uint16_t interval_max;\n  uint16_t slave_latency;\n  uint16_t timeout_multiplier;\n  uint8_t id;\n  uint8_t accept;\n} PACKED l2cap_conn_param_update_resp_cp_IDB04A1;\n\n/** \n * @addtogroup HIGH_LEVEL_INTERFACE HIGH_LEVEL_INTERFACE\n * @{\n */\n\n/**\n * @addtogroup ACI ACI\n * @brief API for ACI layer.\n * @{\n */\n\n/**\n * @defgroup ACI_EVENTS ACI_EVENTS\n * @brief BlueNRG events (vendor specific)\n * @{\n */\n\n/**\n * @name Vendor Specific Event\n * @brief Vendor specific event for BlueNRG.\n */\ntypedef __packed struct _evt_blue_aci{\n  uint16_t ecode; /**< One of the BlueNRG event codes. */\n  uint8_t  data[VARIABLE_SIZE];\n} PACKED evt_blue_aci;\n\n/**\n * @}\n */\n \n/**\n * @}\n */\n\n/**\n * @}\n */\n\n/**\n * @}\n */\n\n#endif /* __BLUENRG_ACI_CONST_H_ */\n",
                "bluenrg_conf.h": "/**\n ******************************************************************************\n * File Name bluenrg_conf.h\n * @author   CL\n * @version  V1.0.0\n * @date     05-Mar-2018\n * @brief \n ******************************************************************************\n  * @attention\n  *\n  * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.\n  * All rights reserved.</center></h2>\n  *\n  * This software component is licensed by ST under Ultimate Liberty license\n  * SLA0044, the \"License\"; You may not use this file except in compliance with\n  * the License. You may obtain a copy of the License at:\n  *                             www.st.com/SLA0044\n  *\n ******************************************************************************\n */\n\n/* Define to prevent recursive inclusion -------------------------------------*/\n#ifndef BLUENRG_CONF_H\n#define BLUENRG_CONF_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Includes ------------------------------------------------------------------*/\n\n#include <string.h>\n#include \"../app_src/atmosphere_platform.h\"\n\n/*---------- Print messages from files at user level -----------*/\n#define DEBUG      0\n/*---------- Print the data travelling over the SPI in the .csv format for the GUI -----------*/\n#define PRINT_CSV_FORMAT      0\n/*---------- Number of Bytes reserved for HCI Read Packet -----------*/\n#define HCI_READ_PACKET_SIZE      128\n/*---------- Number of Bytes reserved for HCI Max Payload -----------*/\n#define HCI_MAX_PAYLOAD_SIZE      128\n/*---------- Scan Interval: time interval from when the Controller started its last scan until it begins the subsequent scan (for a number N, Time = N x 0.625 msec) -----------*/\n#define SCAN_P      16384\n/*---------- Scan Window: amount of time for the duration of the LE scan (for a number N, Time = N x 0.625 msec) -----------*/\n#define SCAN_L      16384\n/*---------- Supervision Timeout for the LE Link (for a number N, Time = N x 10 msec) -----------*/\n#define SUPERV_TIMEOUT      60\n/*---------- Minimum Connection Period (for a number N, Time = N x 1.25 msec) -----------*/\n#define CONN_P1      40\n/*---------- Maximum Connection Period (for a number N, Time = N x 1.25 msec) -----------*/\n#define CONN_P2      40\n/*---------- Minimum Connection Length (for a number N, Time = N x 0.625 msec) -----------*/\n#define CONN_L1      2000\n/*---------- Maximum Connection Length (for a number N, Time = N x 0.625 msec) -----------*/\n#define CONN_L2      2000\n/*---------- Advertising Type -----------*/\n#define ADV_DATA_TYPE      ADV_IND\n/*---------- Minimum Advertising Interval (for a number N, Time = N x 0.625 msec) -----------*/\n#define ADV_INTERV_MIN      2048\n/*---------- Maximum Advertising Interval (for a number N, Time = N x 0.625 msec) -----------*/\n#define ADV_INTERV_MAX      4096\n/*---------- Minimum Connection Event Interval (for a number N, Time = N x 1.25 msec) -----------*/\n#define L2CAP_INTERV_MIN      9\n/*---------- Maximum Connection Event Interval (for a number N, Time = N x 1.25 msec) -----------*/\n#define L2CAP_INTERV_MAX      20\n/*---------- Timeout Multiplier (for a number N, Time = N x 10 msec) -----------*/\n#define L2CAP_TIMEOUT_MULTIPLIER      600\n\n#define HCI_DEFAULT_TIMEOUT_MS        1000\n\n#define BLUENRG_memcpy                memcpy\n#define BLUENRG_memset                memset\n  \n#if (DEBUG == 1)\n#define PRINTF(...)                   ATMO_PLATFORM_DebugPrint(__VA_ARGS__)\n#else\n#define PRINTF(...)\n#endif\n\n#if PRINT_CSV_FORMAT\n#include <stdio.h>\n#define PRINT_CSV(...)                ATMO_PLATFORM_DebugPrint(__VA_ARGS__)\nvoid print_csv_time(void);\n#else\n#define PRINT_CSV(...)\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* BLUENRG_CONF_H */\n\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\n",
                "bluenrg_def.h": "/******************** (C) COPYRIGHT 2012 STMicroelectronics ********************\n* File Name          : ble_def.h\n* Author             : AMS - HEA&RF BU\n* Version            : V1.0.0\n* Date               : 19-July-2012\n* Description        : Header file with BLE Stack defines.\n********************************************************************************\n* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\n* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.\n* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,\n* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE\n* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING\n* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\n*******************************************************************************/\n#ifndef __BLE_DEF_H__\n#define __BLE_DEF_H__\n\n#include \"bluenrg_types.h\"\n\n/** \n * @addtogroup HIGH_LEVEL_INTERFACE HIGH_LEVEL_INTERFACE\n * @{\n */\n\n /**\n * @addtogroup ACI_GAP ACI_GAP\n * @brief API for GAP layer.\n * @{\n */\n \n/** \n * @defgroup ERROR_CODES Bluetooth Status/Error Codes\n * @brief BLE standard and vendor-specific status/error codes\n * @{\n */\n \ntypedef uint8_t tBleStatus; \n\n/* Error Codes as specified by the specification \n * according to the spec the error codes range\n * from 0x00 to 0x3F \n */\n/**\n * @name Standard error codes\n * @brief Standard error codes. See Core v 4.1, Vol. 2, part D.\n * @{\n */\n#define ERR_CMD_SUCCESS         \t                (0x00)\n#define BLE_STATUS_SUCCESS            \t\t        (0x00)\n#define ERR_UNKNOWN_HCI_COMMAND\t                    (0x01)\n#define ERR_UNKNOWN_CONN_IDENTIFIER\t                (0x02)\n\n#define ERR_AUTH_FAILURE                            (0x05)\n#define ERR_PIN_OR_KEY_MISSING                      (0x06)\n#define ERR_MEM_CAPACITY_EXCEEDED                   (0x07)\n#define ERR_CONNECTION_TIMEOUT                      (0x08)\n\n#define ERR_COMMAND_DISALLOWED\t\t\t\t        (0x0C)\n\n#define ERR_UNSUPPORTED_FEATURE\t\t\t\t        (0x11)\n#define ERR_INVALID_HCI_CMD_PARAMS                  (0x12)\n#define ERR_RMT_USR_TERM_CONN                       (0x13)\n#define ERR_RMT_DEV_TERM_CONN_LOW_RESRCES           (0x14)\n#define ERR_RMT_DEV_TERM_CONN_POWER_OFF             (0x15)\n#define ERR_LOCAL_HOST_TERM_CONN                    (0x16)\n\n#define ERR_UNSUPP_RMT_FEATURE                      (0x1A)\n\n#define ERR_INVALID_LMP_PARAM                       (0x1E)\n#define ERR_UNSPECIFIED_ERROR                       (0x1F)\n\n#define ERR_LL_RESP_TIMEOUT                         (0x22)\n#define ERR_LMP_PDU_NOT_ALLOWED                     (0x24)\n\n#define ERR_INSTANT_PASSED                          (0x28)\n\n#define ERR_PAIR_UNIT_KEY_NOT_SUPP                  (0x29)\n#define ERR_CONTROLLER_BUSY                         (0x3A)\n\n#define ERR_DIRECTED_ADV_TIMEOUT                    (0x3C)\n\n#define ERR_CONN_END_WITH_MIC_FAILURE               (0x3D)\n\n#define ERR_CONN_FAILED_TO_ESTABLISH                (0x3E)\n\n/**\n * @}\n */\n \n/**\n * @name Vendor-specific error codes\n * @brief Error codes defined by ST related to BlueNRG stack\n * @{\n */\n/**\n * The command cannot be executed due to the current state of the device.\n */\n#define BLE_STATUS_FAILED                   (0x41)\n/**\n * Some parameters are invalid.\n */\n#define BLE_STATUS_INVALID_PARAMS           (0x42)\n/**\n * It is not allowed to start the procedure (e.g. another the procedure is ongoing\n * or cannot be started on the given handle).\n */\n#define BLE_STATUS_NOT_ALLOWED              (0x46)\n/**\n * Unexpected error.\n */\n#define BLE_STATUS_ERROR                    (0x47)\n#define BLE_STATUS_ADDR_NOT_RESOLVED        (0x48)\n\n#define FLASH_READ_FAILED                   (0x49)\n#define FLASH_WRITE_FAILED                  (0x4A)\n#define FLASH_ERASE_FAILED                  (0x4B)\n\n#define BLE_STATUS_INVALID_CID              (0x50)\n\n#define TIMER_NOT_VALID_LAYER               (0x54)\n#define TIMER_INSUFFICIENT_RESOURCES        (0x55)\n \n#define BLE_STATUS_CSRK_NOT_FOUND           (0x5A)\n#define BLE_STATUS_IRK_NOT_FOUND            (0x5B)\n#define BLE_STATUS_DEV_NOT_FOUND_IN_DB      (0x5C)\n#define BLE_STATUS_SEC_DB_FULL              (0x5D)\n#define BLE_STATUS_DEV_NOT_BONDED           (0x5E)\n#define BLE_STATUS_DEV_IN_BLACKLIST         (0x5F)\n \n#define BLE_STATUS_INVALID_HANDLE           (0x60)\n#define BLE_STATUS_INVALID_PARAMETER        (0x61)\n#define BLE_STATUS_OUT_OF_HANDLE            (0x62)\n#define BLE_STATUS_INVALID_OPERATION        (0x63)\n#define BLE_STATUS_INSUFFICIENT_RESOURCES   (0x64)\n#define BLE_INSUFFICIENT_ENC_KEYSIZE        (0x65)\n#define BLE_STATUS_CHARAC_ALREADY_EXISTS    (0x66)\n\n/**\n * Returned when no valid slots are available (e.g. when there are no available state machines).\n  */\n#define BLE_STATUS_NO_VALID_SLOT                (0x82)\n\n/**\n * Returned when a scan window shorter than minimum allowed value has been requested (i.e. 2ms)\n */\n \n#define BLE_STATUS_SCAN_WINDOW_SHORT            (0x83)\n/**\n * Returned when the maximum requested interval to be allocated is shorter then the current\n * anchor period and a there is no sub-multiple for the current anchor period that is between\n * the minimum and the maximum requested intervals.\n */\n\n#define BLE_STATUS_NEW_INTERVAL_FAILED          (0x84)\n/**\n * Returned when the maximum requested interval to be allocated is greater than the current anchor\n * period and there is no multiple of the anchor period that is between the minimum and the maximum\n * requested intervals.\n */\n\n#define BLE_STATUS_INTERVAL_TOO_LARGE           (0x85)\n/**\n * Returned when the current anchor period or a new one can be found that is compatible to the\n * interval range requested by the new slot but the maximum available length that can be allocated is\n * less than the minimum requested slot length.\n */\n \n#define BLE_STATUS_LENGTH_FAILED                (0x86)\n/**\n * @}\n */\n\n/**\n * @name Library Error Codes\n * @brief Error codes defined by ST related to MCU library.\n * @{\n */\n#define BLE_STATUS_TIMEOUT                      (0xFF)\n#define BLE_STATUS_PROFILE_ALREADY_INITIALIZED  (0xF0)\n#define BLE_STATUS_NULL_PARAM                   (0xF1) \n/**\n * @}\n */\n\n/**\n * @}\n */\n \n/**\n * @}\n */\n \n/**\n * @}\n */\n \n#endif /* __BLE_DEF_H__ */\n",
                "bluenrg_gap.h": "/******************** (C) COPYRIGHT 2012 STMicroelectronics ********************\n* File Name          : bluenrg_gap.h\n* Author             : AMS - HEA&RF BU\n* Version            : V1.0.0\n* Date               : 19-July-2012\n* Description        : Header file for BlueNRG's GAP layer. \n********************************************************************************\n* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\n* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.\n* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,\n* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE\n* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING\n* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\n*******************************************************************************/\n#ifndef __BLUENRG_GAP_H__\n#define __BLUENRG_GAP_H__\n\n#include \"link_layer.h\"\n\n/** \n * @addtogroup HIGH_LEVEL_INTERFACE HIGH_LEVEL_INTERFACE\n * @{\n */\n \n/**\n * @addtogroup ACI_GAP ACI_GAP\n * @brief API for GAP layer.\n * @{\n */\n\n/**\n * @name GAP UUIDs\n * @{\n */\n#define GAP_SERVICE_UUID                        (0x1800)\n#define DEVICE_NAME_UUID\t\t\t\t\t\t(0x2A00)\n#define APPEARANCE_UUID\t\t\t\t\t\t\t(0x2A01)\n#define PERIPHERAL_PRIVACY_FLAG_UUID\t\t\t(0x2A02)\n#define RECONNECTION_ADDR_UUID\t\t\t\t\t(0x2A03)\n#define PERIPHERAL_PREFERRED_CONN_PARAMS_UUID\t(0x2A04)\n/**\n * @}\n */\n\n/**\n * @name Characteristic value lengths\n * @{\n */\n#define DEVICE_NAME_CHARACTERISTIC_LEN\t\t\t        (8)\n#define APPEARANCE_CHARACTERISTIC_LEN\t\t\t        (2)\n#define PERIPHERAL_PRIVACY_CHARACTERISTIC_LEN\t        (1)\n#define RECONNECTION_ADDR_CHARACTERISTIC_LEN\t\t\t(6)\n#define PERIPHERAL_PREF_CONN_PARAMS_CHARACTERISTIC_LEN\t(8)\n/**\n * @}\n */\n\n/*------------- AD types for adv data and scan response data ----------------*/\n\n/**\n * @defgroup AD_Types AD Types\n * @brief AD Types\n * @{\n */\n\n/* FLAGS AD type */\n#define AD_TYPE_FLAGS\t\t\t\t\t\t\t(0x01)\n/* flag bits */\n/**\n * @anchor Flags_AD_Type_bits\n * @name Flags AD Type bits\n * @brief Bits in Flags AD Type\n * @{\n */\n#define FLAG_BIT_LE_LIMITED_DISCOVERABLE_MODE\t(0x01)\n#define FLAG_BIT_LE_GENERAL_DISCOVERABLE_MODE\t(0x02)\n#define FLAG_BIT_BR_EDR_NOT_SUPPORTED\t\t\t(0x04)\n#define FLAG_BIT_LE_BR_EDR_CONTROLLER\t\t\t(0x08)\n#define FLAG_BIT_LE_BR_EDR_HOST\t\t\t\t\t(0x10)\n/**\n * @}\n */\n\n/**\n * @name Service UUID AD types\n * @{\n */\n#define AD_TYPE_16_BIT_SERV_UUID\t\t\t\t(0x02)\n#define AD_TYPE_16_BIT_SERV_UUID_CMPLT_LIST\t\t(0x03)\n#define AD_TYPE_32_BIT_SERV_UUID\t\t\t\t(0x04)\n#define AD_TYPE_32_BIT_SERV_UUID_CMPLT_LIST\t\t(0x05)\n#define AD_TYPE_128_BIT_SERV_UUID\t\t\t\t(0x06)\n#define AD_TYPE_128_BIT_SERV_UUID_CMPLT_LIST\t(0x07)\n/**\n * @}\n */\n\n/* LOCAL NAME AD types */\n/**\n * @name Local name AD types\n * @{\n */\n#define AD_TYPE_SHORTENED_LOCAL_NAME\t\t\t(0x08)\n#define AD_TYPE_COMPLETE_LOCAL_NAME\t\t\t    (0x09)\n/**\n * @}\n */\n\n/* TX power level AD type*/\n#define AD_TYPE_TX_POWER_LEVEL\t\t\t\t\t(0x0A)\n\n/* Class of device */\n#define AD_TYPE_CLASS_OF_DEVICE\t\t\t\t\t(0x0D)\n\n/* security manager TK value AD type */\n#define AD_TYPE_SEC_MGR_TK_VALUE\t\t\t\t(0x10)\n\n/* security manager OOB flags */\n#define AD_TYPE_SEC_MGR_OOB_FLAGS\t\t\t\t(0x11)\n\n/* slave connection interval AD type */\n#define AD_TYPE_SLAVE_CONN_INTERVAL\t\t\t\t(0x12)\n\n/* service solicitation UUID list Ad types*/\n/**\n * @name Service solicitation UUID list AD types\n * @{\n */\n#define AD_TYPE_SERV_SOLICIT_16_BIT_UUID_LIST\t(0x14)\n#define AD_TYPE_SERV_SOLICIT_32_BIT_UUID_LIST\t(0x1F)\n#define AD_TYPE_SERV_SOLICIT_128_BIT_UUID_LIST\t(0x15)\n/**\n * @}\n */\n\n/* service data AD type */\n#define AD_TYPE_SERVICE_DATA\t\t\t\t\t(0x16)\t\n\n/* manufacturer specific data AD type */\n#define AD_TYPE_MANUFACTURER_SPECIFIC_DATA\t\t(0xFF)\n\n/**\n * @}\n */\n\n#define MAX_ADV_DATA_LEN\t\t\t\t\t\t(31)\n\n#define DEVICE_NAME_LEN\t\t\t  \t\t\t\t(7)\n#define BD_ADDR_SIZE\t\t\t\t\t\t\t(6)\n\n/**\n * @name Privacy flag values\n * @{\n */\n#define PRIVACY_ENABLED\t\t\t\t\t\t\t(0x01)\n#define PRIVACY_DISABLED\t\t\t\t\t\t(0x00)\n/**\n * @}\n */\n\n/**\n * @name Intervals\n * Intervals in terms of 625 micro sec\n * @{\n */\n#define DIR_CONN_ADV_INT_MIN\t\t\t\t\t(0x190)/*250ms*/\n#define DIR_CONN_ADV_INT_MAX\t\t\t\t\t(0x320)/*500ms*/\n#define UNDIR_CONN_ADV_INT_MIN\t\t\t\t\t(0x800)/*1.28s*/\n#define UNDIR_CONN_ADV_INT_MAX\t\t\t\t\t(0x1000)/*2.56s*/\n#define LIM_DISC_ADV_INT_MIN\t\t\t\t\t(0x190)/*250ms*/\n#define LIM_DISC_ADV_INT_MAX\t\t\t\t\t(0x320)/*500ms*/\n#define GEN_DISC_ADV_INT_MIN\t\t\t\t\t(0x800)/*1.28s*/\n#define GEN_DISC_ADV_INT_MAX\t\t\t\t\t(0x1000)/*2.56s*/\n/**\n * @}\n */\n\n/**\n * @name Timeout values\n * @{\n */\n#define LIM_DISC_MODE_TIMEOUT\t\t\t\t\t(180000)/* 180 seconds. according to the errata published */\n#define PRIVATE_ADDR_INT_TIMEOUT\t\t\t\t(900000)/* 15 minutes */\n/**\n * @}\n */\n\n/**\n * @anchor gap_roles\n * @name GAP Roles\n * @{\n*/\n#define GAP_PERIPHERAL_ROLE_IDB05A1\t\t\t(0x01)\n#define GAP_BROADCASTER_ROLE_IDB05A1\t\t        (0x02)\n#define GAP_CENTRAL_ROLE_IDB05A1\t\t\t(0x04)\n#define GAP_OBSERVER_ROLE_IDB05A1\t\t\t(0x08)\n\n#define GAP_PERIPHERAL_ROLE_IDB04A1\t\t\t(0x01)\n#define GAP_BROADCASTER_ROLE_IDB04A1\t\t        (0x02)\n#define GAP_CENTRAL_ROLE_IDB04A1\t\t\t(0x03)\n#define GAP_OBSERVER_ROLE_IDB04A1\t\t\t(0x04)\n\n/**\n * @}\n */\n\n/**\n * @anchor gap_procedure_codes\n * @name GAP procedure codes\n * Procedure codes for EVT_BLUE_GAP_PROCEDURE_COMPLETE event\n * and aci_gap_terminate_gap_procedure() command.\n * @{\n */\n#define GAP_LIMITED_DISCOVERY_PROC                  (0x01)\n#define GAP_GENERAL_DISCOVERY_PROC                  (0x02)\n#define GAP_NAME_DISCOVERY_PROC                     (0x04)\n#define GAP_AUTO_CONNECTION_ESTABLISHMENT_PROC      (0x08)\n#define GAP_GENERAL_CONNECTION_ESTABLISHMENT_PROC   (0x10)\n#define GAP_SELECTIVE_CONNECTION_ESTABLISHMENT_PROC (0x20)\n#define GAP_DIRECT_CONNECTION_ESTABLISHMENT_PROC    (0x40)\n\n#define GAP_OBSERVATION_PROC_IDB05A1                (0x80)\n\n/**\n * @}\n */\n\n/**\n * @}\n */\n   \n/**\n * @}\n */\n\n#endif /* __BLUENRG_GAP_H__ */\n",
                "bluenrg_gap_aci.c": "/******************** (C) COPYRIGHT 2014 STMicroelectronics ********************\n* File Name          : bluenrg_hci.c\n* Author             : AMS - HEA&RF BU\n* Version            : V1.0.0\n* Date               : 4-Oct-2013\n* Description        : File with HCI commands for BlueNRG FW6.0 and above.\n********************************************************************************\n* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\n* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.\n* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,\n* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE\n* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING\n* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\n*******************************************************************************/\n\n#include \"bluenrg_types.h\"\n#include \"bluenrg_def.h\"\n#include \"hci_const.h\"\n#include \"bluenrg_aci_const.h\"\n#include \"bluenrg_gap_aci.h\"\n#include \"bluenrg_gatt_server.h\"\n#include \"bluenrg_gap.h\"\n\n#define MIN(a,b)            ((a) < (b) )? (a) : (b)\n#define MAX(a,b)            ((a) > (b) )? (a) : (b)\n\ntBleStatus aci_gap_init_IDB05A1(uint8_t role, uint8_t privacy_enabled, uint8_t device_name_char_len, uint16_t* service_handle, uint16_t* dev_name_char_handle, uint16_t* appearance_char_handle)\n{\n  struct hci_request rq;\n  gap_init_cp_IDB05A1 cp;\n  gap_init_rp resp;\n \n  cp.role = role;\n  cp.privacy_enabled = privacy_enabled;\n  cp.device_name_char_len = device_name_char_len;\n    \n  BLUENRG_memset(&resp, 0, sizeof(resp));\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_INIT;\n  rq.cparam = &cp;\n  rq.clen = sizeof(cp);\n  rq.rparam = &resp;\n  rq.rlen = GAP_INIT_RP_SIZE;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  if (resp.status) {\n    return resp.status;\n  }\n  \n  *service_handle = btohs(resp.service_handle);\n  *dev_name_char_handle = btohs(resp.dev_name_char_handle);\n  *appearance_char_handle = btohs(resp.appearance_char_handle);\n  \n  return 0;\n}\n\ntBleStatus aci_gap_init_IDB04A1(uint8_t role, uint16_t* service_handle, uint16_t* dev_name_char_handle, uint16_t* appearance_char_handle)\n{\n  struct hci_request rq;\n  gap_init_cp_IDB04A1 cp;\n  gap_init_rp resp;\n\n  cp.role = role;\n    \n  BLUENRG_memset(&resp, 0, sizeof(resp));\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_INIT;\n  rq.cparam = &cp;\n  rq.clen = sizeof(cp);\n  rq.rparam = &resp;\n  rq.rlen = GAP_INIT_RP_SIZE;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  if (resp.status) {\n    return resp.status;\n  }\n  \n  *service_handle = btohs(resp.service_handle);\n  *dev_name_char_handle = btohs(resp.dev_name_char_handle);\n  *appearance_char_handle = btohs(resp.appearance_char_handle);\n  \n  return 0;\n}\n\ntBleStatus aci_gap_set_non_discoverable(void)\n{\n  struct hci_request rq;\n  uint8_t status;\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_SET_NON_DISCOVERABLE;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  return status;  \n}\n\ntBleStatus aci_gap_set_limited_discoverable(uint8_t AdvType, uint16_t AdvIntervMin, uint16_t AdvIntervMax,\n\t\t\t\t\t    uint8_t OwnAddrType, uint8_t AdvFilterPolicy, uint8_t LocalNameLen,\n\t\t\t\t\t    const char *LocalName, uint8_t ServiceUUIDLen, uint8_t* ServiceUUIDList,\n\t\t\t\t\t    uint16_t SlaveConnIntervMin, uint16_t SlaveConnIntervMax)\n{\n  struct hci_request rq;\n  uint8_t status;    \n  uint8_t buffer[40];\n  uint8_t indx = 0;\n    \n  if ((LocalNameLen+ServiceUUIDLen+14) > sizeof(buffer))\n    return BLE_STATUS_INVALID_PARAMS;\n\n  buffer[indx] = AdvType;\n  indx++;\n    \n  AdvIntervMin = htobs(AdvIntervMin);\n  BLUENRG_memcpy(buffer + indx, &AdvIntervMin, 2);\n  indx +=  2;\n    \n  AdvIntervMax = htobs(AdvIntervMax);\n  BLUENRG_memcpy(buffer + indx, &AdvIntervMax, 2);\n  indx +=  2;\n    \n  buffer[indx] = OwnAddrType;\n  indx++;\n    \n  buffer[indx] = AdvFilterPolicy;\n  indx++;\n    \n  buffer[indx] = LocalNameLen;\n  indx++;\n    \n  BLUENRG_memcpy(buffer + indx, LocalName, LocalNameLen);\n  indx +=  LocalNameLen;\n\n  buffer[indx] = ServiceUUIDLen;\n  indx++;\n\n  BLUENRG_memcpy(buffer + indx, ServiceUUIDList, ServiceUUIDLen);\n  indx +=  ServiceUUIDLen;\n\n  BLUENRG_memcpy(buffer + indx, &SlaveConnIntervMin, 2);\n  indx +=  2;\n\n  BLUENRG_memcpy(buffer + indx, &SlaveConnIntervMax, 2);\n  indx +=  2;    \n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_SET_LIMITED_DISCOVERABLE;\n  rq.cparam = (void *)buffer;\n  rq.clen = indx;\n  rq.event = EVT_CMD_STATUS;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gap_set_discoverable(uint8_t AdvType, uint16_t AdvIntervMin, uint16_t AdvIntervMax,\n                             uint8_t OwnAddrType, uint8_t AdvFilterPolicy, uint8_t LocalNameLen,\n                             const char *LocalName, uint8_t ServiceUUIDLen, uint8_t* ServiceUUIDList,\n                             uint16_t SlaveConnIntervMin, uint16_t SlaveConnIntervMax)\n{\n  struct hci_request rq;\n  uint8_t status;    \n  uint8_t buffer[40];\n  uint8_t indx = 0;\n  \n  if ((LocalNameLen+ServiceUUIDLen+14) > sizeof(buffer))\n    return BLE_STATUS_INVALID_PARAMS;\n\n  buffer[indx] = AdvType;\n  indx++;\n  \n  AdvIntervMin = htobs(AdvIntervMin);\n  BLUENRG_memcpy(buffer + indx, &AdvIntervMin, 2);\n  indx +=  2;\n    \n  AdvIntervMax = htobs(AdvIntervMax);\n  BLUENRG_memcpy(buffer + indx, &AdvIntervMax, 2);\n  indx +=  2;\n    \n  buffer[indx] = OwnAddrType;\n  indx++;\n    \n  buffer[indx] = AdvFilterPolicy;\n  indx++;\n    \n  buffer[indx] = LocalNameLen;\n  indx++;\n    \n  BLUENRG_memcpy(buffer + indx, LocalName, LocalNameLen);\n  indx +=  LocalNameLen;\n  \n  buffer[indx] = ServiceUUIDLen;\n  indx++;\n\n  BLUENRG_memcpy(buffer + indx, ServiceUUIDList, ServiceUUIDLen);\n  indx +=  ServiceUUIDLen;  \n\n  SlaveConnIntervMin = htobs(SlaveConnIntervMin);\n  BLUENRG_memcpy(buffer + indx, &SlaveConnIntervMin, 2);\n  indx +=  2;\n  \n  SlaveConnIntervMax = htobs(SlaveConnIntervMax);\n  BLUENRG_memcpy(buffer + indx, &SlaveConnIntervMax, 2);\n  indx +=  2;    \n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_SET_DISCOVERABLE;\n  rq.cparam = (void *)buffer;\n  rq.clen = indx;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  if (status) {\n    return status;\n  }\n\n  return 0;\n}\n\ntBleStatus aci_gap_set_direct_connectable_IDB05A1(uint8_t own_addr_type, uint8_t directed_adv_type, uint8_t initiator_addr_type,\n                                                  const uint8_t *initiator_addr, uint16_t adv_interv_min, uint16_t adv_interv_max)\n\n{\n  struct hci_request rq;\n  gap_set_direct_conectable_cp_IDB05A1 cp;\n  uint8_t status;    \n\n  cp.own_bdaddr_type = own_addr_type;\n  cp.directed_adv_type = directed_adv_type;\n  cp.adv_interv_min = adv_interv_min;\n  cp.adv_interv_max = adv_interv_max;\n  cp.direct_bdaddr_type = initiator_addr_type;\n  BLUENRG_memcpy(cp.direct_bdaddr, initiator_addr, 6);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_SET_DIRECT_CONNECTABLE;\n  rq.cparam = &cp;\n  rq.clen = sizeof(cp);\n  rq.rparam = &status;\n  rq.rlen = 1;\n    \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n    \n  return status;\n}\n\ntBleStatus aci_gap_set_direct_connectable_IDB04A1(uint8_t own_addr_type, uint8_t initiator_addr_type, const uint8_t *initiator_addr)\n{\n  struct hci_request rq;\n  gap_set_direct_conectable_cp_IDB04A1 cp;\n  uint8_t status;    \n\n  cp.own_bdaddr_type = own_addr_type; \n  cp.direct_bdaddr_type = initiator_addr_type;\n  BLUENRG_memcpy(cp.direct_bdaddr, initiator_addr, 6);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_SET_DIRECT_CONNECTABLE;\n  rq.cparam = &cp;\n  rq.clen = sizeof(cp);\n  rq.rparam = &status;\n  rq.rlen = 1;\n    \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n    \n  return status;\n}\n\ntBleStatus aci_gap_set_io_capability(uint8_t io_capability)\n{\n  struct hci_request rq;\n  uint8_t status;\n  gap_set_io_capability_cp cp;\n    \n  cp.io_capability = io_capability;\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_SET_IO_CAPABILITY;\n  rq.cparam = &cp;\n  rq.clen = sizeof(cp);\n  rq.rparam = &status;\n  rq.rlen = 1;\n    \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n    \n  return status;\n}\n\ntBleStatus aci_gap_set_auth_requirement(uint8_t mitm_mode,\n                                        uint8_t oob_enable,\n                                        uint8_t oob_data[16],\n                                        uint8_t min_encryption_key_size,\n                                        uint8_t max_encryption_key_size,\n                                        uint8_t use_fixed_pin,\n                                        uint32_t fixed_pin,\n                                        uint8_t bonding_mode)\n{\n  struct hci_request rq;\n  gap_set_auth_requirement_cp cp;    \n  uint8_t status;\n    \n  cp.mitm_mode = mitm_mode;\n  cp.oob_enable = oob_enable;\n  BLUENRG_memcpy(cp.oob_data, oob_data, 16);\n  cp.min_encryption_key_size = min_encryption_key_size;\n  cp.max_encryption_key_size = max_encryption_key_size;\n  cp.use_fixed_pin = use_fixed_pin;\n  cp.fixed_pin = htobl(fixed_pin);\n  cp.bonding_mode = bonding_mode;\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_SET_AUTH_REQUIREMENT;\n  rq.cparam = &cp;\n  rq.clen = sizeof(cp);\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  if (status) {\n    return status;\n  }\n    \n  return 0;\n}\n\ntBleStatus aci_gap_set_author_requirement(uint16_t conn_handle, uint8_t authorization_enable)\n{\n  struct hci_request rq;\n  gap_set_author_requirement_cp cp;    \n  uint8_t status;\n    \n  cp.conn_handle = htobs(conn_handle);\n  cp.authorization_enable = authorization_enable;\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_SET_AUTHOR_REQUIREMENT;\n  rq.cparam = &cp;\n  rq.clen = sizeof(cp);\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  return status;\n}\n\ntBleStatus aci_gap_pass_key_response(uint16_t conn_handle, uint32_t passkey)\n{\n  struct hci_request rq;\n  gap_passkey_response_cp cp;    \n  uint8_t status;\n    \n  cp.conn_handle = htobs(conn_handle);\n  cp.passkey = htobl(passkey);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_PASSKEY_RESPONSE;\n  rq.cparam = &cp;\n  rq.clen = sizeof(cp);\n  rq.event = EVT_CMD_STATUS;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  return status;\n}\n\ntBleStatus aci_gap_authorization_response(uint16_t conn_handle, uint8_t authorize)\n{\n  struct hci_request rq;\n  gap_authorization_response_cp cp;    \n  uint8_t status;\n    \n  cp.conn_handle = htobs(conn_handle);\n  cp.authorize = authorize;\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_AUTHORIZATION_RESPONSE;\n  rq.cparam = &cp;\n  rq.clen = sizeof(cp);\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  return status;\n}\n\ntBleStatus aci_gap_set_non_connectable_IDB05A1(uint8_t adv_type, uint8_t own_address_type)\n{\n  struct hci_request rq;\n  gap_set_non_connectable_cp_IDB05A1 cp;    \n  uint8_t status;\n    \n  cp.advertising_event_type = adv_type;  \n  cp.own_address_type = own_address_type;\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_SET_NON_CONNECTABLE;\n  rq.cparam = &cp;\n  rq.clen = sizeof(cp);\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  return status;\n}\n\ntBleStatus aci_gap_set_non_connectable_IDB04A1(uint8_t adv_type)\n{\n  struct hci_request rq;\n  gap_set_non_connectable_cp_IDB04A1 cp;    \n  uint8_t status;\n    \n  cp.advertising_event_type = adv_type;  \n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_SET_NON_CONNECTABLE;\n  rq.cparam = &cp;\n  rq.clen = sizeof(cp);\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  return status;\n}\n\ntBleStatus aci_gap_set_undirected_connectable(uint8_t own_addr_type, uint8_t adv_filter_policy)\n{\n  struct hci_request rq;\n  gap_set_undirected_connectable_cp cp;    \n  uint8_t status;\n    \n  cp.own_addr_type = own_addr_type;\n  cp.adv_filter_policy = adv_filter_policy;\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_SET_UNDIRECTED_CONNECTABLE;\n  rq.cparam = &cp;\n  rq.clen = sizeof(cp);\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  return status;\n}\n\ntBleStatus aci_gap_slave_security_request(uint16_t conn_handle, uint8_t bonding, uint8_t mitm_protection)\n{\n  struct hci_request rq;\n  gap_slave_security_request_cp cp;\n  uint8_t status;\n\n  cp.conn_handle = htobs(conn_handle);\n  cp.bonding = bonding;\n  cp.mitm_protection = mitm_protection;\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_SLAVE_SECURITY_REQUEST;\n  rq.cparam = &cp;\n  rq.clen = sizeof(cp);\n  rq.event = EVT_CMD_STATUS;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n\n}\n\ntBleStatus aci_gap_update_adv_data(uint8_t AdvLen, const uint8_t *AdvData)\n{\n  struct hci_request rq;\n  uint8_t status;\n  uint8_t buffer[32];\n  uint8_t indx = 0;\n    \n  if (AdvLen > (sizeof(buffer)-1))\n    return BLE_STATUS_INVALID_PARAMS;\n\n  buffer[indx] = AdvLen;\n  indx++;\n    \n  BLUENRG_memcpy(buffer + indx, AdvData, AdvLen);\n  indx +=  AdvLen;\n    \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_UPDATE_ADV_DATA;\n  rq.cparam = (void *)buffer;\n  rq.clen = indx;\n  rq.rparam = &status;\n  rq.rlen = 1;\n    \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n    \n  return status;\n}\n\ntBleStatus aci_gap_delete_ad_type(uint8_t ad_type)\n{\n  struct hci_request rq;\n  gap_delete_ad_type_cp cp;\n  uint8_t status;\n\n  cp.ad_type = ad_type;\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_DELETE_AD_TYPE;\n  rq.cparam = &cp;\n  rq.clen = sizeof(cp);\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gap_get_security_level(uint8_t* mitm_protection, uint8_t* bonding,\n                                      uint8_t* oob_data, uint8_t* passkey_required)\n{\n  struct hci_request rq;\n  gap_get_security_level_rp resp;\n    \n  BLUENRG_memset(&resp, 0, sizeof(resp));\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_GET_SECURITY_LEVEL;\n  rq.rparam = &resp;\n  rq.rlen = GAP_GET_SECURITY_LEVEL_RP_SIZE;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  if (resp.status) {\n    return resp.status;\n  }\n  \n  *mitm_protection = resp.mitm_protection;\n  *bonding = resp.bonding;\n  *oob_data = resp.oob_data;\n  *passkey_required = resp.passkey_required;\n\n  return resp.status;\n}\n\ntBleStatus aci_gap_configure_whitelist(void)\n{\n  struct hci_request rq;\n  uint8_t status;\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_CONFIGURE_WHITELIST;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gap_terminate(uint16_t conn_handle, uint8_t reason)\n{\n  struct hci_request rq;\n  gap_terminate_cp cp;\n  uint8_t status;  \n\n  cp.handle = htobs(conn_handle);\n  cp.reason = reason;\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_TERMINATE;\n  rq.cparam = &cp;\n  rq.clen = sizeof(cp);\n  rq.event = EVT_CMD_STATUS;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status; \n}\n\ntBleStatus aci_gap_clear_security_database(void)\n{\n  struct hci_request rq;\n  uint8_t status;\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_CLEAR_SECURITY_DB;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gap_allow_rebond_IDB05A1(uint16_t conn_handle)\n{\n  struct hci_request rq;\n  gap_allow_rebond_cp_IDB05A1 cp;\n  uint8_t status;\n  \n  cp.conn_handle = conn_handle;\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_ALLOW_REBOND_DB;\n  rq.cparam = &cp;\n  rq.clen = sizeof(cp);\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gap_allow_rebond_IDB04A1(void)\n{\n  struct hci_request rq;\n  uint8_t status;\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_ALLOW_REBOND_DB;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gap_start_limited_discovery_proc(uint16_t scanInterval, uint16_t scanWindow,\n\t\t\t\t\t\tuint8_t own_address_type, uint8_t filterDuplicates)\n{\n  struct hci_request rq;\n  gap_start_limited_discovery_proc_cp cp;\n  uint8_t status;  \n\n  cp.scanInterval = htobs(scanInterval);\n  cp.scanWindow = htobs(scanWindow);\n  cp.own_address_type = own_address_type;\n  cp.filterDuplicates = filterDuplicates;\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_START_LIMITED_DISCOVERY_PROC;\n  rq.cparam = &cp;\n  rq.clen = sizeof(cp);\n  rq.event = EVT_CMD_STATUS;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gap_start_general_discovery_proc(uint16_t scanInterval, uint16_t scanWindow,\n\t\t\t\t\t\tuint8_t own_address_type, uint8_t filterDuplicates)\n{\n  struct hci_request rq;\n  gap_start_general_discovery_proc_cp cp;\n  uint8_t status;  \n\n  cp.scanInterval = htobs(scanInterval);\n  cp.scanWindow = htobs(scanWindow);\n  cp.own_address_type = own_address_type;\n  cp.filterDuplicates = filterDuplicates;\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_START_GENERAL_DISCOVERY_PROC;\n  rq.cparam = &cp;\n  rq.clen = sizeof(cp);\n  rq.event = EVT_CMD_STATUS;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\n\ntBleStatus aci_gap_start_name_discovery_proc(uint16_t scanInterval, uint16_t scanWindow,\n\t\t\t\t     uint8_t peer_bdaddr_type, tBDAddr peer_bdaddr,\t\n\t\t\t\t     uint8_t own_bdaddr_type, uint16_t conn_min_interval,\t\n\t\t\t\t     uint16_t conn_max_interval, uint16_t conn_latency,\t\n\t\t\t\t     uint16_t supervision_timeout, uint16_t min_conn_length, \n\t\t\t\t     uint16_t max_conn_length)\n{\n  struct hci_request rq;\n  gap_start_name_discovery_proc_cp cp;\n  uint8_t status;  \n\n  cp.scanInterval = htobs(scanInterval);\n  cp.scanWindow = htobs(scanWindow);\n  cp.peer_bdaddr_type = peer_bdaddr_type;\n  BLUENRG_memcpy(cp.peer_bdaddr, peer_bdaddr, 6);\n  cp.own_bdaddr_type = own_bdaddr_type;\n  cp.conn_min_interval = htobs(conn_min_interval);\n  cp.conn_max_interval = htobs(conn_max_interval);\n  cp.conn_latency = htobs(conn_latency);\n  cp.supervision_timeout = htobs(supervision_timeout);\n  cp.min_conn_length = htobs(min_conn_length);\n  cp.max_conn_length = htobs(max_conn_length);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_START_NAME_DISCOVERY_PROC;\n  rq.cparam = &cp;\n  rq.clen = sizeof(cp);\n  rq.event = EVT_CMD_STATUS;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gap_start_auto_conn_establish_proc_IDB05A1(uint16_t scanInterval, uint16_t scanWindow,\n\t\t\t\t\t\t uint8_t own_bdaddr_type, uint16_t conn_min_interval,\t\n\t\t\t\t\t\t uint16_t conn_max_interval, uint16_t conn_latency,\t\n\t\t\t\t\t\t uint16_t supervision_timeout, uint16_t min_conn_length, \n\t\t\t\t\t\t uint16_t max_conn_length,\n                         uint8_t num_whitelist_entries,\n                         const uint8_t *addr_array)\n{\n  struct hci_request rq;\n  uint8_t status;\n  uint8_t buffer[HCI_MAX_PAYLOAD_SIZE];\n  uint8_t indx = 0;\n    \n  if (((num_whitelist_entries*7)+25) > HCI_MAX_PAYLOAD_SIZE)\n    return BLE_STATUS_INVALID_PARAMS;\n\n  scanInterval = htobs(scanInterval);\n  BLUENRG_memcpy(buffer + indx, &scanInterval, 2);\n  indx += 2;\n    \n  scanWindow = htobs(scanWindow);\n  BLUENRG_memcpy(buffer + indx, &scanWindow, 2);\n  indx += 2;\n\n  buffer[indx] = own_bdaddr_type;\n  indx++;\n  \n  conn_min_interval = htobs(conn_min_interval);\n  BLUENRG_memcpy(buffer + indx, &conn_min_interval, 2);\n  indx +=  2;\n\n  conn_max_interval = htobs(conn_max_interval);\n  BLUENRG_memcpy(buffer + indx, &conn_max_interval, 2);\n  indx +=  2;\n\n  conn_latency = htobs(conn_latency);\n  BLUENRG_memcpy(buffer + indx, &conn_latency, 2);\n  indx +=  2;\n\n  supervision_timeout = htobs(supervision_timeout);\n  BLUENRG_memcpy(buffer + indx, &supervision_timeout, 2);\n  indx +=  2;\n\n  min_conn_length = htobs(min_conn_length);\n  BLUENRG_memcpy(buffer + indx, &min_conn_length, 2);\n  indx +=  2;\n\n  max_conn_length = htobs(max_conn_length);\n  BLUENRG_memcpy(buffer + indx, &max_conn_length, 2);\n  indx +=  2;\n\n  buffer[indx] = num_whitelist_entries;\n  indx++;\n\n  BLUENRG_memcpy(buffer + indx, addr_array, (num_whitelist_entries*7));\n  indx +=  num_whitelist_entries * 7;\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_START_AUTO_CONN_ESTABLISH_PROC;\n  rq.cparam = (void *)buffer;\n  rq.clen = indx;\n  rq.event = EVT_CMD_STATUS;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;  \n}\n\ntBleStatus aci_gap_start_auto_conn_establish_proc_IDB04A1(uint16_t scanInterval, uint16_t scanWindow,\n\t\t\t\t\t\t uint8_t own_bdaddr_type, uint16_t conn_min_interval,\t\n\t\t\t\t\t\t uint16_t conn_max_interval, uint16_t conn_latency,\t\n\t\t\t\t\t\t uint16_t supervision_timeout, uint16_t min_conn_length, \n\t\t\t\t\t\t uint16_t max_conn_length,\n                         uint8_t use_reconn_addr,\n                         const tBDAddr reconn_addr,\n                         uint8_t num_whitelist_entries,\n                         const uint8_t *addr_array)\n{\n  struct hci_request rq;\n  uint8_t status;\n  uint8_t buffer[HCI_MAX_PAYLOAD_SIZE];\n  uint8_t indx = 0;\n    \n  if (((num_whitelist_entries*7)+25) > HCI_MAX_PAYLOAD_SIZE)\n    return BLE_STATUS_INVALID_PARAMS;\n\n  scanInterval = htobs(scanInterval);\n  BLUENRG_memcpy(buffer + indx, &scanInterval, 2);\n  indx += 2;\n    \n  scanWindow = htobs(scanWindow);\n  BLUENRG_memcpy(buffer + indx, &scanWindow, 2);\n  indx += 2;\n\n  buffer[indx] = own_bdaddr_type;\n  indx++;\n  \n  conn_min_interval = htobs(conn_min_interval);\n  BLUENRG_memcpy(buffer + indx, &conn_min_interval, 2);\n  indx +=  2;\n\n  conn_max_interval = htobs(conn_max_interval);\n  BLUENRG_memcpy(buffer + indx, &conn_max_interval, 2);\n  indx +=  2;\n\n  conn_latency = htobs(conn_latency);\n  BLUENRG_memcpy(buffer + indx, &conn_latency, 2);\n  indx +=  2;\n\n  supervision_timeout = htobs(supervision_timeout);\n  BLUENRG_memcpy(buffer + indx, &supervision_timeout, 2);\n  indx +=  2;\n\n  min_conn_length = htobs(min_conn_length);\n  BLUENRG_memcpy(buffer + indx, &min_conn_length, 2);\n  indx +=  2;\n\n  max_conn_length = htobs(max_conn_length);\n  BLUENRG_memcpy(buffer + indx, &max_conn_length, 2);\n  indx +=  2;\n  \n  buffer[indx] = use_reconn_addr;\n  indx++;\n\n  BLUENRG_memcpy(buffer + indx, reconn_addr, 6);\n  indx += 6;\n\n  buffer[indx] = num_whitelist_entries;\n  indx++;\n\n  BLUENRG_memcpy(buffer + indx, addr_array, (num_whitelist_entries*7));\n  indx +=  num_whitelist_entries * 7;\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_START_AUTO_CONN_ESTABLISH_PROC;\n  rq.cparam = (void *)buffer;\n  rq.clen = indx;\n  rq.event = EVT_CMD_STATUS;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;  \n}\n\ntBleStatus aci_gap_start_general_conn_establish_proc_IDB05A1(uint8_t scan_type, uint16_t scan_interval, uint16_t scan_window,\n\t\t\t\t\t\t uint8_t own_address_type, uint8_t filter_duplicates)\n{\n  struct hci_request rq;\n  gap_start_general_conn_establish_proc_cp_IDB05A1 cp;\n  uint8_t status;  \n\n  cp.scan_type = scan_type;\n  cp.scan_interval = htobs(scan_interval);\n  cp.scan_window = htobs(scan_window);\n  cp.own_address_type = own_address_type;\n  cp.filter_duplicates = filter_duplicates;\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_START_GENERAL_CONN_ESTABLISH_PROC;\n  rq.cparam = &cp;\n  rq.clen = sizeof(cp);\n  rq.event = EVT_CMD_STATUS;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gap_start_general_conn_establish_proc_IDB04A1(uint8_t scan_type, uint16_t scan_interval, uint16_t scan_window,\n\t\t\t\t\t\t uint8_t own_address_type, uint8_t filter_duplicates, uint8_t use_reconn_addr, const tBDAddr reconn_addr)\n{\n  struct hci_request rq;\n  gap_start_general_conn_establish_proc_cp_IDB04A1 cp;\n  uint8_t status;  \n\n  cp.scan_type = scan_type;\n  cp.scan_interval = htobs(scan_interval);\n  cp.scan_window = htobs(scan_window);\n  cp.own_address_type = own_address_type;\n  cp.filter_duplicates = filter_duplicates;\n  cp.use_reconn_addr = use_reconn_addr;\n  BLUENRG_memcpy(cp.reconn_addr, reconn_addr, 6);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_START_GENERAL_CONN_ESTABLISH_PROC;\n  rq.cparam = &cp;\n  rq.clen = sizeof(cp);\n  rq.event = EVT_CMD_STATUS;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gap_start_selective_conn_establish_proc(uint8_t scan_type, uint16_t scan_interval, uint16_t scan_window,\n\t\t\t\t\t\t uint8_t own_address_type, uint8_t filter_duplicates, uint8_t num_whitelist_entries,\n                         const uint8_t *addr_array)\n{\n  struct hci_request rq;\n  gap_start_selective_conn_establish_proc_cp cp;\n  uint8_t status;\n  \n  if (((num_whitelist_entries*7)+GAP_START_SELECTIVE_CONN_ESTABLISH_PROC_CP_SIZE) > HCI_MAX_PAYLOAD_SIZE)\n    return BLE_STATUS_INVALID_PARAMS;\n  \n  cp.scan_type = scan_type;\n  cp.scan_interval = htobs(scan_interval);\n  cp.scan_window = htobs(scan_window);\n  cp.own_address_type = own_address_type;\n  cp.filter_duplicates = filter_duplicates;\n  cp.num_whitelist_entries = num_whitelist_entries;  \n  \n  BLUENRG_memcpy(cp.addr_array, addr_array, (num_whitelist_entries*7));\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_START_SELECTIVE_CONN_ESTABLISH_PROC;\n  rq.cparam = &cp;\n  rq.clen = GAP_START_SELECTIVE_CONN_ESTABLISH_PROC_CP_SIZE + (num_whitelist_entries*7);\n  rq.event = EVT_CMD_STATUS;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gap_create_connection(uint16_t scanInterval, uint16_t scanWindow,\n\t\t\t\t     uint8_t peer_bdaddr_type, tBDAddr peer_bdaddr,\t\n\t\t\t\t     uint8_t own_bdaddr_type, uint16_t conn_min_interval,\t\n\t\t\t\t     uint16_t conn_max_interval, uint16_t conn_latency,\t\n\t\t\t\t     uint16_t supervision_timeout, uint16_t min_conn_length, \n\t\t\t\t     uint16_t max_conn_length)\n{\n  struct hci_request rq;\n  gap_create_connection_cp cp;\n  uint8_t status;  \n\n  cp.scanInterval = htobs(scanInterval);\n  cp.scanWindow = htobs(scanWindow);\n  cp.peer_bdaddr_type = peer_bdaddr_type;\n  BLUENRG_memcpy(cp.peer_bdaddr, peer_bdaddr, 6);\n  cp.own_bdaddr_type = own_bdaddr_type;\n  cp.conn_min_interval = htobs(conn_min_interval);\n  cp.conn_max_interval = htobs(conn_max_interval);\n  cp.conn_latency = htobs(conn_latency);\n  cp.supervision_timeout = htobs(supervision_timeout);\n  cp.min_conn_length = htobs(min_conn_length);\n  cp.max_conn_length = htobs(max_conn_length);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_CREATE_CONNECTION;\n  rq.cparam = &cp;\n  rq.clen = sizeof(cp);\n  rq.event = EVT_CMD_STATUS;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gap_terminate_gap_procedure(uint8_t procedure_code)\n{\n  struct hci_request rq;\n  uint8_t status;  \n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_TERMINATE_GAP_PROCEDURE;\n  rq.cparam = &procedure_code;\n  rq.clen = 1;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n\n}\n\ntBleStatus aci_gap_start_connection_update(uint16_t conn_handle, uint16_t conn_min_interval,\t\n                                           uint16_t conn_max_interval, uint16_t conn_latency,\t\n                                           uint16_t supervision_timeout, uint16_t min_conn_length, \n                                           uint16_t max_conn_length)\n{\n  struct hci_request rq;\n  gap_start_connection_update_cp cp;\n  uint8_t status;  \n\n  cp.conn_handle = htobs(conn_handle);\n  cp.conn_min_interval = htobs(conn_min_interval);\n  cp.conn_max_interval = htobs(conn_max_interval);\n  cp.conn_latency = htobs(conn_latency);\n  cp.supervision_timeout = htobs(supervision_timeout);\n  cp.min_conn_length = htobs(min_conn_length);\n  cp.max_conn_length = htobs(max_conn_length);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_START_CONNECTION_UPDATE;\n  rq.cparam = &cp;\n  rq.clen = sizeof(cp);\n  rq.event = EVT_CMD_STATUS;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gap_send_pairing_request(uint16_t conn_handle, uint8_t force_rebond)\n{\n  struct hci_request rq;\n  gap_send_pairing_request_cp cp;\n  uint8_t status;  \n\n  cp.conn_handle = htobs(conn_handle);\n  cp.force_rebond = force_rebond;\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_SEND_PAIRING_REQUEST;\n  rq.cparam = &cp;\n  rq.clen = sizeof(cp);\n  rq.event = EVT_CMD_STATUS;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gap_resolve_private_address_IDB05A1(const tBDAddr private_address, tBDAddr actual_address)\n{\n  struct hci_request rq;\n  gap_resolve_private_address_cp cp;\n  gap_resolve_private_address_rp rp;\n\n  BLUENRG_memcpy(cp.address, private_address, 6);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_RESOLVE_PRIVATE_ADDRESS;\n  rq.cparam = &cp;\n  rq.clen = sizeof(cp);\n  rq.rparam = &rp;\n  rq.rlen = sizeof(rp);\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  if(rp.status)\n    return rp.status;\n  \n  BLUENRG_memcpy(actual_address, rp.address, 6);\n\n  return 0;\n}\n\ntBleStatus aci_gap_resolve_private_address_IDB04A1(const tBDAddr address)\n{\n  struct hci_request rq;\n  gap_resolve_private_address_cp cp;\n  uint8_t status;\n\n  BLUENRG_memcpy(cp.address, address, 6);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_RESOLVE_PRIVATE_ADDRESS;\n  rq.cparam = &cp;\n  rq.clen = sizeof(cp);\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n  \ntBleStatus aci_gap_set_broadcast_mode(uint16_t adv_interv_min, uint16_t adv_interv_max, uint8_t adv_type,\n\t\t\t\t  uint8_t own_addr_type, uint8_t adv_data_length, const uint8_t *adv_data,  uint8_t num_whitelist_entries,\n                                  const uint8_t *addr_array)\n{\n  struct hci_request rq;\n  gap_set_broadcast_mode_cp cp;\n  uint8_t status;\n  uint8_t indx = 0;  \n  uint8_t variable_size =  1 + adv_data_length + 1 + num_whitelist_entries*7;\n  \n  if (variable_size > sizeof(cp.var_len_data) )\n    return BLE_STATUS_INVALID_PARAMS;\n  \n  cp.adv_interv_min = htobs(adv_interv_min);\n  cp.adv_interv_max = htobs(adv_interv_max);\n  cp.adv_type = adv_type;\n  cp.own_addr_type = own_addr_type;\n  \n  cp.var_len_data[indx] = adv_data_length;\n  indx++;\n  BLUENRG_memcpy(cp.var_len_data + indx, adv_data, adv_data_length);\n  indx += adv_data_length;\n  cp.var_len_data[indx] = num_whitelist_entries;\n  indx ++;\n  BLUENRG_memcpy(cp.var_len_data + indx, addr_array, num_whitelist_entries*7);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_SET_BROADCAST_MODE;\n  rq.cparam = &cp;\n  rq.clen = GAP_SET_BROADCAST_MODE_CP_SIZE + variable_size;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gap_start_observation_procedure(uint16_t scan_interval, uint16_t scan_window, uint8_t scan_type,\n\t\t\t\t\t\t uint8_t own_address_type, uint8_t filter_duplicates)\n{\n  struct hci_request rq;\n  gap_start_observation_proc_cp cp;\n  uint8_t status;\n  \n  cp.scan_interval = scan_interval;\n  cp.scan_window = scan_window;\n  cp.scan_type = scan_type;\n  cp.own_address_type = own_address_type;\n  cp.filter_duplicates = filter_duplicates;\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_START_OBSERVATION_PROC;\n  rq.cparam = &cp;\n  rq.clen = sizeof(cp);\n  rq.event = EVT_CMD_STATUS;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gap_is_device_bonded(uint8_t peer_address_type, const tBDAddr peer_address)\n{\n  struct hci_request rq;\n  gap_is_device_bonded_cp cp;\n  uint8_t status;\n  \n  cp.peer_address_type = peer_address_type;\n  BLUENRG_memcpy(cp.peer_address, peer_address, sizeof(cp.peer_address));\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_IS_DEVICE_BONDED;\n  rq.cparam = &cp;\n  rq.clen = sizeof(cp);\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gap_get_bonded_devices(uint8_t *num_devices, uint8_t *device_list, uint8_t device_list_size)\n{\n  struct hci_request rq;\n  gap_get_bonded_devices_rp rp;\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GAP_GET_BONDED_DEVICES;\n  rq.rparam = &rp;\n  rq.rlen = sizeof(rp);\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  if (rp.status) {\n    return rp.status;\n  }\n  \n  *num_devices = rp.num_addr;\n  if(device_list != NULL)\n    BLUENRG_memcpy(device_list, rp.dev_list, MIN(device_list_size,rp.num_addr*7));\n  \n  return 0;\n}\n",
                "bluenrg_gap_aci.h": "/******************** (C) COPYRIGHT 2014 STMicroelectronics ********************\n* File Name          : bluenrg_gap_aci.h\n* Author             : AMS - AAS\n* Version            : V1.0.0\n* Date               : 26-Jun-2014\n* Description        : Header file with GAP commands for BlueNRG FW6.3.\n********************************************************************************\n* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\n* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.\n* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,\n* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE\n* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING\n* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\n*******************************************************************************/\n\n#ifndef __BLUENRG_GAP_ACI_H__\n#define __BLUENRG_GAP_ACI_H__\n\n/** \n * @addtogroup HIGH_LEVEL_INTERFACE HIGH_LEVEL_INTERFACE\n * @{\n */\n \n/**\n * @addtogroup ACI_GAP ACI_GAP\n * @brief API for GAP layer.\n * @{\n */\n\n/**\n *@defgroup GAP_Functions GAP functions\n *@brief API for GAP layer.\n *@{\n */\n\n/**\n  * @brief  Initialize the GAP layer.\n  * @note   Register the GAP service with the GATT. \n  *         All the standard GAP characteristics will also be added:\n  *         @li Device Name\n  *         @li Appearance\n  *         @li Peripheral Preferred Connection Parameters (peripheral role only)\n  *         @code\n\n              tBleStatus ret;\n              uint16_t service_handle, dev_name_char_handle, appearance_char_handle;\n\n              ret = aci_gap_init_IDB05A1(1, 0, 0x07, &service_handle, &dev_name_char_handle, &appearance_char_handle);\n              if(ret){\n                PRINTF(\"GAP_Init failed.\\n\");\n                reboot();    \n              }  \n              const char *name = \"BlueNRG\";  \n              ret = aci_gatt_update_char_value(service_handle, dev_name_char_handle, 0, strlen(name), (uint8_t *)name);        \n              if(ret){\n                PRINTF(\"aci_gatt_update_char_value failed.\\n\");\n              }  \n  *         @endcode\n  * @param       role     Bitmap of allowed roles: see @ref gap_roles \"GAP roles\".\n  * @param       privacy_enabled     Enable (1) or disable (0) privacy.\n  * @param       device_name_char_len Length of the device name characteristic\n  * @param[out]  service_handle  Handle of the GAP service.\n  * @param[out]  dev_name_char_handle  Device Name Characteristic handle\n  * @param[out]  appearance_char_handle Appearance Characteristic handle\n  * @retval tBleStatus Value indicating success or error code.\n  */\ntBleStatus aci_gap_init_IDB05A1(uint8_t role, uint8_t privacy_enabled,\n                        uint8_t device_name_char_len,\n                        uint16_t* service_handle,\n                        uint16_t* dev_name_char_handle,\n                        uint16_t* appearance_char_handle);\n\n/**\n  * @brief  Initialize the GAP layer.\n  * @note   Register the GAP service with the GATT.\n  *         All the standard GAP characteristics will also be added:\n  *         @li Device Name\n  *         @li Appearance\n  *         @li Peripheral Privacy Flag (peripheral role only)\n  *         @li Reconnection Address (peripheral role only)\n  *         @li Peripheral Preferred Connection Parameters (peripheral role only)\n  *         @code\n\n              tBleStatus ret;\n              uint16_t service_handle, dev_name_char_handle, appearance_char_handle;\n\n              ret = aci_gap_init_IDB04A1(1, &service_handle, &dev_name_char_handle, &appearance_char_handle);\n              if(ret){\n                PRINTF(\"GAP_Init failed.\\n\");\n                reboot();    \n              }  \n              const char *name = \"BlueNRG\";  \n              ret = aci_gatt_update_char_value(service_handle, dev_name_char_handle, 0, strlen(name), (uint8_t *)name);        \n              if(ret){\n                PRINTF(\"aci_gatt_update_char_value failed.\\n\");\n              }  \n  *         @endcode\n  * @param       role     One of the allowed roles: @ref GAP_PERIPHERAL_ROLE or @ref GAP_CENTRAL_ROLE. See @ref gap_roles \"GAP roles\".\n  * @param[out]  service_handle  Handle of the GAP service.\n  * @param[out]  dev_name_char_handle  Device Name Characteristic handle\n  * @param[out]  appearance_char_handle Appearance Characteristic handle\n  * @retval tBleStatus Value indicating success or error code.\n  */\ntBleStatus aci_gap_init_IDB04A1(uint8_t role,\n                 uint16_t* service_handle,\n                 uint16_t* dev_name_char_handle,\n                 uint16_t* appearance_char_handle);\n\n/**\n  * @brief   Set the Device in non-discoverable mode.\n  * @note    This command will disable the LL advertising.\n  * @retval  tBleStatus Value indicating success or error code.\n  */\ntBleStatus aci_gap_set_non_discoverable(void);\n\n/**\n * @brief  Put the device in limited discoverable mode\n *         (as defined in GAP specification volume 3, section 9.2.3).\n * @note    The device will be discoverable for TGAP (lim_adv_timeout) = 180 seconds.\n *          The advertising can be disabled at any time by issuing\n *          aci_gap_set_non_discoverable() command.\n *          The AdvIntervMin and AdvIntervMax parameters are optional. If both\n *          are set to 0, the GAP will use default values (250 ms and 500 ms respectively).\n *          Host can set the Local Name, a Service UUID list and the Slave Connection\n *          Minimum and Maximum. If provided, these data will be inserted into the\n *          advertising packet payload as AD data. These parameters are optional\n *          in this command. These values can be also set using aci_gap_update_adv_data()\n *          separately.\n *          The total size of data in advertising packet cannot exceed 31 bytes.\n *          With this command, the BLE Stack will also add automatically the following\n *          standard AD types:\n *          @li AD Flags\n *          @li TX Power Level\n *\n *          When advertising timeout happens (i.e. limited discovery period has elapsed), controller generates\n *          @ref EVT_BLUE_GAP_LIMITED_DISCOVERABLE event.\n *\n *          Example:\n * @code\n *\n *              #define  ADV_INTERVAL_MIN_MS  100\n *              #define  ADV_INTERVAL_MAX_MS  200\n *\n *              tBleStatus ret;\n *\n *              const char local_name[] = {AD_TYPE_COMPLETE_LOCAL_NAME,'B','l','u','e','N','R','G'};\n *              const uint8_t serviceUUIDList[] = {AD_TYPE_16_BIT_SERV_UUID,0x34,0x12};\n *\n *              ret = aci_gap_set_limited_discoverable(ADV_IND, (ADV_INTERVAL_MIN_MS*1000)/0.625,\n *                                                     (ADV_INTERVAL_MAX_MS*1000)/0.625,\n *                                                     STATIC_RANDOM_ADDR, NO_WHITE_LIST_USE,\n *                                                    sizeof(local_name), local_name,\n *                                                     sizeof(serviceUUIDList), serviceUUIDList,\n *                                                     0, 0);\n * @endcode\n *\n * @param       AdvType     One of the advertising types:\n *               @arg @ref ADV_IND Connectable undirected advertising\n *               @arg @ref ADV_SCAN_IND Scannable undirected advertising\n *               @arg @ref ADV_NONCONN_IND Non connectable undirected advertising\n * @param       AdvIntervMin    Minimum advertising interval.\n * \t\t\t\t\t\t\t\t Range: 0x0020 to 0x4000\n * \t\t\t\t\t\t\t\t Default: 250 ms\n * \t\t\t\t\t\t\t\t Time = N * 0.625 msec\n * \t\t\t\t\t\t\t\t Time Range: 20 ms to 10.24 sec (minimum 100 ms for ADV_SCAN_IND or ADV_NONCONN_IND).\n * @param       AdvIntervMax    Maximum advertising interval.\n * \t\t\t\t\t\t\t\tRange: 0x0020 to 0x4000\n * \t\t\t\t\t\t\t\tDefault: 500 ms\n * \t\t\t\t\t\t\t\tTime = N * 0.625 msec\n * \t\t\t\t\t\t\t\tTime Range: 20 ms to 10.24 sec  (minimum 100 ms for ADV_SCAN_IND or ADV_NONCONN_IND).\n * @param       OwnAddrType     Type of our address used during advertising\n *                              (@ref PUBLIC_ADDR,@ref STATIC_RANDOM_ADDR).\n * @param       AdvFilterPolicy  Filter policy:\n *                               @arg NO_WHITE_LIST_USE\n *                               @arg WHITE_LIST_FOR_ONLY_SCAN\n *                               @arg WHITE_LIST_FOR_ONLY_CONN\n *                               @arg WHITE_LIST_FOR_ALL\n * @param  LocalNameLen  Length of LocalName array.\n * @param  LocalName  Array containing the Local Name AD data. First byte is the AD type:\n *                       @ref AD_TYPE_SHORTENED_LOCAL_NAME or @ref AD_TYPE_COMPLETE_LOCAL_NAME.\n * @param  ServiceUUIDLen Length of ServiceUUIDList array.\n * @param  ServiceUUIDList  This is the list of the UUIDs AD Types as defined in Volume 3,\n *  \t\t\t\t\t\t\tSection 11.1.1 of GAP Specification. First byte is the AD Type.\n *  \t\t\t\t\t\t\t@arg @ref AD_TYPE_16_BIT_SERV_UUID\n *  \t\t\t\t\t\t\t@arg @ref AD_TYPE_16_BIT_SERV_UUID_CMPLT_LIST\n *  \t\t\t\t\t\t\t@arg @ref AD_TYPE_128_BIT_SERV_UUID\n *  \t\t\t\t\t\t\t@arg @ref AD_TYPE_128_BIT_SERV_UUID_CMPLT_LIST\n * @param  SlaveConnIntervMin Slave connection interval minimum value suggested by Peripheral.\n * \t\t\t\t\t\t\t If SlaveConnIntervMin and SlaveConnIntervMax are not 0x0000,\n * \t\t\t\t\t\t\t Slave Connection Interval Range AD structure will be added in advertising\n * \t\t\t\t\t\t\t data.\n * \t\t\t\t\t\t\t Connection interval is defined in the following manner:\n * \t\t\t\t\t\t\t connIntervalmin = Slave_Conn_Interval_Min x 1.25ms\n * \t\t\t\t\t\t\t Slave_Conn_Interval_Min range: 0x0006 to 0x0C80\n * \t\t\t\t\t\t\t Value of 0xFFFF indicates no specific minimum.\n * @param  SlaveConnIntervMax Slave connection interval maximum value suggested by Peripheral.\n * \t\t\t\t\t\t\t If SlaveConnIntervMin and SlaveConnIntervMax are not 0x0000,\n * \t\t\t\t\t\t\t Slave Connection Interval Range AD structure will be added in advertising\n * \t\t\t\t\t\t\t data.\n * \t\t\t\t\t\t\t ConnIntervalmax = Slave_Conn_Interval_Max x 1.25ms\n * \t\t\t\t\t\t\t Slave_Conn_Interval_Max range: 0x0006 to 0x0C80\n * \t\t\t\t\t\t\t Slave_ Conn_Interval_Max shall be equal to or greater than the Slave_Conn_Interval_Min.\n * \t\t\t\t\t\t\t Value of 0xFFFF indicates no specific maximum.\n *\n * @retval tBleStatus Value indicating success or error code.\n */\ntBleStatus aci_gap_set_limited_discoverable(uint8_t AdvType, uint16_t AdvIntervMin, uint16_t AdvIntervMax,\n\t\t\t\t\t    uint8_t OwnAddrType, uint8_t AdvFilterPolicy, uint8_t LocalNameLen,\n\t\t\t\t\t    const char *LocalName, uint8_t ServiceUUIDLen, uint8_t* ServiceUUIDList,\n\t\t\t\t\t    uint16_t SlaveConnIntervMin, uint16_t SlaveConnIntervMax);\n/**\n * @brief Put the Device in general discoverable mode (as defined in GAP specification volume 3, section 9.2.4).\n * @note  The device will be discoverable until the Host issue Aci_Gap_Set_Non_Discoverable command.\n * \t\t  The Adv_Interval_Min and Adv_Interval_Max parameters are optional. If both are set to 0, the GAP uses\n * \t\t  the default values for advertising intervals (1.28 s and 2.56 s respectively for IDB04A1).\n *                When using connectable undirected advertising events:\\n\n *                @li Adv_Interval_Min = 30 ms\n *                @li Adv_Interval_Max = 60 ms\n *                \\nWhen using non-connectable advertising events or scannable undirected advertising events:\\n\n *                @li Adv_Interval_Min = 100 ms\n *                @li Adv_Interval_Max = 150 ms\n * \t\t  Host can set the Local Name, a Service UUID list and the Slave Connection Interval Range. If provided,\n * \t\t  these data will be inserted into the advertising packet payload as AD data. These parameters are optional\n * \t\t  in this command. These values can be also set using aci_gap_update_adv_data() separately.\n * \t\t  The total size of data in advertising packet cannot exceed 31 bytes.\n * \t\t  With this command, the BLE Stack will also add automatically the following standard AD types:\n * \t\t  @li AD Flags\n * \t\t  @li TX Power Level\n *\n * \t\t  Usage example:\n *\n * \t\t  @code\n *\n *              #define  ADV_INTERVAL_MIN_MS  800\n *              #define  ADV_INTERVAL_MAX_MS  900\n *              #define  CONN_INTERVAL_MIN_MS 100\n *              #define  CONN_INTERVAL_MAX_MS 300\n *\n *              tBleStatus ret;\n *\n *              const char local_name[] = {AD_TYPE_COMPLETE_LOCAL_NAME,'B','l','u','e','N','R','G'};\n *              const uint8_t serviceUUIDList[] = {AD_TYPE_16_BIT_SERV_UUID,0x34,0x12};\n *\n *              ret = aci_gap_set_discoverable(ADV_IND, (ADV_INTERVAL_MIN_MS*1000)/625,\n *                                                     (ADV_INTERVAL_MAX_MS*1000)/625,\n *                                                     STATIC_RANDOM_ADDR, NO_WHITE_LIST_USE,\n *                                                     sizeof(local_name), local_name,\n *                                                     0, NULL,\n *                                                     (CONN_INTERVAL_MIN_MS*1000)/1250,\n *                                                     (CONN_INTERVAL_MAX_MS*1000)/1250);\n * \t\t\t@endcode\n *\n * @param AdvType One of the advertising types:\n *                @arg @ref ADV_IND Connectable undirected advertising\n *                @arg @ref ADV_SCAN_IND Scannable undirected advertising\n *                @arg @ref ADV_NONCONN_IND Non connectable undirected advertising\n * @param       AdvIntervMin    Minimum advertising interval.\n * \t\t\t\t\t\t\t\t Range: 0x0020 to 0x4000\n * \t\t\t\t\t\t\t\t Default: 1.28 s\n * \t\t\t\t\t\t\t\t Time = N * 0.625 msec\n * \t\t\t\t\t\t\t\t Time Range: 20 ms to 10.24 sec (minimum 100 ms for ADV_SCAN_IND or ADV_NONCONN_IND).\n * @param       AdvIntervMax    Maximum advertising interval.\n * \t\t\t\t\t\t\t\tRange: 0x0020 to 0x4000\n * \t\t\t\t\t\t\t\tDefault: 2.56 s\n * \t\t\t\t\t\t\t\tTime = N * 0.625 msec\n * \t\t\t\t\t\t\t\tTime Range: 20 ms to 10.24 sec  (minimum 100 ms for ADV_SCAN_IND or ADV_NONCONN_IND).\n * @param       OwnAddrType     Type of our address used during advertising\n *                              (@ref PUBLIC_ADDR,@ref STATIC_RANDOM_ADDR).\n * @param       AdvFilterPolicy  Filter policy:\n *                               @arg @ref NO_WHITE_LIST_USE\n *                               @arg @ref WHITE_LIST_FOR_ONLY_SCAN\n *                               @arg @ref WHITE_LIST_FOR_ONLY_CONN\n *                               @arg @ref WHITE_LIST_FOR_ALL\n * @param  LocalNameLen  Length of LocalName array.\n * @param  LocalName  Array containing the Local Name AD data. First byte is the AD type:\n *                       @ref AD_TYPE_SHORTENED_LOCAL_NAME or @ref AD_TYPE_COMPLETE_LOCAL_NAME.\n * @param  ServiceUUIDLen Length of ServiceUUIDList array.\n * @param  ServiceUUIDList  This is the list of the UUIDs AD Types as defined in Volume 3,\n *  \t\t\t\t\t\t\tSection 11.1.1 of GAP Specification. First byte is the AD Type.\n *  \t\t\t\t\t\t\t@arg @ref AD_TYPE_16_BIT_SERV_UUID\n *  \t\t\t\t\t\t\t@arg @ref AD_TYPE_16_BIT_SERV_UUID_CMPLT_LIST\n *  \t\t\t\t\t\t\t@arg @ref AD_TYPE_128_BIT_SERV_UUID\n *  \t\t\t\t\t\t\t@arg @ref AD_TYPE_128_BIT_SERV_UUID_CMPLT_LIST\n * @param  SlaveConnIntervMin Slave connection interval minimum value suggested by Peripheral.\n * \t\t\t\t\t\t\t If SlaveConnIntervMin and SlaveConnIntervMax are not 0x0000,\n * \t\t\t\t\t\t\t Slave Connection Interval Range AD structure will be added in advertising\n * \t\t\t\t\t\t\t data.\n * \t\t\t\t\t\t\t Connection interval is defined in the following manner:\n * \t\t\t\t\t\t\t connIntervalmin = Slave_Conn_Interval_Min x 1.25ms\n * \t\t\t\t\t\t\t Slave_Conn_Interval_Min range: 0x0006 to 0x0C80\n * \t\t\t\t\t\t\t Value of 0xFFFF indicates no specific minimum.\n * @param  SlaveConnIntervMax Slave connection interval maximum value suggested by Peripheral.\n * \t\t\t\t\t\t\t If SlaveConnIntervMin and SlaveConnIntervMax are not 0x0000,\n * \t\t\t\t\t\t\t Slave Connection Interval Range AD structure will be added in advertising\n * \t\t\t\t\t\t\t data.\n * \t\t\t\t\t\t\t ConnIntervalmax = Slave_Conn_Interval_Max x 1.25ms\n * \t\t\t\t\t\t\t Slave_Conn_Interval_Max range: 0x0006 to 0x0C80\n * \t\t\t\t\t\t\t Slave_ Conn_Interval_Max shall be equal to or greater than the Slave_Conn_Interval_Min.\n * \t\t\t\t\t\t\t Value of 0xFFFF indicates no specific maximum.\n *\n * @retval tBleStatus Value indicating success or error code.\n */\ntBleStatus aci_gap_set_discoverable(uint8_t AdvType, uint16_t AdvIntervMin, uint16_t AdvIntervMax,\n                             uint8_t OwnAddrType, uint8_t AdvFilterPolicy, uint8_t LocalNameLen,\n                             const char *LocalName, uint8_t ServiceUUIDLen, uint8_t* ServiceUUIDList,\n                             uint16_t SlaveConnIntervMin, uint16_t SlaveConnIntervMax);\n\n/**\n * @brief Set the Device in direct connectable mode (as defined in GAP specification Volume 3, Section 9.3.3).\n * @note  If the privacy is enabled, the reconnection address is used for advertising, otherwise the address\n * \t\t  of the type specified in OwnAddrType is used. The device will be in directed connectable mode only\n * \t\t  for 1.28 seconds. If no connection is established within this duration, the device enters non\n * \t\t  discoverable mode and advertising will have to be again enabled explicitly.\n * \t\t  The controller generates a @ref EVT_LE_CONN_COMPLETE event with the status set to @ref HCI_DIRECTED_ADV_TIMEOUT\n * \t\t  if the connection was not established and 0x00 if the connection was successfully established.\n *\n * \t\t  Usage example:\n * \t\t  @code\n *\n * \t\t  tBleStatus ret;\n *\n * \t\t  const uint8_t central_address[] = {0x43,0x27,0x84,0xE1,0x80,0x02};\n * \t\t  ret = aci_gap_set_direct_connectable_IDB05A1(PUBLIC_ADDR, HIGH_DUTY_CYCLE_DIRECTED_ADV, PUBLIC_ADDR, central_address);\n * \t\t  @endcode\n *\n *\n *\n * @param own_addr_type  Type of our address used during advertising (@ref PUBLIC_ADDR,@ref STATIC_RANDOM_ADDR).\n * @param directed_adv_type  Type of directed advertising (@ref HIGH_DUTY_CYCLE_DIRECTED_ADV, @ref LOW_DUTY_CYCLE_DIRECTED_ADV).\n * @param initiator_addr_type Type of peer address (@ref PUBLIC_ADDR,@ref STATIC_RANDOM_ADDR).\n * @param initiator_addr     Initiator's address (Little Endian).\n * @param adv_interv_min     Minimum advertising interval for low duty cycle directed advertising.\n *                           Range: 0x0020 to 0x4000\n *\t\t\t\t\t\t\t Time = N * 0.625 msec\n *\t\t\t\t\t\t\t Time Range: 20 ms to 10.24 sec.\n * @param adv_interv_max     Maximum advertising interval for low duty cycle directed advertising.\n *                           Range: 0x0020 to 0x4000\n *\t\t\t\t\t\t\t Time = N * 0.625 msec\n *\t\t\t\t\t\t\t Time Range: 20 ms to 10.24 sec.\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gap_set_direct_connectable_IDB05A1(uint8_t own_addr_type, uint8_t directed_adv_type, uint8_t initiator_addr_type,\n                                          const uint8_t *initiator_addr, uint16_t adv_interv_min, uint16_t adv_interv_max);\n\n/**\n * @brief Set the Device in direct connectable mode (as defined in GAP specification Volume 3, Section 9.3.3).\n * @note  If the privacy is enabled, the reconnection address is used for advertising, otherwise the address\n * \t\t  of the type specified in OwnAddrType is used. The device will be in directed connectable mode only\n * \t\t  for 1.28 seconds. If no connection is established within this duration, the device enters non\n * \t\t  discoverable mode and advertising will have to be again enabled explicitly.\n * \t\t  The controller generates a @ref EVT_LE_CONN_COMPLETE event with the status set to @ref HCI_DIRECTED_ADV_TIMEOUT\n * \t\t  if the connection was not established and 0x00 if the connection was successfully established.\n *\n * \t\t  Usage example:\n * \t\t  @code\n *\n * \t\t  tBleStatus ret;\n *\n * \t\t  const uint8_t central_address = {0x43,0x27,0x84,0xE1,0x80,0x02};\n * \t\t  ret = aci_gap_set_direct_connectable_IDB04A1(PUBLIC_ADDR, PUBLIC_ADDR, central_address);\n * \t\t  @endcode\n *\n *\n *\n * @param own_addr_type  Type of our address used during advertising (@ref PUBLIC_ADDR,@ref STATIC_RANDOM_ADDR).\n * @param initiator_addr_type Type of peer address (@ref PUBLIC_ADDR,@ref STATIC_RANDOM_ADDR).\n * @param initiator_addr     Initiator's address (Little Endian).\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gap_set_direct_connectable_IDB04A1(uint8_t own_addr_type, uint8_t initiator_addr_type, const uint8_t *initiator_addr);\n\n/**\n * @brief Set the IO capabilities of the device.\n * @note This command has to be given only when the device is not in a connected state.\n * @param io_capability One of the allowed codes for IO Capability:\n * \t\t  @arg @ref IO_CAP_DISPLAY_ONLY\n * \t\t  @arg @ref IO_CAP_DISPLAY_YES_NO\n * \t\t  @arg @ref IO_CAP_KEYBOARD_ONLY\n * \t\t  @arg @ref IO_CAP_NO_INPUT_NO_OUTPUT\n * \t\t  @arg @ref IO_CAP_KEYBOARD_DISPLAY\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gap_set_io_capability(uint8_t io_capability);\n\n/**\n * @brief Set the authentication requirements for the device.\n * @note  If the oob_enable is set to 0, oob_data will be ignored.\n *        This command has to be given only when the device is not in a connected state.\n * @param mitm_mode MITM mode:\n * \t\t\t\t\t@arg @ref MITM_PROTECTION_NOT_REQUIRED\n * \t\t\t\t\t@arg @ref MITM_PROTECTION_REQUIRED\n * @param oob_enable If OOB data are present or not:\n * \t\t\t\t\t @arg @ref OOB_AUTH_DATA_ABSENT\n * \t\t\t\t\t @arg @ref OOB_AUTH_DATA_PRESENT\n * @param oob_data   Out-Of-Band data\n * @param min_encryption_key_size Minimum size of the encryption key to be used during the pairing process\n * @param max_encryption_key_size Maximum size of the encryption key to be used during the pairing process\n * @param use_fixed_pin If application wants to use a fixed pin or not:\n * \t\t\t\t\t\t@arg @ref USE_FIXED_PIN_FOR_PAIRING\n * \t\t\t\t\t\t@arg @ref DONOT_USE_FIXED_PIN_FOR_PAIRING\n * \t\t\t\t\t\tIf a fixed pin is not used, it has to be provided by the application with\n * \t\t\t\t\t\taci_gap_pass_key_response() after @ref EVT_BLUE_GAP_PASS_KEY_REQUEST event.\n * @param fixed_pin If use_fixed_pin is USE_FIXED_PIN_FOR_PAIRING, this is the value of the pin that will\n * \t\t\t\t\tbe used during pairing if MIMT protection is enabled. Any value between 0 to 999999 is\n * \t\t\t\t\taccepted.\n * @param bonding_mode One of the bonding modes:\n * \t\t\t\t\t   @arg @ref BONDING\n * \t\t\t\t\t   @arg @ref NO_BONDING\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gap_set_auth_requirement(uint8_t mitm_mode,\n                                        uint8_t oob_enable,\n                                        uint8_t oob_data[16],\n                                        uint8_t min_encryption_key_size,\n                                        uint8_t max_encryption_key_size,\n                                        uint8_t use_fixed_pin,\n                                        uint32_t fixed_pin,\n                                        uint8_t bonding_mode);\n /**\n  * @brief Set the authorization requirements of the device.\n  * @note This command has to be given when connected to a device if authorization is required to access services\n  *       which require authorization.\n  * @param conn_handle Handle of the connection.\n  * @param authorization_enable @arg @ref AUTHORIZATION_NOT_REQUIRED : Authorization not required\n  * \t\t\t\t\t\t\t@arg @ref AUTHORIZATION_REQUIRED : Authorization required. This enables\n  * \t\t\t\t\t\t\tthe authorization requirement in the device and when a remote device\n  * \t\t\t\t\t\t\ttries to read/write a characeristic with authorization requirements, the stack will\n  *                             send back an error response with \"Insufficient authorization\" error code.\n  *                             After pairing is complete a @ref EVT_BLUE_GAP_AUTHORIZATION_REQUEST event\n  * \t\t\t\t\t\t\twill be sent to the Host.\n  * @return Value indicating success or error code.\n  */\ntBleStatus aci_gap_set_author_requirement(uint16_t conn_handle, uint8_t authorization_enable);\n\n/**\n * @brief Provide the pass key that will be used during pairing.\n * @note This command should be sent by the Host in response to @ref EVT_BLUE_GAP_PASS_KEY_REQUEST event.\n * @param conn_handle Connection handle\n * @param passkey\t  Pass key that will be used during the pairing process. Must be a number between\n * \t\t\t\t\t  0 and 999999.\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gap_pass_key_response(uint16_t conn_handle, uint32_t passkey);\n\n/**\n * @brief Authorize a device to access attributes.\n * @note Application should send this command after it has received a @ref EVT_BLUE_GAP_AUTHORIZATION_REQUEST.\n *\n * @param conn_handle Connection handle\n * @param authorize   @arg @ref CONNECTION_AUTHORIZED : Authorize (accept connection)\n * \t\t\t\t\t  @arg @ref CONNECTION_REJECTED : Reject (reject connection)\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gap_authorization_response(uint16_t conn_handle, uint8_t authorize);\n\n/**\n * @brief Put the device into non-connectable mode.\n * @param adv_type One of the allowed advertising types:\n *                 @arg @ref ADV_SCAN_IND : Scannable undirected advertising\n *                 @arg @ref ADV_NONCONN_IND : Non-connectable undirected advertising\n * @param own_address_type If Privacy is disabled, then the peripheral address can be\n * \t\t\t               @arg @ref PUBLIC_ADDR.\n * \t\t\t               @arg @ref STATIC_RANDOM_ADDR.\n *                         If Privacy is enabled, then the peripheral address can be \n *                         @arg @ref RESOLVABLE_PRIVATE_ADDR\n *                         @arg @ref NON_RESOLVABLE_PRIVATE_ADDR\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gap_set_non_connectable_IDB05A1(uint8_t adv_type, uint8_t own_address_type);\n\n/**\n * @brief Put the device into non-connectable mode.\n * @param adv_type One of the allowed advertising types:\n *                 @arg @ref ADV_SCAN_IND : Scannable undirected advertising\n *                 @arg @ref ADV_NONCONN_IND : Non-connectable undirected advertising\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gap_set_non_connectable_IDB04A1(uint8_t adv_type);\n\n/**\n * @brief Put the device into undirected connectable mode.\n * @note  If privacy is enabled in the device, a resolvable private address is generated and used\n *        as the advertiser's address. If not, the address of the type specified in own_addr_type\n *        is used for advertising.\n * @param own_addr_type Type of our address used during advertising:\n *                      if BLUENRG (IDB04A1)\n * \t\t\t            @arg @ref PUBLIC_ADDR.\n * \t\t\t            @arg @ref STATIC_RANDOM_ADDR.\n *                      else if BLUENRG_MS (IDB05A1)\n *                      If Privacy is disabled:\n * \t\t\t            @arg @ref PUBLIC_ADDR.\n * \t\t\t            @arg @ref STATIC_RANDOM_ADDR.\n *                      If Privacy is enabled:\n *                      @arg @ref RESOLVABLE_PRIVATE_ADDR\n *                      @arg @ref NON_RESOLVABLE_PRIVATE_ADDR\n * @param adv_filter_policy  Filter policy:\n *                         @arg @ref NO_WHITE_LIST_USE\n *                         @arg @ref WHITE_LIST_FOR_ALL\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gap_set_undirected_connectable(uint8_t own_addr_type, uint8_t adv_filter_policy);\n\n/**\n * @brief Send a slave security request to the master.\n * @note This command has to be issued to notify the master of the security requirements of the slave.\n * \t\t The master may encrypt the link, initiate the pairing procedure, or reject the request.\n * @param conn_handle Connection handle\n * @param bonding\t   One of the bonding modes:\n * \t\t\t\t\t   @arg @ref BONDING\n * \t\t\t\t\t   @arg @ref NO_BONDING\n * @param mitm_protection  If MITM protection is required or not:\n * \t\t\t\t\t\t   @arg @ref MITM_PROTECTION_NOT_REQUIRED\n * \t\t\t\t\t       @arg @ref MITM_PROTECTION_REQUIRED\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gap_slave_security_request(uint16_t conn_handle, uint8_t bonding, uint8_t mitm_protection);\n\n/**\n * @brief Update advertising data.\n * @note This command can be used to update the advertising data for a particular AD type.\n *       If the AD type specified does not exist, then it is added to the advertising data.\n *       If the overall advertising data length is more than 31 octets after the update, then\n *       the command is rejected and the old data is retained.\n * @param AdvLen Length of AdvData array\n * @param AdvData Advertisement Data,  formatted as specified in Bluetooth specification\n *        (Volume 3, Part C, 11), including data length. It can contain more than one AD type.\n *        Example\n * @code\n *  tBleStatus ret;\n *  const char local_name[] = {AD_TYPE_COMPLETE_LOCAL_NAME,'B','l','u','e','N','R','G'};\n *  const uint8_t serviceUUIDList[] = {AD_TYPE_16_BIT_SERV_UUID,0x34,0x12};\n *  const uint8_t manuf_data[] = {4, AD_TYPE_MANUFACTURER_SPECIFIC_DATA, 0x05, 0x02, 0x01};\n *\n *  ret = aci_gap_set_discoverable(ADV_IND, 0, 0, STATIC_RANDOM_ADDR, NO_WHITE_LIST_USE,\n *                                 8, local_name, 3, serviceUUIDList, 0, 0);\n *  ret = aci_gap_update_adv_data(5, manuf_data);\n * @endcode\n *\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gap_update_adv_data(uint8_t AdvLen, const uint8_t *AdvData);\n\n/**\n * @brief Delete an AD Type\n * @note This command can be used to delete the specified AD type from the advertisement data if\n * \t\t present.\n * @param ad_type One of the allowed AD types (see @ref AD_Types)\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gap_delete_ad_type(uint8_t ad_type);\n\n/**\n * @brief Get the current security settings\n * @note This command can be used to get the current security settings of the device.\n * @param mitm_protection \t@arg 0: Not required\n * \t\t\t\t\t\t\t@arg 1: Required\n * @param bonding\t\t\t@arg 0: No bonding mode\n * \t\t\t\t\t\t\t@arg 1: Bonding mode\n * @param oob_data\t\t\t@arg 0: Data absent\n * \t\t\t\t\t\t\t@arg 1: Data present\n * @param passkey_required  @arg 0: Not required\n * \t\t\t\t\t\t\t@arg 1: Fixed pin is present which is being used\n * \t\t\t\t\t\t\t@arg 2: Passkey required for pairing. An event will be generated\n * \t\t\t\t\t\t\twhen required.\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gap_get_security_level(uint8_t* mitm_protection, uint8_t* bonding,\n                                      uint8_t* oob_data, uint8_t* passkey_required);\n\n/**\n * @brief Add addresses of bonded devices into the controller's whitelist.\n * @note  The command will return an error if there are no devices in the database or if it was unable\n * \t\t  to add the device into the whitelist.\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gap_configure_whitelist(void);\n\n/**\n * @brief Terminate a connection.\n * @note  A @ref EVT_DISCONN_COMPLETE event will be generated when the link is disconnected.\n * @param conn_handle Connection handle\n * @param reason  Reason for requesting disconnection. The error code can be any of ones as specified\n * \t\t\t\t  for the disconnected command in the HCI specification (See @ref HCI_Error_codes).\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gap_terminate(uint16_t conn_handle, uint8_t reason);\n\n/**\n * @brief Clear the security database.\n * @note  All the devices in the security database will be removed.\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gap_clear_security_database(void);\n\n/**\n * @brief Allows the security manager to complete the pairing procedure and re-bond with the master.\n * @note This command can be issued by the application if a @ref EVT_BLUE_GAP_BOND_LOST event is generated.\n * @param conn_handle \n * @return Value indicating success or error code.\n */\ntBleStatus aci_gap_allow_rebond_IDB05A1(uint16_t conn_handle);\n\n/**\n * @brief Allows the security manager to complete the pairing procedure and re-bond with the master.\n * @note This command can be issued by the application if a @ref EVT_BLUE_GAP_BOND_LOST event is generated.\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gap_allow_rebond_IDB04A1(void);\n\n/**\n * @brief Start the limited discovery procedure.\n * @note  The controller is commanded to start active scanning. When this procedure is started,\n *        only the devices in limited discoverable mode are returned to the upper layers.\n *        The procedure is terminated when either the upper layers issue a command to terminate the\n *        procedure by issuing the command aci_gap_terminate_gap_procedure() with the procedure code\n *        set to @ref GAP_LIMITED_DISCOVERY_PROC or a timeout happens. When the procedure is terminated\n *        due to any of the above  reasons, @ref EVT_BLUE_GAP_PROCEDURE_COMPLETE event is returned with\n *        the procedure code set to @ref GAP_LIMITED_DISCOVERY_PROC.\n *        The device found when the procedure is ongoing is returned to the upper layers through the\n *        event @ref EVT_BLUE_GAP_DEVICE_FOUND (for IDB04A1) or @ref EVT_LE_ADVERTISING_REPORT (for IDB05A1).\n * @param scanInterval Time interval from when the Controller started its last LE scan until it begins\n * \t\t\t\t\t   the subsequent LE scan. The scan interval should be a number in the range\n * \t\t\t\t\t   0x0004 to 0x4000. This corresponds to a time range 2.5 msec to 10240 msec.\n * \t\t\t\t\t   For a number N, Time = N x 0.625 msec.\n * @param scanWindow Amount of time for the duration of the LE scan. Scan_Window shall be less than\n * \t\t\t\t\t or equal to Scan_Interval. The scan window should be a number in the range\n * \t\t\t\t\t 0x0004 to 0x4000. This corresponds to a time range 2.5 msec to 10240 msec.\n * \t\t\t\t\t For a number N, Time = N x 0.625 msec.\n * @param own_address_type Type of our address used during advertising (@ref PUBLIC_ADDR, @ref STATIC_RANDOM_ADDR).\n * @param filterDuplicates Duplicate filtering enabled or not.\n * \t\t\t\t\t\t   @arg 0x00: Do not filter the duplicates\n * \t\t\t\t\t\t   @arg 0x01: Filter duplicates\n *\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gap_start_limited_discovery_proc(uint16_t scanInterval, uint16_t scanWindow,\n\t\t\t\t\t\tuint8_t own_address_type, uint8_t filterDuplicates);\n\n/**\n * @brief Start the general discovery procedure.\n * @note  The controller is commanded to start active scanning. The procedure is terminated when\n * \t\t  either the upper layers issue a command to terminate the procedure by issuing the command\n * \t\t  aci_gap_terminate_gap_procedure() with the procedure code set to GAP_GENERAL_DISCOVERY_PROC\n * \t\t  or a timeout happens. When the procedure is terminated due to any of the above reasons,\n * \t\t  @ref EVT_BLUE_GAP_PROCEDURE_COMPLETE event is returned with the procedure code set to\n * \t\t  @ref GAP_GENERAL_DISCOVERY_PROC. The device found when the procedure is ongoing is returned to\n * \t\t  the upper layers through the event @ref EVT_BLUE_GAP_DEVICE_FOUND  (for IDB04A1) or @ref EVT_LE_ADVERTISING_REPORT (for IDB05A1).\n * @param scanInterval Time interval from when the Controller started its last LE scan until it begins\n * \t\t\t\t\t   the subsequent LE scan. The scan interval should be a number in the range\n * \t\t\t\t\t   0x0004 to 0x4000. This corresponds to a time range 2.5 msec to 10240 msec.\n * \t\t\t\t\t   For a number N, Time = N x 0.625 msec.\n * @param scanWindow Amount of time for the duration of the LE scan. Scan_Window shall be less than\n * \t\t\t\t\t or equal to Scan_Interval. The scan window should be a number in the range\n * \t\t\t\t\t 0x0004 to 0x4000. This corresponds to a time range 2.5 msec to 10240 msec.\n * \t\t\t\t\t For a number N, Time = N x 0.625 msec.\n * @param own_address_type Type of our address used during advertising (@ref PUBLIC_ADDR, @ref STATIC_RANDOM_ADDR).\n * @param filterDuplicates Duplicate filtering enabled or not.\n * \t\t\t\t\t\t   @arg 0x00: Do not filter the duplicates\n * \t\t\t\t\t\t   @arg 0x01: Filter duplicates\n *\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gap_start_general_discovery_proc(uint16_t scanInterval, uint16_t scanWindow,\n\t\t\t\t\t\tuint8_t own_address_type, uint8_t filterDuplicates);\n\n/**\n * @brief Start the name discovery procedure.\n * @note  A LE_Create_Connection call will be made to the controller by GAP with the initiator filter\n * \t\t  policy set to ignore whitelist and process connectable advertising packets only for the\n * \t\t  specified device. Once a connection is established, GATT procedure is started to read the\n * \t\t  device name characteristic. When the read is completed (successfully or unsuccessfully),\n * \t\t  a @ref EVT_BLUE_GAP_PROCEDURE_COMPLETE event is given to the upper layer. The event also\n * \t\t  contains the name of the device if the device name was read successfully.\n * @param scanInterval Time interval from when the Controller started its last LE scan until it begins\n * \t\t\t\t\t   the subsequent LE scan. The scan interval should be a number in the range\n * \t\t\t\t\t   0x0004 to 0x4000. This corresponds to a time range 2.5 msec to 10240 msec.\n * \t\t\t\t\t   For a number N, Time = N x 0.625 msec.\n * @param scanWindow Amount of time for the duration of the LE scan. Scan_Window shall be less than\n * \t\t\t\t\t or equal to Scan_Interval. The scan window should be a number in the range\n * \t\t\t\t\t 0x0004 to 0x4000. This corresponds to a time range 2.5 msec to 10240 msec.\n * \t\t\t\t\t For a number N, Time = N x 0.625 msec.\n * @param peer_bdaddr_type Type of the peer address (@ref PUBLIC_ADDR, @ref STATIC_RANDOM_ADDR).\n * @param peer_bdaddr Address of the peer device with which a connection has to be established.\n * @param own_bdaddr_type Type of our address used during advertising (PUBLIC_ADDR,STATIC_RANDOM_ADDR).\n * @param conn_min_interval Minimum value for the connection event interval. This shall be less than or\n * \t\t\t\t\t\t\tequal to Conn_Interval_Max.\\n\n * \t\t\t\t\t\t\tRange: 0x0006 to 0x0C80\\n\n * \t\t\t\t\t\t\tTime = N x 1.25 msec\\n\n * \t\t\t\t\t\t\tTime Range: 7.5 msec to 4 seconds\n * @param conn_max_interval Maximum value for the connection event interval. This shall be greater than or\n * \t\t\t\t\t\t\tequal to Conn_Interval_Min.\\n\n * \t\t\t\t\t\t\tRange: 0x0006 to 0x0C80\\n\n * \t\t\t\t\t\t\tTime = N x 1.25 msec\\n\n * \t\t\t\t\t\t\tTime Range: 7.5 msec to 4 seconds\n * @param conn_latency Slave latency for the connection in number of connection events.\\n\n * \t\t\t\t\t\t Range: 0x0000 to 0x01F4\n * @param supervision_timeout Supervision timeout for the LE Link.\\n\n * \t\t\t\t\t\t\t  Range: 0x000A to 0x0C80\\n\n * \t\t\t\t\t\t\t  Time = N x 10 msec\\n\n * \t\t\t\t\t\t\t  Time Range: 100 msec to 32 seconds\n * @param min_conn_length Minimum length of connection needed for the LE connection.\\n\n * \t\t\t\t\t\t  Range: 0x0000 - 0xFFFF\\n\n * \t\t\t\t\t\t  Time = N x 0.625 msec.\n * @param max_conn_length Maximum length of connection needed for the LE connection.\\n\n * \t\t\t\t\t\t  Range: 0x0000 - 0xFFFF\\n\n * \t\t\t\t\t\t  Time = N x 0.625 msec.\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gap_start_name_discovery_proc(uint16_t scanInterval, uint16_t scanWindow,\n\t\t\t\t     uint8_t peer_bdaddr_type, tBDAddr peer_bdaddr,\t\n\t\t\t\t     uint8_t own_bdaddr_type, uint16_t conn_min_interval,\t\n\t\t\t\t     uint16_t conn_max_interval, uint16_t conn_latency,\t\n\t\t\t\t     uint16_t supervision_timeout, uint16_t min_conn_length, \n\t\t\t\t     uint16_t max_conn_length);\n\n/**\n * @brief Start the auto connection establishment procedure.\n * @note The devices specified are added to the white list of the controller and a LE_Create_Connection\n * \t\t call will be made to the controller by GAP with the initiator filter policy set to\n * \t\t use whitelist to determine which advertiser to connect to. When a command is issued to\n * \t\t terminate the procedure by upper layer, a LE_Create_Connection_Cancel call will be made to the\n * \t\t controller by GAP.\n * \t\t The procedure is terminated when either a connection is successfully established with one of\n * \t\t the specified devices in the white list or the procedure is explicitly terminated by issuing\n * \t\t the command aci_gap_terminate_gap_procedure() with the procedure code set to\n * \t\t @ref GAP_AUTO_CONNECTION_ESTABLISHMENT_PROC. A @ref EVT_BLUE_GAP_PROCEDURE_COMPLETE event is returned with\n * \t\t the procedure code set to @ref GAP_AUTO_CONNECTION_ESTABLISHMENT_PROC.\n * @param scanInterval Time interval from when the Controller started its last LE scan until it begins\n * \t\t\t\t\t   the subsequent LE scan. The scan interval should be a number in the range\n * \t\t\t\t\t   0x0004 to 0x4000. This corresponds to a time range 2.5 msec to 10240 msec.\n * \t\t\t\t\t   For a number N, Time = N x 0.625 msec.\n * @param scanWindow Amount of time for the duration of the LE scan. Scan_Window shall be less than\n * \t\t\t\t\t or equal to Scan_Interval. The scan window should be a number in the range\n * \t\t\t\t\t 0x0004 to 0x4000. This corresponds to a time range 2.5 msec to 10240 msec.\n * \t\t\t\t\t For a number N, Time = N x 0.625 msec.\n * @param own_bdaddr_type Type of our address used during advertising (PUBLIC_ADDR,STATIC_RANDOM_ADDR).\n * @param conn_min_interval Minimum value for the connection event interval. This shall be less than or\n * \t\t\t\t\t\t\tequal to Conn_Interval_Max.\\n\n * \t\t\t\t\t\t\tRange: 0x0006 to 0x0C80\\n\n * \t\t\t\t\t\t\tTime = N x 1.25 msec\\n\n * \t\t\t\t\t\t\tTime Range: 7.5 msec to 4 seconds\n * @param conn_max_interval Maximum value for the connection event interval. This shall be greater than or\n * \t\t\t\t\t\t\tequal to Conn_Interval_Min.\\n\n * \t\t\t\t\t\t\tRange: 0x0006 to 0x0C80\\n\n * \t\t\t\t\t\t\tTime = N x 1.25 msec\\n\n * \t\t\t\t\t\t\tTime Range: 7.5 msec to 4 seconds\n * @param conn_latency Slave latency for the connection in number of connection events.\\n\n * \t\t\t\t\t\t Range: 0x0000 to 0x01F4\n * @param supervision_timeout Supervision timeout for the LE Link.\\n\n * \t\t\t\t\t\t\t  Range: 0x000A to 0x0C80\\n\n * \t\t\t\t\t\t\t  Time = N x 10 msec\\n\n * \t\t\t\t\t\t\t  Time Range: 100 msec to 32 seconds\n * @param min_conn_length Minimum length of connection needed for the LE connection.\\n\n * \t\t\t\t\t\t  Range: 0x0000 - 0xFFFF\\n\n * \t\t\t\t\t\t  Time = N x 0.625 msec.\n * @param max_conn_length Maximum length of connection needed for the LE connection.\\n\n * \t\t\t\t\t\t  Range: 0x0000 - 0xFFFF\\n\n * \t\t\t\t\t\t  Time = N x 0.625 msec.\n * @cond BLUENRG\n * @param use_reconn_addr If 1, the provided reconnection address is used as our address during the procedure (the address\n * \t\t\t\t\t\t  has been previously notified to the application through @ref EVT_BLUE_GAP_RECONNECTION_ADDRESS event).\\n\n * @param reconn_addr\tReconnection address used if use_reconn_addr is 1.\n * @endcond\n * @param num_whitelist_entries Number of devices that have to be added to the whitelist.\n * @param addr_array addr_array will contain the addresses that have to be added into the whitelist. The\n * \t\t\t\t\t format of the addr_array should be: address type followed by address.\n * \t\t\t\t\t Example:\n * \t\t\t\t\t @code\n * \t\t\t\t\t uint8_t addr_array[] = {PUBLIC_ADDR,0x01,0x00,0x00,0xe1,0x80,0x02,\n * \t\t\t\t\t \tPUBLIC_ADDR,0x02,0x00,0x00,0xe1,0x80,0x02};\n * \t\t\t\t\t @endcode\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gap_start_auto_conn_establish_proc_IDB05A1(uint16_t scanInterval, uint16_t scanWindow,\n\t\t\t\t\t\t uint8_t own_bdaddr_type, uint16_t conn_min_interval,\t\n\t\t\t\t\t\t uint16_t conn_max_interval, uint16_t conn_latency,\t\n\t\t\t\t\t\t uint16_t supervision_timeout, uint16_t min_conn_length, \n\t\t\t\t\t\t uint16_t max_conn_length,\n                         uint8_t num_whitelist_entries,\n                         const uint8_t *addr_array);\n\ntBleStatus aci_gap_start_auto_conn_establish_proc_IDB04A1(uint16_t scanInterval, uint16_t scanWindow,\n\t\t\t\t\t\t uint8_t own_bdaddr_type, uint16_t conn_min_interval,\t\n\t\t\t\t\t\t uint16_t conn_max_interval, uint16_t conn_latency,\t\n\t\t\t\t\t\t uint16_t supervision_timeout, uint16_t min_conn_length, \n\t\t\t\t\t\t uint16_t max_conn_length,\n                                                 uint8_t use_reconn_addr,\n                                                 const tBDAddr reconn_addr,\n                                                 uint8_t num_whitelist_entries,\n                                                 const uint8_t *addr_array);\n/**\n * @brief Start a general connection establishment procedure.\n * @note  The host enables scanning in the controller with the scanner filter policy set\n *        to accept all advertising packets and from the scanning results all the devices\n *        are sent to the upper layer using the event @ref EVT_BLUE_GAP_DEVICE_FOUND (for IDB04A1) or @ref EVT_LE_ADVERTISING_REPORT (for IDB05A1).\n *        The upper layer then has to select one of the devices to which it wants to connect\n *        by issuing the command aci_gap_create_connection(). The procedure is terminated\n *        when a connection is established or the upper layer terminates the procedure by\n *        issuing the command aci_gap_terminate_gap_procedure() with the procedure code set to\n *        @ref GAP_GENERAL_CONNECTION_ESTABLISHMENT_PROC. On completion of the procedure a\n *        @ref EVT_BLUE_GAP_PROCEDURE_COMPLETE event is generated with the procedure code set to\n *        @ref GAP_GENERAL_CONNECTION_ESTABLISHMENT_PROC.\n * @param scan_type Passive or active scanning (@ref PASSIVE_SCAN, @ref ACTIVE_SCAN)\n * @param scan_interval Time interval from when the Controller started its last LE scan until it begins\n * \t\t\t\t\t   the subsequent LE scan. The scan interval should be a number in the range\n * \t\t\t\t\t   0x0004 to 0x4000. This corresponds to a time range 2.5 msec to 10240 msec.\n * \t\t\t\t\t   For a number N, Time = N x 0.625 msec.\n * @param scan_window Amount of time for the duration of the LE scan. Scan_Window shall be less than\n * \t\t\t\t\t or equal to Scan_Interval. The scan window should be a number in the range\n * \t\t\t\t\t 0x0004 to 0x4000. This corresponds to a time range 2.5 msec to 10240 msec.\n * \t\t\t\t\t For a number N, Time = N x 0.625 msec.\n * @param own_address_type Type of our address used during active scanning (@ref PUBLIC_ADDR, @ref STATIC_RANDOM_ADDR).\n * @param filter_duplicates Duplicate filtering enabled or not.\n * \t\t\t\t\t\t   @arg 0x00: Do not filter the duplicates\n * \t\t\t\t\t\t   @arg 0x01: Filter duplicates\n * @cond BLUENRG\n * @param use_reconn_addr If 1, the provided reconnection address is used as our address during the procedure (the address\n * \t\t\t\t\t\t  has been previously notified to the application through @ref EVT_BLUE_GAP_RECONNECTION_ADDRESS event).\\n\n * @param reconn_addr\tReconnection address used if use_reconn_addr is 1.\n * @endcond\n *\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gap_start_general_conn_establish_proc_IDB05A1(uint8_t scan_type, uint16_t scan_interval, uint16_t scan_window,\n\t\t\t\t\t\t uint8_t own_address_type, uint8_t filter_duplicates);\ntBleStatus aci_gap_start_general_conn_establish_proc_IDB04A1(uint8_t scan_type, uint16_t scan_interval, uint16_t scan_window,\n\t\t\t\t\t\t uint8_t own_address_type, uint8_t filter_duplicates, uint8_t use_reconn_addr, const tBDAddr reconn_addr);\n\n/**\n * @brief Start a selective connection establishment procedure.\n * @note  The GAP adds the specified device addresses into white list and enables scanning in\n * \t\t  the controller with the scanner filter policy set to accept packets only from\n * \t\t  devices in whitelist. All the devices found are sent to the upper layer by the\n * \t\t  event @ref EVT_BLUE_GAP_DEVICE_FOUND (for IDB04A1) or @ref EVT_LE_ADVERTISING_REPORT (for IDB05A1). The upper layer then has to select one of the\n * \t\t  devices to which it wants to connect by issuing the command aci_gap_create_connection().\n * \t\t  On completion of the procedure a  @ref EVT_BLUE_GAP_PROCEDURE_COMPLETE event is generated\n * \t\t  with the procedure code set to @ref GAP_SELECTIVE_CONNECTION_ESTABLISHMENT_PROC.\n * \t\t  The procedure is terminated when a connection is established or the upper layer terminates\n * \t\t  the procedure by issuing the command aci_gap_terminate_gap_procedure with the procedure\n * \t\t  code set to @ref GAP_SELECTIVE_CONNECTION_ESTABLISHMENT_PROC.\n * @param scan_type Passive or active scanning (@ref PASSIVE_SCAN, @ref ACTIVE_SCAN)\n * @param scan_interval Time interval from when the Controller started its last LE scan until it begins\n * \t\t\t\t\t   the subsequent LE scan. The scan interval should be a number in the range\n * \t\t\t\t\t   0x0004 to 0x4000. This corresponds to a time range 2.5 msec to 10240 msec.\n * \t\t\t\t\t   For a number N, Time = N x 0.625 msec.\n * @param scan_window Amount of time for the duration of the LE scan. Scan_Window shall be less than\n * \t\t\t\t\t or equal to Scan_Interval. The scan window should be a number in the range\n * \t\t\t\t\t 0x0004 to 0x4000. This corresponds to a time range 2.5 msec to 10240 msec.\n * \t\t\t\t\t For a number N, Time = N x 0.625 msec.\n * @param own_address_type Type of our address used during active scanning (@ref PUBLIC_ADDR, @ref STATIC_RANDOM_ADDR).\n * @param filter_duplicates Duplicate filtering enabled or not.\n * \t\t\t\t\t\t   @arg 0x00: Do not filter the duplicates\n * \t\t\t\t\t\t   @arg 0x01: Filter duplicates\n * @param num_whitelist_entries Number of devices that have to be added to the whitelist.\n * @param addr_array addr_array will contain the addresses that have to be added into the whitelist. The\n * \t\t\t\t\t format of the addr_array should be: address type followed by address.\n * \t\t\t\t\t Example:\n * \t\t\t\t\t @code\n * \t\t\t\t\t uint8_t addr_array[] = {PUBLIC_ADDR,0x01,0x00,0x00,0xe1,0x80,0x02,\n * \t\t\t\t\t \tPUBLIC_ADDR,0x02,0x00,0x00,0xe1,0x80,0x02};\n * \t\t\t\t\t @endcode\n *\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gap_start_selective_conn_establish_proc(uint8_t scan_type, uint16_t scan_interval, uint16_t scan_window,\n\t\t\t\t\t\t uint8_t own_address_type, uint8_t filter_duplicates, uint8_t num_whitelist_entries,\n                         const uint8_t *addr_array);\n\n/**\n * @brief Start the direct connection establishment procedure.\n * @note  A LE_Create_Connection call will be made to the controller by GAP with the initiator filter\n * \t\t  policy set to ignore whitelist and process connectable advertising packets only for the\n * \t\t  specified device. The procedure can be terminated explicitly by the upper layer by issuing\n * \t\t  the command aci_gap_terminate_gap_procedure(). When a command is issued to terminate the\n * \t\t  procedure by upper layer, a LE_Create_Connection_Cancel call will be made to the controller\n * \t\t  by GAP.\n * \t\t  On termination of the procedure, a @ref EVT_LE_CONN_COMPLETE event is returned. The procedure can\n * \t\t  be explicitly terminated by the upper layer by issuing the command\n * \t\t  aci_gap_terminate_gap_procedure() with the procedure_code set to @ref GAP_DIRECT_CONNECTION_ESTABLISHMENT_PROC.\n * @param scanInterval Time interval from when the Controller started its last LE scan until it begins\n * \t\t\t\t\t   the subsequent LE scan. The scan interval should be a number in the range\n * \t\t\t\t\t   0x0004 to 0x4000. This corresponds to a time range 2.5 msec to 10240 msec.\n * \t\t\t\t\t   For a number N, Time = N x 0.625 msec.\n * @param scanWindow Amount of time for the duration of the LE scan. Scan_Window shall be less than\n * \t\t\t\t\t or equal to Scan_Interval. The scan window should be a number in the range\n * \t\t\t\t\t 0x0004 to 0x4000. This corresponds to a time range 2.5 msec to 10240 msec.\n * \t\t\t\t\t For a number N, Time = N x 0.625 msec.\n * @param peer_bdaddr_type Type of the peer address (@ref PUBLIC_ADDR, @ref STATIC_RANDOM_ADDR).\n * @param peer_bdaddr Address of the peer device with which a connection has to be established.\n * @param own_bdaddr_type Type of our address used during advertising (PUBLIC_ADDR,STATIC_RANDOM_ADDR).\n * @param conn_min_interval Minimum value for the connection event interval. This shall be less than or\n * \t\t\t\t\t\t\tequal to Conn_Interval_Max.\\n\n * \t\t\t\t\t\t\tRange: 0x0006 to 0x0C80\\n\n * \t\t\t\t\t\t\tTime = N x 1.25 msec\\n\n * \t\t\t\t\t\t\tTime Range: 7.5 msec to 4 seconds\n * @param conn_max_interval Maximum value for the connection event interval. This shall be greater than or\n * \t\t\t\t\t\t\tequal to Conn_Interval_Min.\\n\n * \t\t\t\t\t\t\tRange: 0x0006 to 0x0C80\\n\n * \t\t\t\t\t\t\tTime = N x 1.25 msec\\n\n * \t\t\t\t\t\t\tTime Range: 7.5 msec to 4 seconds\n * @param conn_latency Slave latency for the connection in number of connection events.\\n\n * \t\t\t\t\t\t Range: 0x0000 to 0x01F4\n * @param supervision_timeout Supervision timeout for the LE Link.\\n\n * \t\t\t\t\t\t\t  Range: 0x000A to 0x0C80\\n\n * \t\t\t\t\t\t\t  Time = N x 10 msec\\n\n * \t\t\t\t\t\t\t  Time Range: 100 msec to 32 seconds\n * @param min_conn_length Minimum length of connection needed for the LE connection.\\n\n * \t\t\t\t\t\t  Range: 0x0000 - 0xFFFF\\n\n * \t\t\t\t\t\t  Time = N x 0.625 msec.\n * @param max_conn_length Maximum length of connection needed for the LE connection.\\n\n * \t\t\t\t\t\t  Range: 0x0000 - 0xFFFF\\n\n * \t\t\t\t\t\t  Time = N x 0.625 msec.\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gap_create_connection(uint16_t scanInterval, uint16_t scanWindow,\n\t\t\t\t     uint8_t peer_bdaddr_type, tBDAddr peer_bdaddr,\t\n\t\t\t\t     uint8_t own_bdaddr_type, uint16_t conn_min_interval,\t\n\t\t\t\t     uint16_t conn_max_interval, uint16_t conn_latency,\t\n\t\t\t\t     uint16_t supervision_timeout, uint16_t min_conn_length, \n\t\t\t\t     uint16_t max_conn_length);\n\n/**\n * @brief Terminate the specified GAP procedure. @ref EVT_BLUE_GAP_PROCEDURE_COMPLETE event is\n *  \t  returned with the procedure code set to the corresponding procedure.\n * @param procedure_code One of the procedure codes (@ref gap_procedure_codes \"GAP procedure codes\").\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gap_terminate_gap_procedure(uint8_t procedure_code);\n\n/**\n * @brief Start the connection parameter update procedure.\n * @note  Allowed by the Central to update the connection parameter of the specified connection.\n * \t\t  A Link Layer Connection Update procedure is started on the controller.\n * \t\t  On completion of the procedure, a @ref EVT_LE_CONN_UPDATE_COMPLETE event is returned to\n * \t\t  the upper layer.\n * @param conn_handle Handle of the connection for which the update procedure has to be started.\n * @param conn_min_interval Minimum value for the connection event interval. This shall be less than or\n * \t\t\t\t\t\t\tequal to Conn_Interval_Max.\\n\n * \t\t\t\t\t\t\tRange: 0x0006 to 0x0C80\\n\n * \t\t\t\t\t\t\tTime = N x 1.25 msec\\n\n * \t\t\t\t\t\t\tTime Range: 7.5 msec to 4 seconds\n * @param conn_max_interval Maximum value for the connection event interval. This shall be greater than or\n * \t\t\t\t\t\t\tequal to Conn_Interval_Min.\\n\n * \t\t\t\t\t\t\tRange: 0x0006 to 0x0C80\\n\n * \t\t\t\t\t\t\tTime = N x 1.25 msec\\n\n * \t\t\t\t\t\t\tTime Range: 7.5 msec to 4 seconds\n * @param conn_latency Slave latency for the connection in number of connection events.\\n\n * \t\t\t\t\t\t Range: 0x0000 to 0x01F4\n * @param supervision_timeout Supervision timeout for the LE Link.\\n\n * \t\t\t\t\t\t\t  Range: 0x000A to 0x0C80\\n\n * \t\t\t\t\t\t\t  Time = N x 10 msec\\n\n * \t\t\t\t\t\t\t  Time Range: 100 msec to 32 seconds\n * @param min_conn_length Minimum length of connection needed for the LE connection.\\n\n * \t\t\t\t\t\t  Range: 0x0000 - 0xFFFF\\n\n * \t\t\t\t\t\t  Time = N x 0.625 msec.\n * @param max_conn_length Maximum length of connection needed for the LE connection.\\n\n * \t\t\t\t\t\t  Range: 0x0000 - 0xFFFF\\n\n * \t\t\t\t\t\t  Time = N x 0.625 msec.\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gap_start_connection_update(uint16_t conn_handle, uint16_t conn_min_interval,\t\n                                           uint16_t conn_max_interval, uint16_t conn_latency,\t\n                                           uint16_t supervision_timeout, uint16_t min_conn_length, \n                                           uint16_t max_conn_length);\n\n/**\n * @brief Send a pairing request.\n * @note  Send the SM pairing request to start a pairing process from a Central. The authentication\n * \t\t  requirements and  IO capabilities should be set before issuing this command using\n * \t\t  aci_gap_set_io_capability() and aci_gap_set_auth_requirement().\n * \t\t  A @ref EVT_BLUE_GAP_PAIRING_CMPLT event is returned after the pairing process is completed.\n * @param conn_handle Handle of the connection for which the pairing request has to be sent.\n * @param force_rebond  @arg 0x00: Pairing request is sent only if the device has not previously bonded\n * \t\t\t\t\t\t@arg 0x01: Pairing request will be sent even if the device was previously bonded\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gap_send_pairing_request(uint16_t conn_handle, uint8_t force_rebond);\n\n/**\n * @brief Resolve a private address.\n * @note  This command tries to resolve the address provided with the IRKs present in its database. If\n * \t\t  the address is resolved successfully with any one of the IRKs present in the database, it\n * \t\t  returns success.\n * @param[in] address Address to be resolved.\n * @param[out] actual_address The public or static random address of the peer device, distributed during pairing phase.\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gap_resolve_private_address_IDB05A1(const tBDAddr private_address, tBDAddr actual_address);\n\n/**\n * @brief Resolve a private address.\n * @note  This command tries to resolve the address provided with the IRKs present in its database. If\n * \t\t  the address is resolved successfully with any one of the IRKs present in the database, it\n * \t\t  returns success.\n * @param address Address to be resolved.\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gap_resolve_private_address_IDB04A1(const tBDAddr private_address);\n\n/**\n * @brief This command gets the list of bonded devices.\n * @note  It returns the number of addresses and the corresponding address types and values.\n *        Example:\n *        @code\n *        tBleStatus ret;\n *        uint8_t num_devices = 0;\n *        uint8_t device_list[12*7];\n *        ret = aci_gap_get_bonded_devices(&num_devices, device_list, sizeof(device_list));\n *        for(int i = 0; i < num_devices; i+=7){\n *        \tuint8_t addr_type = device_list[i];\n *        \tuint8_t addr = device_list[i+1];\n *        \tprintf(\"Type: %d, Addr: %02X%02X%02X%02X%02X%02X\\n\",addr_type,addr[5],addr[4],addr[3],addr[2],addr[1],addr[0]);\n *        }\n *        @endcode\n *\n * @param[out] num_devices The number of bonded devices.\n * @param[out] device_list List of addresses. It contains a sequence of [address type, address] pairs, where address\n *        \t\t\t\t  type can be @ref PUBLIC_ADDR or @arg @ref STATIC_RANDOM_ADDR.\n * @param device_list_size Maximum size of the device_list buffer used to return the device list.\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gap_get_bonded_devices(uint8_t *num_devices, uint8_t *device_list, uint8_t device_list_size);\n\n/**\n * @brief Puts the device into broadcast mode\n * @note  A privacy enabled device uses either a resolvable private address or a non-resolvable private address\n * \t\t  as specified in the own_addr_type parameter of the command.\n * @param adv_interv_min    Minimum advertising interval.\n * \t\t\t\t\t\t\tRange: 0x00A0 to 0x4000\n * \t\t\t\t\t\t\tTime = N * 0.625 msec\n * \t\t\t\t\t\t\tTime Range: 100 ms to 10.24 sec\n * @param adv_interv_max    Maximum advertising interval.\n * \t\t\t\t\t\t    Range: 0x00A0 to 0x4000\n * \t\t\t\t\t\t\tTime = N * 0.625 msec\n * \t\t\t\t\t\t\tTime Range: 100 ms to 10.24 sec\n * @param adv_type One of the allowed advertising types:\n *                @arg @ref ADV_SCAN_IND Scannable undirected advertising\n *                @arg @ref ADV_NONCONN_IND Non connectable undirected advertising\n * @param own_addr_type If Privacy is disabled, the broadcaster address can be\n * \t\t\t               @arg @ref PUBLIC_ADDR.\n * \t\t\t               @arg @ref STATIC_RANDOM_ADDR.\n *                         If Privacy is enabled, then the broadcaster address can be\n *                         @arg @ref RESOLVABLE_PRIVATE_ADDR\n *                         @arg @ref NON_RESOLVABLE_PRIVATE_ADDR\n * @param adv_data_length Length of the advertising data in the advertising packet\n * @param adv_data\t\t  Advertising data used by the device while advertising\n * @param num_whitelist_entries Number of devices to be added to whitelist\n * @param addr_array It will contain the addresses that have to be added into the whitelist. The\n * \t\t\t\t\t format of the addr_array should be: address type followed by address.\n * \t\t\t\t\t Example:\n * \t\t\t\t\t @code\n * \t\t\t\t\t uint8_t addr_array[] = {PUBLIC_ADDR,0x01,0x00,0x00,0xe1,0x80,0x02,\n * \t\t\t\t\t \tPUBLIC_ADDR,0x02,0x00,0x00,0xe1,0x80,0x02};\n * \t\t\t\t\t @endcode\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gap_set_broadcast_mode(uint16_t adv_interv_min, uint16_t adv_interv_max, uint8_t adv_type,\n                                      uint8_t own_addr_type, uint8_t adv_data_length, const uint8_t *adv_data,  uint8_t num_whitelist_entries,\n                                      const uint8_t *addr_array);\n\n/**\n * @brief Starts an observation procedure, when the device is in Observer role.\n * @note  The host enables scanning in the controller. The advertising reports are sent to the upper layer\n *        using standard @ref EVT_LE_ADVERTISING_REPORT subevent in @ref EVT_LE_META_EVENT. See Bluetooth\n *        Core v4.0, Vol. 2, part E, Ch. 7.7.65.2, LE Advertising Report Event.\n * @param scan_interval Time interval from when the Controller started its last LE scan until it begins the subsequent LE scan.\n * \t\t  The scan interval should be a number in the range 0x0004 to 0x4000. This corresponds to a time range from 2.5 msec\n * \t\t  to 10240 msec. For a number N, Time = N * 0.625 msec.\n * @param scan_window Amount of time for the duration of the LE scan. scan_window shall be less than or equal to scan_interval.\n * \t\t  The scan window should be a number in the range 0x0004 to 0x4000. This corresponds to a time range from 2.5 msec\n * \t\t  to 10240 msec. For a number N, Time = N * 0.625 msec.\n * @param scan_type Passive or active scanning (@ref PASSIVE_SCAN, @ref ACTIVE_SCAN)\n * @param own_address_type If Privacy is disabled, then the scanner address can be\n * \t\t\t               @arg @ref PUBLIC_ADDR.\n * \t\t\t               @arg @ref STATIC_RANDOM_ADDR.\n *                         If Privacy is enabled, then the scanner address can be\n *                         @arg @ref RESOLVABLE_PRIVATE_ADDR\n *                         @arg @ref NON_RESOLVABLE_PRIVATE_ADDR\n * @param filter_duplicates Duplicate filtering enabled or not.\n * \t\t\t\t\t\t   @arg 0x00: Do not filter the duplicates\n * \t\t\t\t\t\t   @arg 0x01: Filter duplicates\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gap_start_observation_procedure(uint16_t scan_interval, uint16_t scan_window, uint8_t scan_type,\n\t\t\t\t\t\t uint8_t own_address_type, uint8_t filter_duplicates);\n\n/**\n * @brief The command finds whether a device is bonded.\n * @note If the device is using a resolvable private address and it has been bonded, then the command will return\n *       BLE_STATUS_SUCCESS.\n * @param peer_address_type The address type of the peer device\n *                         @arg @ref PUBLIC_ADDR.\n * \t\t\t               @arg @ref RANDOM_ADDR.\n * @param peer_address Address used by the peer device while advertising.\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gap_is_device_bonded(uint8_t peer_address_type, const tBDAddr peer_address);\n\n/**\n * @}\n */\n\n/**\n * @defgroup GAP_Events GAP events\n * @{\n */\n\n/**\n * This event is generated by the controller when the limited discoverable\n *  mode ends due to timeout (180 seconds). No parameters in the event.\n */\n#define EVT_BLUE_GAP_LIMITED_DISCOVERABLE     (0x0400)\n\n\n/**\n * This event is generated when the pairing process has completed successfully\n * or a pairing procedure timeout has occurred or the pairing has failed.\n * This is to notify the application that we have paired with a remote device\n * so that it can take further actions or to notify that a timeout has occurred\n *  so that the upper layer can decide to disconnect the link. See @ref _evt_gap_pairing_cmplt.\n */\n#define EVT_BLUE_GAP_PAIRING_CMPLT                (0x0401)\ntypedef __packed struct _evt_gap_pairing_cmplt{\n  uint16_t conn_handle; /**< Connection handle on which the pairing procedure completed */\n  /**\n   * 0x00: Pairing Success. Pairing with a remote device was successful\\n\n   * 0x01: Pairing Timeout. The SMP timeout has elapsed and no further SMP commands will be processed until reconnection\\n\n   * 0x02: Pairing Failed. The pairing failed with the remote device.\n   */\n  uint8_t  status;\n} PACKED evt_gap_pairing_cmplt;\n\n\n/**\n * This event is generated by the Security manager to the application when a pass key is required for pairing.\n * When this event is received, the application has to respond with the aci_gap_pass_key_response() command.\n * See @ref _evt_gap_pass_key_req.\n */\n#define EVT_BLUE_GAP_PASS_KEY_REQUEST             (0x0402)\ntypedef __packed struct _evt_gap_pass_key_req{\n  uint16_t conn_handle; /**< Connection handle for which the passkey has been requested. */\n} PACKED evt_gap_pass_key_req;\n\n\n/**\n * This event is generated by the Security manager to the application when the application\n * has set that authorization is required for reading/writing of attributes. This event will\n * be generated as soon as the pairing is complete. When this event is received,\n * aci_gap_authorization_response() command should be used by the application.\n * See @ref _evt_gap_author_req.\n */\n#define EVT_BLUE_GAP_AUTHORIZATION_REQUEST        (0x0403)\ntypedef __packed struct _evt_gap_author_req{\n  uint16_t conn_handle; /**< Connection handle for which authorization has been requested. */\n} PACKED evt_gap_author_req;\n\n/**\n * This event is generated when the slave security request is successfully sent to the master.\n * No parameters for this event.\n */\n#define EVT_BLUE_GAP_SLAVE_SECURITY_INITIATED     (0X0404)\n\n/**\n * This event is generated on the slave when a aci_gap_slave_security_request()  is called to reestablish the bond\n * with a master but the master has lost the bond. When this event is received, the upper layer has to issue the\n * command aci_gap_allow_rebond() in order to allow the slave to continue the pairing process with the master.\n * On the master this event is raised when aci_gap_send_pairing_request() is called to reestablish a bond with a slave\n * but the slave has lost the bond. In order to create a new bond the master has to launch aci_gap_send_pairing_request()\n * with force_rebond set to 1.\n * No parameters for this event\n */\n#define EVT_BLUE_GAP_BOND_LOST                    (0X0405)\n\n/**\n * The event is given by the GAP layer to the upper layers when a device is discovered during scanning\n * as a consequence of one of the GAP procedures started by the upper layers. See @ref _evt_gap_device_found.\n */\n#define EVT_BLUE_GAP_DEVICE_FOUND                 (0x0406)\ntypedef __packed struct _evt_gap_device_found{\n  \tuint8_t\t\tevt_type;     /**< Type of event (@ref ADV_IND, @ref ADV_DIRECT_IND, @ref ADV_SCAN_IND, @ref ADV_NONCONN_IND, @ref SCAN_RSP) */\n\tuint8_t\t\tbdaddr_type;  /**< Type of the peer address (@ref PUBLIC_ADDR, @ref RANDOM_ADDR). */\n\ttBDAddr\t    bdaddr;       /**< Address of the peer device found during scanning. */\n\tuint8_t\t\tdata_length;  /**< Length of advertising or scan response data. */\n\tuint8_t\t\tdata_RSSI[VARIABLE_SIZE]; /**< Advertising or scan response data + RSSI. RSSI is last octect (signed integer). */\n} PACKED evt_gap_device_found;\n\n/**\n * This event is sent by the GAP to the upper layers when a procedure previously started has been terminated\n * by the upper layer or has completed for any other reason. See @ref _evt_gap_procedure_complete.\n */\n#define EVT_BLUE_GAP_PROCEDURE_COMPLETE           (0x0407)\ntypedef __packed struct _evt_gap_procedure_complete{\n  uint8_t procedure_code; /**< Terminated procedure. See @ref gap_procedure_codes \"GAP procedure codes\". */\n  /**\n   * @ref BLE_STATUS_SUCCESS, @ref BLE_STATUS_FAILED or @ref ERR_AUTH_FAILURE (procedure failed\n   * due to authentication requirements).\n   */\n  uint8_t status;\n  /**\n   * Procedure specific data.\\n\n   * @li For Name Discovery Procedure:\\n\n   * the name of the peer device if the procedure completed successfully.\n   * @li For General Connection Establishment Procedure:\\n\n   * The reconnection address written to the peripheral device if the peripheral is privacy enabled\n   */\n  uint8_t data[VARIABLE_SIZE];\n} PACKED evt_gap_procedure_complete;\n\n/**\n * This event is sent only by a privacy enabled Peripheral. The event is sent to the upper layers when the peripheral\n * is not able to resolve the private address of the peer device after connecting to it.\n */\n#define EVT_BLUE_GAP_ADDR_NOT_RESOLVED_IDB05A1          (0x0408)\ntypedef __packed struct _evt_gap_addr_not_resolved_IDB05A1{\n  uint16_t conn_handle; /**< Connection handle for which the private address could not be resolved with any of the stored IRK's.  */\n} PACKED evt_gap_addr_not_resolved_IDB05A1;\n\n/**\n * This event is raised when the reconnection address is generated during the general connection\n * establishment procedure. The same address is set into the peer device also as a part of the general\n * connection establishment procedure. In order to make use of the reconnection address the next time\n * while connecting to the bonded peripheral, the application needs to use this reconnection address\n * as its own address as well as the peer address to which it wants to connect. See aci_gap_start_general_conn_establish_proc()\n * and aci_gap_start_auto_conn_establish_proc().\n */\n#define EVT_BLUE_GAP_RECONNECTION_ADDRESS_IDB04A1       (0x0408)\ntypedef __packed struct _evt_gap_reconnection_addr_IDB04A1{\n  uint8_t reconnection_address[6]; /**< 6 bytes of reconnection address that has been generated */\n} PACKED evt_gap_reconnection_addr_IDB04A1;\n\n/**\n * @}\n */\n\n/**\n * @}\n */\n\n /**\n * @}\n */\n\n/**\n * @}\n */\n\n/**\n * @}\n */\n\n#endif /* __BLUENRG_GAP_ACI_H__ */\n",
                "bluenrg_gatt_aci.c": "/******************** (C) COPYRIGHT 2014 STMicroelectronics ********************\n* File Name          : bluenrg_gatt_aci.c\n* Author             : AMS - AAS\n* Version            : V1.0.0\n* Date               : 26-Jun-2014\n* Description        : File with GATT commands for BlueNRG FW6.3.\n********************************************************************************\n* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\n* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.\n* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,\n* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE\n* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING\n* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\n*******************************************************************************/\n\n#include \"bluenrg_types.h\"\n#include \"bluenrg_def.h\"\n#include \"hci_const.h\"\n#include \"bluenrg_aci_const.h\"\n#include \"bluenrg_gatt_aci.h\"\n#include \"bluenrg_gatt_server.h\"\n#include \"bluenrg_gap.h\"\n\n#define MIN(a,b)            ((a) < (b) )? (a) : (b)\n#define MAX(a,b)            ((a) > (b) )? (a) : (b)\n\n\ntBleStatus aci_gatt_init(void)\n{\n  struct hci_request rq;\n  uint8_t status;\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_INIT;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gatt_add_serv(uint8_t service_uuid_type, const uint8_t* service_uuid, uint8_t service_type, uint8_t max_attr_records, uint16_t *serviceHandle)\n{\n  struct hci_request rq;\n  gatt_add_serv_rp resp;    \n  uint8_t buffer[19];\n  uint8_t uuid_len;\n  uint8_t indx = 0;\n    \n  buffer[indx] = service_uuid_type;\n  indx++;\n    \n  if(service_uuid_type == UUID_TYPE_16){\n    uuid_len = 2;\n  }\n  else {\n    uuid_len = 16;\n  }        \n  BLUENRG_memcpy(buffer + indx, service_uuid, uuid_len);\n  indx +=  uuid_len;\n    \n  buffer[indx] = service_type;\n  indx++;\n    \n  buffer[indx] = max_attr_records;\n  indx++;\n    \n    \n  BLUENRG_memset(&resp, 0, sizeof(resp));\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_ADD_SERV;\n  rq.cparam = (void *)buffer;\n  rq.clen = indx;\n  rq.rparam = &resp;\n  rq.rlen = GATT_ADD_SERV_RP_SIZE;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  if (resp.status) {\n    return resp.status;\n  }\n    \n  *serviceHandle = btohs(resp.handle);\n\n  return 0;\n}\n\ntBleStatus aci_gatt_include_service(uint16_t service_handle, uint16_t included_start_handle,\n\t\t\t\t    uint16_t included_end_handle, uint8_t included_uuid_type,\n\t\t\t\t    const uint8_t* included_uuid, uint16_t *included_handle)\n{\n  struct hci_request rq;\n  gatt_include_serv_rp resp;    \n  uint8_t buffer[23];\n  uint8_t uuid_len;\n  uint8_t indx = 0;\n\n  service_handle = htobs(service_handle);\n  BLUENRG_memcpy(buffer, &service_handle, 2);\n  indx += 2;\n    \n  included_start_handle = htobs(included_start_handle);\n  BLUENRG_memcpy(buffer+indx, &included_start_handle, 2);\n  indx += 2;\n\n  included_end_handle = htobs(included_end_handle);\n  BLUENRG_memcpy(buffer+indx, &included_end_handle, 2);\n  indx += 2;\n\n  if(included_uuid_type == UUID_TYPE_16){\n    uuid_len = 2;\n  } else {\n    uuid_len = 16;\n  }        \n\n  buffer[indx] = included_uuid_type;\n  indx++;\n\n  BLUENRG_memcpy(buffer + indx, included_uuid, uuid_len);\n  indx += uuid_len;\n    \n  BLUENRG_memset(&resp, 0, sizeof(resp));\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_INCLUDE_SERV;\n  rq.cparam = (void *)buffer;\n  rq.clen = indx;\n  rq.rparam = &resp;\n  rq.rlen = GATT_INCLUDE_SERV_RP_SIZE;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  if (resp.status) {\n    return resp.status;\n  }\n    \n  *included_handle = btohs(resp.handle);\n\n  return 0;\n}\n\ntBleStatus aci_gatt_add_char(uint16_t serviceHandle,\n\t\t\t     uint8_t charUuidType,\n\t\t\t     const uint8_t* charUuid, \n\t\t\t     uint8_t charValueLen, \n\t\t\t     uint8_t charProperties,\n\t\t\t     uint8_t secPermissions,\n\t\t\t     uint8_t gattEvtMask,\n\t\t\t     uint8_t encryKeySize,\n\t\t\t     uint8_t isVariable,\n\t\t\t     uint16_t* charHandle)                     \n{\n  struct hci_request rq;\n  gatt_add_serv_rp resp;\n  uint8_t buffer[25];\n  uint8_t uuid_len;\n  uint8_t indx = 0;\n    \n  serviceHandle = htobs(serviceHandle);\n  BLUENRG_memcpy(buffer + indx, &serviceHandle, 2);\n  indx += 2;\n    \n  buffer[indx] = charUuidType;\n  indx++;\n    \n  if(charUuidType == UUID_TYPE_16){\n    uuid_len = 2;\n  }\n  else {\n    uuid_len = 16;\n  }        \n  BLUENRG_memcpy(buffer + indx, charUuid, uuid_len);\n  indx +=  uuid_len;\n    \n  buffer[indx] = charValueLen;\n  indx++;\n    \n  buffer[indx] = charProperties;\n  indx++;\n    \n  buffer[indx] = secPermissions;\n  indx++;\n    \n  buffer[indx] = gattEvtMask;\n  indx++;\n    \n  buffer[indx] = encryKeySize;\n  indx++;\n    \n  buffer[indx] = isVariable;\n  indx++;\n    \n  BLUENRG_memset(&resp, 0, sizeof(resp));\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_ADD_CHAR;\n  rq.cparam = (void *)buffer;\n  rq.clen = indx;\n  rq.rparam = &resp;\n  rq.rlen = GATT_ADD_CHAR_RP_SIZE;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  if (resp.status) {\n    return resp.status;\n  }\n    \n  *charHandle = btohs(resp.handle);\n\n  return 0;\n}\n\ntBleStatus aci_gatt_add_char_desc(uint16_t serviceHandle,\n                                  uint16_t charHandle,\n                                  uint8_t descUuidType,\n                                  const uint8_t* uuid, \n                                  uint8_t descValueMaxLen,\n                                  uint8_t descValueLen,\n                                  const void* descValue, \n                                  uint8_t secPermissions,\n                                  uint8_t accPermissions,\n                                  uint8_t gattEvtMask,\n                                  uint8_t encryKeySize,\n                                  uint8_t isVariable,\n                                  uint16_t* descHandle)                     \n{\n  struct hci_request rq;\n  gatt_add_char_desc_rp resp;\n  uint8_t buffer[HCI_MAX_PAYLOAD_SIZE];\n  uint8_t uuid_len;\n  uint8_t indx = 0;\n    \n  serviceHandle = htobs(serviceHandle);\n  BLUENRG_memcpy(buffer + indx, &serviceHandle, 2);\n  indx += 2;\n    \n  charHandle = htobs(charHandle);\n  BLUENRG_memcpy(buffer + indx, &charHandle, 2);\n  indx += 2;\n    \n  buffer[indx] = descUuidType;\n  indx++;\n    \n  if(descUuidType == UUID_TYPE_16){\n    uuid_len = 2;\n  }\n  else {\n    uuid_len = 16;\n  }        \n  BLUENRG_memcpy(buffer + indx, uuid, uuid_len);\n  indx +=  uuid_len;\n    \n  buffer[indx] = descValueMaxLen;\n  indx++;\n    \n  buffer[indx] = descValueLen;\n  indx++;\n\n  if ((descValueLen+indx+5) > HCI_MAX_PAYLOAD_SIZE)\n    return BLE_STATUS_INVALID_PARAMS;\n  \n  BLUENRG_memcpy(buffer + indx, descValue, descValueLen);\n  indx += descValueLen;\n    \n  buffer[indx] = secPermissions;\n  indx++;\n    \n  buffer[indx] = accPermissions;\n  indx++;\n    \n  buffer[indx] = gattEvtMask;\n  indx++;\n    \n  buffer[indx] = encryKeySize;\n  indx++;\n    \n  buffer[indx] = isVariable;\n  indx++;\n    \n  BLUENRG_memset(&resp, 0, sizeof(resp));\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_ADD_CHAR_DESC;\n  rq.cparam = (void *)buffer;\n  rq.clen = indx;\n  rq.rparam = &resp;\n  rq.rlen = GATT_ADD_CHAR_DESC_RP_SIZE;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  if (resp.status) {\n    return resp.status;\n  }\n    \n  *descHandle = btohs(resp.handle);\n\n  return 0;\n}\n\n\ntBleStatus aci_gatt_update_char_value(uint16_t servHandle, \n\t\t\t\t      uint16_t charHandle,\n\t\t\t\t      uint8_t charValOffset,\n\t\t\t\t      uint8_t charValueLen,   \n                                      const void *charValue)\n{\n  struct hci_request rq;\n  uint8_t status;\n  uint8_t buffer[HCI_MAX_PAYLOAD_SIZE];\n  uint8_t indx = 0;\n    \n  if ((charValueLen+6) > HCI_MAX_PAYLOAD_SIZE)\n    return BLE_STATUS_INVALID_PARAMS;\n\n  servHandle = htobs(servHandle);\n  BLUENRG_memcpy(buffer + indx, &servHandle, 2);\n  indx += 2;\n    \n  charHandle = htobs(charHandle);\n  BLUENRG_memcpy(buffer + indx, &charHandle, 2);\n  indx += 2;\n    \n  buffer[indx] = charValOffset;\n  indx++;\n    \n  buffer[indx] = charValueLen;\n  indx++;\n        \n  BLUENRG_memcpy(buffer + indx, charValue, charValueLen);\n  indx +=  charValueLen;\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_UPD_CHAR_VAL;\n  rq.cparam = (void *)buffer;\n  rq.clen = indx;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  if (status) {\n    return status;\n  }\n\n  return 0;\n}\n\ntBleStatus aci_gatt_del_char(uint16_t servHandle, uint16_t charHandle)\n{\n  struct hci_request rq;\n  uint8_t status;\n  gatt_del_char_cp cp;\n\n  cp.service_handle = htobs(servHandle);\n  cp.char_handle = htobs(charHandle);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_DEL_CHAR;\n  rq.cparam = &cp;\n  rq.clen = GATT_DEL_CHAR_CP_SIZE;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n                                      \ntBleStatus aci_gatt_del_service(uint16_t servHandle)\n{\n  struct hci_request rq;\n  uint8_t status;\n  gatt_del_serv_cp cp;\n\n  cp.service_handle = htobs(servHandle);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_DEL_SERV;\n  rq.cparam = &cp;\n  rq.clen = GATT_DEL_SERV_CP_SIZE;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gatt_del_include_service(uint16_t servHandle, uint16_t includeServHandle)\n{\n  struct hci_request rq;\n  uint8_t status;\n  gatt_del_inc_serv_cp cp;\n\n  cp.service_handle = htobs(servHandle);\n  cp.inc_serv_handle = htobs(includeServHandle);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_DEL_INC_SERV;\n  rq.cparam = &cp;\n  rq.clen = GATT_DEL_INC_SERV_CP_SIZE;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gatt_set_event_mask(uint32_t event_mask)\n{\n  struct hci_request rq;\n  uint8_t status;\n  gatt_set_evt_mask_cp cp;\n\n  cp.evt_mask = htobs(event_mask);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_SET_EVT_MASK;\n  rq.cparam = &cp;\n  rq.clen = GATT_SET_EVT_MASK_CP_SIZE;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n  \ntBleStatus aci_gatt_exchange_configuration(uint16_t conn_handle)\n{\n  struct hci_request rq;\n  uint8_t status;\n  gatt_exchange_config_cp cp;\n\n  cp.conn_handle = htobs(conn_handle);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_EXCHANGE_CONFIG;\n  rq.cparam = &cp;\n  rq.clen = GATT_EXCHANGE_CONFIG_CP_SIZE;\n  rq.event = EVT_CMD_STATUS; \n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n  \ntBleStatus aci_att_find_information_req(uint16_t conn_handle, uint16_t start_handle, uint16_t end_handle)\n{\n  struct hci_request rq;\n  uint8_t status;\n  att_find_info_req_cp cp;\n\n  cp.conn_handle = htobs(conn_handle);\n  cp.start_handle = htobs(start_handle);\n  cp.end_handle = htobs(end_handle);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_ATT_FIND_INFO_REQ;\n  rq.cparam = &cp;\n  rq.clen = ATT_FIND_INFO_REQ_CP_SIZE;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_att_find_by_type_value_req(uint16_t conn_handle, uint16_t start_handle, uint16_t end_handle,\n                                          uint8_t* uuid, uint8_t attr_val_len, uint8_t* attr_val)\n{\n  struct hci_request rq;\n  uint8_t status;\n  att_find_by_type_value_req_cp cp;\n  \n  if(attr_val_len > sizeof(cp.attr_val))\n    return BLE_STATUS_INVALID_PARAMS;\n\n  cp.conn_handle = htobs(conn_handle);\n  cp.start_handle = htobs(start_handle);\n  cp.end_handle = htobs(end_handle);\n  BLUENRG_memcpy(cp.uuid, uuid, 2);\n  cp.attr_val_len = attr_val_len;\n  BLUENRG_memcpy(cp.attr_val, attr_val, attr_val_len);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_ATT_FIND_BY_TYPE_VALUE_REQ;\n  rq.cparam = &cp;\n  rq.clen = ATT_FIND_BY_TYPE_VALUE_REQ_CP_SIZE + attr_val_len;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_att_read_by_type_req(uint16_t conn_handle, uint16_t start_handle, uint16_t end_handle,\n                                    uint8_t  uuid_type, uint8_t* uuid)\n{\n  struct hci_request rq;\n  uint8_t status;\n  att_read_by_type_req_cp cp;\n  uint8_t uuid_len;\n  \n  if(uuid_type == UUID_TYPE_16){\n    uuid_len = 2;\n  }\n  else{\n    uuid_len = 16;\n  }\n\n  cp.conn_handle = htobs(conn_handle);\n  cp.start_handle = htobs(start_handle);\n  cp.end_handle = htobs(end_handle);\n  cp.uuid_type = uuid_type;\n  BLUENRG_memcpy(cp.uuid, uuid, uuid_len);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_ATT_READ_BY_TYPE_REQ;\n  rq.cparam = &cp;\n  rq.clen = ATT_READ_BY_TYPE_REQ_CP_SIZE + uuid_len;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_att_read_by_group_type_req(uint16_t conn_handle, uint16_t start_handle, uint16_t end_handle,\n                                    uint8_t  uuid_type, uint8_t* uuid)\n{\n  struct hci_request rq;\n  uint8_t status;\n  att_read_by_group_type_req_cp cp;\n  uint8_t uuid_len;\n  \n  if(uuid_type == UUID_TYPE_16){\n    uuid_len = 2;\n  }\n  else{\n    uuid_len = 16;\n  }\n\n  cp.conn_handle = htobs(conn_handle);\n  cp.start_handle = htobs(start_handle);\n  cp.end_handle = htobs(end_handle);\n  cp.uuid_type = uuid_type;\n  BLUENRG_memcpy(cp.uuid, uuid, uuid_len);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_ATT_READ_BY_GROUP_TYPE_REQ;\n  rq.cparam = &cp;\n  rq.clen = ATT_READ_BY_GROUP_TYPE_REQ_CP_SIZE + uuid_len;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_att_prepare_write_req(uint16_t conn_handle, uint16_t attr_handle, uint16_t value_offset,\n                                    uint8_t  attr_val_len, uint8_t* attr_val)\n{\n  struct hci_request rq;\n  uint8_t status;\n  att_prepare_write_req_cp cp;\n  \n  if(attr_val_len > sizeof(cp.attr_val))\n    return BLE_STATUS_INVALID_PARAMS;\n\n  cp.conn_handle = htobs(conn_handle);\n  cp.attr_handle = htobs(attr_handle);\n  cp.value_offset = htobs(value_offset);\n  cp.attr_val_len = attr_val_len;\n  BLUENRG_memcpy(cp.attr_val, attr_val, attr_val_len);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_ATT_PREPARE_WRITE_REQ;\n  rq.cparam = &cp;\n  rq.clen = ATT_PREPARE_WRITE_REQ_CP_SIZE + attr_val_len;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_att_execute_write_req(uint16_t conn_handle, uint8_t execute)\n{\n  struct hci_request rq;\n  uint8_t status;\n  att_execute_write_req_cp cp;\n\n  cp.conn_handle = htobs(conn_handle);\n  cp.execute = execute;\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_ATT_EXECUTE_WRITE_REQ;\n  rq.cparam = &cp;\n  rq.clen = ATT_EXECUTE_WRITE_REQ_CP_SIZE;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gatt_disc_all_prim_services(uint16_t conn_handle)\n{\n  struct hci_request rq;\n  uint8_t status;\n  gatt_disc_all_prim_services_cp cp;\n\n  cp.conn_handle = htobs(conn_handle);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_DISC_ALL_PRIM_SERVICES;\n  rq.cparam = &cp;\n  rq.clen = GATT_DISC_ALL_PRIM_SERVICES_CP_SIZE;\n  rq.event = EVT_CMD_STATUS;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gatt_disc_prim_service_by_uuid(uint16_t conn_handle, uint8_t uuid_type, uint8_t* uuid)\n{\n  struct hci_request rq;\n  uint8_t status;\n  gatt_disc_prim_service_by_uuid_cp cp;\n  uint8_t uuid_len;\n  \n  if(uuid_type == UUID_TYPE_16){\n    uuid_len = 2;\n  }\n  else{\n    uuid_len = 16;\n  }\n\n  cp.conn_handle = htobs(conn_handle);\n  cp.uuid_type = uuid_type;\n  BLUENRG_memcpy(cp.uuid, uuid, uuid_len);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_DISC_PRIM_SERVICE_BY_UUID;\n  rq.cparam = &cp;\n  rq.clen = GATT_DISC_PRIM_SERVICE_BY_UUID_CP_SIZE + uuid_len;\n  rq.event = EVT_CMD_STATUS;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gatt_find_included_services(uint16_t conn_handle, uint16_t start_service_handle, \n\t\t\t\t\t   uint16_t end_service_handle)\n{\n  struct hci_request rq;\n  uint8_t status;\n  gatt_find_included_services_cp cp;\n\n  cp.conn_handle = htobs(conn_handle);\n  cp.start_handle = htobs(start_service_handle);\n  cp.end_handle = htobs(end_service_handle);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_FIND_INCLUDED_SERVICES;\n  rq.cparam = &cp;\n  rq.clen = GATT_FIND_INCLUDED_SERVICES_CP_SIZE;\n  rq.event = EVT_CMD_STATUS;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gatt_disc_all_charac_of_serv(uint16_t conn_handle, uint16_t start_attr_handle, \n\t\t\t\t\t    uint16_t end_attr_handle)\n{\n  struct hci_request rq;\n  uint8_t status;\n  gatt_disc_all_charac_of_serv_cp cp;\n\n  cp.conn_handle = htobs(conn_handle);\n  cp.start_attr_handle = htobs(start_attr_handle);\n  cp.end_attr_handle = htobs(end_attr_handle);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_DISC_ALL_CHARAC_OF_SERV;\n  rq.cparam = &cp;\n  rq.clen = GATT_DISC_ALL_CHARAC_OF_SERV_CP_SIZE;\n  rq.event = EVT_CMD_STATUS;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gatt_disc_charac_by_uuid(uint16_t conn_handle, uint16_t start_handle,\n\t\t\t\t                     uint16_t end_handle, uint8_t charUuidType,\n                                                     const uint8_t* charUuid)\n{\n  struct hci_request rq;\n  uint8_t status;\n  \n  uint8_t buffer[23];\n  uint8_t uuid_len;\n  uint8_t indx = 0;\n    \n  conn_handle = htobs(conn_handle);\n  BLUENRG_memcpy(buffer + indx, &conn_handle, 2);\n  indx += 2;\n    \n  start_handle = htobs(start_handle);\n  BLUENRG_memcpy(buffer + indx, &start_handle, 2);\n  indx += 2;\n  \n  end_handle = htobs(end_handle);\n  BLUENRG_memcpy(buffer + indx, &end_handle, 2);\n  indx += 2;\n  \n  buffer[indx] = charUuidType;\n  indx++;\n    \n  if(charUuidType == 0x01){\n    uuid_len = 2;\n  }\n  else {\n    uuid_len = 16;\n  }        \n  BLUENRG_memcpy(buffer + indx, charUuid, uuid_len);\n  indx +=  uuid_len;\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_DISC_CHARAC_BY_UUID;\n  rq.cparam = (void *)buffer;\n  rq.clen = indx;\n  rq.event = EVT_CMD_STATUS;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gatt_disc_all_charac_descriptors(uint16_t conn_handle, uint16_t char_val_handle, \n\t\t\t\t\t\tuint16_t char_end_handle)\n{\n  struct hci_request rq;\n  uint8_t status;\n  gatt_disc_all_charac_descriptors_cp cp;\n\n  cp.conn_handle = htobs(conn_handle);\n  cp.char_val_handle = htobs(char_val_handle);\n  cp.char_end_handle = htobs(char_end_handle);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_DISC_ALL_CHARAC_DESCRIPTORS;\n  rq.cparam = &cp;\n  rq.clen = GATT_DISC_ALL_CHARAC_DESCRIPTORS_CP_SIZE;\n  rq.event = EVT_CMD_STATUS;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gatt_read_charac_val(uint16_t conn_handle, uint16_t attr_handle)\n{\n  struct hci_request rq;\n  uint8_t status;\n  gatt_read_charac_val_cp cp;\n\n  cp.conn_handle = htobs(conn_handle);\n  cp.attr_handle = htobs(attr_handle);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_READ_CHARAC_VAL;\n  rq.cparam = &cp;\n  rq.clen = GATT_READ_CHARAC_VAL_CP_SIZE;\n  rq.event = EVT_CMD_STATUS;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  return status;\n}\n\ntBleStatus aci_gatt_read_using_charac_uuid(uint16_t conn_handle, uint16_t start_handle, uint16_t end_handle,\n                                    uint8_t  uuid_type, uint8_t* uuid)\n{\n  struct hci_request rq;\n  uint8_t status;\n  gatt_read_using_charac_uuid_cp cp;\n  uint8_t uuid_len;\n  \n  if(uuid_type == UUID_TYPE_16){\n    uuid_len = 2;\n  }\n  else{\n    uuid_len = 16;\n  }\n\n  cp.conn_handle = htobs(conn_handle);\n  cp.start_handle = htobs(start_handle);\n  cp.end_handle = htobs(end_handle);\n  cp.uuid_type = uuid_type;\n  BLUENRG_memcpy(cp.uuid, uuid, uuid_len);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_READ_USING_CHARAC_UUID;\n  rq.cparam = &cp;\n  rq.clen = GATT_READ_USING_CHARAC_UUID_CP_SIZE + uuid_len;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gatt_read_long_charac_val(uint16_t conn_handle, uint16_t attr_handle, \n\t\t\t\t\t uint16_t val_offset)\n{\n  struct hci_request rq;\n  uint8_t status;\n  gatt_read_long_charac_val_cp cp;\n\n  cp.conn_handle = htobs(conn_handle);\n  cp.attr_handle = htobs(attr_handle);\n  cp.val_offset = htobs(val_offset);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_READ_LONG_CHARAC_VAL;\n  rq.cparam = &cp;\n  rq.clen = GATT_READ_LONG_CHARAC_VAL_CP_SIZE;\n  rq.event = EVT_CMD_STATUS;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gatt_read_multiple_charac_val(uint16_t conn_handle, uint8_t num_handles, \n                                             uint8_t* set_of_handles)\n{\n  struct hci_request rq;\n  uint8_t status;\n  gatt_read_multiple_charac_val_cp cp;\n  \n  if(num_handles*2 > sizeof(cp.set_of_handles))\n    return BLE_STATUS_INVALID_PARAMS;\n\n  cp.conn_handle = htobs(conn_handle);\n  cp.num_handles = htobs(num_handles);\n  BLUENRG_memcpy(cp.set_of_handles, set_of_handles, 2*num_handles);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_READ_MULTIPLE_CHARAC_VAL;\n  rq.cparam = &cp;\n  rq.clen = GATT_READ_MULTIPLE_CHARAC_VAL_CP_SIZE + 2*num_handles;\n  rq.event = EVT_CMD_STATUS;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\n\n\ntBleStatus aci_gatt_write_charac_value(uint16_t conn_handle, uint16_t attr_handle, \n\t\t\t\t       uint8_t value_len, uint8_t *attr_value)\n{\n  struct hci_request rq;\n  uint8_t status;\n  uint8_t buffer[HCI_MAX_PAYLOAD_SIZE];\n  uint8_t indx = 0;\n    \n  if ((value_len+5) > HCI_MAX_PAYLOAD_SIZE)\n    return BLE_STATUS_INVALID_PARAMS;\n\n  conn_handle = htobs(conn_handle);\n  BLUENRG_memcpy(buffer + indx, &conn_handle, 2);\n  indx += 2;\n    \n  attr_handle = htobs(attr_handle);\n  BLUENRG_memcpy(buffer + indx, &attr_handle, 2);\n  indx += 2;\n\n  buffer[indx] = value_len;\n  indx++;\n        \n  BLUENRG_memcpy(buffer + indx, attr_value, value_len);\n  indx +=  value_len;\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_WRITE_CHAR_VALUE;\n  rq.cparam = (void *)buffer;\n  rq.clen = indx;\n  rq.event = EVT_CMD_STATUS;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gatt_write_long_charac_val(uint16_t conn_handle, uint16_t attr_handle,\n                                          uint16_t val_offset, uint8_t val_len, const uint8_t* attr_val)\n{\n  struct hci_request rq;\n  uint8_t status;\n  gatt_write_long_charac_val_cp cp;\n  \n  if(val_len > sizeof(cp.attr_val))\n    return BLE_STATUS_INVALID_PARAMS;\n\n  cp.conn_handle = htobs(conn_handle);\n  cp.attr_handle = htobs(attr_handle);\n  cp.val_offset = htobs(val_offset);\n  cp.val_len = val_len;\n  BLUENRG_memcpy(cp.attr_val, attr_val, val_len);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_WRITE_LONG_CHARAC_VAL;\n  rq.cparam = &cp;\n  rq.clen = GATT_WRITE_LONG_CHARAC_VAL_CP_SIZE + val_len;\n  rq.event = EVT_CMD_STATUS;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gatt_write_charac_reliable(uint16_t conn_handle, uint16_t attr_handle,\n                                          uint16_t val_offset, uint8_t val_len, uint8_t* attr_val)\n{\n  struct hci_request rq;\n  uint8_t status;\n  gatt_write_charac_reliable_cp cp;\n  \n  if(val_len > sizeof(cp.attr_val))\n    return BLE_STATUS_INVALID_PARAMS;\n\n  cp.conn_handle = htobs(conn_handle);\n  cp.attr_handle = htobs(attr_handle);\n  cp.val_offset = htobs(val_offset);\n  cp.val_len = val_len;\n  BLUENRG_memcpy(cp.attr_val, attr_val, val_len);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_WRITE_CHARAC_RELIABLE;\n  rq.cparam = &cp;\n  rq.clen = GATT_WRITE_CHARAC_RELIABLE_CP_SIZE + val_len;\n  rq.event = EVT_CMD_STATUS;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gatt_write_long_charac_desc(uint16_t conn_handle, uint16_t attr_handle,\n                                          uint16_t val_offset, uint8_t val_len, uint8_t* attr_val)\n{\n  struct hci_request rq;\n  uint8_t status;\n  gatt_write_charac_reliable_cp cp;\n  \n  if(val_len > sizeof(cp.attr_val))\n    return BLE_STATUS_INVALID_PARAMS;\n\n  cp.conn_handle = htobs(conn_handle);\n  cp.attr_handle = htobs(attr_handle);\n  cp.val_offset = htobs(val_offset);\n  cp.val_len = val_len;\n  BLUENRG_memcpy(cp.attr_val, attr_val, val_len);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_WRITE_LONG_CHARAC_DESC;\n  rq.cparam = &cp;\n  rq.clen = GATT_WRITE_LONG_CHARAC_DESC_CP_SIZE + val_len;\n  rq.event = EVT_CMD_STATUS;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gatt_read_long_charac_desc(uint16_t conn_handle, uint16_t attr_handle,\n                                          uint16_t val_offset)\n{\n  struct hci_request rq;\n  uint8_t status;\n  gatt_read_long_charac_desc_cp cp;\n\n  cp.conn_handle = htobs(conn_handle);\n  cp.attr_handle = htobs(attr_handle);\n  cp.val_offset = htobs(val_offset);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_READ_LONG_CHARAC_DESC;\n  rq.cparam = &cp;\n  rq.clen = GATT_READ_LONG_CHARAC_DESC_CP_SIZE;\n  rq.event = EVT_CMD_STATUS;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gatt_write_charac_descriptor(uint16_t conn_handle, uint16_t attr_handle, \n\t\t\t\t\t   uint8_t value_len, uint8_t *attr_value)\n{\n  struct hci_request rq;\n  uint8_t status;\n  uint8_t buffer[HCI_MAX_PAYLOAD_SIZE];\n  uint8_t indx = 0;\n    \n  if ((value_len+5) > HCI_MAX_PAYLOAD_SIZE)\n    return BLE_STATUS_INVALID_PARAMS;\n\n  conn_handle = htobs(conn_handle);\n  BLUENRG_memcpy(buffer + indx, &conn_handle, 2);\n  indx += 2;\n    \n  attr_handle = htobs(attr_handle);\n  BLUENRG_memcpy(buffer + indx, &attr_handle, 2);\n  indx += 2;\n\n  buffer[indx] = value_len;\n  indx++;\n        \n  BLUENRG_memcpy(buffer + indx, attr_value, value_len);\n  indx +=  value_len;\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_WRITE_CHAR_DESCRIPTOR;\n  rq.cparam = (void *)buffer;\n  rq.clen = indx;\n  rq.event = EVT_CMD_STATUS; \n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gatt_read_charac_desc(uint16_t conn_handle, uint16_t attr_handle)\n{\n  struct hci_request rq;\n  uint8_t status;\n  gatt_read_long_charac_desc_cp cp;\n\n  cp.conn_handle = htobs(conn_handle);\n  cp.attr_handle = htobs(attr_handle);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_READ_CHAR_DESCRIPTOR;\n  rq.cparam = &cp;\n  rq.clen = GATT_READ_CHAR_DESCRIPTOR_CP_SIZE;\n  rq.event = EVT_CMD_STATUS;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gatt_write_without_response(uint16_t conn_handle, uint16_t attr_handle,\n                                              uint8_t val_len, const uint8_t* attr_val)\n{\n  struct hci_request rq;\n  uint8_t status;\n  gatt_write_without_resp_cp cp;\n  \n  if(val_len > sizeof(cp.attr_val))\n    return BLE_STATUS_INVALID_PARAMS;\n\n  cp.conn_handle = htobs(conn_handle);\n  cp.attr_handle = htobs(attr_handle);\n  cp.val_len = val_len;\n  BLUENRG_memcpy(cp.attr_val, attr_val, val_len);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_WRITE_WITHOUT_RESPONSE;\n  rq.cparam = &cp;\n  rq.clen = GATT_WRITE_WITHOUT_RESPONSE_CP_SIZE + val_len; \n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gatt_signed_write_without_resp(uint16_t conn_handle, uint16_t attr_handle,\n                                              uint8_t val_len, uint8_t* attr_val)\n{\n  struct hci_request rq;\n  uint8_t status;\n  gatt_signed_write_without_resp_cp cp;\n  \n  if(val_len > sizeof(cp.attr_val))\n    return BLE_STATUS_INVALID_PARAMS;\n\n  cp.conn_handle = htobs(conn_handle);\n  cp.attr_handle = htobs(attr_handle);\n  cp.val_len = val_len;\n  BLUENRG_memcpy(cp.attr_val, attr_val, val_len);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_SIGNED_WRITE_WITHOUT_RESPONSE;\n  rq.cparam = &cp;\n  rq.clen = GATT_SIGNED_WRITE_WITHOUT_RESPONSE_CP_SIZE + val_len;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gatt_confirm_indication(uint16_t conn_handle)\n{\n  struct hci_request rq;\n  uint8_t status;\n  gatt_confirm_indication_cp cp;\n\n  cp.conn_handle = htobs(conn_handle);\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_CONFIRM_INDICATION;\n  rq.cparam = &cp;\n  rq.clen = GATT_CONFIRM_INDICATION_CP_SIZE;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  return status;\n}\n\ntBleStatus aci_gatt_write_response(uint16_t conn_handle,\n                                   uint16_t attr_handle,\n                                   uint8_t write_status,\n                                   uint8_t err_code,\n                                   uint8_t att_val_len,\n                                   uint8_t *att_val)\n{\n  struct hci_request rq;\n  uint8_t status;\n  uint8_t buffer[HCI_MAX_PAYLOAD_SIZE];\n  uint8_t indx = 0;\n  \n  if ((att_val_len+7) > HCI_MAX_PAYLOAD_SIZE)\n    return BLE_STATUS_INVALID_PARAMS;\n\n  conn_handle = htobs(conn_handle);  \n  BLUENRG_memcpy(buffer + indx, &conn_handle, 2);\n  indx += 2;\n    \n  attr_handle = htobs(attr_handle);\n  BLUENRG_memcpy(buffer + indx, &attr_handle, 2);\n  indx += 2;\n    \n  buffer[indx] = write_status;\n  indx += 1;\n    \n  buffer[indx] = err_code;\n  indx += 1;\n    \n  buffer[indx] = att_val_len;\n  indx += 1;\n    \n  BLUENRG_memcpy(buffer + indx, att_val, att_val_len);\n  indx += att_val_len;\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_WRITE_RESPONSE;\n  rq.cparam = (void *)buffer;\n  rq.clen = indx;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  if (status) {\n    return status;\n  }\n\n  return 0;\n}\n\ntBleStatus aci_gatt_allow_read(uint16_t conn_handle)\n{\n    struct hci_request rq;\n    gatt_allow_read_cp cp;\n    uint8_t status;\n    \n    cp.conn_handle = htobs(conn_handle);\n\n    BLUENRG_memset(&rq, 0, sizeof(rq));\n    rq.ogf = OGF_VENDOR_CMD;\n    rq.ocf = OCF_GATT_ALLOW_READ;\n    rq.cparam = &cp;\n    rq.clen = GATT_ALLOW_READ_CP_SIZE;\n    rq.rparam = &status;\n    rq.rlen = 1;\n\n    if (hci_send_req(&rq, FALSE) < 0)\n      return BLE_STATUS_TIMEOUT;\n\n    return status;\n}\n\ntBleStatus aci_gatt_set_security_permission(uint16_t service_handle, uint16_t attr_handle,\n                                            uint8_t security_permission)\n{\n    struct hci_request rq;\n    gatt_set_security_permission_cp cp;\n    uint8_t status;\n    \n    cp.service_handle = htobs(service_handle);\n    cp.attr_handle = htobs(attr_handle);\n    cp.security_permission = security_permission;\n\n    BLUENRG_memset(&rq, 0, sizeof(rq));\n    rq.ogf = OGF_VENDOR_CMD;\n    rq.ocf = OCF_GATT_SET_SECURITY_PERMISSION;\n    rq.cparam = &cp;\n    rq.clen = GATT_GATT_SET_SECURITY_PERMISSION_CP_SIZE;\n    rq.rparam = &status;\n    rq.rlen = 1;\n\n    if (hci_send_req(&rq, FALSE) < 0)\n      return BLE_STATUS_TIMEOUT;\n\n    return status;\n}\n\ntBleStatus aci_gatt_set_desc_value(uint16_t servHandle, \n\t\t\t\t   uint16_t charHandle,\n\t\t\t\t   uint16_t charDescHandle,\n\t\t\t\t   uint16_t charDescValOffset,\n\t\t\t\t   uint8_t charDescValueLen,   \n                                   const void *charDescValue)\n{\n  struct hci_request rq;\n  uint8_t status;\n  uint8_t buffer[HCI_MAX_PAYLOAD_SIZE];\n  uint8_t indx = 0;\n    \n  if ((charDescValueLen+9) > HCI_MAX_PAYLOAD_SIZE)\n    return BLE_STATUS_INVALID_PARAMS;\n\n  servHandle = htobs(servHandle);\n  BLUENRG_memcpy(buffer + indx, &servHandle, 2);\n  indx += 2;\n    \n  charHandle = htobs(charHandle);\n  BLUENRG_memcpy(buffer + indx, &charHandle, 2);\n  indx += 2;\n    \n  charDescHandle = htobs(charDescHandle);\n  BLUENRG_memcpy(buffer + indx, &charDescHandle, 2);\n  indx += 2;\n    \n  BLUENRG_memcpy(buffer + indx, &charDescValOffset, 2);\n  indx += 2;\n    \n  buffer[indx] = charDescValueLen;\n  indx++;\n        \n  BLUENRG_memcpy(buffer + indx, charDescValue, charDescValueLen);\n  indx +=  charDescValueLen;\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_SET_DESC_VAL;\n  rq.cparam = (void *)buffer;\n  rq.clen = indx;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_gatt_read_handle_value(uint16_t attr_handle, uint16_t data_len, uint16_t *data_len_out_p, uint8_t *data)\n{\n  struct hci_request rq;\n  gatt_read_handle_val_cp cp;\n  gatt_read_handle_val_rp rp;\n \n  if(data_len > sizeof(rp.value))\n    return BLE_STATUS_INVALID_PARAMS;\n\n  cp.attr_handle = htobs(attr_handle);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_READ_HANDLE_VALUE;\n  rq.cparam = &cp;\n  rq.clen = sizeof(cp);\n  rq.rparam = &rp;\n  rq.rlen = sizeof(rp);\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  if(rp.status)\n    return rp.status;\n\n  *data_len_out_p = btohs(rp.value_len);\n\n  BLUENRG_memcpy(data, rp.value, MIN(data_len, *data_len_out_p));\n\n  return 0;\n}\n\ntBleStatus aci_gatt_read_handle_value_offset_IDB05A1(uint16_t attr_handle, uint8_t offset, uint16_t data_len, uint16_t *data_len_out_p, uint8_t *data)\n{\n  struct hci_request rq;\n  gatt_read_handle_val_offset_cp cp;\n  gatt_read_handle_val_offset_rp rp;\n  \n  if(data_len > sizeof(rp.value))\n    return BLE_STATUS_INVALID_PARAMS;\n\n  cp.attr_handle = htobs(attr_handle);\n  cp.offset = offset;\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_READ_HANDLE_VALUE_OFFSET;\n  rq.cparam = &cp;\n  rq.clen = sizeof(cp);\n  rq.rparam = &rp;\n  rq.rlen = sizeof(rp);\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  if(rp.status)\n    return rp.status;\n\n  *data_len_out_p = rp.value_len;\n\n  BLUENRG_memcpy(data, rp.value, MIN(data_len, *data_len_out_p));\n\n  return 0; \n}\n\ntBleStatus aci_gatt_update_char_value_ext_IDB05A1(uint16_t service_handle, uint16_t char_handle,\n                                                  uint8_t update_type, uint16_t char_length,\n                                                  uint16_t value_offset, uint8_t value_length,\n                                                  const uint8_t* value)\n{\n  struct hci_request rq;\n  uint8_t status;\n  gatt_upd_char_val_ext_cp cp;\n  \n  if(value_length > sizeof(cp.value))\n    return BLE_STATUS_INVALID_PARAMS;\n  \n  cp.service_handle = htobs(service_handle);\n  cp.char_handle = htobs(char_handle);\n  cp.update_type = update_type;\n  cp.char_length = htobs(char_length);\n  cp.value_offset = htobs(value_offset);\n  cp.value_length = value_length;\n  BLUENRG_memcpy(cp.value, value, value_length);\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GATT_UPD_CHAR_VAL_EXT;\n  rq.cparam = &cp;\n  rq.clen = GATT_UPD_CHAR_VAL_EXT_CP_SIZE + value_length;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  return status;\n}\n\n\n",
                "bluenrg_gatt_aci.h": "/******************** (C) COPYRIGHT 2014 STMicroelectronics ********************\n* File Name          : bluenrg_gatt_aci.h\n* Author             : AMS - AAS\n* Version            : V1.0.0\n* Date               : 26-Jun-2014\n* Description        : Header file with GATT commands for BlueNRG FW6.3.\n********************************************************************************\n* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\n* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.\n* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,\n* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE\n* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING\n* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\n*******************************************************************************/\n\n#ifndef __BLUENRG_GATT_ACI_H__\n#define __BLUENRG_GATT_ACI_H__\n\n#include \"bluenrg_gatt_server.h\"\n\n/** \n * @addtogroup HIGH_LEVEL_INTERFACE HIGH_LEVEL_INTERFACE\n * @{\n */\n\n/**\n * @addtogroup ACI_GATT ACI_GATT\n * @brief API for GATT layer.\n * @{\n */\n \n/**\n * @defgroup GATT_Functions GATT functions\n * @brief API for GATT layer.\n * @{\n */\n\n/**\n  * @brief  Initialize the GATT layer for server and client roles.\n  * @note   It adds also the GATT service with Service Changed Characteristic.\n  *         Until this command is issued the GATT channel will not process any commands\n  *         even if the connection is opened. This command has to be given\n  *         before using any of the GAP features.\n  * @return Value indicating success or error code.\n  */\ntBleStatus aci_gatt_init(void);\n\n/**\n * @brief Add a service to the GATT Server. When a service is created in the server, the Host needs\n *        to reserve the handle ranges for this service using max_attr_records parameter. This\n *        parameter specifies the maximum number of attribute records that can be added to this\n *        service (including the service attribute, include attribute, characteristic attribute,\n *        characteristic value attribute and characteristic descriptor attribute). Handle of the\n *        created service is returned.\n * @note  Service declaration is taken from the service pool. The attributes for characteristics and descriptors\n *        are allocated from the attribute pool.\n * @param service_uuid_type Type of service UUID (16-bit or 128-bit). See @ref UUID_Types \"UUID Types\".\n * @param[in] service_uuid 16-bit or 128-bit UUID based on the UUID Type field\n * @param service_type Primary or secondary service. See @ref Service_type \"Service Type\".\n * @param max_attr_records Maximum number of attribute records that can be added to this service\n *                         (including the service declaration itself)\n * @param[out] serviceHandle Handle of the Service. When this service is added to the service,\n * \t\t\t\t\t\t\t a handle is allocated by the server to this service. Server also\n * \t\t\t\t\t\t\t allocates a range of handles for this service from serviceHandle to\n * \t\t\t\t\t\t\t <serviceHandle + max_attr_records>.\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gatt_add_serv(uint8_t service_uuid_type,\n\t\t\t     const uint8_t* service_uuid,\n\t\t\t     uint8_t service_type,\n\t\t\t     uint8_t max_attr_records,\n\t\t\t     uint16_t *serviceHandle);\n\n/**\n * @brief Include a service given by included_start_handle and included_end_handle to another service\n * \t\t  given by service_handle. Attribute server creates an INCLUDE definition attribute and return\n * \t\t  the handle of this attribute in included_handle.\n * @param service_handle Handle of the service to which another service has to be included\n * @param included_start_handle Start Handle of the service which has to be included in service\n * @param included_end_handle End Handle of the service which has to be included in service\n * @param included_uuid_type Type of UUID for included service (16-bit or 128-bit). See @ref Well-Known_UUIDs \"Well-Known UUIDs\".\n * @param[in] included_uuid 16-bit or 128-bit UUID.\n * @param[out] included_handle Handle of the include declaration.\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gatt_include_service(uint16_t service_handle, uint16_t included_start_handle,\n\t\t\t\t    uint16_t included_end_handle, uint8_t included_uuid_type,\n\t\t\t\t    const uint8_t* included_uuid, uint16_t *included_handle);\n\n/**\n * @brief Add a characteristic to a service.\n * @param serviceHandle Handle of the service to which the characteristic has to be added.\n * @param charUuidType Type of characteristic UUID (16-bit or 128-bit). See @ref UUID_Types \"UUID Types\".\n *         @arg @ref UUID_TYPE_16\n *         @arg @ref UUID_TYPE_128\n * @param charUuid 16-bit or 128-bit UUID.\n * @param charValueLen Maximum length of the characteristic value.\n * @param charProperties Bitwise OR values of Characteristic Properties (defined in Volume 3,\n *        Section 3.3.3.1 of Bluetooth Specification 4.0). See @ref Char_properties \"Characteristic properties\".\n * @param secPermissions Security permissions for the added characteristic. See @ref Security_permissions \"Security permissions\".\n * \t\t\t@arg ATTR_PERMISSION_NONE\n * \t\t\t@arg ATTR_PERMISSION_AUTHEN_READ\n * \t\t\t@arg ATTR_PERMISSION_AUTHOR_READ\n * \t\t\t@arg ATTR_PERMISSION_ENCRY_READ\n * \t\t\t@arg ATTR_PERMISSION_AUTHEN_WRITE\n * \t\t\t@arg ATTR_PERMISSION_AUTHOR_WRITE\n * \t\t\t@arg ATTR_PERMISSION_ENCRY_WRITE\n * @param gattEvtMask Bit mask that enables events that will be sent to the application by the GATT server\n * \t\t\t\t\t  on certain ATT requests. See @ref Gatt_Event_Mask \"Gatt Event Mask\".\n * \t\t   @arg GATT_DONT_NOTIFY_EVENTS\n * \t\t   @arg GATT_NOTIFY_ATTRIBUTE_WRITE\n * \t\t   @arg GATT_NOTIFY_WRITE_REQ_AND_WAIT_FOR_APPL_RESP\n * \t\t   @arg GATT_NOTIFY_READ_REQ_AND_WAIT_FOR_APPL_RESP\n * @param encryKeySize The minimum encryption key size requirement for this attribute. Valid Range: 7 to 16.\n * @param isVariable If the attribute has a variable length value field (1) or not (0).\n * @param charHandle Handle of the Characteristic that has been added. It is the handle of the characteristic declaration.\n * \t\t  The attribute that holds the characteristic value is allocated at the next handle, followed by the Client\n * \t\t  Characteristic Configuration descriptor if the characteristic has @ref CHAR_PROP_NOTIFY or @ref CHAR_PROP_INDICATE\n * \t\t  properties.\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gatt_add_char(uint16_t serviceHandle,\n\t\t\t     uint8_t charUuidType,\n\t\t\t     const uint8_t* charUuid, \n\t\t\t     uint8_t charValueLen, \n\t\t\t     uint8_t charProperties,\n\t\t\t     uint8_t secPermissions,\n\t\t\t     uint8_t gattEvtMask,\n\t\t\t     uint8_t encryKeySize,\n\t\t\t     uint8_t isVariable,\n\t\t\t     uint16_t* charHandle);\n\n/**\n * Add a characteristic descriptor to a service.\n * @param serviceHandle Handle of the service to which the characteristic belongs\n * @param charHandle Handle of the characteristic to which description has to be added.\n * @param descUuidType 16-bit or 128-bit UUID. See @ref UUID_Types \"UUID Types\".\n *         @arg @ref UUID_TYPE_16\n *         @arg @ref UUID_TYPE_128\n * @param[in] uuid UUID of the Characteristic descriptor. It can be one of the UUID assigned by Bluetooth SIG\n * \t\t(Well_known_UUIDs) or a user-defined one.\n * @param descValueMaxLen The maximum length of the descriptor value\n * @param descValueLen Current Length of the characteristic descriptor value\n * @param[in] descValue Value of the characteristic description\n * @param secPermissions Security permissions for the added descriptor. See @ref Security_permissions \"Security permissions\".\n * \t\t\t@arg ATTR_PERMISSION_NONE\n * \t\t\t@arg ATTR_PERMISSION_AUTHEN_READ\n * \t\t\t@arg ATTR_PERMISSION_AUTHOR_READ\n * \t\t\t@arg ATTR_PERMISSION_ENCRY_READ\n * \t\t\t@arg ATTR_PERMISSION_AUTHEN_WRITE\n * \t\t\t@arg ATTR_PERMISSION_AUTHOR_WRITE\n * \t\t\t@arg ATTR_PERMISSION_ENCRY_WRITE\n * @param accPermissions Access permissions for the added descriptor. See @ref Access_permissions \"Access permissions\".\n * \t\t\t@arg ATTR_NO_ACCESS\n * \t\t\t@arg ATTR_ACCESS_READ_ONLY\n * \t\t\t@arg ATTR_ACCESS_WRITE_REQ_ONLY\n * \t\t\t@arg ATTR_ACCESS_READ_WRITE\n * \t\t\t@arg ATTR_ACCESS_WRITE_WITHOUT_RESPONSE\n * \t\t\t@arg ATTR_ACCESS_SIGNED_WRITE_ALLOWED\n * @param gattEvtMask Bit mask that enables events that will be sent to the application by the GATT server\n * \t\t\t\t\t  on certain ATT requests. See @ref Gatt_Event_Mask \"Gatt Event Mask\".\n * @param encryKeySize The minimum encryption key size requirement for this attribute. Valid Range: 7 to 16.\n * @param isVariable If the attribute has a variable length value field (1) or not (0).\n * @param[out] descHandle Handle of the Characteristic Descriptor.\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gatt_add_char_desc(uint16_t serviceHandle,\n                                  uint16_t charHandle,\n                                  uint8_t descUuidType,\n                                  const uint8_t* uuid, \n                                  uint8_t descValueMaxLen,\n                                  uint8_t descValueLen,\n                                  const void* descValue, \n                                  uint8_t secPermissions,\n                                  uint8_t accPermissions,\n                                  uint8_t gattEvtMask,\n                                  uint8_t encryKeySize,\n                                  uint8_t isVariable,\n                                  uint16_t* descHandle);\n\n/**\n * @brief Update a characteristic value in a service.\n * @note If notifications (or indications) are enabled on that characteristic, a notification (or indication)\n *   \t will be sent to the client after sending this command to the BlueNRG. The command is queued into the\n *   \t BlueNRG command queue. If the buffer is full, because previous commands could not be still processed,\n *   \t the function will return @ref BLE_STATUS_INSUFFICIENT_RESOURCES. This will happen if notifications (or\n *   \t indications) are enabled and the application calls aci_gatt_update_char_value() at an higher rate\n *   \t than what is allowed by the link. Throughput on BLE link depends on connection interval and\n *   \t connection length parameters (decided by the master, see aci_l2cap_connection_parameter_update_request()\n *   \t for more info on how to suggest new connection parameters from a slave). If the application does not\n *   \t want to lose notifications because BlueNRG buffer becomes full, it has to retry again till the function\n *   \t returns @ref BLE_STATUS_SUCCESS or any other error code.\\n\n *   \t Example:\\n\n *   \t Here if BlueNRG buffer become full because BlueNRG was not able to send packets for a while, some\n *   \t notifications will be lost.\n *   \t @code\n *   \t tBleStatus Free_Fall_Notify(void)\n *\t\t {\n *\t\t \tuint8_t val;\n * \t\t\ttBleStatus ret;\n *\n *\t\t\tval = 0x01;\n *\t\t\tret = aci_gatt_update_char_value(accServHandle, freeFallCharHandle, 0, 1, &val);\n *\n *\t\t\tif (ret != BLE_STATUS_SUCCESS){\n *\t\t\t  PRINTF(\"Error while updating FFall characteristic.\\n\") ;\n *\t\t\t  return BLE_STATUS_ERROR ;\n *\t\t\t}\n *\t\t    return BLE_STATUS_SUCCESS;\n *\t\t }\n *\t\t @endcode\n *\t\t Here if BlueNRG buffer become full, the application try again to send the notification.\n *\t\t @code\n *       struct timer t;\n *       Timer_Set(&t, CLOCK_SECOND*10);\n *       while(aci_gatt_update_char_value(chatServHandle,TXCharHandle,0,len,array_val)==BLE_STATUS_INSUFFICIENT_RESOURCES){\n *         // Radio is busy (buffer full).\n *         if(Timer_Expired(&t))\n *           break;\n *       }\n *       @endcode\n *\n * @param servHandle Handle of the service to which characteristic belongs\n * @param charHandle Handle of the characteristic\n * @param charValOffset The offset from which the attribute value has to be updated. If this is set to 0,\n * \t\t\t\t\t\tand the attribute value is of variable length, then the length of the attribute will\n * \t\t\t\t\t\tbe set to the charValueLen. If the charValOffset is set to a value greater than 0,\n * \t\t\t\t\t\tthen the length of the attribute will be set to the maximum length as specified for\n * \t\t\t\t\t\tthe attribute while adding the characteristic.\n * @param charValueLen Length of the characteristic value in octets\n * @param[in] charValue Characteristic value\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gatt_update_char_value(uint16_t servHandle, \n\t\t\t\t      uint16_t charHandle,\n\t\t\t\t      uint8_t charValOffset,\n\t\t\t\t      uint8_t charValueLen,   \n\t\t\t\t      const void *charValue);\n/**\n * @brief Delete the specified characteristic from the service.\n * @param servHandle Handle of the service to which characteristic belongs\n * @param charHandle Handle of the characteristic to be deleted\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gatt_del_char(uint16_t servHandle, uint16_t charHandle);\n\n/**\n * @brief Delete the specified service from the GATT server database.\n * @param servHandle Handle of the service to be deleted\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gatt_del_service(uint16_t servHandle);\n\n/**\n * @brief Delete the Include definition from the service.\n * @param servHandle Handle of the service to which Include definition belongs\n * @param includeServHandle Handle of the Included definition to be deleted\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gatt_del_include_service(uint16_t servHandle, uint16_t includeServHandle);\n\n/**\n * @brief Perform an ATT MTU exchange procedure.\n * @note  When the ATT MTU exchange procedure is completed, a @ref EVT_BLUE_ATT_EXCHANGE_MTU_RESP\n * \t\t  event is generated. A @ref EVT_BLUE_GATT_PROCEDURE_COMPLETE event is also generated\n * \t\t  to indicate the end of the procedure.\n * @param conn_handle Connection handle for which the command is given.\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gatt_exchange_configuration(uint16_t conn_handle);\n\n/**\n * @brief Send a @a Find @a Information @a Request.\n * @note This command is used to obtain the mapping of attribute handles with their associated\n * \t\t types. The responses of the procedure are given through the\n * \t\t @ref EVT_BLUE_ATT_FIND_INFORMATION_RESP event. The end of the procedure is indicated by\n * \t\t a @ref EVT_BLUE_GATT_PROCEDURE_COMPLETE event.\n * @param conn_handle Connection handle for which the command is given\n * @param start_handle Starting handle of the range of attributes to be discovered on the server\n * @param end_handle Ending handle of the range of attributes to be discovered on the server\n * @return Value indicating success or error code.\n */\ntBleStatus aci_att_find_information_req(uint16_t conn_handle, uint16_t start_handle, uint16_t end_handle);\n\n/**\n * @brief Send a @a Find @a By @a Type @a Value @a Request\n * @note The Find By Type Value Request is used to obtain the handles of attributes that\n * \t\t have a given 16-bit UUID attribute type and a given attribute value.\n * \t\t The responses of the procedure are given through the @ref EVT_BLUE_ATT_FIND_BY_TYPE_VAL_RESP event.\n * \t\t The end of the procedure is indicated by a @ref EVT_BLUE_GATT_PROCEDURE_COMPLETE event.\n * @param conn_handle Connection handle for which the command is given.\n * @param start_handle \tFirst requested handle number\n * @param end_handle \tLast requested handle number\n * @param uuid\t\t\t2 octet UUID to find (little-endian)\n * @param attr_val_len  Length of attribute value (maximum value is ATT_MTU - 7).\n * @param attr_val\t\tAttribute value to find\n * @return Value indicating success or error code.\n */\ntBleStatus aci_att_find_by_type_value_req(uint16_t conn_handle, uint16_t start_handle, uint16_t end_handle,\n                                          uint8_t* uuid, uint8_t attr_val_len, uint8_t* attr_val);\n\n/**\n * @brief Send a @a Read @a By @a Type @a Request\n * @note  The Read By Type Request is used to obtain the values of attributes where the attribute type\n * \t\t  is known but the handle is not known.\n * \t\t  The responses of the procedure are given through the @ref EVT_BLUE_ATT_READ_BY_TYPE_RESP event.\n * \t\t  The end of the procedure is indicated by a @ref EVT_BLUE_GATT_PROCEDURE_COMPLETE event.\n * @param conn_handle Connection handle for which the command is given.\n * @param start_handle First requested handle number\n * @param end_handle Last requested handle number\n * @param uuid_type @arg @ref UUID_TYPE_16\n *         \t\t\t@arg @ref UUID_TYPE_128\n * @param uuid 2 or 16 octet UUID\n * @return Value indicating success or error code.\n */\ntBleStatus aci_att_read_by_type_req(uint16_t conn_handle, uint16_t start_handle, uint16_t end_handle,\n                                    uint8_t  uuid_type, uint8_t* uuid);\n\n/**\n * @brief Send a @a Read @a By @a Group @a Type @a Request\n * @note The Read By Group Type Request is used to obtain the values of grouping attributes where the attribute\n * \t\t type is known but the handle is not known. Grouping attributes are defined at GATT layer. The grouping\n * \t\t attribute types are: Primary Service, Secondary Service and Characteristic.\n * \t\t The responses of the procedure are given through the @ref EVT_BLUE_ATT_READ_BY_GROUP_TYPE_RESP event.\n * \t\t The end of the procedure is indicated by a @ref EVT_BLUE_GATT_PROCEDURE_COMPLETE.\n * @param conn_handle Connection handle for which the command is given.\n * @param start_handle First requested handle number\n * @param end_handle Last requested handle number\n * @param uuid_type @arg @ref UUID_TYPE_16\n *         \t\t\t@arg @ref UUID_TYPE_128\n * @param uuid 2 or 16 octet UUID\n * @return Value indicating success or error code.\n */\ntBleStatus aci_att_read_by_group_type_req(uint16_t conn_handle, uint16_t start_handle, uint16_t end_handle,\n                                    uint8_t  uuid_type, uint8_t* uuid);\n\n/**\n * @brief Send a @a Prepare @a Write @a Request\n * @note  The Prepare Write Request is used to request the server to prepare to write the value of an attribute.\n * \t\t The responses of the procedure are given through the @ref EVT_BLUE_ATT_PREPARE_WRITE_RESP event.\n * \t\t The end of the procedure is indicated by a @ref EVT_BLUE_GATT_PROCEDURE_COMPLETE.\n * @param conn_handle Connection handle for which the command is given.\n * @param attr_handle The handle of the attribute to be written\n * @param value_offset The offset of the first octet to be written\n * @param attr_val_len Length of attribute value (maximum value is ATT_MTU - 5).\n * @param attr_val \t   The value of the attribute to be written\n * @return Value indicating success or error code.\n */\ntBleStatus aci_att_prepare_write_req(uint16_t conn_handle, uint16_t attr_handle, uint16_t value_offset,\n                                    uint8_t  attr_val_len, uint8_t* attr_val);\n\n/**\n * @brief Send an @a Execute @a Write @a Request\n * @note The Execute Write Request is used to request the server to write or cancel the write of all the\n *  \t prepared values currently held in the prepare queue from this client.\n *  \t The result of the procedure is given through the @ref EVT_BLUE_ATT_EXEC_WRITE_RESP event.\n *  \t The end of the procedure is indicated by a @ref EVT_BLUE_GATT_PROCEDURE_COMPLETE event.\n * @param conn_handle Connection handle for which the command is given.\n * @param execute @arg 0x00  Cancel all prepared writes\n * \t\t\t\t  @arg 0x01  Immediately write all pending prepared values.\n * @return Value indicating success or error code.\n */\ntBleStatus aci_att_execute_write_req(uint16_t conn_handle, uint8_t execute);\n\n/**\n * @brief This command will start the GATT client procedure to discover all primary services on the server.\n * @note  The responses of the procedure are given through the @ref EVT_BLUE_ATT_READ_BY_GROUP_TYPE_RESP event.\n * \t\t  The end of the procedure is indicated by a @ref EVT_BLUE_GATT_PROCEDURE_COMPLETE event.\n * @param conn_handle Connection handle for which the command is given.\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gatt_disc_all_prim_services(uint16_t conn_handle);\n\n/**\n * @brief Start the procedure to discover the primary services of the specified UUID on the server.\n * @note The responses of the procedure are given through the @ref EVT_BLUE_ATT_FIND_BY_TYPE_VAL_RESP event.\n *  \t The end of the procedure is indicated by a @ref EVT_BLUE_GATT_PROCEDURE_COMPLETE event.\n * @param conn_handle Connection handle for which the command is given.\n * @param uuid_type @arg @ref UUID_TYPE_16\n *         \t\t\t@arg @ref UUID_TYPE_128\n * @param uuid 2 or 16 octet UUID\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gatt_disc_prim_service_by_uuid(uint16_t conn_handle, uint8_t uuid_type, uint8_t* uuid);\n\n/**\n * @brief Start the procedure to find all included services.\n * @note The responses of the procedure are given through the @ref EVT_BLUE_ATT_READ_BY_TYPE_RESP event.\n * \t\t The end of the procedure is indicated by a @ref EVT_BLUE_GATT_PROCEDURE_COMPLETE event.\n * @param conn_handle Connection handle for which the command is given.\n * @param start_handle Start handle of the service\n * @param end_handle End handle of the service\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gatt_find_included_services(uint16_t conn_handle, uint16_t start_handle,\n\t\t\t\t\t   uint16_t end_handle);\n\n/**\n * @brief Start the procedure to discover all the characteristics of a given service.\n * @note When the procedure is completed, a @ref EVT_BLUE_GATT_PROCEDURE_COMPLETE event is generated.\n * \t\t Before procedure completion the response packets are given through @ref EVT_BLUE_ATT_READ_BY_TYPE_RESP event.\n * @param conn_handle Connection handle for which the command is given\n * @param start_attr_handle Start attribute handle of the service\n * @param end_attr_handle End attribute handle of the service\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gatt_disc_all_charac_of_serv(uint16_t conn_handle, uint16_t start_attr_handle,\n\t\t\t\t\t    uint16_t end_attr_handle);\n\n/**\n * @brief Start the procedure to discover all the characteristics specified by a UUID.\n * @note  When the procedure is completed, a @ref EVT_BLUE_GATT_PROCEDURE_COMPLETE event is generated.\n *  \t  Before procedure completion the response packets are given through\n *        @ref EVT_BLUE_GATT_DISC_READ_CHAR_BY_UUID_RESP event.\n * @param conn_handle Connection handle for which the command is given\n * @param start_handle \tStart attribute handle of the service\n * @param end_handle \tEnd attribute handle of the service\n * @param uuid_type @arg @ref UUID_TYPE_16\n *         \t\t\t@arg @ref UUID_TYPE_128\n * @param uuid 2 or 16 octet UUID\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gatt_disc_charac_by_uuid(uint16_t conn_handle, uint16_t start_handle,\n\t\t\t\t                     uint16_t end_handle, uint8_t uuid_type, const uint8_t* uuid);\n\n/**\n * @brief Start the procedure to discover all characteristic descriptors on the server.\n * @note When the procedure is completed, a @ref EVT_BLUE_GATT_PROCEDURE_COMPLETE event is generated.\n * \t\t Before procedure completion the response packets are given through @ref EVT_BLUE_ATT_FIND_INFORMATION_RESP event.\n * @param conn_handle Connection handle for which the command is given.\n * @param char_val_handle Starting handle of the characteristic\n * @param char_end_handle End handle of the characteristic\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gatt_disc_all_charac_descriptors(uint16_t conn_handle, uint16_t char_val_handle,\n\t\t\t\t\t\tuint16_t char_end_handle);\n\n/**\n * @brief Start the procedure to read the attribute value.\n * @note  When the procedure is completed, a @ref EVT_BLUE_GATT_PROCEDURE_COMPLETE event is generated.\n * \t\t  Before procedure completion the response packet is given through @ref EVT_BLUE_ATT_READ_RESP event.\n * @param conn_handle Connection handle for which the command is given\n * @param attr_handle Handle of the characteristic to be read\n * @return Value indicating success or error code.\\n\n * \t\t It can be @ref BLE_STATUS_NOT_ALLOWED in the following cases:\\n\n *\t\t- If the exchange has already taken place\\n\n *\t\t- If GATT is expecting response for previous request\\n\n *\t\t- Already a request is in the queue to be sent\\n\n *\t\t- Channel not open\\n\n *\t\t- Already one GATT procedure is started\n */\ntBleStatus aci_gatt_read_charac_val(uint16_t conn_handle, uint16_t attr_handle);\n\n/**\n * @brief Start the procedure to read all the characteristics specified by the UUID.\n * @note When the procedure is completed, a @ref EVT_BLUE_GATT_PROCEDURE_COMPLETE event is generated.\n * \t\t Before procedure completion the response packets are given through\n * \t\t @ref EVT_BLUE_GATT_DISC_READ_CHAR_BY_UUID_RESP event.\n * @param conn_handle Connection handle for which the command is given\n * @param start_handle Starting handle of the range to be searched\n * @param end_handle End handle of the range to be searched\n * @param uuid_type @arg @ref UUID_TYPE_16\n *         \t\t\t@arg @ref UUID_TYPE_128\n * @param uuid 2 or 16 octet UUID\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gatt_read_using_charac_uuid(uint16_t conn_handle, uint16_t start_handle, uint16_t end_handle,\n                                    uint8_t  uuid_type, uint8_t* uuid);\n\n/**\n * @brief Start the procedure to read a long characteristic value.\n * @note When the procedure is completed, a @ref EVT_BLUE_GATT_PROCEDURE_COMPLETE event is generated.\n * \t\t Before procedure completion the response packets are given through @ref EVT_BLUE_ATT_READ_BLOB_RESP event.\n * @param conn_handle Connection handle for which the command is given\n * @param attr_handle Handle of the characteristic to be read\n * @param val_offset Offset from which the value needs to be read\n * @return Value indicating success or error code.\\n\n * \t\t It can be @ref BLE_STATUS_NOT_ALLOWED in the following cases:\\n\n *\t\t- If the exchange has already taken place\\n\n *\t\t- If GATT is expecting response for previous request\\n\n *\t\t- Already a request is in the queue to be sent\\n\n *\t\t- Channel not open\\n\n *\t\t- Already one GATT procedure is started\n */\ntBleStatus aci_gatt_read_long_charac_val(uint16_t conn_handle, uint16_t attr_handle,\n\t\t\t\t\t uint16_t val_offset);\n\n/**\n * @brief Start a procedure to read multiple characteristic values from a server.\n * @note This sub-procedure is used to read multiple Characteristic Values from a server when the\n *  \t client knows the Characteristic Value Handles.\n *  \t When the procedure is completed, a @ref EVT_BLUE_GATT_PROCEDURE_COMPLETE event is generated.\n *  \t Before procedure completion the response packets are given through\n *  \t @ref EVT_BLUE_ATT_READ_MULTIPLE_RESP event.\n * @param conn_handle Connection handle for which the command is given\n * @param num_handles The number of handles for which the value has to be read\n * @param set_of_handles The handles for which the attribute value has to be read\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gatt_read_multiple_charac_val(uint16_t conn_handle, uint8_t num_handles, \n                                             uint8_t* set_of_handles);\n\n/**\n * @brief Start the procedure to write a characteristic value.\n * @note When the procedure is completed, a @ref EVT_BLUE_GATT_PROCEDURE_COMPLETE event is generated.\n * @param conn_handle Connection handle for which the command is given\n * @param attr_handle Handle of the characteristic to be written\n * @param value_len Length of the value to be written\n * @param[in] attr_value Value to be written\n * @return Value indicating success or error code.\\n\n * \t\t It can be @ref BLE_STATUS_NOT_ALLOWED in the following cases:\\n\n *\t\t- If the exchange has already taken place\\n\n *\t\t- If GATT is expecting response for previous request\\n\n *\t\t- Already a request is in the queue to be sent\\n\n *\t\t- Channel not open\\n\n *\t\t- Already one GATT procedure is started\n */\ntBleStatus aci_gatt_write_charac_value(uint16_t conn_handle, uint16_t attr_handle,\n\t\t\t\t       uint8_t value_len, uint8_t *attr_value);\n\n/**\n * @brief Start the procedure to write a long characteristic value.\n * @note When the procedure is completed, a @ref EVT_BLUE_GATT_PROCEDURE_COMPLETE event is generated.\n * \t\t During the procedure, @ref EVT_BLUE_ATT_PREPARE_WRITE_RESP and @ref EVT_BLUE_ATT_EXEC_WRITE_RESP\n * \t\t events are raised.\n * @param conn_handle Connection handle for which the command is given\n * @param attr_handle Handle of the attribute to be written\n * @param val_offset Offset at which the attribute has to be written\n * @param val_len Length of the value to be written\n * @param attr_val Value to be written\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gatt_write_long_charac_val(uint16_t conn_handle, uint16_t attr_handle,\n                                          uint16_t val_offset, uint8_t val_len, const uint8_t* attr_val);\n\n/**\n * @brief Start the procedure to write a characteristic reliably.\n * @note When the procedure is completed, a  @ref EVT_BLUE_GATT_PROCEDURE_COMPLETE event is generated.\n *  \t During the procedure, @ref EVT_BLUE_ATT_PREPARE_WRITE_RESP and @ref EVT_BLUE_ATT_EXEC_WRITE_RESP\n * \t\t events are raised.\n * @param conn_handle Connection handle for which the command is given\n * @param attr_handle Handle of the attribute to be written\n * @param val_offset Offset at which the attribute has to be written\n * @param val_len Length of the value to be written\n * @param attr_val Value to be written\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gatt_write_charac_reliable(uint16_t conn_handle, uint16_t attr_handle,\n                                          uint16_t val_offset, uint8_t val_len, uint8_t* attr_val);\n\n/**\n * @brief Start the procedure to write a long characteristic descriptor.\n * @note When the procedure is completed, a @ref EVT_BLUE_GATT_PROCEDURE_COMPLETE event is generated.\n * \t\t During the procedure, @ref EVT_BLUE_ATT_PREPARE_WRITE_RESP and @ref EVT_BLUE_ATT_EXEC_WRITE_RESP\n * \t\t events are raised.\n * @param conn_handle Connection handle for which the command is given\n * @param attr_handle Handle of the attribute to be written\n * @param val_offset Offset at which the attribute has to be written\n * @param val_len Length of the value to be written\n * @param attr_val Value to be written\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gatt_write_long_charac_desc(uint16_t conn_handle, uint16_t attr_handle,\n                                          uint16_t val_offset, uint8_t val_len, uint8_t* attr_val);\n\n/**\n * @brief Start the procedure to read a long characteristic value.\n * @note  When the procedure is completed, a @ref EVT_BLUE_GATT_PROCEDURE_COMPLETE event is generated.\n * \t\t  Before procedure completion the response packets are given through @ref EVT_BLUE_ATT_READ_BLOB_RESP\n * \t\t  event.\n * @param conn_handle Connection handle for which the command is given\n * @param attr_handle Handle of the characteristic descriptor\n * @param val_offset Offset from which the value needs to be read\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gatt_read_long_charac_desc(uint16_t conn_handle, uint16_t attr_handle,\n                                          uint16_t val_offset);\n\n/**\n * @brief Start the procedure to write a characteristic descriptor.\n * @note When the procedure is completed, a @ref EVT_BLUE_GATT_PROCEDURE_COMPLETE event is generated.\n * @param conn_handle Connection handle for which the command is given\n * @param attr_handle Handle of the attribute to be written\n * @param value_len Length of the value to be written\n * @param[in] attr_value Value to be written\n * @return Value indicating success or error code.\\n\n * \t\t It can be @ref BLE_STATUS_NOT_ALLOWED in the following cases:\\n\n *\t\t- If the exchange has already taken place\\n\n *\t\t- If GATT is expecting response for previous request\\n\n *\t\t- Already a request is in the queue to be sent\\n\n *\t\t- Channel not open\\n\n *\t\t- Already one GATT procedure is started\n */\ntBleStatus aci_gatt_write_charac_descriptor(uint16_t conn_handle, uint16_t attr_handle,\n\t\t\t\t\t   uint8_t value_len, uint8_t *attr_value);\n\n/**\n * @brief Start the procedure to read the descriptor specified.\n * @note When the procedure is completed, a @ref EVT_BLUE_GATT_PROCEDURE_COMPLETE event is generated.\n * \t\t Before procedure completion the response packet is given through @ref EVT_BLUE_ATT_READ_RESP event.\n * @param conn_handle Connection handle for which the command is given\n * @param attr_handle Handle of the descriptor to be read\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gatt_read_charac_desc(uint16_t conn_handle, uint16_t attr_handle);\n\n/**\n * @brief Start the procedure to write a characteristic value without waiting for any response from the server.\n * @note No events are generated after this command is executed.\n * @param conn_handle Connection handle for which the command is given\n * @param attr_handle Handle of the attribute to be written\n * @param val_len Length of the value to be written (up to ATT_MTU - 3)\n * @param[in] attr_val Value to be written\n * @return Value indicating success or error code.\\n\n * \t\t It can be @ref BLE_STATUS_NOT_ALLOWED in the following cases:\\n\n *\t\t- If the exchange has already taken place\\n\n *\t\t- If GATT is expecting response for previous request\\n\n *\t\t- Already a request is in the queue to be sent\\n\n *\t\t- Channel not open\\n\n *\t\t- Already one GATT procedure is started\n */\ntBleStatus aci_gatt_write_without_response(uint16_t conn_handle, uint16_t attr_handle,\n                                              uint8_t val_len, const uint8_t* attr_val);\n\n/**\n * @brief Start a signed write without response from the server.\n * @note  The procedure i used to write a characteristic value with an authentication signature without waiting\n * \t\t  for any response from the server. It cannot be used when the link is encrypted.\n * @param conn_handle Connection handle for which the command is given\n * @param attr_handle Handle of the attribute to be written\n * @param val_len Length of the value to be written (up to ATT_MTU - 13).\n * @param attr_val Value to be written\n * @return Value indicating success or error code\n */\ntBleStatus aci_gatt_signed_write_without_resp(uint16_t conn_handle, uint16_t attr_handle,\n                                              uint8_t val_len, uint8_t* attr_val);\n\n/**\n * @brief Confirm an indication\n * @note  This command has to be sent when the application receives the event @ref EVT_BLUE_GATT_INDICATION.\n * @param conn_handle Connection handle for which the command is given.\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gatt_confirm_indication(uint16_t conn_handle);\n\n/**\n * @brief Allow or reject a write request from a client.\n * @note This command has to be sent by the application when it receives the @ref EVT_BLUE_GATT_WRITE_PERMIT_REQ.\n *  \t If the write is allowed, then the status and error code has to be set to 0. If the write is not allowed,\n *  \t then the status has to be set to 1 and the error code has to be set to the error code that has to be\n *  \t passed to the client.\n * @param conn_handle Connection handle for which the command is given\n * @param attr_handle Handle of the attribute that was passed in the event @ref EVT_BLUE_GATT_WRITE_PERMIT_REQ.\n * @param write_status 0x00: The value can be written to the attribute specified by attr_handle\\n\n * \t\t\t\t\t   0x01: The value cannot be written to the attribute specified by the attr_handle.\n * @param err_code  The error code that has to be passed to the client in case the write has to be rejected.\n * @param att_val_len Length of the value to be written as passed in the event @ref EVT_BLUE_GATT_WRITE_PERMIT_REQ.\n * @param att_val Value as passed in the event @ref EVT_BLUE_GATT_WRITE_PERMIT_REQ.\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gatt_write_response(uint16_t conn_handle,\n                                   uint16_t attr_handle,\n                                   uint8_t write_status,\n                                   uint8_t err_code,\n                                   uint8_t att_val_len,\n                                   uint8_t *att_val);\n\n/**\n * @brief Allow the GATT server to send a response to a read request from a client.\n * @note The application has to send this command when it receives the @ref EVT_BLUE_GATT_READ_PERMIT_REQ\n * \t\t or @ref EVT_BLUE_GATT_READ_MULTI_PERMIT_REQ. This command indicates to the stack that the response\n * \t\t can be sent to the client. So if the application wishes to update any of the attributes before\n * \t\t they are read by the client, it has to update the characteristic values using the aci_gatt_update_char_value\n * \t\t and then give this command. The application should perform the required operations within 30 seconds,\n * \t\t otherwise the GATT procedure will go to timeout.\n * @param conn_handle Connection handle for which the command is given.\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gatt_allow_read(uint16_t conn_handle);\n\n/**\n * @brief Set the security permission for the attribute handle specified.\n * @note  Currently the setting of security permission is allowed only for client configuration descriptor.\n * @param service_handle Handle of the service which contains the attribute whose security\n * \t\t\t\t\t\t permission has to be modified.\n * @param attr_handle\tHandle of the attribute whose security permission has to be modified.\n * @param security_permission Security permissions for the descriptor. See @ref Security_permissions \"Security permissions\".\n * \t\t\t@arg ATTR_PERMISSION_NONE\n * \t\t\t@arg ATTR_PERMISSION_AUTHEN_READ\n * \t\t\t@arg ATTR_PERMISSION_AUTHOR_READ\n * \t\t\t@arg ATTR_PERMISSION_ENCRY_READ\n * \t\t\t@arg ATTR_PERMISSION_AUTHEN_WRITE\n * \t\t\t@arg ATTR_PERMISSION_AUTHOR_WRITE\n * \t\t\t@arg ATTR_PERMISSION_ENCRY_WRITE\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gatt_set_security_permission(uint16_t service_handle, uint16_t attr_handle,\n                                            uint8_t security_permission);\n\n/**\n * @brief This command sets the value of the descriptor specified by charDescHandle.\n * @param servHandle Handle of the service which contains the descriptor.\n * @param charHandle Handle of the characteristic which contains the descriptor.\n * @param charDescHandle Handle of the descriptor whose value has to be set.\n * @param charDescValOffset Offset from which the descriptor value has to be updated.\n * @param charDescValueLen Length of the descriptor value\n * @param[in] charDescValue descriptor value\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gatt_set_desc_value(uint16_t servHandle,\n\t\t\t\t   uint16_t charHandle,\n\t\t\t\t   uint16_t charDescHandle,\n\t\t\t\t   uint16_t charDescValOffset,\n\t\t\t\t   uint8_t charDescValueLen,\n\t\t\t\t   const void *charDescValue);\n\n/**\n * @brief Reads the value of the attribute handle specified from the local GATT database.\n * @param attr_handle Handle of the attribute to read\n * @param data_len Length of the data buffer.\n * @param[out] data_len_out_p Length of the read attribute.\n * @param[out] data Pointer to the buffer that will contain the read value.\n * \t\t\t\tThe buffer will be filled with the attribute value.\n * \t\t\t\tThe length will be the minimum between the provided data_len and the actual length of the\n * \t\t\t\tattribute (in data_len_out_p).\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gatt_read_handle_value(uint16_t attr_handle, uint16_t data_len, uint16_t *data_len_out_p, uint8_t *data);\n\n/**\n * @brief Reads the value of the attribute handle specified from the local GATT database, starting from a given offset.\n * @param attr_handle Handle of the attribute to read\n * @param offset      Offset from which the value needs to be read\n * @param data_len    Length of the data buffer.\n * @param[out] data_len_out_p Length of the read attribute.\n * @param[out] data Pointer to the buffer that will contain the read value.\n * \t\t\t\tThe buffer will be filled with the attribute value.\n * \t\t\t\tThe length will be the minimum between the provided data_len and the actual length of the\n * \t\t\t\tattribute (in data_len_out_p).\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gatt_read_handle_value_offset_IDB05A1(uint16_t attr_handle, uint8_t offset, uint16_t data_len, uint16_t *data_len_out_p, uint8_t *data);\n\n/**\n * @brief Update the value of a characteristic and sends notifications or indications.\n * @note This command is a more flexible version of ACI_GATT_UPDATE_CHAR_VALUE to support update of long attribute\n *  \t up to 512 bytes and indicate selectively the generation of indications and notifications.\n * @param service_handle Handle of the service to which the characteristic belongs.\n * @param char_handle Handle of the characteristic\n * @param update_type Bitmask that controls generation of notifications and indications. It can be a combination\n * \t\t\t\t\t\t@arg @ref NOTIFICATION (0x01): send notification, if enabled.\n * \t\t\t\t\t\t@arg @ref INDICATION (0x02): send indication, if enabled.\n * \t\t\t\t\t  If set to 0 no notifications or indications are sent.\n * @param char_length Total length of the characteristic value. In case of a variable size characteristic,\n * \t\t\t\t\t  this field specifies the new length of the characteristic value after the update;\n * \t\t\t\t\t  in case of fixed length characteristic this field is ignored.\n * @param value_offset The offset from which the attribute value has to be updated\n * @param value_length Length of the value to be updated\n * @param[out] value   Updated characteristic value\n * @return Value indicating success or error code.\n */\ntBleStatus aci_gatt_update_char_value_ext_IDB05A1(uint16_t service_handle, uint16_t char_handle,\n                                                  uint8_t update_type, uint16_t char_length,\n                                                  uint16_t value_offset, uint8_t value_length,\n                                                  const uint8_t* value);\n\ntBleStatus aci_gatt_set_event_mask(uint32_t event_mask);\n\n/**\n * @}\n */\n\n\n/**\n * @defgroup GATT_Events GATT events\n * The structures are the data field of @ref evt_blue_aci.\n * @{\n */\n\n/**\n * This event (if enabled, see @ref Gatt_Event_Mask \"Gatt Event Mask\") is raised to the application\n * by the GATT server when a client modifies any attribute on the server, as consequence of one of\n * the following GATT procedures:\n * @li write without response\n * @li signed write without response\n * @li write characteristic value\n * @li write long characteristic value\n * @li reliable write.\n * See @ref _evt_gatt_attr_modified_IDB04A1 or @ref _evt_gatt_attr_modified__IDB05A1.\n */\n#define EVT_BLUE_GATT_ATTRIBUTE_MODIFIED          (0x0C01)\n\ntypedef __packed struct _evt_gatt_attr_modified_IDB05A1{\n  uint16_t conn_handle; /**< The connection handle which modified the attribute. */\n  uint16_t attr_handle; /**< Handle of the attribute that was modified. */\n  uint8_t  data_length; /**< The length of the data */\n  uint16_t  offset; /**< Offset from which the write has been performed by the peer device */\n  uint8_t  att_data[VARIABLE_SIZE]; /**< The new value (length is data_length) */\n} PACKED evt_gatt_attr_modified_IDB05A1;\n\ntypedef __packed struct _evt_gatt_attr_modified_IDB04A1{\n  uint16_t conn_handle; /**< The connection handle which modified the attribute. */\n  uint16_t attr_handle; /**< Handle of the attribute that was modified. */\n  uint8_t  data_length; /**< The length of the data */\n  uint8_t  att_data[VARIABLE_SIZE]; /**< The new value (length is data_length) */\n} PACKED evt_gatt_attr_modified_IDB04A1;\n\n/**\n * This event is generated by the client/server to the application on a GATT timeout (30 seconds).\n * See @ref _evt_gatt_procedure_timeout.\n */\n#define EVT_BLUE_GATT_PROCEDURE_TIMEOUT           (0x0C02)\ntypedef __packed struct _evt_gatt_procedure_timeout{\n\tuint16_t conn_handle; /**< The connection handle on which the GATT procedure has timed out */\n} PACKED evt_gatt_procedure_timeout;\n\n/**\n * This event is generated in response to an Exchange MTU request. See aci_gatt_exchange_configuration().\n * See @ref _evt_att_exchange_mtu_resp.\n */\n#define EVT_BLUE_ATT_EXCHANGE_MTU_RESP\t\t  (0x0C03)\ntypedef __packed struct _evt_att_exchange_mtu_resp{\n  uint16_t conn_handle; /**< The connection handle related to the response */\n  uint8_t  event_data_length; /**< Length of following data (always 1). */\n  uint16_t server_rx_mtu; /**< Attribute server receive MTU size */\n} PACKED evt_att_exchange_mtu_resp;\n\n/**\n * This event is generated in response to a @a Find @a Information @a Request. See aci_att_find_information_req() and\n * Find Information Response in Bluetooth Core v4.0 spec. See @ref _evt_att_find_information_resp.\n */\n#define EVT_BLUE_ATT_FIND_INFORMATION_RESP\t  (0x0C04)\ntypedef __packed struct _evt_att_find_information_resp{\n  uint16_t conn_handle;\t\t\t/**< The connection handle related to the response */\n  uint8_t  event_data_length;\t/**< Length of following data. */\n  uint8_t  format;\t\t\t\t/**< The format of the handle_uuid_pair. @arg 1: 16-bit UUIDs @arg 2: 128-bit UUIDs */\n  /**\n   *  A sequence of handle-uuid pairs.\\n\n   *  @li if format=1, each pair is:\\n\n   *  [2 octets for handle, 2 octets for UUIDs] \\n\n   *  @li if format=2, each pair is:\\n\n   *  [2 octets for handle, 16 octets for UUIDs]\n   */\n  uint8_t  handle_uuid_pair[VARIABLE_SIZE];\n} PACKED evt_att_find_information_resp;\n\n/**\n * This event is generated in response to a @a Find @a By @a Type @a Value @a Request. See\n * Find By Type Value Response in Bluetooth Core v4.0 spec. See @ref _evt_att_find_by_type_val_resp.\n */\n#define EVT_BLUE_ATT_FIND_BY_TYPE_VAL_RESP\t  (0x0C05)\ntypedef __packed struct _evt_att_find_by_type_val_resp{\n  uint16_t conn_handle;\t\t\t\t/**< The connection handle related to the response */\n  uint8_t  event_data_length;\t\t/**< Length of following data. */\n  /**\n   *  Handles Information List as defined in Bluetooth Core v4.0 spec.\n   *  A sequence of handle pairs: [2 octets for Found Attribute Handle, 2 octets for Group End Handle]\n   */\n  uint8_t  handles_info_list[VARIABLE_SIZE];\n} PACKED evt_att_find_by_type_val_resp;\n\n/**\n * This event is generated in response to a @a Read @a By @a Type @a Request. See aci_gatt_find_included_services() and\n * aci_gatt_disc_all_charac_of_serv().\n * For more info see Read By Type Response in Bluetooth Core v4.0 spec. See @ref _evt_att_read_by_type_resp.\n */\n#define EVT_BLUE_ATT_READ_BY_TYPE_RESP\t\t  (0x0C06)\ntypedef __packed struct _evt_att_read_by_type_resp{\n  uint16_t conn_handle;\t\t\t\t/**< The connection handle related to the response */\n  uint8_t  event_data_length;\t\t/**< Length of following data. */\n  uint8_t  handle_value_pair_length; /**< The size of each attribute handle-value pair */\n  /**\n   *  Attribute Data List as defined in Bluetooth Core v4.0 spec.\n   *  A sequence of handle-value pairs: [2 octets for Attribute Handle, (handle_value_pair_length - 2 octets) for Attribute Value]\n   */\n  uint8_t  handle_value_pair[VARIABLE_SIZE];\n} PACKED evt_att_read_by_type_resp;\n\n/**\n * This event is generated in response to a @a Read @a Request. See aci_gatt_read_charac_val().\n * For more info see Read Response in Bluetooth Core v4.0 spec. See @ref _evt_att_read_resp.\n */\n#define EVT_BLUE_ATT_READ_RESP\t\t\t  (0x0C07)\ntypedef __packed struct _evt_att_read_resp{\n  uint16_t conn_handle;\t\t\t\t/**< The connection handle related to the response. */\n  uint8_t  event_data_length;\t\t/**< Length of following data. */\n  uint8_t  attribute_value[VARIABLE_SIZE]; /**< The value of the attribute. */\n} PACKED evt_att_read_resp;\n\n/**\n * This event is generated in response to a @a Read @a Blob @a Request. See aci_gatt_read_long_charac_val().\n * For more info see Read Blob Response in Bluetooth Core v4.0 spec. See @ref _evt_att_read_blob_resp.\n */\n#define EVT_BLUE_ATT_READ_BLOB_RESP\t\t  (0x0C08)\ntypedef __packed struct _evt_att_read_blob_resp{\n  uint16_t conn_handle;\t\t\t\t/**< The connection handle related to the response. */\n  uint8_t  event_data_length;\t\t/**< Length of following data. */\n  uint8_t  part_attribute_value[VARIABLE_SIZE]; /**< Part of the attribute value. */\n} PACKED evt_att_read_blob_resp;\n\n/**\n * This event is generated in response to a @a Read @a Multiple @a Request.\n * For more info see Read Multiple Response in Bluetooth Core v4.0 spec. See @ref _evt_att_read_mult_resp.\n */\n#define EVT_BLUE_ATT_READ_MULTIPLE_RESP\t\t  (0x0C09)\ntypedef __packed struct _evt_att_read_mult_resp{\n  uint16_t conn_handle;\t\t\t\t/**< The connection handle related to the response. */\n  uint8_t  event_data_length;\t\t/**< Length of following data. */\n  uint8_t  set_of_values[VARIABLE_SIZE]; /**< A set of two or more values.*/\n} PACKED evt_att_read_mult_resp;\n\n/**\n * This event is generated in response to a @a Read @a By @a Group @a Type @a Request. See aci_gatt_disc_all_prim_services().\n * For more info see Read By Group type Response in Bluetooth Core v4.0 spec. See @ref _evt_att_read_by_group_resp.\n */\n#define EVT_BLUE_ATT_READ_BY_GROUP_TYPE_RESP           (0x0C0A)\ntypedef __packed struct _evt_att_read_by_group_resp{\n  uint16_t conn_handle;\t\t\t\t/**< The connection handle related to the response. */\n  uint8_t  event_data_length;\t\t/**< Length of following data. */\n  uint8_t  attribute_data_length;   /**< The size of each Attribute Data. */\n  /**\n   *  A list of Attribute Data where the attribute data is composed by:\n   *  @li 2 octets for Attribute Handle\n   *  @li 2 octets for End Group Handle\n   *  @li (attribute_data_length - 4) octets for Attribute Value\n   */\n  uint8_t  attribute_data_list[VARIABLE_SIZE];\n} PACKED evt_att_read_by_group_resp;\n\n/**\n * This event is generated in response to a @a Prepare @a Write @a Request.\n * For more info see Prepare Write Response in Bluetooth Core v4.0 spec. See @ref _evt_att_prepare_write_resp.\n */\n#define EVT_BLUE_ATT_PREPARE_WRITE_RESP\t\t  (0x0C0C)\ntypedef __packed struct _evt_att_prepare_write_resp{\n  uint16_t conn_handle;\t\t\t\t/**< The connection handle related to the response. */\n  uint8_t  event_data_length;\t\t/**< Length of following data. */\n  uint16_t  attribute_handle;\t\t/**< The handle of the attribute to be written. */\n  uint16_t  offset;\t\t\t\t\t/**< The offset of the first octet to be written. */\n  uint8_t  part_attr_value[VARIABLE_SIZE]; /**< The value of the attribute to be written. */\n} PACKED evt_att_prepare_write_resp;\n\n/**\n * This event is generated in response to an @a Execute @a Write @a Request.\n * For more info see Execute Write Response in Bluetooth Core v4.0 spec. See @ref _evt_att_exec_write_resp.\n */\n#define EVT_BLUE_ATT_EXEC_WRITE_RESP\t\t  (0x0C0D)\ntypedef __packed struct _evt_att_exec_write_resp{\n  uint16_t conn_handle;\t\t\t/**< The connection handle related to the response. */\n  uint8_t  event_data_length; \t/**< Always 0. */\n} PACKED evt_att_exec_write_resp;\n\n/**\n * This event is generated when an indication is received from the server.\n * For more info see Handle Value Indication in Bluetooth Core v4.0 spec. See @ref _evt_gatt_indication.\n */\n#define EVT_BLUE_GATT_INDICATION\t\t  (0x0C0E)\ntypedef __packed struct _evt_gatt_indication{\n  uint16_t conn_handle;\t\t  \t\t\t/**< The connection handle related to the event. */\n  uint8_t  event_data_length; \t\t\t/**< Length of following data. */\n  uint16_t attr_handle;\t\t\t\t\t/**< The handle of the attribute. */\n  uint8_t  attr_value[VARIABLE_SIZE]; \t/**< The current value of the attribute. */\n} PACKED evt_gatt_indication;\n\n/**\n * This event is generated when a notification is received from the server.\n * For more info see Handle Value Notification in Bluetooth Core v4.0 spec. See @ref _evt_gatt_notification.\n */\n#define EVT_BLUE_GATT_NOTIFICATION\t\t  (0x0C0F)\ntypedef __packed struct _evt_gatt_notification{\n  uint16_t conn_handle;\t\t\t\t\t/**< The connection handle related to the event. */\n  uint8_t  event_data_length; \t\t\t/**< Length of following data. */\n  uint16_t attr_handle;\t\t\t\t\t/**< The handle of the attribute. */\n  uint8_t  attr_value[VARIABLE_SIZE]; \t/**< The current value of the attribute. */\n} PACKED evt_gatt_attr_notification;\n\n/**\n * This event is generated when a GATT client procedure completes either with error or successfully.\n * See @ref _evt_gatt_procedure_complete.\n */\n#define EVT_BLUE_GATT_PROCEDURE_COMPLETE          (0x0C10)\ntypedef __packed struct _evt_gatt_procedure_complete{\n  uint16_t conn_handle; /**< The connection handle on which the GATT procedure has completed */\n  uint8_t  data_length; /**< Length of error_code field (always 1). */\n  /**\n   * Indicates whether the procedure completed with error (BLE_STATUS_FAILED) or was successful (BLE_STATUS_SUCCESS).\n   */\n  uint8_t  error_code;\n} PACKED evt_gatt_procedure_complete;\n\n/**\n * This event is generated when an Error Response is received from the server. The error response can be given\n * by the server at the end of one of the GATT discovery procedures. This does not mean that the procedure ended\n * with an error, but this error event is part of the procedure itself. See @ref _evt_gatt_error_resp.\n */\n#define EVT_BLUE_GATT_ERROR_RESP                  (0x0C11)\ntypedef __packed struct _evt_gatt_error_resp{\n  uint16_t conn_handle;\t\t\t/**< The connection handle related to the event. */\n  uint8_t  event_data_length;\t/**< Length of following data. */\n  uint8_t  req_opcode;\t\t\t/**< The request that generated this error response. */\n  uint16_t attr_handle;\t\t\t/**< The attribute handle that generated this error response. */\n  uint8_t  error_code;\t\t\t/**< The reason why the request has generated an error response. See Error Response in Bluetooth Core v4.0 spec.  */\n} PACKED evt_gatt_error_resp;\n\n/**\n * This event can be generated during a \"Discover Characteristics By UUID\" procedure or a \"Read using\n * Characteristic UUID\" procedure.\n * The attribute value will be a service declaration as defined in Bluetooth Core v4.0 spec (vol.3, Part G, ch. 3.3.1),\n * when a \"Discover Characteristics By UUID\" has been started. It will be the value of the Characteristic if a\n * \"Read using Characteristic UUID\" has been performed. See @ref _evt_gatt_disc_read_char_by_uuid_resp.\n */\n#define EVT_BLUE_GATT_DISC_READ_CHAR_BY_UUID_RESP (0x0C12)\ntypedef __packed struct _evt_gatt_disc_read_char_by_uuid_resp{\n  uint16_t conn_handle;\t\t\t\t\t\t/**< The connection handle related to the event. */\n  uint8_t  event_data_length;\t\t\t\t/**< Length of following data. */\n  uint16_t attr_handle;\t\t\t\t\t\t/**< The handle of the attribute. */\n  /**\n   * The attribute value will be a service declaration as defined in Bluetooth Core v4.0 spec (vol.3, Part G, ch. 3.3.1),\n   * when a \"Discover Characteristics By UUID\" has been started. It will be the value of the Characteristic if a\n   * \"Read using Characteristic UUID\" has been performed.\n   */\n  uint8_t  attr_value[VARIABLE_SIZE];\n} PACKED evt_gatt_disc_read_char_by_uuid_resp;\n\n/**\n * This event is given to the application when a write request, write command or signed write command\n * is received by the server from the client. This event will be given to the application only if the\n * event bit for this event generation is set when the characteristic was added.\n * When this event is received, the application has to check whether the value being requested for write\n * is allowed to be written and respond with the command aci_gatt_write_response().\n * If the write is rejected by the application, then the value of the attribute will not be modified.\n * In case of a write request, an error response will be sent to the client, with the error code as specified by the application.\n * In case of write/signed write commands, no response is sent to the client but the attribute is not modified.\n * See @ref evt_gatt_write_permit_req.\n */\n#define EVT_BLUE_GATT_WRITE_PERMIT_REQ            (0x0C13)\ntypedef __packed struct _evt_gatt_write_permit_req{\n  uint16_t conn_handle; /**< Handle of the connection on which there was the request to write the attribute. */\n  uint16_t attr_handle; /**< The handle of the attribute for which the write request has been made by the client */\n  uint8_t  data_length; /**< Length of data field. */\n  uint8_t  data[VARIABLE_SIZE]; /**< The data that the client has requested to write */\n} PACKED evt_gatt_write_permit_req;\n\n/**\n * This event is given to the application when a read request or read blob request is received by the server\n * from the client. This event will be given to the application only if the event bit for this event generation\n * is set when the characteristic was added.\n * On receiving this event, the application can update the value of the handle if it desires and when done\n * it has to use the aci_gatt_allow_read() command to indicate to the stack that it can send the response to the client.\n * See @ref evt_gatt_read_permit_req.\n *\n */\n#define EVT_BLUE_GATT_READ_PERMIT_REQ             (0x0C14)\ntypedef __packed struct _evt_gatt_read_permit_req{\n  uint16_t conn_handle; /**< Handle of the connection on which there was the request to read the attribute. */\n  uint16_t attr_handle; /**< The handle of the attribute for which the read request has been made by the client */\n  uint8_t  data_length; /**< Length of offset field. */\n  uint16_t offset;      /**< Contains the offset from which the read has been requested */\n} PACKED evt_gatt_read_permit_req;\n\n/**\n * This event is given to the application when a read multiple request or read by type request is received\n * by the server from the client. This event will be given to the application only if the event bit for this\n * event generation is set when the characteristic was added.\n * On receiving this event, the application can update the values of the handles if it desires and when done\n * it has to send the aci_gatt_allow_read command to indicate to the stack that it can send the response to the client.\n * See @ref evt_gatt_read_multi_permit_req.\n *\n */\n#define EVT_BLUE_GATT_READ_MULTI_PERMIT_REQ       (0x0C15)\ntypedef __packed struct _evt_gatt_read_multi_permit_req{\n  uint16_t conn_handle; /**< Handle of the connection on which there was the request to read the attribute. */\n  uint8_t  data_length; /**< Length of data field. */\n  uint8_t  data[VARIABLE_SIZE]; /**< The handles of the attributes that have been requested by the client for a read. */\n} PACKED evt_gatt_read_multi_permit_req;\n\n/**\n * This event is raised when the number of available TX buffers is above a threshold TH (TH = 2).\n * The event will be given only if a previous ACI command returned with BLE_STATUS_INSUFFICIENT_RESOURCES.\n * On receiving this event, the application can continue to send notifications by calling aci_gatt_update_char_value().\n * See @ref evt_gatt_tx_pool_vailable.\n *\n */\n#define EVT_BLUE_GATT_TX_POOL_AVAILABLE           (0x0C16)\ntypedef __packed struct _evt_gatt_tx_pool_available{\n  uint16_t conn_handle; /**< Handle of the connection on which there was the request to read the attribute. */\n  uint16_t available_buffers; /**< Length of data field. */\n} PACKED evt_gatt_tx_pool_available;\n\n/**\n * This event is raised on the server when the client confirms the reception of an indication.\n */\n#define EVT_BLUE_GATT_SERVER_CONFIRMATION_EVENT    (0x0C17)\ntypedef __packed struct _evt_gatt_server_confirmation{\n  uint16_t conn_handle; /**< Handle of the connection on which there was the request to read the attribute. */\n} PACKED evt_gatt_server_confirmation;\n\n\n/**\n * This event is given to the application when a prepare write request\n * is received by the server from the client. This event will be given to the application only if the\n * event bit for this event generation is set when the characteristic was added.\n * When this event is received, the application has to check whether the value being requested for write\n * is allowed to be written and respond with the command aci_gatt_write_response().\n * Based on the response from the application, the attribute value will be modified by the stack.\n * If the write is rejected by the application, then the value of the attribute will not be modified\n * and an error response will be sent to the client, with the error code as specified by the application.\n * See @ref evt_gatt_write_permit_req.\n */\n#define EVT_BLUE_GATT_PREPARE_WRITE_PERMIT_REQ            (0x0C18)\ntypedef __packed struct _evt_gatt_prepare_write_permit_req{\n  uint16_t conn_handle; /**< Handle of the connection on which there was the request to write the attribute. */\n  uint16_t attr_handle; /**< The handle of the attribute for which the write request has been made by the client */\n  uint16_t offset; /**< The offset from which the prepare write has been requested */\n  uint8_t  data_length; /**< Length of data field. */\n  uint8_t  data[VARIABLE_SIZE]; /**< The data that the client has requested to write */\n} PACKED evt_gatt_prepare_write_permit_req;\n\n/**\n * @}\n */\n\n/**\n * @}\n */\n\n/**\n * @}\n */\n\n#endif /* __BLUENRG_GATT_ACI_H__ */\n",
                "bluenrg_gatt_server.h": "/******************** (C) COPYRIGHT 2012 STMicroelectronics ********************\n* File Name          : bluenrg_gatt_server.h\n* Author             : AMS - HEA&RF BU\n* Version            : V1.0.0\n* Date               : 19-July-2012\n* Description        : Header file for BlueNRG's GATT server layer.\n********************************************************************************\n* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\n* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.\n* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,\n* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE\n* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING\n* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\n*******************************************************************************/\n\n#ifndef __GATT_SERVER_H__\n#define __GATT_SERVER_H__\n\n#include \"bluenrg_def.h\"\n\n/** \n * @addtogroup HIGH_LEVEL_INTERFACE HIGH_LEVEL_INTERFACE\n * @{\n */\n\n/**\n * @addtogroup ACI_GATT ACI_GATT\n * @brief API for GATT layer.\n * @{\n */ \n \n/**\n * @addtogroup ACI_GATT_SERVER ACI_GATT_SERVER\n * @brief API for GATT SERVER layer.\n * @{\n */\n\n/**\n * @anchor Well-Known_UUIDs\n * @name Well-Known UUIDs\n * @{\n */\n#define PRIMARY_SERVICE_UUID                       (0x2800)\n#define SECONDARY_SERVICE_UUID                     (0x2801)\n#define INCLUDE_SERVICE_UUID                       (0x2802)\n#define CHARACTERISTIC_UUID                        (0x2803)\n#define CHAR_EXTENDED_PROP_DESC_UUID               (0x2900)\n#define CHAR_USER_DESC_UUID                        (0x2901)\n#define CHAR_CLIENT_CONFIG_DESC_UUID               (0x2902)\n#define CHAR_SERVER_CONFIG_DESC_UUID               (0x2903)\n#define CHAR_FORMAT_DESC_UUID                      (0x2904)\n#define CHAR_AGGR_FMT_DESC_UUID                    (0x2905)\n#define GATT_SERVICE_UUID                          (0x1801)\n#define GAP_SERVICE_UUID                           (0x1800)\n#define SERVICE_CHANGED_UUID                       (0x2A05)\n/**\n * @}\n */\n\n/**\n * @anchor Access_permissions\n * @name Access permissions\n * Access permissions for an attribute\n * @{\n */\n#define ATTR_NO_ACCESS                             (0x00)\n#define ATTR_ACCESS_READ_ONLY                      (0x01) \n#define ATTR_ACCESS_WRITE_REQ_ONLY                 (0x02)\n#define ATTR_ACCESS_READ_WRITE                     (0x03)\n#define ATTR_ACCESS_WRITE_WITHOUT_RESPONSE         (0x04)\n#define ATTR_ACCESS_SIGNED_WRITE_ALLOWED           (0x08)\n/**\n * Allows all write procedures\n */\n#define ATTR_ACCESS_WRITE_ANY                      (0x0E)\n/**\n * @}\n */\n\n/**\n * @anchor Char_properties\n * @name Characteristic properties.\n * @{\n */\n#define CHAR_PROP_BROADCAST                        (0x01)\n#define CHAR_PROP_READ                             (0x02)\n#define CHAR_PROP_WRITE_WITHOUT_RESP               (0x04)\n#define CHAR_PROP_WRITE                            (0x08)\n#define CHAR_PROP_NOTIFY                           (0x10)\n#define CHAR_PROP_INDICATE                         (0x20)\n#define CHAR_PROP_SIGNED_WRITE                     (0x40)\n#define CHAR_PROP_EXT                              (0x80)\n/**\n * @}\n */\n\n\n/**\n * @anchor Security_permissions\n * @name Security permissions for an attribute.\n * @{\n */\n#define ATTR_PERMISSION_NONE                       (0x00) /**< No security. */\n#define ATTR_PERMISSION_AUTHEN_READ                (0x01) /**< Need authentication to read */\n#define ATTR_PERMISSION_AUTHOR_READ                (0x02) /**< Need authorization to read */\n#define ATTR_PERMISSION_ENCRY_READ                 (0x04) /**< Link must be encrypted to read */\n#define ATTR_PERMISSION_AUTHEN_WRITE               (0x08) /**< Need authentication to write */\n#define ATTR_PERMISSION_AUTHOR_WRITE               (0x10) /**< Need authorization to write */\n#define ATTR_PERMISSION_ENCRY_WRITE                (0x20) /**< Link must be encrypted for write */\n/**\n * @}\n */\n\n/**\n * @anchor UUID_Types\n * @name Type of UUID (16 bit or 128 bit).\n * @{\n */\n#define UUID_TYPE_16                               (0x01)\n#define UUID_TYPE_128                              (0x02)\n/**\n * @}\n */\n\n/**\n * @anchor Service_type\n * @name Type of service (primary or secondary)\n * @{\n */\n#define PRIMARY_SERVICE                            (0x01)\n#define SECONDARY_SERVICE                          (0x02)\n/**\n * @}\n */\n\n/**\n * @anchor Gatt_Event_Mask\n * @name Gatt Event Mask\n * Type of event generated by GATT server\n * @{\n */\n#define GATT_DONT_NOTIFY_EVENTS                       (0x00) /**< Do not notify events. */\n#define GATT_NOTIFY_ATTRIBUTE_WRITE                   (0x01) /**< The application will be notified when a client writes to this attribute.\n                                                                  An @ref EVT_BLUE_GATT_ATTRIBUTE_MODIFIED will be issued. */\n#define GATT_NOTIFY_WRITE_REQ_AND_WAIT_FOR_APPL_RESP  (0x02) /**< The application will be notified when a write request, a write cmd\n                                                                    or a signed write cmd are received by the server for this attribute.\n                                                                    An @ref EVT_BLUE_GATT_WRITE_PERMIT_REQ will be issued. */\n#define GATT_NOTIFY_READ_REQ_AND_WAIT_FOR_APPL_RESP   (0x04) /**< The application will be notified when a read request of any type is\n                                                                  received for this attribute. An @ref EVT_BLUE_GATT_READ_PERMIT_REQ will be issued. */\n/**\n * @}\n */\n\n/** \n * @name Type of characteristic length\n * See aci_gatt_add_char()\n * @{\n */\n#define CHAR_VALUE_LEN_CONSTANT           (0x00)\n#define CHAR_VALUE_LEN_VARIABLE           (0x01)\n/**\n * @}\n */\n\n\n/**\n * @name Encryption key size\n * @{\n */\n/**\n * Minimum encryption key size\n */\n#define MIN_ENCRY_KEY_SIZE                (7)\n\n/**\n * Maximum encryption key size\n */\n#define MAX_ENCRY_KEY_SIZE                (0x10)\n/**\n * @}\n */\n\n/**\n * @name Characteristic Presentation Format\n * @{\n */\ntypedef __packed struct _charactFormat {\n    uint8_t format;\n    int8_t exp;\n    uint16_t unit;\n    uint8_t name_space;\n    uint16_t desc;\n} PACKED charactFormat;\n\n/**\n * @}\n */\n\n/**\n * @name Format\n * @{\n */\n#define FORMAT_UINT8         0x04\n#define FORMAT_UINT16        0x06\n#define FORMAT_SINT16        0x0E\n#define FORMAT_SINT24        0x0F\n/**\n * @}\n */\n\n/**\n * @name Unit\n * @{\n */\n#define UNIT_UNITLESS        0x2700\n#define UNIT_TEMP_CELSIUS    0x272F\n#define UNIT_PRESSURE_BAR    0x2780\n/**\n * @}\n */\n\n\n/**\n * ATT MTU size\n */\n#define ATT_MTU       (23)\n\n/**\n * @}\n */\n\n/**\n * @name Update type of aci_gatt_upd_char_val_ext().\n * @{\n */\n\n#define NOTIFICATION         1\n#define INDICATION           2\n\n/**\n * @}\n */\n\n/**\n * @}\n */\n\n/**\n * @}\n */\n \n/**\n * @}\n */\n\n#endif /* __GATT_SERVER_H__ */\n",
                "bluenrg_hal_aci.c": "/******************** (C) COPYRIGHT 2013 STMicroelectronics ********************\n* File Name          : bluenrg_hci.c\n* Author             : AMS - HEA&RF BU\n* Version            : V1.0.0\n* Date               : 4-Oct-2013\n* Description        : File with HCI commands for BlueNRG FW6.0 and above.\n********************************************************************************\n* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\n* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.\n* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,\n* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE\n* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING\n* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\n*******************************************************************************/\n\n#include \"bluenrg_types.h\"\n#include \"bluenrg_def.h\"\n#include \"hci_const.h\"\n#include \"bluenrg_aci_const.h\"\n#include \"bluenrg_hal_aci.h\"\n#include \"bluenrg_gatt_server.h\"\n#include \"bluenrg_gap.h\"\n\n#define MIN(a,b)            ((a) < (b) )? (a) : (b)\n#define MAX(a,b)            ((a) > (b) )? (a) : (b)\n\ntBleStatus aci_hal_get_fw_build_number(uint16_t *build_number)\n{\n  struct hci_request rq;\n  hal_get_fw_build_number_rp rp;\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_HAL_GET_FW_BUILD_NUMBER;\n  rq.rparam = &rp;\n  rq.rlen = sizeof(rp);\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  if(rp.status)\n    return rp.status;\n  \n  *build_number = rp.build_number;\n  \n  return 0;\n}\n\ntBleStatus aci_hal_write_config_data(uint8_t offset, \n                                    uint8_t len,\n                                    const uint8_t *val)\n{\n  struct hci_request rq;\n  uint8_t status;\n  uint8_t buffer[HCI_MAX_PAYLOAD_SIZE];\n  uint8_t indx = 0;\n    \n  if ((len+2) > HCI_MAX_PAYLOAD_SIZE)\n    return BLE_STATUS_INVALID_PARAMS;\n\n  buffer[indx] = offset;\n  indx++;\n    \n  buffer[indx] = len;\n  indx++;\n        \n  BLUENRG_memcpy(buffer + indx, val, len);\n  indx +=  len;\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_HAL_WRITE_CONFIG_DATA;\n  rq.cparam = (void *)buffer;\n  rq.clen = indx;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_hal_read_config_data(uint8_t offset, uint16_t data_len, uint8_t *data_len_out_p, uint8_t *data)\n{\n  struct hci_request rq;\n  hal_read_config_data_cp cp;\n  hal_read_config_data_rp rp;\n  \n  cp.offset = offset;\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_HAL_READ_CONFIG_DATA;\n  rq.cparam = &cp;\n  rq.clen = sizeof(cp);\n  rq.rparam = &rp;\n  rq.rlen = sizeof(rp);\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  if(rp.status)\n    return rp.status;\n  \n  *data_len_out_p = rq.rlen-1;\n  \n  BLUENRG_memcpy(data, rp.data, MIN(data_len, *data_len_out_p));\n  \n  return 0;\n}\n\ntBleStatus aci_hal_set_tx_power_level(uint8_t en_high_power, uint8_t pa_level)\n{\n  struct hci_request rq;\n  hal_set_tx_power_level_cp cp;    \n  uint8_t status;\n    \n  cp.en_high_power = en_high_power;\n  cp.pa_level = pa_level;\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_HAL_SET_TX_POWER_LEVEL;\n  rq.cparam = &cp;\n  rq.clen = HAL_SET_TX_POWER_LEVEL_CP_SIZE;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_hal_le_tx_test_packet_number(uint32_t *number_of_packets)\n{\n  struct hci_request rq;\n  hal_le_tx_test_packet_number_rp resp;\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_HAL_LE_TX_TEST_PACKET_NUMBER;\n  rq.rparam = &resp;\n  rq.rlen = sizeof(resp);\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  if (resp.status) {\n    return resp.status;\n  }\n  \n  *number_of_packets = btohl(resp.number_of_packets);\n  \n  return 0;\n}\n\ntBleStatus aci_hal_device_standby(void)\n{\n  struct hci_request rq;\n  uint8_t status;\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_HAL_DEVICE_STANDBY;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_hal_tone_start(uint8_t rf_channel)\n{\n  struct hci_request rq;\n  hal_tone_start_cp cp;    \n  uint8_t status;\n    \n  cp.rf_channel = rf_channel;\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_HAL_TONE_START;\n  rq.cparam = &cp;\n  rq.clen = HAL_TONE_START_CP_SIZE;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n    \n  return status;\n}\n\ntBleStatus aci_hal_tone_stop(void)\n{\n  struct hci_request rq;\n  uint8_t status;\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_HAL_TONE_STOP;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_hal_get_link_status(uint8_t link_status[8], uint16_t conn_handle[8])\n{\n  struct hci_request rq;\n  hal_get_link_status_rp rp;\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_HAL_GET_LINK_STATUS;\n  rq.rparam = &rp;\n  rq.rlen = sizeof(rp);\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  if(rp.status)\n    return rp.status;\n  \n  BLUENRG_memcpy(link_status,rp.link_status,8);\n  for(int i = 0; i < 8; i++)  \n    conn_handle[i] = btohs(rp.conn_handle[i]);\n  \n  return 0;\n}\n\ntBleStatus aci_hal_get_anchor_period(uint32_t *anchor_period, uint32_t *max_free_slot)\n{\n  struct hci_request rq;\n  hal_get_anchor_period_rp rp;\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_HAL_GET_ANCHOR_PERIOD;\n  rq.rparam = &rp;\n  rq.rlen = sizeof(rp);\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  if(rp.status)\n    return rp.status;\n  \n  *anchor_period = btohl(rp.anchor_period);\n  *max_free_slot = btohl(rp.max_free_slot);\n  \n  return 0;\n}\n\n\n\n",
                "bluenrg_hal_aci.h": "/******************** (C) COPYRIGHT 2014 STMicroelectronics ********************\n* File Name          : bluenrg_hal_aci.h\n* Author             : AMS - AAS\n* Version            : V1.0.0\n* Date               : 26-Jun-2014\n* Description        : Header file with HCI commands for BlueNRG\n********************************************************************************\n* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\n* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.\n* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,\n* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE\n* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING\n* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\n*******************************************************************************/\n\n#ifndef __BLUENRG_HAL_ACI_H__\n#define __BLUENRG_HAL_ACI_H__\n\n/** \n * @addtogroup HIGH_LEVEL_INTERFACE HIGH_LEVEL_INTERFACE\n * @{\n */\n \n/**\n *@addtogroup ACI_HAL ACI_HAL\n *@brief API for HAL layer.\n *@{\n */\n\n/**\n * @defgroup HAL_Functions HAL functions\n * @brief API for BlueNRG HAL layer.\n * @{\n */\n\n/**\n * @brief This command retrieves the buid number of the firmware.\n * @param[out] build_number Build number identifying the firmware release.\n * @return Value indicating success or error code.\n */\ntBleStatus aci_hal_get_fw_build_number(uint16_t *build_number);\n\n/**\n * @brief This command writes a value to a low level configure data structure.\n * @note  It is useful to setup directly some low level parameters for the system at runtime.\n * @param offset Offset in the data structure. The starting member in the data structure will have an offset 0.\\n\n * \t\t\t\t See @ref Config_vals.\n *\n * @param len Length of data to be written\n * @param[out] val Data to be written\n * @return Value indicating success or error code.\n */\ntBleStatus aci_hal_write_config_data(uint8_t offset, \n                                    uint8_t len,\n                                    const uint8_t *val);\n/**\n * @brief This command requests the value in the low level configure data structure.\n *        The number of read bytes changes for different Offset.\n * @param offset Offset in the data structure. The starting member in the data structure will have an offset 0.\\n\n * \t\t\t\t See @ref Config_vals.\n * @param data_len Length of the data buffer\n * @param[out] data_len_out_p length of the data returned by the read.\n * @param[out] data Read data\n * @return Value indicating success or error code.\n */\ntBleStatus aci_hal_read_config_data(uint8_t offset, uint16_t data_len, uint8_t *data_len_out_p, uint8_t *data);\n\n/**\n * @brief This command sets the TX power level of the BlueNRG.\n * @note  By controlling the EN_HIGH_POWER and the PA_LEVEL, the combination of the 2 determines\n *        the output power level (dBm).\n *        When the system starts up or reboots, the default TX power level will be used, which is\n *        the maximum value of 8dBm. Once this command is given, the output power will be changed\n *        instantly, regardless if there is Bluetooth communication going on or not. For example,\n *        for debugging purpose, the BlueNRG can be set to advertise all the time and use this\n *        command to observe the signal strength changing. The system will keep the last received\n *        TX power level from the command, i.e. the 2nd command overwrites the previous TX power\n *        level. The new TX power level remains until another Set TX Power command, or the system\n *        reboots.\\n\n * @param en_high_power Can be only 0 or 1. Set high power bit on or off. It is strongly adviced to use the\n * \t\t\t\t\t\tright value, depending on the selected hardware configuration for the RF network:\n * \t\t\t\t\t\tnormal mode or high power mode.\n * @param pa_level Can be from 0 to 7. Set the PA level value.\n * @return Value indicating success or error code.\n */\ntBleStatus aci_hal_set_tx_power_level(uint8_t en_high_power, uint8_t pa_level);\n\n/**\n * @brief This command returns the number of packets sent in Direct Test Mode.\n * @note  When the Direct TX test is started, a 32-bit counter is used to count how many packets\n *        have been transmitted. This command can be used to check how many packets have been sent\n *        during the Direct TX test.\\n\n *        The counter starts from 0 and counts upwards. The counter can wrap and start from 0 again.\n *        The counter is not cleared until the next Direct TX test starts.\n * @param[out] number_of_packets Number of packets sent during the last Direct TX test.\n * @return Value indicating success or error code.\n */\ntBleStatus aci_hal_le_tx_test_packet_number(uint32_t *number_of_packets);\n\n/**\n * @brief Put the device in standby mode.\n * @note Normally the BlueNRG will automatically enter sleep mode to save power. This command puts the\n * \t\t device into the Standby mode instead of the sleep mode. The difference is that, in sleep mode,\n * \t\t the device can still wake up itself with the internal timer. But in standby mode, this timer is\n * \t\t disabled. So the only possibility to wake up the device is by external signals, e.g. a HCI command\n * \t\t sent via SPI bus.\n * \t\t The command is only accepted when there is no other Bluetooth activity. Otherwise an error code\n * \t\t ERR_COMMAND_DISALLOWED will be returned.\n *\n * @return Value indicating success or error code.\n */\ntBleStatus aci_hal_device_standby(void);\n\n/**\n * @brief This command starts a carrier frequency, i.e. a tone, on a specific channel.\n * @note  The frequency sine wave at the specific channel may be used for test purpose only.\n * \t\t  The channel ID is a parameter from 0 to 39 for the 40 BLE channels, e.g. 0 for 2.402GHz, 1 for 2.404GHz etc.\n * \t\t  This command shouldn't be used when normal Bluetooth activities are ongoing.\n * \t\t  The tone should be stopped by aci_hal_tone_stop() command.\n *\n * @param rf_channel BLE Channel ID, from 0 to 39 meaning (2.402 + 2*N) GHz. Actually the tone will be emitted at the\n * \t\t\t\t\t channel central frequency minus 250 kHz.\n * @return Value indicating success or error code.\n */\ntBleStatus aci_hal_tone_start(uint8_t rf_channel);\n\n/**\n * This command is used to stop the previously started aci_hal_tone_start() command.\n * @return Value indicating success or error code.\n */\ntBleStatus aci_hal_tone_stop(void);\n\n/**\n * @brief This command returns the status of all the connections.\n * @note  This command returns the status of the 8 Bluetooth low energy links managed by the device.\n * @param[out] link_status Array of link status (8 links). See @ref Link_Status.\n * @param[out] conn_handle Array of connection handles for each link.\n * @return Value indicating success or error code.\n */\ntBleStatus aci_hal_get_link_status(uint8_t link_status[8], uint16_t conn_handle[8]);\n\n/**\n * @brief This command returns the anchor period and the largest available slot.\n * @note  This command returns information about the anchor period to help application in selecting\n * \t\t  slot timings when operating in multi-link scenarios.\n * @param anchor_period Current anchor period (multiple of 0.625 ms).\n * @param max_free_slot Maximum available time (multiple of 0.625 ms) that can be allocated for a new slot.\n * @return Value indicating success or error code.\n */\ntBleStatus aci_hal_get_anchor_period(uint32_t *anchor_period, uint32_t *max_free_slot);\n\n/**\n * @}\n */\n\n/**\n * @defgroup HAL_Events HAL events\n * The structures are the data field of @ref evt_blue_aci.\n * @{\n */\n\n/** HCI vendor specific event, raised at BlueNRG power-up or reboot. */\n#define EVT_BLUE_HAL_INITIALIZED                 (0x0001)\ntypedef __packed struct _evt_hal_initialized{\n  uint8_t reason_code; /**< Reset reason. See @ref Reset_Reasons */\n} PACKED evt_hal_initialized;\n\n/**\n * This event is generated when an overflow occurs in the event queue read by the external microcontroller.\n * This is normally caused when the external microcontroller does not read pending events.\n * The returned bitmap indicates which event has been lost. Please note that one bit set to 1 indicates one or\n * more occurrences of the particular events. The event EVT_BLUE_HAL_EVENTS_LOST cannot be lost and it will\n * be inserted in the event queue as soon as a position is freed in the event queue. This event should not\n * happen under normal operating condition where external microcontroller promptly reads events signaled by\n * IRQ pin. It is provided to detected unexpected behavior of the external microcontroller or to allow\n * application to recover situations where critical events are lost.\n */\n#define EVT_BLUE_HAL_EVENTS_LOST_IDB05A1                (0x0002)\ntypedef __packed struct _evt_hal_events_lost{\n  uint8_t  lost_events[8]; /**< Bitmap of lost events. Each bit indicates one or more occurrences of the specific event. See @ref Lost_Events */\n} PACKED evt_hal_events_lost_IDB05A1;\n\n\n/**\n * This event is given to the application after the @ref ACI_BLUE_INITIALIZED_EVENT\n * when a system crash is detected. This events returns system crash information for debugging purposes.\n * Information reported are useful to understand the root cause of the crash.\n */\n#define EVT_BLUE_HAL_CRASH_INFO_IDB05A1                 (0x0003)\ntypedef __packed struct _evt_hal_crash_info{\n  uint8_t  crash_type; /**< Type of crash: Assert failed (0), NMI Fault (1), Hard Fault (2)  */\n  uint32_t sp; /**< SP register */\n  uint32_t r0; /**< R0 register  */\n  uint32_t r1; /**< R1 register  */\n  uint32_t r2; /**< R2 register  */\n  uint32_t r3; /**< R3 register  */\n  uint32_t r12; /**< R12 register  */\n  uint32_t lr; /**< LR register  */\n  uint32_t pc; /**< PC register  */\n  uint32_t xpsr; /**< xPSR register  */\n  uint8_t  debug_data_len; /**< length of debug_data field  */\n  uint8_t  debug_data[VARIABLE_SIZE]; /**< Debug data */  \n} PACKED evt_hal_crash_info_IDB05A1;\n\n\n/**\n * @}\n */\n\n\n/**\n * @anchor Reset_Reasons\n * @name Reset Reasons\n * See @ref EVT_BLUE_HAL_INITIALIZED.\n * @{\n */\n#define RESET_NORMAL            1 /**< Normal startup. */\n#define RESET_UPDATER_ACI       2 /**< Updater mode entered with ACI command */\n#define RESET_UPDATER_BAD_FLAG  3 /**< Updater mode entered due to a bad BLUE flag */\n#define RESET_UPDATER_PIN       4 /**< Updater mode entered with IRQ pin */\n#define RESET_WATCHDOG          5 /**< Reset caused by watchdog */\n#define RESET_LOCKUP            6 /**< Reset due to lockup */\n#define RESET_BROWNOUT          7 /**< Brownout reset */\n#define RESET_CRASH             8 /**< Reset caused by a crash (NMI or Hard Fault) */\n#define RESET_ECC_ERR           9 /**< Reset caused by an ECC error */\n/**\n * @}\n */\n\n\n/**\n * @defgroup Config_vals Offsets and lengths for configuration values.\n * @brief Offsets and lengths for configuration values.\n * \t\t  See aci_hal_write_config_data().\n * @{\n */\n\n/**\n * @name Configuration values.\n * See @ref aci_hal_write_config_data().\n * @{\n */\n#define CONFIG_DATA_PUBADDR_OFFSET          (0x00) /**< Bluetooth public address */\n#define CONFIG_DATA_DIV_OFFSET              (0x06) /**< DIV used to derive CSRK */\n#define CONFIG_DATA_ER_OFFSET               (0x08) /**< Encryption root key used to derive LTK and CSRK */\n#define CONFIG_DATA_IR_OFFSET               (0x18) /**< Identity root key used to derive LTK and CSRK */\n#define CONFIG_DATA_LL_WITHOUT_HOST         (0x2C) /**< Switch on/off Link Layer only mode. Set to 1 to disable Host.\n \t \t \t \t \t \t \t \t \t \t \t \t \t It can be written only if aci_hal_write_config_data() is the first command \t \t \t \t \t \t \t \t \t \t \t \t after reset. */\n#define CONFIG_DATA_RANDOM_ADDRESS          (0x80) /**< Stored static random address. Read-only. */\n\n/**\n * Select the BlueNRG mode configurations.\\n\n * @li Mode 1: slave or master, 1 connection, RAM1 only (small GATT DB)\n * @li Mode 2: slave or master, 1 connection, RAM1 and RAM2 (large GATT DB)\n * @li Mode 3: master/slave, 8 connections, RAM1 and RAM2.\n * @li Mode 4: master/slave, 4 connections, RAM1 and RAM2 simultaneous scanning and advertising.\n */\n#define CONFIG_DATA_MODE_OFFSET \t\t\t(0x2D)\n\n#define CONFIG_DATA_WATCHDOG_DISABLE \t\t(0x2F) /**< Set to 1 to disable watchdog. It is enabled by default. */\n\n/**\n * @}\n */\n\n/**\n * @name Length for configuration values.\n * See @ref aci_hal_write_config_data().\n * @{\n */\n#define CONFIG_DATA_PUBADDR_LEN             (6)\n#define CONFIG_DATA_DIV_LEN                 (2)\n#define CONFIG_DATA_ER_LEN                  (16)\n#define CONFIG_DATA_IR_LEN                  (16)\n#define CONFIG_DATA_LL_WITHOUT_HOST_LEN     (1)\n#define CONFIG_DATA_MODE_LEN                (1)\n#define CONFIG_DATA_WATCHDOG_DISABLE_LEN    (1)\n/**\n * @}\n */\n\n/**\n * @anchor Link_Status\n * @name Status of the link\n * See @ref aci_hal_get_link_status().\n * @{\n */\n#define STATUS_IDLE                         0\n#define STATUS_ADVERTISING                  1\n#define STATUS_CONNECTED_AS_SLAVE           2\n#define STATUS_SCANNING                     3\n#define STATUS_CONNECTED_AS_MASTER          5\n#define STATUS_TX_TEST                      6\n#define STATUS_RX_TEST                      7\n/**\n * @}\n */\n\n/**\n * @}\n */\n\n /**\n * @anchor Lost_Events\n * @name Lost events bitmap\n * See @ref EVT_BLUE_HAL_EVENTS_LOST.\n * @{\n */   \n#define EVT_DISCONN_COMPLETE_BIT                                     0\n#define EVT_ENCRYPT_CHANGE_BIT                                       1\n#define EVT_READ_REMOTE_VERSION_COMPLETE_BIT                         2\n#define EVT_CMD_COMPLETE_BIT                                         3\n#define EVT_CMD_STATUS_BIT                                           4\n#define EVT_HARDWARE_ERROR_BIT                                       5\n#define EVT_NUM_COMP_PKTS_BIT                                        6\n#define EVT_ENCRYPTION_KEY_REFRESH_BIT                               7\n#define EVT_BLUE_HAL_INITIALIZED_BIT                                 8\n#define EVT_BLUE_GAP_SET_LIMITED_DISCOVERABLE_BIT                    9\n#define EVT_BLUE_GAP_PAIRING_CMPLT_BIT                               10\n#define EVT_BLUE_GAP_PASS_KEY_REQUEST_BIT                            11\n#define EVT_BLUE_GAP_AUTHORIZATION_REQUEST_BIT                       12\n#define EVT_BLUE_GAP_SECURITY_REQ_INITIATED_BIT                      13\n#define EVT_BLUE_GAP_BOND_LOST_BIT                                   14\n#define EVT_BLUE_GAP_PROCEDURE_COMPLETE_BIT                          15\n#define EVT_BLUE_GAP_ADDR_NOT_RESOLVED_BIT                           16\n#define EVT_BLUE_L2CAP_CONN_UPDATE_RESP_BIT                          17\n#define EVT_BLUE_L2CAP_PROCEDURE_TIMEOUT_BIT                         18\n#define EVT_BLUE_L2CAP_CONN_UPDATE_REQ_BIT                           19\n#define EVT_BLUE_GATT_ATTRIBUTE_MODIFIED_BIT                         20\n#define EVT_BLUE_GATT_PROCEDURE_TIMEOUT_BIT                          21\n#define EVT_BLUE_EXCHANGE_MTU_RESP_BIT                               22\n#define EVT_BLUE_ATT_FIND_INFORMATION_RESP_BIT                       23\n#define EVT_BLUE_ATT_FIND_BY_TYPE_VAL_RESP_BIT                       24\n#define EVT_BLUE_ATT_READ_BY_TYPE_RESP_BIT                           25\n#define EVT_BLUE_ATT_READ_RESP_BIT                                   26\n#define EVT_BLUE_ATT_READ_BLOB_RESP_BIT                              27\n#define EVT_BLUE_ATT_READ_MULTIPLE_RESP_BIT                          28\n#define EVT_BLUE_ATT_READ_BY_GROUP_RESP_BIT                          29\n#define EVT_BLUE_ATT_WRITE_RESP_BIT                                  30\n#define EVT_BLUE_ATT_PREPARE_WRITE_RESP_BIT                          31\n#define EVT_BLUE_ATT_EXEC_WRITE_RESP_BIT                             32\n#define EVT_BLUE_GATT_INDICATION_BIT                                 33\n#define EVT_BLUE_GATT_NOTIFICATION_BIT                               34\n#define EVT_BLUE_GATT_PROCEDURE_COMPLETE_BIT                         35\n#define EVT_BLUE_GATT_ERROR_RESP_BIT                                 36\n#define EVT_BLUE_GATT_DISC_READ_CHARAC_BY_UUID_RESP_BIT              37\n#define EVT_BLUE_GATT_WRITE_PERMIT_REQ_BIT                           38\n#define EVT_BLUE_GATT_READ_PERMIT_REQ_BIT                            39\n#define EVT_BLUE_GATT_READ_MULTI_PERMIT_REQ_BIT                      40\n#define EVT_BLUE_GATT_TX_POOL_AVAILABLE_BIT                          41\n#define EVT_BLUE_GATT_SERVER_RX_CONFIRMATION_BIT                     42\n#define EVT_BLUE_GATT_PREPARE_WRITE_PERMIT_REQ_BIT                   43\n#define EVT_LL_CONNECTION_COMPLETE_BIT                               44\n#define EVT_LL_ADVERTISING_REPORT_BIT                                45\n#define EVT_LL_CONNECTION_UPDATE_COMPLETE_BIT                        46\n#define EVT_LL_READ_REMOTE_USED_FEATURES_BIT                         47\n#define EVT_LL_LTK_REQUEST_BIT                                       48   \n/**\n * @}\n */\n\n/**\n * @name Hardware error event codes\n * See @ref EVT_HARDWARE_ERROR.\n * @{\n */\n/**\n * Error on the SPI bus has been detected, most likely caused by incorrect SPI configuration on the external micro-controller.\n */\n#define SPI_FRAMING_ERROR           0\n/**\n * Caused by a slow crystal startup and they are an indication that the HS_STARTUP_TIME\n * in the device configuration needs to be tuned. After this event is recommended to hardware reset the device.\n */\n#define RADIO_STATE_ERROR           1\n/**\n * Caused by a slow crystal startup and they are an indication that the HS_STARTUP_TIME\n * in the device configuration needs to be tuned. After this event is recommended to hardware reset the device.\n */\n#define TIMER_OVERRUN_ERROR         2 \n/**\n * @}\n */\n \n/**\n * @}\n */\n\n/**\n * @}\n */\n\n#endif /* __BLUENRG_HAL_ACI_H__ */\n",
                "bluenrg_l2cap_aci.c": "/******************** (C) COPYRIGHT 2013 STMicroelectronics ********************\n* File Name          : bluenrg_hci.c\n* Author             : AMS - HEA&RF BU\n* Version            : V1.0.0\n* Date               : 4-Oct-2013\n* Description        : File with HCI commands for BlueNRG FW6.0 and above.\n********************************************************************************\n* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\n* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.\n* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,\n* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE\n* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING\n* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\n*******************************************************************************/\n\n#include \"bluenrg_types.h\"\n#include \"bluenrg_def.h\"\n#include \"hci_const.h\"\n#include \"bluenrg_aci_const.h\"\n#include \"bluenrg_l2cap_aci.h\"\n#include \"bluenrg_hal_aci.h\"\n#include \"bluenrg_gap.h\"\n\n#define MIN(a,b)            ((a) < (b) )? (a) : (b)\n#define MAX(a,b)            ((a) > (b) )? (a) : (b)\n\ntBleStatus aci_l2cap_connection_parameter_update_request(uint16_t conn_handle, uint16_t interval_min,\n\t\t\t\t\t\t\t uint16_t interval_max, uint16_t slave_latency,\n\t\t\t\t\t\t\t uint16_t timeout_multiplier)\n{\n  struct hci_request rq;\n  uint8_t status;\n  l2cap_conn_param_update_req_cp cp;\n\n  cp.conn_handle = htobs(conn_handle);\n  cp.interval_min = htobs(interval_min);\n  cp.interval_max = htobs(interval_max);\n  cp.slave_latency = htobs(slave_latency);\n  cp.timeout_multiplier = htobs(timeout_multiplier);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_L2CAP_CONN_PARAM_UPDATE_REQ;\n  rq.cparam = &cp;\n  rq.clen = L2CAP_CONN_PARAM_UPDATE_REQ_CP_SIZE;\n  rq.event = EVT_CMD_STATUS;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  return status;  \n}\n\ntBleStatus aci_l2cap_connection_parameter_update_response_IDB05A1(uint16_t conn_handle, uint16_t interval_min,\n\t\t\t\t\t\t\t uint16_t interval_max, uint16_t slave_latency,\n\t\t\t\t\t\t\t uint16_t timeout_multiplier, uint16_t min_ce_length, uint16_t max_ce_length,\n                             uint8_t id, uint8_t accept)\n{\n  struct hci_request rq;\n  uint8_t status;\n  l2cap_conn_param_update_resp_cp_IDB05A1 cp;\n\n  cp.conn_handle = htobs(conn_handle);\n  cp.interval_min = htobs(interval_min);\n  cp.interval_max = htobs(interval_max);\n  cp.slave_latency = htobs(slave_latency);\n  cp.timeout_multiplier = htobs(timeout_multiplier);\n  cp.min_ce_length = htobs(min_ce_length);\n  cp.max_ce_length = htobs(max_ce_length);\n  cp.id = id;\n  cp.accept = accept;\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_L2CAP_CONN_PARAM_UPDATE_RESP;\n  rq.cparam = &cp;\n  rq.clen = sizeof(cp);\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_l2cap_connection_parameter_update_response_IDB04A1(uint16_t conn_handle, uint16_t interval_min,\n\t\t\t\t\t\t\t uint16_t interval_max, uint16_t slave_latency,\n\t\t\t\t\t\t\t uint16_t timeout_multiplier, uint8_t id, uint8_t accept)\n{\n  struct hci_request rq;\n  uint8_t status;\n  l2cap_conn_param_update_resp_cp_IDB04A1 cp;\n\n  cp.conn_handle = htobs(conn_handle);\n  cp.interval_min = htobs(interval_min);\n  cp.interval_max = htobs(interval_max);\n  cp.slave_latency = htobs(slave_latency);\n  cp.timeout_multiplier = htobs(timeout_multiplier);\n  cp.id = id;\n  cp.accept = accept;\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_L2CAP_CONN_PARAM_UPDATE_RESP;\n  rq.cparam = &cp;\n  rq.clen = sizeof(cp);\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n",
                "bluenrg_l2cap_aci.h": "/******************** (C) COPYRIGHT 2014 STMicroelectronics ********************\n* File Name          : bluenrg_l2cap_aci.h\n* Author             : AMS - HEA&RF BU\n* Version            : V1.0.0\n* Date               : 26-Jun-2014\n* Description        : Header file with L2CAP commands for BlueNRG FW6.3.\n********************************************************************************\n* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\n* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.\n* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,\n* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE\n* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING\n* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\n*******************************************************************************/\n\n#ifndef __BLUENRG_L2CAP_ACI_H__\n#define __BLUENRG_L2CAP_ACI_H__\n\n/** \n * @addtogroup HIGH_LEVEL_INTERFACE HIGH_LEVEL_INTERFACE\n * @{\n */\n \n/**\n *@addtogroup ACI_L2CAP ACI_L2CAP\n *@brief API for L2CAP layer.\n *@{\n */\n\n/**\n *@defgroup L2CAP_Functions L2CAP functions\n *@brief API for L2CAP layer.\n *@{\n */\n\n/**\n * @brief Send an L2CAP Connection Parameter Update request from the slave to the master.\n * @note  An @ref EVT_BLUE_L2CAP_CONN_UPD_RESP event will be raised when the master will respond to the request\n * \t\t  (accepts or rejects).\n * @param conn_handle Connection handle on which the connection parameter update request has to be sent.\n * @param interval_min Defines minimum value for the connection event interval in the following manner:\n *\t\t\t\t\t\tconnIntervalMin = interval_min x 1.25ms\n * @param interval_max Defines maximum value for the connection event interval in the following manner:\n * \t\t\t\t\t\tconnIntervalMax = interval_max x 1.25ms\n * @param slave_latency Defines the slave latency parameter (number of connection events that can be skipped).\n * @param timeout_multiplier Defines connection timeout parameter in the following manner:\n * \t\t\t\t\t\t\t timeout_multiplier x 10ms.\n * @return Value indicating success or error code.\n */\ntBleStatus aci_l2cap_connection_parameter_update_request(uint16_t conn_handle, uint16_t interval_min,\n\t\t\t\t\t\t\t uint16_t interval_max, uint16_t slave_latency,\n\t\t\t\t\t\t\t uint16_t timeout_multiplier);\n/**\n * @brief Accept or reject a connection update.\n * @note  This command should be sent in response to a @ref EVT_BLUE_L2CAP_CONN_UPD_REQ event from the controller.\n * \t\t  The accept parameter has to be set if the connection parameters given in the event are acceptable.\n * @param conn_handle Handle received in @ref EVT_BLUE_L2CAP_CONN_UPD_REQ event.\n * @param interval_min The connection interval parameter as received in the l2cap connection update request event\n * @param interval_max The maximum connection interval parameter as received in the l2cap connection update request event.\n * @param slave_latency The slave latency parameter as received in the l2cap connection update request event.\n * @param timeout_multiplier The supervision connection timeout parameter as received in the l2cap connection update request event.\n * @param min_ce_length Minimum length of connection event needed for the LE connection.\\n\n * \t\t\t\t\t\tRange: 0x0000 - 0xFFFF\\n\n * \t\t\t\t\t\tTime = N x 0.625 msec.\n * @param max_ce_length Maximum length of connection event needed for the LE connection.\\n\n * \t\t\t\t\t\tRange: 0x0000 - 0xFFFF\\n\n * \t\t\t\t\t\tTime = N x 0.625 msec.\n * @param id Identifier received in @ref EVT_BLUE_L2CAP_CONN_UPD_REQ event.\n * @param accept @arg 0x00: The connection update parameters are not acceptable.\n *               @arg 0x01: The connection update parameters are acceptable.\n * @return Value indicating success or error code.\n */\ntBleStatus aci_l2cap_connection_parameter_update_response_IDB05A1(uint16_t conn_handle, uint16_t interval_min,\n\t\t\t\t\t\t\t uint16_t interval_max, uint16_t slave_latency,\n\t\t\t\t\t\t\t uint16_t timeout_multiplier, uint16_t min_ce_length, uint16_t max_ce_length,\n                                                         uint8_t id, uint8_t accept);\n\n /**\n * @brief Accept or reject a connection update.\n * @note  This command should be sent in response to a @ref EVT_BLUE_L2CAP_CONN_UPD_REQ event from the controller.\n * \t\t  The accept parameter has to be set if the connection parameters given in the event are acceptable.\n * @param conn_handle Handle received in @ref EVT_BLUE_L2CAP_CONN_UPD_REQ event.\n * @param interval_min The connection interval parameter as received in the l2cap connection update request event\n * @param interval_max The maximum connection interval parameter as received in the l2cap connection update request event.\n * @param slave_latency The slave latency parameter as received in the l2cap connection update request event.\n * @param timeout_multiplier The supervision connection timeout parameter as received in the l2cap connection update request event.\n * @param id Identifier received in @ref EVT_BLUE_L2CAP_CONN_UPD_REQ event.\n * @param accept @arg 0x00: The connection update parameters are not acceptable.\n *               @arg 0x01: The connection update parameters are acceptable.\n * @return Value indicating success or error code.\n */\ntBleStatus aci_l2cap_connection_parameter_update_response_IDB04A1(uint16_t conn_handle, uint16_t interval_min,\n\t\t\t\t\t\t\t uint16_t interval_max, uint16_t slave_latency,\n\t\t\t\t\t\t\t uint16_t timeout_multiplier, uint8_t id, uint8_t accept);\n\n/**\n * @}\n */\n   \n/**\n * @defgroup L2CAP_Events L2CAP events\n * @{\n */\n\n/**\n * This event is generated when the master responds to the L2CAP connection update request packet.\n * For more info see CONNECTION PARAMETER UPDATE RESPONSE and COMMAND REJECT in Bluetooth Core v4.0 spec.\n */\n#define EVT_BLUE_L2CAP_CONN_UPD_RESP\t\t  (0x0800)\ntypedef __packed struct _evt_l2cap_conn_upd_resp{\n  uint16_t conn_handle;         /**< The connection handle related to the event. */\n  uint8_t  event_data_length;  /**< Length of following data. */\n/**\n * @li 0x13 in case of valid L2CAP Connection Parameter Update Response packet.\n * @li 0x01 in case of Command Reject.\n */\n  uint8_t  code;\n  uint8_t  identifier;    /**< Identifier of the response. It is equal to the request. */\n  uint16_t l2cap_length;  /**< Length of following data. It should always be 2 */\n/**\n * Result code (parameters accepted or rejected) in case of Connection Parameter Update\n * Response (code=0x13) or reason code for rejection in case of Command Reject (code=0x01).\n */\n  uint16_t result;\n} PACKED evt_l2cap_conn_upd_resp;\n\n/**\n * This event is generated when the master does not respond to the connection update request\n * within 30 seconds.\n */\n#define EVT_BLUE_L2CAP_PROCEDURE_TIMEOUT      (0x0801)\ntypedef __packed struct _evt_l2cap_procedure_timeout{\n  uint16_t conn_handle;         /**< The connection handle related to the event. */\n  uint8_t  event_data_length;  /**< Length of following data. It should be always 0 for this event. */\n} PACKED evt_l2cap_procedure_timeout;\n\n/**\n * The event is given by the L2CAP layer when a connection update request is received from the slave.\n * The application has to respond by calling aci_l2cap_connection_parameter_update_response().\n */\n#define EVT_BLUE_L2CAP_CONN_UPD_REQ\t\t  \t  (0x0802)\ntypedef __packed struct _evt_l2cap_conn_upd_req{\n/**\n * Handle of the connection for which the connection update request has been received.\n * The same handle has to be returned while responding to the event with the command\n * aci_l2cap_connection_parameter_update_response().\n */\n  uint16_t conn_handle; \n  uint8_t  event_data_length; /**< Length of following data. */\n/**\n * This is the identifier which associates the request to the\n * response. The same identifier has to be returned by the upper\n * layer in the command aci_l2cap_connection_parameter_update_response().\n */\n  uint8_t  identifier; \n  uint16_t l2cap_length;  /**< Length of the L2CAP connection update request. */\n  uint16_t interval_min;  /**< Value as defined in Bluetooth 4.0 spec, Volume 3, Part A 4.20. */\n  uint16_t interval_max;  /**< Value as defined in Bluetooth 4.0 spec, Volume 3, Part A 4.20. */\n  uint16_t slave_latency; /**< Value as defined in Bluetooth 4.0 spec, Volume 3, Part A 4.20. */\n  uint16_t timeout_mult;  /**< Value as defined in Bluetooth 4.0 spec, Volume 3, Part A 4.20. */\n} PACKED evt_l2cap_conn_upd_req;\n\n/**\n * @}\n */\n\n/**\n * @}\n */\n\n/**\n * @}\n */\n\n#endif /* __BLUENRG_L2CAP_ACI_H__ */\n",
                "bluenrg_types.h": "/******************** (C) COPYRIGHT 2012 STMicroelectronics ********************\n* File Name          : bluenrg_types.h\n* Author             : AMS - HEA&RF BU\n* Version            : V1.0.0\n* Date               : 19-July-2012\n* Description        : This header file defines the basic data types used by the\n*                       BLE stack.\n********************************************************************************\n* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\n* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.\n* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,\n* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE\n* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING\n* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\n*******************************************************************************/\n#ifndef __BLUENRG_TYPES_H__\n#define __BLUENRG_TYPES_H__\n\n#include <stdint.h>\n\n#ifndef NULL\n#define NULL ((void *)0)\n#endif\n\n#ifndef __LITTLE_ENDIAN\n#define __LITTLE_ENDIAN 0\n#define __BIG_ENDIAN    1\n#endif\n\n/* Change this define to 1 if zero-length arrays are not supported by your compiler. */\n#define VARIABLE_SIZE   \n\n/* Byte order conversions */\n#if __BYTE_ORDER == __LITTLE_ENDIAN\n#define htobs(d)  (d)\n#define htobl(d)  (d)\n#define btohs(d)  (d)\n#define btohl(d)  (d)\n#elif __BYTE_ORDER == __BIG_ENDIAN\n#define htobs(d)  (d<<8|d>>8)\n#define htobl(d)  (d<<24|((d<<8)&0x00ff0000)|((d>>8)&0x0000ff00)|((d>>24)&0x000000ff))\n#define btohs(d)  (d<<8|d>>8)\n#define btohl(d)  (d<<24|((d<<8)&0x00ff0000)|((d>>8)&0x0000ff00)|((d>>24)&0x000000ff))\n#else\n#error \"Unknown byte order\"\n#endif\n\ntypedef uint8_t BOOL;\n\n#ifndef TRUE \n#define TRUE (1)\n#endif\n\n#ifndef FALSE\n#define FALSE (0)\n#endif\n\n#ifdef __GNUC__\n#undef __packed\n#define __packed\n#define PACKED __attribute__((packed))\n#else\n#define PACKED\n#endif\n\n#endif /* __BLUENRG_TYPES_H__ */\n\n",
                "bluenrg_updater_aci.c": "/******************** (C) COPYRIGHT 2013 STMicroelectronics ********************\n* File Name          : bluenrg_hci.c\n* Author             : AMS - HEA&RF BU\n* Version            : V1.0.0\n* Date               : 4-Oct-2013\n* Description        : File with HCI commands for BlueNRG FW6.0 and above.\n********************************************************************************\n* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\n* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.\n* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,\n* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE\n* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING\n* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\n*******************************************************************************/\n\n#include \"bluenrg_def.h\"\n#include \"bluenrg_types.h\"\n#include \"hci_const.h\"\n#include \"bluenrg_aci_const.h\"\n#include \"bluenrg_updater_aci.h\"\n\n#define MIN(a,b)            ((a) < (b) )? (a) : (b)\n#define MAX(a,b)            ((a) > (b) )? (a) : (b)\n\ntBleStatus aci_updater_start(void)\n{\n  struct hci_request rq;\n  uint8_t status = 0;\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_UPDATER_START;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  hci_send_req(&rq, FALSE); // No command complete is sent.\n\n  return status;  \n}\n\ntBleStatus aci_updater_reboot(void)\n{\n  struct hci_request rq;\n  uint8_t status = 0;\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_UPDATER_REBOOT;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  hci_send_req(&rq, FALSE); // No command complete is sent.\n\n  return status;\n}\n\ntBleStatus aci_get_updater_version(uint8_t *version)\n{\n  struct hci_request rq;\n  get_updater_version_rp resp;\n\n  BLUENRG_memset(&resp, 0, sizeof(resp));\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GET_UPDATER_VERSION;\n  rq.rparam = &resp;\n  rq.rlen = GET_UPDATER_VERSION_RP_SIZE;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n    \n  *version = resp.version;\n\n  return resp.status;\n}\n\ntBleStatus aci_get_updater_buffer_size(uint8_t *buffer_size)\n{\n  struct hci_request rq;\n  get_updater_bufsize_rp resp;\n\n  BLUENRG_memset(&resp, 0, sizeof(resp));\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_GET_UPDATER_BUFSIZE;\n  rq.rparam = &resp;\n  rq.rlen = GET_UPDATER_BUFSIZE_RP_SIZE;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n    \n  *buffer_size = resp.buffer_size;\n\n  return resp.status;\n}\n\ntBleStatus aci_erase_blue_flag(void)\n{\n  struct hci_request rq;\n  uint8_t status;\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_UPDATER_ERASE_BLUE_FLAG;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;  \n}\n\ntBleStatus aci_reset_blue_flag(void)\n{\n  struct hci_request rq;\n  uint8_t status;\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_UPDATER_RESET_BLUE_FLAG;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;  \n}\n\ntBleStatus aci_updater_erase_sector(uint32_t address)\n{\n  struct hci_request rq;\n  updater_erase_sector_cp cp;    \n  uint8_t status;\n    \n  cp.address = htobl(address);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_UPDATER_ERASE_SECTOR;\n  rq.cparam = &cp;\n  rq.clen = UPDATER_ERASE_SECTOR_CP_SIZE;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n\n  return status;\n}\n\ntBleStatus aci_updater_program_data_block(uint32_t address, \n\t\t\t\t   uint16_t len,\n\t\t\t\t   const uint8_t *data)\n{\n  struct hci_request rq;\n  uint8_t status;\n  updater_prog_data_block_cp cp;\n    \n  if( len > sizeof(cp.data))\n    return BLE_STATUS_INVALID_PARAMS;\n  \n  cp.address = htobl(address);\n  cp.data_len = htobs(len);        \n  BLUENRG_memcpy(cp.data, data, len);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_UPDATER_PROG_DATA_BLOCK;\n  rq.cparam = &cp;\n  rq.clen = UPDATER_PROG_DATA_BLOCK_CP_SIZE+len;\n  rq.rparam = &status;\n  rq.rlen = 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n    \n  return status;\n}\n\ntBleStatus aci_updater_read_data_block(uint32_t address,\n\t\t\t\tuint16_t data_len,\n\t\t\t\tuint8_t *data)\n{\n  struct hci_request rq;\n  updater_read_data_block_cp cp;\n  uint8_t buffer[HCI_MAX_PAYLOAD_SIZE];\n    \n  if((data_len+1) > HCI_MAX_PAYLOAD_SIZE)\n    return BLE_STATUS_INVALID_PARAMS;\n    \n  cp.address = htobl(address);\n  cp.data_len = htobs(data_len);\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_UPDATER_READ_DATA_BLOCK;\n  rq.cparam = &cp;\n  rq.clen = UPDATER_READ_DATA_BLOCK_CP_SIZE;\n  rq.rparam = buffer;\n  rq.rlen = data_len + 1;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n    \n  // First byte is status\n  BLUENRG_memcpy(data, buffer+1, data_len);\n\n  return buffer[0];\n}\n\ntBleStatus aci_updater_calc_crc(uint32_t address,\n                         uint8_t num_sectors,\n                         uint32_t *crc)\n{\n  struct hci_request rq;\n  updater_calc_crc_cp cp;\n  updater_calc_crc_rp resp;\n    \n  BLUENRG_memset(&resp, 0, sizeof(resp));\n    \n  cp.address = htobl(address);\n  cp.num_sectors = num_sectors;\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_UPDATER_CALC_CRC;\n  rq.cparam = &cp;\n  rq.clen = UPDATER_CALC_CRC_CP_SIZE;\n  rq.rparam = &resp;\n  rq.rlen = UPDATER_CALC_CRC_RP_SIZE;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n    \n  *crc = btohl(resp.crc);\n    \n  return resp.status;\n}\n\ntBleStatus aci_updater_hw_version(uint8_t *version)\n{\n  struct hci_request rq;\n  updater_hw_version_rp resp;\n\n  BLUENRG_memset(&resp, 0, sizeof(resp));\n\n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_VENDOR_CMD;\n  rq.ocf = OCF_UPDATER_HW_VERSION;\n  rq.rparam = &resp;\n  rq.rlen = UPDATER_HW_VERSION_RP_SIZE;\n\n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n    \n  *version = resp.version;\n\n  return resp.status;\n}\n\n\n\n\n",
                "bluenrg_updater_aci.h": "/******************** (C) COPYRIGHT 2014 STMicroelectronics ********************\n* File Name          : bluenrg_updater_aci.h\n* Author             : AMS - HEA&RF BU\n* Version            : V1.0.0\n* Date               : 26-Jun-2014\n* Description        : Header file with updater commands for BlueNRG FW6.3.\n********************************************************************************\n* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\n* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.\n* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,\n* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE\n* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING\n* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\n*******************************************************************************/\n\n#ifndef __BLUENRG_UPDATER_ACI_H__\n#define __BLUENRG_UPDATER_ACI_H__\n\n#include \"bluenrg_types.h\"\n\n/** \n * @addtogroup HIGH_LEVEL_INTERFACE HIGH_LEVEL_INTERFACE\n * @{\n */\n\n/**\n * @addtogroup ACI_UPDATER ACI_UPDATER\n * @brief API for UPDATER layer.\n * @{\n */\n \n/**\n * @defgroup Updater_Functions Updater functions\n * @brief API for BlueNRG Updater.\n * @{\n */\n\ntBleStatus aci_updater_start(void);\n\ntBleStatus aci_updater_reboot(void);\n\ntBleStatus aci_get_updater_version(uint8_t *version);\n\ntBleStatus aci_get_updater_buffer_size(uint8_t *buffer_size);\n\ntBleStatus aci_erase_blue_flag(void);\n\ntBleStatus aci_reset_blue_flag(void);\n\ntBleStatus aci_updater_erase_sector(uint32_t address);\n\ntBleStatus aci_updater_program_data_block(uint32_t address, uint16_t len, const uint8_t *data);\n\ntBleStatus aci_updater_read_data_block(uint32_t address, uint16_t data_len, uint8_t *data);\n\ntBleStatus aci_updater_calc_crc(uint32_t address, uint8_t num_sectors, uint32_t *crc);\n\ntBleStatus aci_updater_hw_version(uint8_t *version);\n\n/**\n * @}\n */\n\n/**\n * @defgroup Updater_Events Updater events\n * @{\n */\n/** HCI vendor specific event, raised at BlueNRG power-up or reboot. */\n#define EVT_BLUE_INITIALIZED                      (0x0001)\ntypedef __packed struct _evt_blue_initialized{\n  uint8_t reason_code;\n} PACKED evt_blue_initialized;\n/**\n * @}\n */\n\n/**\n * @}\n */\n\n/**\n * @}\n */\n\n#endif /* __BLUENRG_UPDATER_ACI_H__ */\n",
                "bluenrg_utils.h": "/******************** (C) COPYRIGHT 2014 STMicroelectronics ********************\n* File Name          : bluenrg_utils.h\n* Author             : AMS - VMA, RF Application Team\n* Version            : V1.0.1\n* Date               : 03-October-2014\n* Description        : Header file for BlueNRG utility functions \n********************************************************************************\n* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\n* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.\n* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,\n* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE\n* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING\n* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\n*******************************************************************************/\n\n/* Define to prevent recursive inclusion -------------------------------------*/\n#ifndef __BLUENRG_UTILS_H\n#define __BLUENRG_UTILS_H\n\n#ifdef __cplusplus\n extern \"C\" {\n#endif\n\n/* Includes ------------------------------------------------------------------*/\n#include \"bluenrg_types.h\" \n\n/* Exported types ------------------------------------------------------------*/\ntypedef struct{\n  uint8_t stack_mode;\n  uint8_t day;\n  uint8_t month;\n  uint8_t year;\n  uint16_t slave_sca_ppm;\n  uint8_t master_sca;\n  uint16_t hs_startup_time; /* In system time units*/\n} IFR_config2_TypeDef;\n\n/**\n * Structure inside IFR for configuration options. \n */\ntypedef __packed struct{\n  uint8_t cold_ana_act_config_table[64];\n  uint8_t hot_ana_config_table[64];\n  uint8_t stack_mode;\n  uint8_t gpio_config;\n  uint8_t rsrvd1[2];\n  uint32_t rsrvd2[3];\n  uint32_t max_conn_event_time;\n  uint32_t ls_crystal_period;\n  uint32_t ls_crystal_freq;\n  uint16_t slave_sca_ppm;\n  uint8_t master_sca;\n  uint8_t rsrvd3;\n  uint16_t hs_startup_time; /* In system time units*/\n  uint8_t rsrvd4[2];\n  uint32_t uid;\n  uint8_t rsrvd5;\n  uint8_t year;  \n  uint8_t month;\n  uint8_t day;\n  uint32_t unused[5];\n} PACKED IFR_config_TypeDef;\n\n/* Exported constants --------------------------------------------------------*/\nextern const IFR_config_TypeDef IFR_config;\n\n/* Exported macros -----------------------------------------------------------*/\n#define FROM_US_TO_SYS_TIME(us)      ((uint16_t)(us/2.4414)+1)\n#define FROM_SYS_TIME_TO_US(sys)     ((uint16_t)(sys*2.4414))\n\n/* Convert 2 digit BCD number to an integer */\n#define BCD_TO_INT(bcd) ((bcd & 0xF) + ((bcd & 0xF0) >> 4)*10)\n\n/* Convert 2 digit number to a BCD number */\n#define INT_TO_BCD(n) ((((uint8_t)n/10)<<4) + (uint8_t)n%10)\n\n/** \n  * Return values \n  */ \n#define BLE_UTIL_SUCCESS                 0\n#define BLE_UTIL_UNSUPPORTED_VERSION     1\n#define BLE_UTIL_WRONG_IMAGE_SIZE        2\n#define BLE_UTIL_ACI_ERROR               3\n#define BLE_UTIL_CRC_ERROR               4\n#define BLE_UTIL_PARSE_ERROR             5\n#define BLE_UTIL_WRONG_VERIFY            6\n\n/* Exported functions ------------------------------------------------------- */ \n/**\n  * @brief  Flash a new firmware using internal bootloader.\n  * @param  fw_image     Pointer to the firmware image (raw binary data,\n  *                      little-endian).\n  * @param  fw_size      Size of the firmware image. The firmware image size shall\n  *                      be multiple of 4 bytes.\n  * @retval int      It returns 0 if successful, or a number not equal to 0 in\n  *                  case of error (ACI_ERROR, UNSUPPORTED_VERSION,\n  *                  WRONG_IMAGE_SIZE, CRC_ERROR)\n  */\nint program_device(const uint8_t *fw_image, uint32_t fw_size);\n\n/**\n  * @brief  Read raw data from IFR (3 64-bytes blocks).\n  * @param  data     Pointer to the buffer that will contain the read data.\n  *                  Its size must be 192 bytes. This data can be parsed by\n  *                  parse_IFR_data_config().\n  * @retval int      It returns 0 if successful, or a number not equal to 0 in\n  *                  case of error (ACI_ERROR, UNSUPPORTED_VERSION)\n  */\nint read_IFR(uint8_t data[192]);\n\n/**\n  * @brief  Verify raw data from IFR (3 64-bytes blocks).\n  * @param  ifr_data Pointer to the buffer that will contain the data to verify.\n  *                  Its size must be 192 bytes.\n  * @retval int      It returns 0 if successful, or a number not equal to 0 in\n                     case of error (ACI_ERROR, BLE_UTIL_WRONG_VERIFY)\n  */\nuint8_t verify_IFR(const IFR_config_TypeDef *ifr_data);\n\n/**\n  * @brief  Program raw data to IFR (3 64-bytes blocks).\n  * @param  ifr_image     Pointer to the buffer that will contain the data to program.\n  *                  Its size must be 192 bytes.\n  * @retval int      It returns 0 if successful\n  */\nint program_IFR(const IFR_config_TypeDef *ifr_image);\n\n/**\n  * @brief  Parse IFR raw data.\n  * @param  data     Pointer to the raw data: last 64 bytes read from IFR sector.\n  * @param  IFR_config     Data structure that will be filled with parsed data.\n  * @retval None\n  */\nvoid parse_IFR_data_config(const uint8_t data[64], IFR_config2_TypeDef *IFR_config);\n\n/**\n  * @brief  Check for the correctness of parsed data.\n  * @param  IFR_config     Data structure filled with parsed data.\n  * @retval int      It returns 0 if successful, or PARSE_ERROR in case data is\n  *                  not correct.\n  */\nint IFR_validate(IFR_config2_TypeDef *IFR_config);\n\n/**\n  * @brief  Modify IFR data. (Last 64-bytes block).\n  * @param  IFR_config   Structure that contains the new parameters inside the\n  *                      IFR configuration data.\n  * @note   It is highly recommended to parse the IFR configuration from\n  *         a working IFR block (this should be done with parse_IFR_data_config()).\n  *         Then it is possible to write the new parameters inside the IFR_config\n  *         structure.\n  * @param  data     Pointer to the buffer that contains the original data. It\n  *                  will be modified according to the new data in the IFR_config\n  *                  structure. Then this data must be written in the last\n  *                  64-byte block in the IFR.\n  *                  Its size must be 64 bytes.\n  * @retval None\n  */\nvoid change_IFR_data_config(IFR_config2_TypeDef *IFR_config, uint8_t data[64]);\n\n/**\n  * @brief  Get BlueNRG hardware and firmware version\n  * @param  hwVersion This parameter returns the Hardware Version (i.e. CUT 3.0 = 0x30, CUT 3.1 = 0x31).\n  * @param  fwVersion This parameter returns the Firmware Version in the format 0xJJMN\n  *                   where JJ = Major Version number, M = Minor Version number and N = Patch Version number.\n  * @retval Status of the call\n  */\nuint8_t getBlueNRGVersion(uint8_t *hwVersion, uint16_t *fwVersion);\n\n/**\n  * @brief  Get BlueNRG updater version\n  * @param  version This parameter returns the updater version. If the updadter version is 0x03 \n  *                 the chip has the updater old, needs to update the bootloader.\n  * @retval Status of the call\n  */\nuint8_t getBlueNRGUpdaterVersion(uint8_t *version);\n\n/**\n  * @brief  Verifies if the bootloader is patched or not. This function shall be used to fix a bug on\n  *         the HW bootloader related to the 32 MHz external crystal oscillator.\n  * @retval TRUE if the HW bootloader is already patched, FALSE otherwise\n  */\nuint8_t isHWBootloader_Patched(void);\n   \n#ifdef __cplusplus\n}\n#endif\n\n#endif /*__BLUENRG_UTILS_H */\n\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\n",
                "bluenrg_utils_small.c": "\n#include \"bluenrg_types.h\"\n#include \"bluenrg_def.h\"\n#include \"bluenrg_aci.h\"\n#include \"bluenrg_utils.h\"\n#include \"hci.h\"\n#include \"hci_le.h\"\n#include \"string.h\"\n\nuint8_t getBlueNRGVersion(uint8_t *hwVersion, uint16_t *fwVersion)\n{\n  uint8_t status;\n  uint8_t hci_version, lmp_pal_version;\n  uint16_t hci_revision, manufacturer_name, lmp_pal_subversion;\n\n  status = hci_le_read_local_version(&hci_version, &hci_revision, &lmp_pal_version, \n\t\t\t\t     &manufacturer_name, &lmp_pal_subversion);\n\n  if (status == BLE_STATUS_SUCCESS) {\n    *hwVersion = hci_revision >> 8;\n    *fwVersion = (hci_revision & 0xFF) << 8;              // Major Version Number\n    *fwVersion |= ((lmp_pal_subversion >> 4) & 0xF) << 4; // Minor Version Number\n    *fwVersion |= lmp_pal_subversion & 0xF;               // Patch Version Number\n  }\n  return status;\n}\n",
                "compiler.h": "/******************** (C) COPYRIGHT 2012 STMicroelectronics ********************\n* File Name          : compiler.h\n* Author             : AMS - HEA&RF BU\n* Version            : V1.0.0\n* Date               : 19-July-2012\n* Description        : This header file defines the basic data types used by the\n*                       BLE stack.\n********************************************************************************\n* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\n* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.\n* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,\n* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE\n* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING\n* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\n*******************************************************************************/\n#ifndef __COMPILER_H__\n#define __COMPILER_H__\n\n#ifdef __GNUC__\n#undef __packed\n#define __packed\n#define PACKED __attribute__((packed))\n#else\n#define PACKED\n#endif\n\n#endif /* __COMPILER_H__ */\n\n",
                "hci.h": "/**\n******************************************************************************\n* @file    hci.h\n* @author  AMG RF FW team\n* @version V1.1.0\n* @date    18-July-2016\n* @brief   Header file for framework required for handling HCI interface\n******************************************************************************\n  *\n  * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics</center></h2>\n  * All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without \n  * modification, are permitted, provided that the following conditions are met:\n  *\n  * 1. Redistribution of source code must retain the above copyright notice, \n  *    this list of conditions and the following disclaimer.\n  * 2. Redistributions in binary form must reproduce the above copyright notice,\n  *    this list of conditions and the following disclaimer in the documentation\n  *    and/or other materials provided with the distribution.\n  * 3. Neither the name of STMicroelectronics nor the names of other \n  *    contributors to this software may be used to endorse or promote products \n  *    derived from this software without specific written permission.\n  * 4. This software, including modifications and/or derivative works of this \n  *    software, must execute solely and exclusively on microcontroller or\n  *    microprocessor devices manufactured by or for STMicroelectronics.\n  * 5. Redistribution and use of this software other than as permitted under \n  *    this license is void and will automatically terminate your rights under \n  *    this license. \n  *\n  * THIS SOFTWARE IS PROVIDED BY STMICROELECTRONICS AND CONTRIBUTORS \"AS IS\" \n  * AND ANY EXPRESS, IMPLIED OR STATUTORY WARRANTIES, INCLUDING, BUT NOT \n  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A \n  * PARTICULAR PURPOSE AND NON-INFRINGEMENT OF THIRD PARTY INTELLECTUAL PROPERTY\n  * RIGHTS ARE DISCLAIMED TO THE FULLEST EXTENT PERMITTED BY LAW. IN NO EVENT \n  * SHALL STMICROELECTRONICS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, \n  * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF \n  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING \n  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n  *\n  ******************************************************************************\n*/\n#ifndef __HCI_H_\n#define __HCI_H_\n\n#include \"bluenrg_types.h\"\n\n/** \n * @addtogroup HIGH_LEVEL_INTERFACE HIGH_LEVEL_INTERFACE\n * @{\n */\n\n/**\n * @defgroup HCI_TL HCI_TL\n * @{\n */\n\n/** \n * @defgroup HCI_TL_functions HCI_TL functions\n * @{\n */\n\n/**\n * @brief Initialize the Host Controller Interface. \n *        This function must be called before any data can be received \n *        from BLE controller.\n *\n * @param  pData: ACI events callback function pointer\n *         This callback is triggered when an user event is received from \n *         the BLE core device. \n * @param  pConf: Configuration structure pointer\n * @retval None\n */\nvoid hci_init(void(* UserEvtRx)(void* pData), void* pConf);\n\n/**\n * @brief  Processing function that must be called after an event is received from\n *         HCI interface. \n *         It must be called outside ISR. It will call user_notify() if necessary.\n *\n * @param  None\n * @retval None\n */ \nvoid hci_user_evt_proc(void);\n\n/**\n * @}\n */\n\n/**\n * @}\n */ \n\n/**\n * @}\n */  \n#endif /* __HCI_H_ */\n",
                "hci_const.h": "/******************************************************************************\n*\n*  File Description \n*  ---------------------\n* This file defines constants and functions for HCI layer.\n* See Bluetooth Core v 4.0, Vol. 2, Part E.\n* \n*******************************************************************************/\n\n#ifndef __HCI_CONST_H_\n#define __HCI_CONST_H_\n\n#include \"link_layer.h\"\n#include \"hci_tl.h\"\n#include \"compiler.h\"\n\n/* HCI Packet types */\n#define HCI_COMMAND_PKT     0x01\n#define HCI_ACLDATA_PKT     0x02\n#define HCI_SCODATA_PKT     0x03\n#define HCI_EVENT_PKT       0x04\n#define HCI_VENDOR_PKT      0xff\n\ntypedef __packed struct _hci_uart_pckt{\n  uint8_t type;\n  uint8_t data[VARIABLE_SIZE];\n} PACKED hci_uart_pckt;\n#define HCI_HDR_SIZE 1\n\ntypedef __packed struct _hci_command_hdr{\n  uint16_t opcode;\t\t/* OCF & OGF */\n  uint8_t  plen;\n} PACKED hci_command_hdr;\n#define HCI_COMMAND_HDR_SIZE  3\n\ntypedef __packed struct _hci_event_pckt{\n  uint8_t evt;\n  uint8_t plen;\n  uint8_t data[VARIABLE_SIZE];\n} PACKED hci_event_pckt;\n#define HCI_EVENT_HDR_SIZE  2\n\ntypedef __packed struct _hci_acl_hdr{\n  uint16_t handle;\t\t/* Handle & Flags(PB, BC) */\n  uint16_t dlen;\n} PACKED hci_acl_hdr;\n#define HCI_ACL_HDR_SIZE  4\n\n/* Link Control */\n#define OGF_LINK_CTL      0x01\n\n#define OCF_DISCONNECT    0x0006\ntypedef __packed struct _disconnect_cp{\n  uint16_t handle;\n  uint8_t  reason;\n} PACKED disconnect_cp;\n#define DISCONNECT_CP_SIZE  3\n\n/* Host Controller and Baseband */\n#define OGF_HOST_CTL            0x03\n\n#define OCF_SET_EVENT_MASK      0x0001\n#define OCF_RESET               0x0003\n\n#define OCF_READ_TRANSMIT_POWER_LEVEL\t0x002D\ntypedef __packed struct _read_transmit_power_level_cp{\n  uint16_t handle;\n  uint8_t  type;\n} PACKED read_transmit_power_level_cp;\n#define READ_TRANSMIT_POWER_LEVEL_CP_SIZE 3\ntypedef __packed struct _read_transmit_power_level_rp{\n  uint8_t  status;\n  uint16_t handle;\n  int8_t   level;\n} PACKED read_transmit_power_level_rp;\n#define READ_TRANSMIT_POWER_LEVEL_RP_SIZE 4\n\n#define OCF_SET_CONTROLLER_TO_HOST_FC   0x0031\n#define OCF_HOST_BUFFER_SIZE            0x0033\n#define OCF_HOST_NUM_COMP_PKTS          0x0035\n\n/* Informational Parameters */\n#define OGF_INFO_PARAM                  0x04\n\n#define OCF_READ_LOCAL_VERSION          0x0001\ntypedef __packed struct _read_local_version_rp{\n  uint8_t  status;\n  uint8_t  hci_version;\n  uint16_t hci_revision;\n  uint8_t  lmp_pal_version;\n  uint16_t manufacturer_name;\n  uint16_t lmp_pal_subversion;\n} PACKED read_local_version_rp;\n#define READ_LOCAL_VERSION_RP_SIZE      9\n\n#define OCF_READ_LOCAL_COMMANDS         0x0002\n#define OCF_READ_LOCAL_FEATURES         0x0003\n\n#define OCF_READ_BD_ADDR                0x0009\ntypedef __packed struct _read_bd_addr_rp{\n  uint8_t status;\n  tBDAddr bdaddr;\n} PACKED read_bd_addr_rp;\n#define READ_BD_ADDR_RP_SIZE            7\n\n/* Status params */\n#define OGF_STATUS_PARAM                0x05\n\n#define OCF_READ_RSSI                   0x0005\ntypedef __packed struct _read_rssi_cp{\n  uint16_t handle;\n} PACKED read_rssi_cp;\n#define READ_RSSI_CP_SIZE               2\ntypedef __packed struct _read_rssi_rp{\n  uint8_t  status;\n  uint16_t handle;\n  int8_t   rssi;\n} PACKED read_rssi_rp;\n#define READ_RSSI_RP_SIZE               4\n\n\n/* LE commands */\n#define OGF_LE_CTL                      0x08\n\n#define OCF_LE_SET_EVENT_MASK           0x0001\ntypedef __packed struct _le_set_event_mask_cp{\n  uint8_t mask[8];\n} PACKED le_set_event_mask_cp;\n#define LE_SET_EVENT_MASK_CP_SIZE       8\n\n#define OCF_LE_READ_BUFFER_SIZE         0x0002\ntypedef __packed struct _le_read_buffer_size_rp{\n  uint8_t  status;\n  uint16_t pkt_len;\n  uint8_t  max_pkt;\n} PACKED le_read_buffer_size_rp;\n#define LE_READ_BUFFER_SIZE_RP_SIZE     4\n\n#define OCF_LE_READ_LOCAL_SUPPORTED_FEATURES\t0x0003\ntypedef __packed struct _le_read_local_supported_features_rp{\n  uint8_t status;\n  uint8_t features[8];\n} PACKED le_read_local_supported_features_rp;\n#define LE_READ_LOCAL_SUPPORTED_FEATURES_RP_SIZE 9\n\n#define OCF_LE_SET_RANDOM_ADDRESS\t\t0x0005\ntypedef __packed struct _le_set_random_address_cp{\n  tBDAddr bdaddr;\n} PACKED le_set_random_address_cp;\n#define LE_SET_RANDOM_ADDRESS_CP_SIZE 6\n\n#define OCF_LE_SET_ADV_PARAMETERS\t0x0006\ntypedef __packed struct _le_set_adv_parameters_cp{\n  uint16_t min_interval;\n  uint16_t max_interval;\n  uint8_t  advtype;\n  uint8_t  own_bdaddr_type;\n  uint8_t  direct_bdaddr_type;\n  tBDAddr  direct_bdaddr;\n  uint8_t  chan_map;\n  uint8_t  filter;\n} PACKED le_set_adv_parameters_cp;\n#define LE_SET_ADV_PARAMETERS_CP_SIZE 15\n\n#define OCF_LE_READ_ADV_CHANNEL_TX_POWER\t0x0007\ntypedef __packed struct _le_read_adv_channel_tx_power_rp{\n  uint8_t status;\n  int8_t  level;\n} PACKED le_read_adv_channel_tx_power_rp;\n#define LE_READ_ADV_CHANNEL_TX_POWER_RP_SIZE 2\n\n#define OCF_LE_SET_ADV_DATA\t\t0x0008\ntypedef __packed struct _le_set_adv_data_cp{\n  uint8_t length;\n  uint8_t data[31];\n} PACKED le_set_adv_data_cp;\n#define LE_SET_ADV_DATA_CP_SIZE 32\n\n#define OCF_LE_SET_SCAN_RESPONSE_DATA\t\t0x0009\ntypedef __packed struct _le_set_scan_response_data_cp{\n  uint8_t length;\n  uint8_t data[31];\n} PACKED le_set_scan_response_data_cp;\n#define LE_SET_SCAN_RESPONSE_DATA_CP_SIZE 32\n\n#define OCF_LE_SET_ADVERTISE_ENABLE\t\t0x000A\ntypedef __packed struct _le_set_advertise_enable_cp{\n  uint8_t enable;\n} PACKED le_set_advertise_enable_cp;\n#define LE_SET_ADVERTISE_ENABLE_CP_SIZE 1\n\n#define OCF_LE_SET_SCAN_PARAMETERS\t\t0x000B\ntypedef __packed struct _le_set_scan_parameters_cp{\n  uint8_t  type;\n  uint16_t interval;\n  uint16_t window;\n  uint8_t  own_bdaddr_type;\n  uint8_t  filter;\n} PACKED le_set_scan_parameters_cp;\n#define LE_SET_SCAN_PARAMETERS_CP_SIZE 7\n\n#define OCF_LE_SET_SCAN_ENABLE\t\t\t0x000C\ntypedef __packed struct _le_set_scan_enable_cp{\n  uint8_t enable;\n  uint8_t filter_dup;\n} PACKED le_set_scan_enable_cp;\n#define LE_SET_SCAN_ENABLE_CP_SIZE 2\n\n#define OCF_LE_CREATE_CONN\t\t\t0x000D\ntypedef __packed struct _le_create_connection_cp{\n  uint16_t interval;\n  uint16_t window;\n  uint8_t  initiator_filter;\n  uint8_t  peer_bdaddr_type;\n  tBDAddr  peer_bdaddr;\n  uint8_t  own_bdaddr_type;\n  uint16_t min_interval;\n  uint16_t max_interval;\n  uint16_t latency;\n  uint16_t supervision_timeout;\n  uint16_t min_ce_length;\n  uint16_t max_ce_length;\n} PACKED le_create_connection_cp;\n#define LE_CREATE_CONN_CP_SIZE 25\n\n#define OCF_LE_CREATE_CONN_CANCEL\t\t0x000E\n\n#define OCF_LE_READ_WHITE_LIST_SIZE\t\t0x000F\ntypedef __packed struct _le_read_white_list_size_rp{\n  uint8_t status;\n  uint8_t size;\n} PACKED le_read_white_list_size_rp;\n#define LE_READ_WHITE_LIST_SIZE_RP_SIZE 2\n\n#define OCF_LE_CLEAR_WHITE_LIST\t\t\t0x0010\n\n#define OCF_LE_ADD_DEVICE_TO_WHITE_LIST\t\t0x0011\ntypedef __packed struct _le_add_device_to_white_list_cp{\n  uint8_t bdaddr_type;\n  tBDAddr bdaddr;\n} PACKED le_add_device_to_white_list_cp;\n#define LE_ADD_DEVICE_TO_WHITE_LIST_CP_SIZE 7\n\n#define OCF_LE_REMOVE_DEVICE_FROM_WHITE_LIST\t0x0012\ntypedef __packed struct _le_remove_device_from_white_list_cp{\n  uint8_t bdaddr_type;\n  tBDAddr bdaddr;\n} PACKED le_remove_device_from_white_list_cp;\n#define LE_REMOVE_DEVICE_FROM_WHITE_LIST_CP_SIZE 7\n\n#define OCF_LE_CONN_UPDATE\t\t\t0x0013\ntypedef __packed struct _le_connection_update_cp{\n  uint16_t handle;\n  uint16_t min_interval;\n  uint16_t max_interval;\n  uint16_t latency;\n  uint16_t supervision_timeout;\n  uint16_t min_ce_length;\n  uint16_t max_ce_length;\n} PACKED le_connection_update_cp;\n#define LE_CONN_UPDATE_CP_SIZE 14\n\n#define OCF_LE_SET_HOST_CHANNEL_CLASSIFICATION\t0x0014\ntypedef __packed struct _le_set_host_channel_classification_cp{\n  uint8_t map[5];\n} PACKED le_set_host_channel_classification_cp;\n#define LE_SET_HOST_CHANNEL_CLASSIFICATION_CP_SIZE 5\n\n#define OCF_LE_READ_CHANNEL_MAP\t\t\t0x0015\ntypedef __packed struct _le_read_channel_map_cp{\n  uint16_t handle;\n} PACKED le_read_channel_map_cp;\n#define LE_READ_CHANNEL_MAP_CP_SIZE 2\n\ntypedef __packed struct _le_read_channel_map_rp{\n  uint8_t  status;\n  uint16_t handle;\n  uint8_t  map[5];\n} PACKED le_read_channel_map_rp;\n#define LE_READ_CHANNEL_MAP_RP_SIZE 8\n\n#define OCF_LE_READ_REMOTE_USED_FEATURES\t0x0016\ntypedef __packed struct _le_read_remote_used_features_cp{\n  uint16_t handle;\n} PACKED le_read_remote_used_features_cp;\n#define LE_READ_REMOTE_USED_FEATURES_CP_SIZE 2\n\n#define OCF_LE_ENCRYPT\t\t\t\t0x0017\ntypedef __packed struct _le_encrypt_cp{\n  uint8_t key[16];\n  uint8_t plaintext[16];\n} PACKED le_encrypt_cp;\n#define LE_ENCRYPT_CP_SIZE 32\n\ntypedef __packed struct _le_encrypt_rp{\n  uint8_t status;\n  uint8_t encdata[16];\n} PACKED le_encrypt_rp;\n#define LE_ENCRYPT_RP_SIZE 17\n\n#define OCF_LE_RAND\t\t\t\t0x0018\ntypedef __packed struct _le_rand_rp{\n  uint8_t status;\n  uint8_t random[8];\n} PACKED le_rand_rp;\n#define LE_RAND_RP_SIZE 9\n\n#define OCF_LE_START_ENCRYPTION\t\t\t0x0019\ntypedef __packed struct _le_start_encryption_cp{\n  uint16_t handle;\n  uint8_t  random[8];\n  uint16_t diversifier;\n  uint8_t  key[16];\n} PACKED le_start_encryption_cp;\n#define LE_START_ENCRYPTION_CP_SIZE 28\n\n#define OCF_LE_LTK_REPLY\t\t\t0x001A\ntypedef __packed struct _le_ltk_reply_cp{\n  uint16_t handle;\n  uint8_t  key[16];\n} PACKED le_ltk_reply_cp;\n#define LE_LTK_REPLY_CP_SIZE 18\n\ntypedef __packed struct _le_ltk_reply_rp{\n  uint8_t  status;\n  uint16_t handle;\n} PACKED le_ltk_reply_rp;\n#define LE_LTK_REPLY_RP_SIZE 3\n\n#define OCF_LE_LTK_NEG_REPLY\t\t\t0x001B\ntypedef __packed struct _le_ltk_neg_reply_cp{\n  uint16_t handle;\n} PACKED le_ltk_neg_reply_cp;\n#define LE_LTK_NEG_REPLY_CP_SIZE 2\n\ntypedef __packed struct _le_ltk_neg_reply_rp{\n  uint8_t  status;\n  uint16_t handle;\n} PACKED le_ltk_neg_reply_rp;\n#define LE_LTK_NEG_REPLY_RP_SIZE 3\n\n#define OCF_LE_READ_SUPPORTED_STATES\t\t0x001C\ntypedef __packed struct _le_read_supported_states_rp{\n  uint8_t status;\n  uint8_t states[8];\n} PACKED le_read_supported_states_rp;\n#define LE_READ_SUPPORTED_STATES_RP_SIZE 9\n\n#define OCF_LE_RECEIVER_TEST\t\t\t0x001D\ntypedef __packed struct _le_receiver_test_cp{\n  uint8_t frequency;\n} PACKED le_receiver_test_cp;\n#define LE_RECEIVER_TEST_CP_SIZE 1\n\n#define OCF_LE_TRANSMITTER_TEST\t\t\t0x001E\ntypedef __packed struct _le_transmitter_test_cp{\n  uint8_t frequency;\n  uint8_t length;\n  uint8_t payload;\n} PACKED le_transmitter_test_cp;\n#define LE_TRANSMITTER_TEST_CP_SIZE 3\n\n#define OCF_LE_TEST_END\t\t\t\t0x001F\ntypedef __packed struct _le_test_end_rp{\n  uint8_t  status;\n  uint16_t num_pkts;\n} PACKED le_test_end_rp;\n#define LE_TEST_END_RP_SIZE 3\n\n/* Vendor specific commands */\n#define OGF_VENDOR_CMD\t\t0x3f\n\n\n/*------------- Events -------------*/\n#define EVT_CONN_COMPLETE\t\t0x03\ntypedef __packed struct _evt_conn_complete{\n  uint8_t  status;\n  uint16_t handle;\n  tBDAddr  bdaddr;\n  uint8_t  link_type;\n  uint8_t  encr_mode;\n} PACKED evt_conn_complete;\n#define EVT_CONN_COMPLETE_SIZE 13\n\n#define EVT_DISCONN_COMPLETE\t\t0x05\ntypedef __packed struct _evt_disconn_complete{\n  uint8_t  status;\n  uint16_t handle;\n  uint8_t  reason;\n} PACKED evt_disconn_complete;\n#define EVT_DISCONN_COMPLETE_SIZE 4\n\n#define EVT_ENCRYPT_CHANGE\t\t0x08\ntypedef __packed struct _evt_encrypt_change{\n  uint8_t  status;\n  uint16_t handle;\n  uint8_t  encrypt;\n} PACKED evt_encrypt_change;\n#define EVT_ENCRYPT_CHANGE_SIZE 5\n\n#define EVT_READ_REMOTE_VERSION_COMPLETE\t0x0C\n\n#define EVT_CMD_COMPLETE \t\t0x0E\ntypedef __packed struct _evt_cmd_complete{\n  uint8_t  ncmd;\n  uint16_t opcode;\n} PACKED evt_cmd_complete;\n#define EVT_CMD_COMPLETE_SIZE 3\n\n#define EVT_CMD_STATUS \t\t\t0x0F\ntypedef __packed struct _evt_cmd_status{\n  uint8_t  status;\n  uint8_t  ncmd;\n  uint16_t opcode;\n} PACKED evt_cmd_status;\n#define EVT_CMD_STATUS_SIZE 4\n\n#define EVT_HARDWARE_ERROR\t\t0x10\ntypedef __packed struct _evt_hardware_error{\n  uint8_t code;\n} PACKED evt_hardware_error;\n#define EVT_HARDWARE_ERROR_SIZE 1\n\n#define EVT_NUM_COMP_PKTS\t\t0x13\ntypedef __packed struct _evt_num_comp_pkts{\n  uint8_t num_hndl;\n  /* variable length part */\n} PACKED evt_num_comp_pkts;\n#define EVT_NUM_COMP_PKTS_SIZE 1\n\n/* variable length part of evt_num_comp_pkts. */\ntypedef __packed struct _evt_num_comp_pkts_param{\n  uint16_t hndl;\n  uint16_t num_comp_pkts;\n} PACKED evt_num_comp_pkts_param;\n#define EVT_NUM_COMP_PKTS_PARAM_SIZE 1\n\n#define EVT_DATA_BUFFER_OVERFLOW\t\t0x1A\ntypedef __packed struct _evt_data_buffer_overflow{\n  uint8_t link_type;\n} PACKED evt_data_buffer_overflow;\n#define EVT_DATA_BUFFER_OVERFLOW_SIZE 1\n\n#define EVT_ENCRYPTION_KEY_REFRESH_COMPLETE\t0x30\ntypedef __packed struct _evt_encryption_key_refresh_complete{\n  uint8_t  status;\n  uint16_t handle;\n} PACKED evt_encryption_key_refresh_complete;\n#define EVT_ENCRYPTION_KEY_REFRESH_COMPLETE_SIZE 3\n\n#define EVT_LE_META_EVENT\t0x3E\ntypedef __packed struct _evt_le_meta_event{\n  uint8_t subevent;\n  uint8_t data[VARIABLE_SIZE];\n} PACKED evt_le_meta_event;\n#define EVT_LE_META_EVENT_SIZE 1\n\n#define EVT_LE_CONN_COMPLETE\t0x01\ntypedef __packed struct _evt_le_connection_complete{\n  uint8_t  status;\n  uint16_t handle;\n  uint8_t  role;\n  uint8_t  peer_bdaddr_type;\n  tBDAddr  peer_bdaddr;\n  uint16_t interval;\n  uint16_t latency;\n  uint16_t supervision_timeout;\n  uint8_t  master_clock_accuracy;\n} PACKED evt_le_connection_complete;\n#define EVT_LE_CONN_COMPLETE_SIZE 18\n\n#define EVT_LE_ADVERTISING_REPORT\t0x02\ntypedef __packed struct _le_advertising_info{\n  uint8_t evt_type;\n  uint8_t bdaddr_type;\n  tBDAddr bdaddr;\n  uint8_t data_length;\n  uint8_t data_RSSI[VARIABLE_SIZE]; // RSSI is last octect (signed integer).\n} PACKED le_advertising_info;\n#define LE_ADVERTISING_INFO_SIZE 9\n\n#define EVT_LE_CONN_UPDATE_COMPLETE\t0x03\ntypedef __packed struct _evt_le_connection_update_complete{\n  uint8_t  status;\n  uint16_t handle;\n  uint16_t interval;\n  uint16_t latency;\n  uint16_t supervision_timeout;\n} PACKED evt_le_connection_update_complete;\n#define EVT_LE_CONN_UPDATE_COMPLETE_SIZE 9\n\n#define EVT_LE_READ_REMOTE_USED_FEATURES_COMPLETE\t0x04\ntypedef __packed struct _evt_le_read_remote_used_features_complete{\n  uint8_t  status;\n  uint16_t handle;\n  uint8_t  features[8];\n} PACKED evt_le_read_remote_used_features_complete;\n#define EVT_LE_READ_REMOTE_USED_FEATURES_COMPLETE_SIZE 11\n\n#define EVT_LE_LTK_REQUEST\t0x05\ntypedef __packed struct _evt_le_long_term_key_request{\n  uint16_t handle;\n  uint8_t  random[8];\n  uint16_t ediv;\n} PACKED evt_le_long_term_key_request;\n#define EVT_LE_LTK_REQUEST_SIZE 12\n\n/**\n* The event code in the @ref hci_event_pckt structure. If event code is EVT_VENDOR,\n* application can use @ref evt_blue_aci structure to parse the packet.\n*/\n#define EVT_VENDOR\t0xFF\n\n\n/* Command opcode pack/unpack */\n#define cmd_opcode_pack(ogf, ocf)   (uint16_t)((ocf & 0x03ff)|(ogf << 10))\n#define cmd_opcode_ogf(op)          (op >> 10)\n#define cmd_opcode_ocf(op)          (op & 0x03ff)\n\ntypedef enum {\n  WAITING_TYPE,\n  WAITING_OPCODE1,\n  WAITING_OPCODE2,\n  WAITING_EVENT_CODE,\n  WAITING_HANDLE,\n  WAITING_HANDLE_FLAG,\n  WAITING_PARAM_LEN,\n  WAITING_DATA_LEN1,\n  WAITING_DATA_LEN2,\n  WAITING_PAYLOAD\n} hci_state;\n\ntypedef void (*hci_packet_complete_callback)(void *pckt, uint16_t len);\n\n#endif /* __HCI_CONST_H_ */\n",
                "hci_le.c": "/**\n  ******************************************************************************\n  * @file    hci_le.c \n  * @author  AMG RF  Application Team\n  * @brief   Function for managing HCI interface.\n  ******************************************************************************\n  *\n  *\n  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\n  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\n  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\n  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\n  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\n  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\n  *\n  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>\n  */ \n\n#include \"hci_le.h\"\n#include \"bluenrg_types.h\"\n#include \"bluenrg_def.h\"\n#include \"hci_const.h\"\n#include \"bluenrg_conf.h\"\n\n#define MIN(a,b)            ((a) < (b) )? (a) : (b)\n#define MAX(a,b)            ((a) > (b) )? (a) : (b)\n\nint hci_reset(void)\n{\n  struct hci_request rq;\n  uint8_t status;\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_HOST_CTL;\n  rq.ocf = OCF_RESET;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  return status;  \n}\n\nint hci_disconnect(uint16_t handle, uint8_t reason)\n{\n  struct hci_request rq;\n  disconnect_cp cp;\n  uint8_t status;\n  \n  cp.handle = handle;\n  cp.reason = reason;\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_LINK_CTL;\n  rq.ocf = OCF_DISCONNECT;\n  rq.cparam = &cp;\n  rq.clen = DISCONNECT_CP_SIZE;\n  rq.event = EVT_CMD_STATUS;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  return status;  \n}\n\nint hci_le_read_local_version(uint8_t *hci_version, uint16_t *hci_revision, uint8_t *lmp_pal_version, \n                              uint16_t *manufacturer_name, uint16_t *lmp_pal_subversion)\n{\n  struct hci_request rq;\n  read_local_version_rp resp;\n  \n  BLUENRG_memset(&resp, 0, sizeof(resp));\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_INFO_PARAM;\n  rq.ocf = OCF_READ_LOCAL_VERSION;\n  rq.cparam = NULL;\n  rq.clen = 0;\n  rq.rparam = &resp;\n  rq.rlen = READ_LOCAL_VERSION_RP_SIZE;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  if (resp.status) {\n    return resp.status;\n  }\n  \n  \n  *hci_version = resp.hci_version;\n  *hci_revision =  btohs(resp.hci_revision);\n  *lmp_pal_version = resp.lmp_pal_version;\n  *manufacturer_name = btohs(resp.manufacturer_name);\n  *lmp_pal_subversion = btohs(resp.lmp_pal_subversion);\n  \n  return 0;\n}\n\nint hci_le_read_buffer_size(uint16_t *pkt_len, uint8_t *max_pkt)\n{\n  struct hci_request rq;\n  le_read_buffer_size_rp resp;\n  \n  BLUENRG_memset(&resp, 0, sizeof(resp));\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_LE_CTL;\n  rq.ocf = OCF_LE_READ_BUFFER_SIZE;\n  rq.cparam = NULL;\n  rq.clen = 0;\n  rq.rparam = &resp;\n  rq.rlen = LE_READ_BUFFER_SIZE_RP_SIZE;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  if (resp.status) {\n    return resp.status;\n  }\n  \n  *pkt_len = resp.pkt_len;\n  *max_pkt = resp.max_pkt;\n  \n  return 0;\n}\n\nint hci_le_set_advertising_parameters(uint16_t min_interval, uint16_t max_interval, uint8_t advtype,\n                                      uint8_t own_bdaddr_type, uint8_t direct_bdaddr_type, const tBDAddr direct_bdaddr, uint8_t chan_map,\n                                      uint8_t filter)\n{\n  struct hci_request rq;\n  le_set_adv_parameters_cp adv_cp;\n  uint8_t status;\n  \n  BLUENRG_memset(&adv_cp, 0, sizeof(adv_cp));\n  adv_cp.min_interval = min_interval;\n  adv_cp.max_interval = max_interval;\n  adv_cp.advtype = advtype;\n  adv_cp.own_bdaddr_type = own_bdaddr_type;\n  adv_cp.direct_bdaddr_type = direct_bdaddr_type;\n  if(direct_bdaddr != NULL)\n    BLUENRG_memcpy(adv_cp.direct_bdaddr,direct_bdaddr,sizeof(adv_cp.direct_bdaddr));\n  adv_cp.chan_map = chan_map;\n  adv_cp.filter = filter;\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_LE_CTL;\n  rq.ocf = OCF_LE_SET_ADV_PARAMETERS;\n  rq.cparam = &adv_cp;\n  rq.clen = LE_SET_ADV_PARAMETERS_CP_SIZE;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  return status;\n}\n\nint hci_le_set_advertising_data(uint8_t length, const uint8_t data[])\n{\n  struct hci_request rq;\n  le_set_adv_data_cp adv_cp;\n  uint8_t status;\n  \n  BLUENRG_memset(&adv_cp, 0, sizeof(adv_cp));\n  adv_cp.length = length;\n  BLUENRG_memcpy(adv_cp.data, data, MIN(31,length));\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_LE_CTL;\n  rq.ocf = OCF_LE_SET_ADV_DATA;\n  rq.cparam = &adv_cp;\n  rq.clen = LE_SET_ADV_DATA_CP_SIZE;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  return status;\n}\n\nint hci_le_set_advertise_enable(uint8_t enable)\n{\n  struct hci_request rq;\n  le_set_advertise_enable_cp adv_cp;\n  uint8_t status;\n  \n  BLUENRG_memset(&adv_cp, 0, sizeof(adv_cp));\n  adv_cp.enable = enable?1:0;\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_LE_CTL;\n  rq.ocf = OCF_LE_SET_ADVERTISE_ENABLE;\n  rq.cparam = &adv_cp;\n  rq.clen = LE_SET_ADVERTISE_ENABLE_CP_SIZE;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  return status;\n}\n\nint hci_le_set_scan_parameters(uint8_t\ttype, uint16_t interval,\n                               uint16_t window, uint8_t own_bdaddr_type,\n                               uint8_t\tfilter)\n{\n  struct hci_request rq;\n  le_set_scan_parameters_cp scan_cp;\n  uint8_t status;\n  \n  BLUENRG_memset(&scan_cp, 0, sizeof(scan_cp));\n  scan_cp.type = type;\n  scan_cp.interval = interval;\n  scan_cp.window = window;\n  scan_cp.own_bdaddr_type = own_bdaddr_type;\n  scan_cp.filter = filter;\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_LE_CTL;\n  rq.ocf = OCF_LE_SET_SCAN_PARAMETERS;\n  rq.cparam = &scan_cp;\n  rq.clen = LE_SET_SCAN_PARAMETERS_CP_SIZE;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  return status;\n}\n\nint hci_le_set_scan_enable(uint8_t enable, uint8_t filter_dup)\n{\n  struct hci_request rq;\n  le_set_scan_enable_cp scan_cp;\n  uint8_t status;\n  \n  BLUENRG_memset(&scan_cp, 0, sizeof(scan_cp));\n  scan_cp.enable = enable?1:0;\n  scan_cp.filter_dup = filter_dup;\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_LE_CTL;\n  rq.ocf = OCF_LE_SET_SCAN_ENABLE;\n  rq.cparam = &scan_cp;\n  rq.clen = LE_SET_SCAN_ENABLE_CP_SIZE;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  return status;\n}\n\nint hci_le_rand(uint8_t random_number[8])\n{\n  struct hci_request rq;\n  le_rand_rp resp;\n  \n  BLUENRG_memset(&resp, 0, sizeof(resp));\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_LE_CTL;\n  rq.ocf = OCF_LE_RAND;\n  rq.cparam = NULL;\n  rq.clen = 0;\n  rq.rparam = &resp;\n  rq.rlen = LE_RAND_RP_SIZE;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  if (resp.status) {\n    return resp.status;\n  }\n  \n  BLUENRG_memcpy(random_number, resp.random, 8);\n  \n  return 0;\n}\n\nint hci_le_set_scan_resp_data(uint8_t length, const uint8_t data[])\n{\n  struct hci_request rq;\n  le_set_scan_response_data_cp scan_resp_cp;\n  uint8_t status;\n  \n  BLUENRG_memset(&scan_resp_cp, 0, sizeof(scan_resp_cp));\n  scan_resp_cp.length = length;\n  BLUENRG_memcpy(scan_resp_cp.data, data, MIN(31,length));\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_LE_CTL;\n  rq.ocf = OCF_LE_SET_SCAN_RESPONSE_DATA;\n  rq.cparam = &scan_resp_cp;\n  rq.clen = LE_SET_SCAN_RESPONSE_DATA_CP_SIZE;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  return status;\n}\n\nint hci_le_read_advertising_channel_tx_power(int8_t *tx_power_level)\n{\n  struct hci_request rq;\n  le_read_adv_channel_tx_power_rp resp;\n  \n  BLUENRG_memset(&resp, 0, sizeof(resp));\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_LE_CTL;\n  rq.ocf = OCF_LE_READ_ADV_CHANNEL_TX_POWER;\n  rq.cparam = NULL;\n  rq.clen = 0;\n  rq.rparam = &resp;\n  rq.rlen = LE_RAND_RP_SIZE;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  if (resp.status) {\n    return resp.status;\n  }\n  \n  *tx_power_level = resp.level;\n  \n  return 0;\n}\n\nint hci_le_set_random_address(tBDAddr bdaddr)\n{\n  struct hci_request rq;\n  le_set_random_address_cp set_rand_addr_cp;\n  uint8_t status;\n  \n  BLUENRG_memset(&set_rand_addr_cp, 0, sizeof(set_rand_addr_cp));\n  BLUENRG_memcpy(set_rand_addr_cp.bdaddr, bdaddr, sizeof(tBDAddr));\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_LE_CTL;\n  rq.ocf = OCF_LE_SET_RANDOM_ADDRESS;\n  rq.cparam = &set_rand_addr_cp;\n  rq.clen = LE_SET_RANDOM_ADDRESS_CP_SIZE;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  return status;\n}\n\nint hci_read_bd_addr(tBDAddr bdaddr)\n{\n  struct hci_request rq;\n  read_bd_addr_rp resp;\n  \n  BLUENRG_memset(&resp, 0, sizeof(resp));\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_INFO_PARAM;\n  rq.ocf = OCF_READ_BD_ADDR;\n  rq.cparam = NULL;\n  rq.clen = 0;\n  rq.rparam = &resp;\n  rq.rlen = READ_BD_ADDR_RP_SIZE;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  if (resp.status) {\n    return resp.status;\n  }\n  BLUENRG_memcpy(bdaddr, resp.bdaddr, sizeof(tBDAddr));\n  \n  return 0;\n}\n\nint hci_le_create_connection(uint16_t interval,\tuint16_t window, uint8_t initiator_filter, uint8_t peer_bdaddr_type,\n                             const tBDAddr peer_bdaddr,\tuint8_t\town_bdaddr_type, uint16_t min_interval,\tuint16_t max_interval,\n                             uint16_t latency,\tuint16_t supervision_timeout, uint16_t min_ce_length, uint16_t max_ce_length)\n{\n  struct hci_request rq;\n  le_create_connection_cp create_cp;\n  uint8_t status;\n  \n  BLUENRG_memset(&create_cp, 0, sizeof(create_cp));\n  create_cp.interval = interval;\n  create_cp.window =  window;\n  create_cp.initiator_filter = initiator_filter;\n  create_cp.peer_bdaddr_type = peer_bdaddr_type;\n  BLUENRG_memcpy(create_cp.peer_bdaddr, peer_bdaddr, sizeof(tBDAddr));\n  create_cp.own_bdaddr_type = own_bdaddr_type;\n  create_cp.min_interval=min_interval;\n  create_cp.max_interval=max_interval;\n  create_cp.latency = latency;\n  create_cp.supervision_timeout=supervision_timeout;\n  create_cp.min_ce_length=min_ce_length;\n  create_cp.max_ce_length=max_ce_length;\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_LE_CTL;\n  rq.ocf = OCF_LE_CREATE_CONN;\n  rq.cparam = &create_cp;\n  rq.clen = LE_CREATE_CONN_CP_SIZE;\n  rq.event = EVT_CMD_STATUS;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  return status;\n}\n\nint hci_le_create_connection_cancel(void)\n{\n  struct hci_request rq;\n  uint8_t status;\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_LE_CTL;\n  rq.ocf = OCF_LE_CREATE_CONN_CANCEL;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  return status;  \n}\n\nint hci_le_encrypt(uint8_t key[16], uint8_t plaintextData[16], uint8_t encryptedData[16])\n{\n  struct hci_request rq;\n  le_encrypt_cp params;\n  le_encrypt_rp resp;\n  \n  BLUENRG_memset(&resp, 0, sizeof(resp));\n  \n  BLUENRG_memcpy(params.key, key, 16);\n  BLUENRG_memcpy(params.plaintext, plaintextData, 16);\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_LE_CTL;\n  rq.ocf = OCF_LE_ENCRYPT;\n  rq.cparam = &params;\n  rq.clen = LE_ENCRYPT_CP_SIZE;\n  rq.rparam = &resp;\n  rq.rlen = LE_ENCRYPT_RP_SIZE;\n  \n  if (hci_send_req(&rq, FALSE) < 0){\n    return BLE_STATUS_TIMEOUT;\n  }\n  \n  if (resp.status) {\n    return resp.status;\n  }\n  \n  BLUENRG_memcpy(encryptedData, resp.encdata, 16);\n  \n  return 0;\n}\n\nint hci_le_ltk_request_reply(uint8_t key[16])\n{\n  struct hci_request rq;\n  le_ltk_reply_cp params;\n  le_ltk_reply_rp resp;\n  \n  BLUENRG_memset(&resp, 0, sizeof(resp));\n  \n  params.handle = 1;\n  BLUENRG_memcpy(params.key, key, 16);\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_LE_CTL;\n  rq.ocf = OCF_LE_LTK_REPLY;\n  rq.cparam = &params;\n  rq.clen = LE_LTK_REPLY_CP_SIZE;\n  rq.rparam = &resp;\n  rq.rlen = LE_LTK_REPLY_RP_SIZE;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  return resp.status;\n}\n\nint hci_le_ltk_request_neg_reply(void)\n{\n  struct hci_request rq;\n  le_ltk_neg_reply_cp params;\n  le_ltk_neg_reply_rp resp;\n  \n  BLUENRG_memset(&resp, 0, sizeof(resp));\n  \n  params.handle = 1;\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_LE_CTL;\n  rq.ocf = OCF_LE_LTK_NEG_REPLY;\n  rq.cparam = &params;\n  rq.clen = LE_LTK_NEG_REPLY_CP_SIZE;\n  rq.rparam = &resp;\n  rq.rlen = LE_LTK_NEG_REPLY_RP_SIZE;\n  \n  if (hci_send_req(&rq, FALSE) < 0)\n    return BLE_STATUS_TIMEOUT;\n  \n  return resp.status;\n}\n\nint hci_le_read_white_list_size(uint8_t *size)\n{\n  struct hci_request rq;\n  le_read_white_list_size_rp resp;\n  \n  BLUENRG_memset(&resp, 0, sizeof(resp));\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_LE_CTL;\n  rq.ocf = OCF_LE_READ_WHITE_LIST_SIZE;\n  rq.rparam = &resp;\n  rq.rlen = LE_READ_WHITE_LIST_SIZE_RP_SIZE;\n  \n  if (hci_send_req(&rq, FALSE) < 0){\n    return BLE_STATUS_TIMEOUT;\n  }\n  \n  if (resp.status) {\n    return resp.status;\n  }\n  \n  *size = resp.size;\n  \n  return 0;\n}\n\nint hci_le_clear_white_list(void)\n{\n  struct hci_request rq;\n  uint8_t status;\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_LE_CTL;\n  rq.ocf = OCF_LE_CLEAR_WHITE_LIST;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0){\n    return BLE_STATUS_TIMEOUT;\n  }\n  \n  return status;\n}\n\nint hci_le_add_device_to_white_list(uint8_t\tbdaddr_type, tBDAddr bdaddr)\n{\n  struct hci_request rq;\n  le_add_device_to_white_list_cp params;\n  uint8_t status;\n  \n  params.bdaddr_type = bdaddr_type;\n  BLUENRG_memcpy(params.bdaddr, bdaddr, 6);\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_LE_CTL;\n  rq.ocf = OCF_LE_ADD_DEVICE_TO_WHITE_LIST;\n  rq.cparam = &params;\n  rq.clen = LE_ADD_DEVICE_TO_WHITE_LIST_CP_SIZE;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0){\n    return BLE_STATUS_TIMEOUT;\n  }\n  \n  return status;\n}\n\nint hci_le_remove_device_from_white_list(uint8_t bdaddr_type, tBDAddr bdaddr)\n{\n  struct hci_request rq;\n  le_remove_device_from_white_list_cp params;\n  uint8_t status;\n  \n  params.bdaddr_type = bdaddr_type;\n  BLUENRG_memcpy(params.bdaddr, bdaddr, 6);\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_LE_CTL;\n  rq.ocf = OCF_LE_REMOVE_DEVICE_FROM_WHITE_LIST;\n  rq.cparam = &params;\n  rq.clen = LE_REMOVE_DEVICE_FROM_WHITE_LIST_CP_SIZE;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0){\n    return BLE_STATUS_TIMEOUT;\n  }\n  \n  return status;\n}\n\nint hci_read_transmit_power_level(uint16_t *conn_handle, uint8_t type, int8_t * tx_level)\n{\n  struct hci_request rq;\n  read_transmit_power_level_cp params;\n  read_transmit_power_level_rp resp;\n  \n  BLUENRG_memset(&resp, 0, sizeof(resp));\n  \n  params.handle = *conn_handle;\n  params.type = type;\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_HOST_CTL;\n  rq.ocf = OCF_READ_TRANSMIT_POWER_LEVEL;\n  rq.cparam = &params;\n  rq.clen = READ_TRANSMIT_POWER_LEVEL_CP_SIZE;\n  rq.rparam = &resp;\n  rq.rlen = READ_TRANSMIT_POWER_LEVEL_RP_SIZE;\n  \n  if (hci_send_req(&rq, FALSE) < 0){\n    return BLE_STATUS_TIMEOUT;\n  }\n  \n  if (resp.status) {\n    return resp.status;\n  }\n  \n  *conn_handle = resp.handle;\n  *tx_level = resp.level;\n  \n  return 0;\n}\n\nint hci_read_rssi(uint16_t *conn_handle, int8_t * rssi)\n{\n  struct hci_request rq;\n  read_rssi_cp params;\n  read_rssi_rp resp;\n  \n  BLUENRG_memset(&resp, 0, sizeof(resp));\n  \n  params.handle = *conn_handle;\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_STATUS_PARAM;\n  rq.ocf = OCF_READ_RSSI;\n  rq.cparam = &params;\n  rq.clen = READ_RSSI_CP_SIZE;\n  rq.rparam = &resp;\n  rq.rlen = READ_RSSI_RP_SIZE;\n  \n  if (hci_send_req(&rq, FALSE) < 0){\n    return BLE_STATUS_TIMEOUT;\n  }\n  \n  if (resp.status) {\n    return resp.status;\n  }\n  \n  *conn_handle = resp.handle;\n  *rssi = resp.rssi;\n  \n  return 0;\n}\n\nint hci_le_read_local_supported_features(uint8_t *features)\n{\n  struct hci_request rq;\n  le_read_local_supported_features_rp resp;\n  \n  BLUENRG_memset(&resp, 0, sizeof(resp));\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_LE_CTL;\n  rq.ocf = OCF_LE_READ_LOCAL_SUPPORTED_FEATURES;\n  rq.rparam = &resp;\n  rq.rlen = LE_READ_LOCAL_SUPPORTED_FEATURES_RP_SIZE;\n  \n  if (hci_send_req(&rq, FALSE) < 0){\n    return BLE_STATUS_TIMEOUT;\n  }\n  \n  if (resp.status) {\n    return resp.status;\n  }\n  \n  BLUENRG_memcpy(features, resp.features, sizeof(resp.features));\n  \n  return 0;\n}\n\nint hci_le_read_channel_map(uint16_t conn_handle, uint8_t ch_map[5])\n{\n  struct hci_request rq;\n  le_read_channel_map_cp params;\n  le_read_channel_map_rp resp;\n  \n  BLUENRG_memset(&resp, 0, sizeof(resp));\n  \n  params.handle = conn_handle;\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_LE_CTL;\n  rq.ocf = OCF_LE_READ_CHANNEL_MAP;\n  rq.cparam = &params;\n  rq.clen = LE_READ_CHANNEL_MAP_CP_SIZE;\n  rq.rparam = &resp;\n  rq.rlen = LE_READ_CHANNEL_MAP_RP_SIZE;\n  \n  if (hci_send_req(&rq, FALSE) < 0){\n    return BLE_STATUS_TIMEOUT;\n  }\n  \n  if (resp.status) {\n    return resp.status;\n  }\n  \n  BLUENRG_memcpy(ch_map, resp.map, 5);\n  \n  return 0;\n}\n\nint hci_le_read_supported_states(uint8_t states[8])\n{\n  struct hci_request rq;\n  le_read_supported_states_rp resp;\n  \n  BLUENRG_memset(&resp, 0, sizeof(resp));\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_LE_CTL;\n  rq.ocf = OCF_LE_READ_SUPPORTED_STATES;\n  rq.rparam = &resp;\n  rq.rlen = LE_READ_SUPPORTED_STATES_RP_SIZE;\n  \n  if (hci_send_req(&rq, FALSE) < 0){\n    return BLE_STATUS_TIMEOUT;\n  }\n  \n  if (resp.status) {\n    return resp.status;\n  }\n  \n  BLUENRG_memcpy(states, resp.states, 8);\n  \n  return 0;\n}\n\nint hci_le_receiver_test(uint8_t frequency)\n{\n  struct hci_request rq;\n  le_receiver_test_cp params;\n  uint8_t status;\n  \n  params.frequency = frequency;\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_LE_CTL;\n  rq.ocf = OCF_LE_RECEIVER_TEST;\n  rq.cparam = &params;\n  rq.clen = LE_RECEIVER_TEST_CP_SIZE;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0){\n    return BLE_STATUS_TIMEOUT;\n  }\n  \n  return status;\n}\n\nint hci_le_transmitter_test(uint8_t frequency, uint8_t length, uint8_t payload)\n{\n  struct hci_request rq;\n  le_transmitter_test_cp params;\n  uint8_t status;\n  \n  params.frequency = frequency;\n  params.length = length;\n  params.payload = payload;\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_LE_CTL;\n  rq.ocf = OCF_LE_TRANSMITTER_TEST;\n  rq.cparam = &params;\n  rq.clen = LE_TRANSMITTER_TEST_CP_SIZE;\n  rq.rparam = &status;\n  rq.rlen = 1;\n  \n  if (hci_send_req(&rq, FALSE) < 0){\n    return BLE_STATUS_TIMEOUT;\n  }\n  \n  return status;\n}\n\nint hci_le_test_end(uint16_t *num_pkts)\n{\n  struct hci_request rq;\n  le_test_end_rp resp;\n  \n  BLUENRG_memset(&resp, 0, sizeof(resp));\n  \n  BLUENRG_memset(&rq, 0, sizeof(rq));\n  rq.ogf = OGF_LE_CTL;\n  rq.ocf = OCF_LE_TEST_END;\n  rq.rparam = &resp;\n  rq.rlen = LE_TEST_END_RP_SIZE;\n  \n  if (hci_send_req(&rq, FALSE) < 0){\n    return BLE_STATUS_TIMEOUT;\n  }\n  \n  if (resp.status) {\n    return resp.status;\n  }\n  \n  *num_pkts = resp.num_pkts;\n  \n  return 0;\n}\n",
                "hci_le.h": "/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************\n* File Name          : hci_le.h\n* Author             : AMG RF FW team\n* Version            : V1.1.0\n* Date               : 18-July-2016\n* Description        : Constants and functions for HCI layer. See Bluetooth Core\n*                       v 4.1, Vol. 2, Part E.\n********************************************************************************\n* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\n* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.\n* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,\n* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE\n* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING\n* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\n*******************************************************************************/\n\n#ifndef __HCI_LE_H_\n#define __HCI_LE_H_\n\n#include \"bluenrg_types.h\"\n#include \"link_layer.h\"\n\n/** \n * @addtogroup HIGH_LEVEL_INTERFACE HIGH_LEVEL_INTERFACE\n * @{\n */\n\n/**\n * @defgroup HCI_LE HCI_LE\n * @brief API for HCI LE layer.\n * @{\n */\n\n/**\n * @defgroup HCI_Error_codes HCI Error codes\n * @{\n */\n#define HCI_UNKNOWN_COMMAND\t\t\t0x01\n#define HCI_NO_CONNECTION\t\t\t0x02\n#define HCI_HARDWARE_FAILURE\t\t\t0x03\n#define HCI_PAGE_TIMEOUT\t\t\t0x04\n#define HCI_AUTHENTICATION_FAILURE\t\t0x05\n#define HCI_PIN_OR_KEY_MISSING\t\t\t0x06\n#define HCI_MEMORY_FULL\t\t\t\t0x07\n#define HCI_CONNECTION_TIMEOUT\t\t\t0x08\n#define HCI_MAX_NUMBER_OF_CONNECTIONS\t\t0x09\n#define HCI_MAX_NUMBER_OF_SCO_CONNECTIONS\t0x0a\n#define HCI_ACL_CONNECTION_EXISTS\t\t0x0b\n#define HCI_COMMAND_DISALLOWED\t\t\t0x0c\n#define HCI_REJECTED_LIMITED_RESOURCES\t\t0x0d\n#define HCI_REJECTED_SECURITY\t\t\t0x0e\n#define HCI_REJECTED_PERSONAL\t\t\t0x0f\n#define HCI_HOST_TIMEOUT\t\t\t0x10\n#define HCI_UNSUPPORTED_FEATURE\t\t\t0x11\n#define HCI_INVALID_PARAMETERS\t\t\t0x12\n#define HCI_OE_USER_ENDED_CONNECTION\t\t0x13\n#define HCI_OE_LOW_RESOURCES\t\t\t0x14\n#define HCI_OE_POWER_OFF\t\t\t0x15\n#define HCI_CONNECTION_TERMINATED\t\t0x16\n#define HCI_REPEATED_ATTEMPTS\t\t\t0x17\n#define HCI_PAIRING_NOT_ALLOWED\t\t\t0x18\n#define HCI_UNKNOWN_LMP_PDU\t\t\t0x19\n#define HCI_UNSUPPORTED_REMOTE_FEATURE\t\t0x1a\n#define HCI_SCO_OFFSET_REJECTED\t\t        0x1b\n#define HCI_SCO_INTERVAL_REJECTED\t\t0x1c\n#define HCI_AIR_MODE_REJECTED\t\t\t0x1d\n#define HCI_INVALID_LMP_PARAMETERS\t\t0x1e\n#define HCI_UNSPECIFIED_ERROR\t\t\t0x1f\n#define HCI_UNSUPPORTED_LMP_PARAMETER_VALUE\t0x20\n#define HCI_ROLE_CHANGE_NOT_ALLOWED\t\t0x21\n#define HCI_LMP_RESPONSE_TIMEOUT\t\t0x22\n#define HCI_LMP_ERROR_TRANSACTION_COLLISION\t0x23\n#define HCI_LMP_PDU_NOT_ALLOWED\t\t\t0x24\n#define HCI_ENCRYPTION_MODE_NOT_ACCEPTED\t0x25\n#define HCI_UNIT_LINK_KEY_USED\t\t\t0x26\n#define HCI_QOS_NOT_SUPPORTED\t\t\t0x27\n#define HCI_INSTANT_PASSED\t\t\t0x28\n#define HCI_PAIRING_NOT_SUPPORTED\t\t0x29\n#define HCI_TRANSACTION_COLLISION\t\t0x2a\n#define HCI_QOS_UNACCEPTABLE_PARAMETER\t\t0x2c\n#define HCI_QOS_REJECTED\t\t\t0x2d\n#define HCI_CLASSIFICATION_NOT_SUPPORTED\t0x2e\n#define HCI_INSUFFICIENT_SECURITY\t\t0x2f\n#define HCI_PARAMETER_OUT_OF_RANGE\t\t0x30\n#define HCI_ROLE_SWITCH_PENDING\t\t\t0x32\n#define HCI_SLOT_VIOLATION\t\t\t0x34\n#define HCI_ROLE_SWITCH_FAILED\t\t\t0x35\n#define HCI_EIR_TOO_LARGE\t\t\t0x36\n#define HCI_SIMPLE_PAIRING_NOT_SUPPORTED\t0x37\n#define HCI_HOST_BUSY_PAIRING\t\t\t0x38\n#define HCI_CONN_REJ_NO_CH_FOUND\t\t0x39\n#define HCI_CONTROLLER_BUSY\t\t\t0x3A\n#define HCI_UNACCEPTABLE_CONN_INTERV\t\t0x3B\n#define HCI_DIRECTED_ADV_TIMEOUT\t\t0x3C\n#define HCI_CONN_TERM_MIC_FAIL\t\t\t0x3D\n#define HCI_CONN_FAIL_TO_BE_ESTABL\t\t0x3E\n#define HCI_MAC_CONN_FAILED\t\t\t0x3F\n/**\n * @}\n */\n\n\n/*\n * HCI library functions.\n * Each function returns 0 in case of success, otherwise one of the error codes.\n */\n\nint hci_reset(void);\n\nint hci_disconnect(uint16_t handle, uint8_t reason);\n\nint hci_le_set_advertise_enable(uint8_t enable);\n\nint hci_le_set_advertising_parameters(uint16_t min_interval, uint16_t max_interval, uint8_t advtype,\n\t\tuint8_t own_bdaddr_type, uint8_t direct_bdaddr_type, const tBDAddr direct_bdaddr, uint8_t chan_map,\n\t\tuint8_t filter);\n\nint hci_le_set_scan_parameters(uint8_t\ttype, uint16_t interval,\n                               uint16_t window, uint8_t own_bdaddr_type,\n                               uint8_t\tfilter);\n\nint hci_le_set_scan_enable(uint8_t enable, uint8_t filter_dup);\n\nint hci_le_set_advertising_data(uint8_t length, const uint8_t data[]);\n\nint hci_le_set_scan_resp_data(uint8_t length, const uint8_t data[]);\n\nint hci_le_rand(uint8_t random_number[8]);\n\nint hci_le_read_advertising_channel_tx_power(int8_t *tx_power_level);\n\nint hci_acl_data(const uint8_t * data, uint16_t len);\n\nint hci_le_set_random_address(tBDAddr bdaddr);\n\nint hci_read_bd_addr(tBDAddr bdaddr);\n\nint hci_le_read_white_list_size(uint8_t *size);\n\nint hci_le_clear_white_list(void);\n\nint hci_le_add_device_to_white_list(uint8_t bdaddr_type, tBDAddr bdaddr);\n\nint hci_le_remove_device_from_white_list(uint8_t bdaddr_type, tBDAddr bdaddr);\n\nint hci_le_encrypt(uint8_t key[16], uint8_t plaintextData[16], uint8_t encryptedData[16]);\n\nint hci_le_ltk_request_reply(uint8_t key[16]);\n\nint hci_le_ltk_request_neg_reply(void);\n\nint hci_le_read_buffer_size(uint16_t *pkt_len, uint8_t *max_pkt);\n\nint hci_le_create_connection(uint16_t interval,\tuint16_t window, uint8_t initiator_filter, uint8_t peer_bdaddr_type,\n                             const tBDAddr peer_bdaddr,\tuint8_t\town_bdaddr_type, uint16_t min_interval,\tuint16_t max_interval,\n                             uint16_t latency,\tuint16_t supervision_timeout, uint16_t min_ce_length, uint16_t max_ce_length);\n\nint hci_le_create_connection_cancel(void);\n\nint hci_read_transmit_power_level(uint16_t *conn_handle, uint8_t type, int8_t * tx_level);\n\nint hci_read_rssi(uint16_t *conn_handle, int8_t * rssi);\n\nint hci_le_read_local_supported_features(uint8_t *features);\n\nint hci_le_read_channel_map(uint16_t conn_handle, uint8_t ch_map[5]);\n\nint hci_le_read_supported_states(uint8_t states[8]);\n\nint hci_le_receiver_test(uint8_t frequency);\n\nint hci_le_transmitter_test(uint8_t frequency, uint8_t length, uint8_t payload);\n\nint hci_le_test_end(uint16_t *num_pkts);\n\nint hci_le_read_local_version(uint8_t *hci_version, uint16_t *hci_revision, uint8_t *lmp_pal_version, \n\t\t\t      uint16_t *manufacturer_name, uint16_t *lmp_pal_subversion);\n\n/**\n * @}\n */\n\n/**\n * @}\n */\n\n/**\n * @}\n */\n\n\n#endif /* __HCI_LE_H_ */\n",
                "hci_tl.c": "/**\n  ******************************************************************************\n  * @file    hci_tl.c \n  * @author  AMG RF Application Team\n  * @version V1.0.0\n  * @date    18-Jan-2018\n  * @brief   Contains the basic functions for managing the framework required\n  *          for handling the HCI interface\n  ******************************************************************************\n  *\n  * <h2><center>&copy; Copyright (c) 2018 STMicroelectronics</center></h2>\n  * All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without \n  * modification, are permitted, provided that the following conditions are met:\n  *\n  * 1. Redistribution of source code must retain the above copyright notice, \n  *    this list of conditions and the following disclaimer.\n  * 2. Redistributions in binary form must reproduce the above copyright notice,\n  *    this list of conditions and the following disclaimer in the documentation\n  *    and/or other materials provided with the distribution.\n  * 3. Neither the name of STMicroelectronics nor the names of other \n  *    contributors to this software may be used to endorse or promote products \n  *    derived from this software without specific written permission.\n  * 4. This software, including modifications and/or derivative works of this \n  *    software, must execute solely and exclusively on microcontroller or\n  *    microprocessor devices manufactured by or for STMicroelectronics.\n  * 5. Redistribution and use of this software other than as permitted under \n  *    this license is void and will automatically terminate your rights under \n  *    this license. \n  *\n  * THIS SOFTWARE IS PROVIDED BY STMICROELECTRONICS AND CONTRIBUTORS \"AS IS\" \n  * AND ANY EXPRESS, IMPLIED OR STATUTORY WARRANTIES, INCLUDING, BUT NOT \n  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A \n  * PARTICULAR PURPOSE AND NON-INFRINGEMENT OF THIRD PARTY INTELLECTUAL PROPERTY\n  * RIGHTS ARE DISCLAIMED TO THE FULLEST EXTENT PERMITTED BY LAW. IN NO EVENT \n  * SHALL STMICROELECTRONICS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, \n  * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF \n  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING \n  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n  *\n  ******************************************************************************\n*/ \n#include \"hci_const.h\"\n#include \"hci.h\"\n#include \"hci_tl.h\"\n\n#define HCI_LOG_ON                      0\n#define HCI_PCK_TYPE_OFFSET             0\n#define EVENT_PARAMETER_TOT_LEN_OFFSET  2\n\n/**\n * Increase this parameter to overcome possible issues due to BLE devices crowded environment \n * or high number of incoming notifications from peripheral devices \n */\n#define HCI_READ_PACKET_NUM_MAX \t   (5)\n\n#define MIN(a,b)      ((a) < (b))? (a) : (b)\n#define MAX(a,b)      ((a) > (b))? (a) : (b)\n\ntListNode             hciReadPktPool;\ntListNode             hciReadPktRxQueue;\nstatic tHciDataPacket hciReadPacketBuffer[HCI_READ_PACKET_NUM_MAX];\nstatic tHciContext    hciContext;\n\n/************************* Static internal functions **************************/\n\n/**\n  * @brief  Verify the packet type.\n  *\n  * @param  hciReadPacket The HCI data packet\n  * @retval 0: valid packet, 1: incorrect packet, 2: wrong length (packet truncated or too long)\n  */\nstatic int verify_packet(const tHciDataPacket * hciReadPacket)\n{\n  const uint8_t *hci_pckt = hciReadPacket->dataBuff;\n  \n  if (hci_pckt[HCI_PCK_TYPE_OFFSET] != HCI_EVENT_PKT)\n    return 1; /* Incorrect type */\n  \n  if (hci_pckt[EVENT_PARAMETER_TOT_LEN_OFFSET] != hciReadPacket->data_len - (1+HCI_EVENT_HDR_SIZE))\n    return 2; /* Wrong length (packet truncated or too long) */\n  \n  return 0;      \n}\n\n/**\n  * @brief  Send an HCI command.\n  *\n  * @param  ogf The Opcode Group Field\n  * @param  ocf The Opcode Command Field\n  * @param  plen The HCI command length\n  * @param  param The HCI command parameters\n  * @retval None\n  */\nstatic void send_cmd(uint16_t ogf, uint16_t ocf, uint8_t plen, void *param)\n{\n  uint8_t payload[HCI_MAX_PAYLOAD_SIZE];  \n  hci_command_hdr hc;\n  \n  hc.opcode = htobs(cmd_opcode_pack(ogf, ocf));\n  hc.plen = plen;\n\n  payload[0] = HCI_COMMAND_PKT;\n  BLUENRG_memcpy(payload + 1, &hc, sizeof(hc));\n  BLUENRG_memcpy(payload + HCI_HDR_SIZE + HCI_COMMAND_HDR_SIZE, param, plen);\n  \n  if (hciContext.io.Send)\n  {\n    hciContext.io.Send (payload, HCI_HDR_SIZE + HCI_COMMAND_HDR_SIZE + plen);\n  }\n}\n\n/**\n  * @brief  Remove the tail from a source list and insert it to the head \n  *         of a destination list.\n  *\n  * @param  dest_list\n  * @param  src_list\n  * @retval None\n  */\nstatic void move_list(tListNode * dest_list, tListNode * src_list)\n{\n  pListNode tmp_node;\n  \n  while (!list_is_empty(src_list))\n  {\n    list_remove_tail(src_list, &tmp_node);\n    list_insert_head(dest_list, tmp_node);\n  }\n}\n\n/**\n  * @brief  Free the HCI event list.\n  *\n  * @param  None\n  * @retval None\n  */\nstatic void free_event_list(void)\n{\n  tHciDataPacket * pckt;\n  \n  while(list_get_size(&hciReadPktPool) < HCI_READ_PACKET_NUM_MAX/2){\n    list_remove_head(&hciReadPktRxQueue, (tListNode **)&pckt);    \n    list_insert_tail(&hciReadPktPool, (tListNode *)pckt);\n  }\n}\n\n/********************** HCI Transport layer functions *****************************/\n\nvoid hci_init(void(* UserEvtRx)(void* pData), void* pConf)\n{\n  uint8_t index;\n  \n  if(UserEvtRx != NULL)\n  {\n    hciContext.UserEvtRx = UserEvtRx;\n  }\n  \n  /* Initialize TL BLE layer */\n  hci_tl_lowlevel_init();\n  \n  /* Initialize list heads of ready and free hci data packet queues */\n  list_init_head(&hciReadPktPool);\n  list_init_head(&hciReadPktRxQueue);\n  \n  /* Initialize the queue of free hci data packets */\n  for (index = 0; index < HCI_READ_PACKET_NUM_MAX; index++)\n  {\n    list_insert_tail(&hciReadPktPool, (tListNode *)&hciReadPacketBuffer[index]);\n  } \n  \n  /* Initialize low level driver */\n  if (hciContext.io.Init)  hciContext.io.Init(NULL);\n  if (hciContext.io.Reset) hciContext.io.Reset();\n}\n\nvoid hci_register_io_bus(tHciIO* fops)\n{\n  /* Register bus function */\n  hciContext.io.Init    = fops->Init; \n  hciContext.io.Receive = fops->Receive;  \n  hciContext.io.Send    = fops->Send;\n  hciContext.io.GetTick = fops->GetTick;\n  hciContext.io.Reset   = fops->Reset;    \n}\n\nint hci_send_req(struct hci_request* r, BOOL async)\n{\n  uint8_t *ptr;\n  uint16_t opcode = htobs(cmd_opcode_pack(r->ogf, r->ocf));\n  hci_event_pckt *event_pckt;\n  hci_uart_pckt *hci_hdr;\n\n  tHciDataPacket * hciReadPacket = NULL;\n  tListNode hciTempQueue;\n  \n  list_init_head(&hciTempQueue);\n\n  free_event_list();\n  \n  send_cmd(r->ogf, r->ocf, r->clen, r->cparam);\n  \n  if (async)\n  {\n    return 0;\n  }\n  \n  while (1) \n  {\n    evt_cmd_complete  *cc;\n    evt_cmd_status    *cs;\n    evt_le_meta_event *me;\n    uint32_t len;\n    \n    uint32_t tickstart = ATMO_PLATFORM_UptimeMs();\n      \n    while (1)\n    {\n      if ((ATMO_PLATFORM_UptimeMs() - tickstart) > HCI_DEFAULT_TIMEOUT_MS)\n      {\n        goto failed;\n      }\n      \n      if (!list_is_empty(&hciReadPktRxQueue)) \n      {\n        break;\n      }\n    }\n    \n    /* Extract packet from HCI event queue. */\n    list_remove_head(&hciReadPktRxQueue, (tListNode **)&hciReadPacket);    \n    \n    hci_hdr = (void *)hciReadPacket->dataBuff;\n\n    if (hci_hdr->type == HCI_EVENT_PKT)\n    {\n      event_pckt = (void *)(hci_hdr->data);\n    \n      ptr = hciReadPacket->dataBuff + (1 + HCI_EVENT_HDR_SIZE);\n      len = hciReadPacket->data_len - (1 + HCI_EVENT_HDR_SIZE);\n    \n      switch (event_pckt->evt) \n      {      \n      case EVT_CMD_STATUS:\n        cs = (void *) ptr;\n        \n        if (cs->opcode != opcode)\n          goto failed;\n        \n        if (r->event != EVT_CMD_STATUS) {\n          if (cs->status) {\n            goto failed;\n          }\n          break;\n        }\n\n        r->rlen = MIN(len, r->rlen);\n        BLUENRG_memcpy(r->rparam, ptr, r->rlen);\n        goto done;\n      \n      case EVT_CMD_COMPLETE:\n        cc = (void *) ptr;\n      \n        if (cc->opcode != opcode)\n          goto failed;\n      \n        ptr += EVT_CMD_COMPLETE_SIZE;\n        len -= EVT_CMD_COMPLETE_SIZE;\n      \n        r->rlen = MIN(len, r->rlen);\n        BLUENRG_memcpy(r->rparam, ptr, r->rlen);\n        goto done;\n      \n      case EVT_LE_META_EVENT:\n        me = (void *) ptr;\n      \n        if (me->subevent != r->event)\n          break;\n      \n        len -= 1;\n        r->rlen = MIN(len, r->rlen);\n        BLUENRG_memcpy(r->rparam, me->data, r->rlen);\n        goto done;\n      \n      case EVT_HARDWARE_ERROR:            \n        goto failed;\n      \n      default:      \n        break;\n      }\n    }\n    \n    /* If there are no more packets to be processed, be sure there is at list one\n       packet in the pool to process the expected event.\n       If no free packets are available, discard the processed event and insert it\n       into the pool. */\n    if (list_is_empty(&hciReadPktPool) && list_is_empty(&hciReadPktRxQueue)) {\n      list_insert_tail(&hciReadPktPool, (tListNode *)hciReadPacket);\n      hciReadPacket=NULL;\n    }\n    else {\n      /* Insert the packet in a different queue. These packets will be\n      inserted back in the main queue just before exiting from send_req(), so that\n      these events can be processed by the application.\n    */\n    list_insert_tail(&hciTempQueue, (tListNode *)hciReadPacket);\n      hciReadPacket=NULL;\n    }\n  }\n  \nfailed: \n  if (hciReadPacket!=NULL) {\n    list_insert_head(&hciReadPktPool, (tListNode *)hciReadPacket);\n  }\n  move_list(&hciReadPktRxQueue, &hciTempQueue);  \n  return -1;\n  \ndone:\n  /* Insert the packet back into the pool.*/\n  list_insert_head(&hciReadPktPool, (tListNode *)hciReadPacket); \n  move_list(&hciReadPktRxQueue, &hciTempQueue);\n  return 0;\n}\n\nvoid hci_user_evt_proc(void)\n{\n  tHciDataPacket * hciReadPacket = NULL;\n     \n  /* process any pending events read */\n  while (list_is_empty(&hciReadPktRxQueue) == FALSE)\n  {\n    list_remove_head (&hciReadPktRxQueue, (tListNode **)&hciReadPacket);\n    if (hciContext.UserEvtRx != NULL)\n    {\n      hciContext.UserEvtRx(hciReadPacket->dataBuff);\n    }\n    list_insert_tail(&hciReadPktPool, (tListNode *)hciReadPacket);\n  }\n}\n\nint32_t hci_notify_asynch_evt(void* pdata)\n{\n  tHciDataPacket * hciReadPacket = NULL;\n  uint8_t data_len;\n  \n  int32_t ret = 0;\n  \n  if (list_is_empty (&hciReadPktPool) == FALSE)\n  {\n    /* Queuing a packet to read */\n    list_remove_head (&hciReadPktPool, (tListNode **)&hciReadPacket);\n    \n    if (hciContext.io.Receive)\n    {\n      data_len = hciContext.io.Receive(hciReadPacket->dataBuff, HCI_READ_PACKET_SIZE);\n      if (data_len > 0)\n      {                    \n        hciReadPacket->data_len = data_len;\n        if (verify_packet(hciReadPacket) == 0)\n          list_insert_tail(&hciReadPktRxQueue, (tListNode *)hciReadPacket);\n        else\n          list_insert_head(&hciReadPktPool, (tListNode *)hciReadPacket);          \n      }\n      else \n      {\n        /* Insert the packet back into the pool*/\n        list_insert_head(&hciReadPktPool, (tListNode *)hciReadPacket);\n      }\n    }\n  }\n  else \n  {\n    ret = 1;\n  }\n  return ret;\n\n}\n\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\n",
                "hci_tl.h": "/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************\n* File Name          : hci.h\n* Author             : AMG RF FW team\n* Version            : V1.1.0\n* Date               : 18-July-2016\n* Description        : Header file for framework required for handling HCI interface.\n********************************************************************************\n* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\n* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.\n* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,\n* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE\n* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING\n* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\n*******************************************************************************/\n\n#ifndef __HCI_TL_H_\n#define __HCI_TL_H_\n\n#include \"hci_tl_interface.h\"\n#include \"bluenrg_types.h\"\n#include \"ble_list.h\"\n#include \"bluenrg_conf.h\"\n\n/** \n * @addtogroup LOW_LEVEL_INTERFACE LOW_LEVEL_INTERFACE\n * @{\n */\n  \n/** \n * @defgroup LL_HCI_TL HCI_TL\n * @{\n */\n\n/** \n * @defgroup BASIC BASIC\n * @{\n */\n \n/** @defgroup BASIC_Types Exported Types\n * @{\n */ \n\n/**\n * @brief Structure hosting the HCI request\n * @{\n */ \nstruct hci_request {\n  uint16_t ogf;     /**< Opcode Group Field */\n  uint16_t ocf;     /**< Opcode Command Field */\n  uint32_t event;   /**< HCI Event */\n  void     *cparam; /**< HCI Command from MCU to Host */\n  uint32_t clen;    /**< Command Length */\n  void     *rparam; /**< Response from Host to MCU */\n  uint32_t rlen;    /**< Response Length */\n};\n/**\n * @}\n */\n \n/**\n * @brief Structure used to read received HCI data packet\n * @{\n */\ntypedef struct _tHciDataPacket\n{\n  tListNode currentNode;\n  uint8_t dataBuff[HCI_READ_PACKET_SIZE];\n  uint8_t data_len;\n} tHciDataPacket;\n/**\n * @}\n */\n\n/**\n * @brief Structure used to manage the BUS IO operations.\n *        All the structure fields will point to functions defined at user level.\n * @{\n */ \ntypedef struct\n{                \n  int32_t (* Init)    (void* pConf); /**< Pointer to HCI TL function for the IO Bus initialization */\n  int32_t (* DeInit)  (void); /**< Pointer to HCI TL function for the IO Bus de-initialization */  \n  int32_t (* Reset)   (void); /**< Pointer to HCI TL function for the IO Bus reset */    \n  int32_t (* Receive) (uint8_t*, uint16_t); /**< Pointer to HCI TL function for the IO Bus data reception */\n  int32_t (* Send)    (uint8_t*, uint16_t); /**< Pointer to HCI TL function for the IO Bus data transmission */\n  int32_t (* DataAck) (uint8_t*, uint16_t* len); /**< Pointer to HCI TL function for the IO Bus data ack reception */\t\n  int32_t (* GetTick) (void); /**< Pointer to BSP function for getting the HAL time base timestamp */    \n} tHciIO;\n/**\n * @}\n */\n\n/**\n * @brief Describe the HCI flow status\n * @{\n */ \ntypedef enum\n{     \n  HCI_DATA_FLOW_DISABLE = 0,\n  HCI_DATA_FLOW_ENABLE,\n} tHciflowStatus;\n/**\n * @}\n */\n \n/**\n * @brief Contain the HCI context\n * @{\n */\ntypedef struct\n{   \n  tHciIO io; /**< Manage the BUS IO operations */\n  void (* UserEvtRx) (void * pData); /**< ACI events callback function pointer */  \n} tHciContext;\n\n/**\n * @}\n */ \n \n/**\n * @}\n */\n \n/** @defgroup BASIC_Functions Exported Functions\n * @{\n */\n\n/**\n  * @brief  Send an HCI request either in synchronous or in asynchronous mode.\n  *\n  * @param  r: The HCI request\n  * @param  async: TRUE if asynchronous mode, FALSE if synchronous mode\n  * @retval int: 0 when success, -1 when failure\n  */\nint hci_send_req(struct hci_request *r, BOOL async);\n \n/**\n * @brief  Register IO bus services.\n *         The tHciIO structure is initialized here by assigning to each structure field a  \n *         function for managing the IO Bus.\n *         E.g. In case the user needs to register the SPI bus services:\n *         @code\n           void hci_register_io_bus(tHciIO* fops)\n           {\t\t\t \n             hciContext.io.Init    = fops->Init; \n             hciContext.io.Receive = fops->Receive;  \n             hciContext.io.Send    = fops->Send;\n             hciContext.io.GetTick = fops->GetTick;\n             hciContext.io.Reset   = fops->Reset;    \n           }\n *         @endcode\n *         where:\n *         - hciContext is a static variable defined in the hci_tl.c\n *         - all fops fields are initialized, at user level (hci_tl_interface.c file), in the \n *           void hci_tl_lowlevel_init(void) function. All the functions for managing the initialization,\n *           de-initialization, data sending/receiving, ... must be implemented by the user.\n *         e.g. \n *         @code\n           void hci_tl_lowlevel_init(void)\n           {\n             tHciIO fops;  \n  \n             //Register IO bus services \n             fops.Init    = HCI_TL_SPI_Init;\n             fops.DeInit  = HCI_TL_SPI_DeInit;\n             fops.Send    = HCI_TL_SPI_Send;\n             fops.Receive = HCI_TL_SPI_Receive;\n             fops.Reset   = HCI_TL_SPI_Reset;\n             fops.GetTick = BSP_GetTick;\n  \n             hci_register_io_bus (&fops);\n  \n             //Register event irq handler\n             ... ... ...\n           }\n *         @endcode\n *            \n * @param  fops The HCI IO structure managing the IO BUS\n * @retval None\n */\nvoid hci_register_io_bus(tHciIO* fops);\n  \n/**\n * @brief  Interrupt service routine that must be called when the BlueNRG \n *         reports a packet received or an event to the host through the \n *         BlueNRG-MS interrupt line.\n *\n * @param  pdata Packet or event pointer\n * @retval 0: packet/event processed, 1: no packet/event processed \n */\nint32_t hci_notify_asynch_evt(void* pdata);\n\n/**\n * @brief  This function resume the User Event Flow which has been stopped on return \n *         from UserEvtRx() when the User Event has not been processed.\n *\n * @param  None\n * @retval None\n */\nvoid hci_resume_flow(void);\n\n/**\n * @brief  This function is called when an ACI/HCI command is sent and the response \n *         is waited from the BLE core.\n *         The application shall implement a mechanism to not return from this function \n *         until the waited event is received.\n *         This is notified to the application with hci_cmd_resp_release().\n *         It is called from the same context the HCI command has been sent.\n *\n * @param  timeout: Waiting timeout\n * @retval None\n */\nvoid hci_cmd_resp_wait(uint32_t timeout);\n\n/**\n * @brief  This function is called when an ACI/HCI command is sent and the response is\n *         received from the BLE core.\n *\n * @param  flag: Release flag\n * @retval None\n */\nvoid hci_cmd_resp_release(uint32_t flag);\n\n/**\n * @}\n */\n \n/**\n * @}\n */\n \n/**\n * @}\n */\n \n/**\n * @}\n */\n \n#endif /* __HCI_TL_H_ */\n",
                "hci_tl_interface.c": "/**\n  ******************************************************************************\n  * @file  : hci_tl_interface.c\n  * @brief : This file provides the implementation for all functions prototypes \n  *          for the STM32 BlueNRG-MS HCI Transport Layer interface\n  ******************************************************************************\n  *\n  * COPYRIGHT 2019 STMicroelectronics\n  *\n  * Licensed under MCD-ST Liberty SW License Agreement V2, (the \"License\");\n  * You may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at:\n  *\n  *        http://www.st.com/software_license_agreement_liberty_v2\n  *\n  * Unless required by applicable law or agreed to in writing, software \n  * distributed under the License is distributed on an \"AS IS\" BASIS, \n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  ******************************************************************************\n  */\n\n/* Includes ------------------------------------------------------------------*/\n\n#include \"hci_tl.h\"\n#include \"bluenrg.h\"\n\n#define HEADER_SIZE       5U\n#define MAX_BUFFER_SIZE   255U\n#define TIMEOUT_DURATION  15U\n\n/******************** IO Operation and BUS services ***************************/\n\nvoid _BLUENRG_ISR(void *data)\n{\n    hci_tl_lowlevel_isr();\n}\n\n/**\n * @brief  Initializes the peripherals communication with the BlueNRG\n *         Expansion Board (via SPI, I2C, USART, ...)\n *\n * @param  void* Pointer to configuration struct \n * @retval int32_t Status\n */\nint32_t HCI_TL_SPI_Init(void* pConf)\n{\n  // Set SPI Master Device\n  ATMO_SPI_Device_t device;\n  device.msbFirst = true;\n  device.clockMode = ATMO_SPI_ClockMode_0;\n  device.baudRate = 2500000;\n  device.clockContinuous = false;\n  device.ssContinuous = true;\n  device.ssActiveLow = true;\n  ATMO_SPI_MasterSetDeviceConfiguration(BLUENRG_GetConfig()->spiHandle, ATMO_SPI_CS_NONE, &device);\n\n  ATMO_GPIO_Config_t gpioConf;\n  gpioConf.pinMode = ATMO_GPIO_PinMode_Output_PushPull;\n  gpioConf.initialState = ATMO_GPIO_PinState_High;\n  ATMO_GPIO_SetPinConfiguration(BLUENRG_GetConfig()->gpioHandle, BLUENRG_GetConfig()->rstPin, &gpioConf);\n  ATMO_GPIO_SetPinConfiguration(BLUENRG_GetConfig()->gpioHandle, BLUENRG_GetConfig()->csPin, &gpioConf);\n\n  gpioConf.pinMode = ATMO_GPIO_PinMode_Input_HighImpedance;\n  ATMO_GPIO_SetPinConfiguration(BLUENRG_GetConfig()->gpioHandle, BLUENRG_GetConfig()->intPin, &gpioConf);\n  ATMO_GPIO_RegisterInterruptCallback(BLUENRG_GetConfig()->gpioHandle, BLUENRG_GetConfig()->intPin, ATMO_GPIO_InterruptTrigger_RisingEdge | ATMO_GPIO_InterruptTrigger_DirectCallback, _BLUENRG_ISR);\n\n  return 0;\n}\n\n/**\n * @brief  DeInitializes the peripherals communication with the BlueNRG\n *         Expansion Board (via SPI, I2C, USART, ...)\n *\n * @param  None\n * @retval int32_t 0\n */\nint32_t HCI_TL_SPI_DeInit(void)\n{\n  return 0;\n}\n\n/**\n * @brief Reset BlueNRG module.\n *\n * @param  None\n * @retval int32_t 0\n */\nint32_t HCI_TL_SPI_Reset(void)\n{\n  ATMO_GPIO_SetPinState(BLUENRG_GetConfig()->gpioHandle, BLUENRG_GetConfig()->rstPin, ATMO_GPIO_PinState_Low);\n  ATMO_PLATFORM_DelayMilliseconds(5);\n  ATMO_GPIO_SetPinState(BLUENRG_GetConfig()->gpioHandle, BLUENRG_GetConfig()->rstPin, ATMO_GPIO_PinState_High);\n  ATMO_PLATFORM_DelayMilliseconds(5);    \n  return 0;\n}  \n\n/**\n * @brief  Reads from BlueNRG SPI buffer and store data into local buffer.\n *\n * @param  buffer : Buffer where data from SPI are stored\n * @param  size   : Buffer size\n * @retval int32_t: Number of read bytes\n */\nint32_t HCI_TL_SPI_Receive(uint8_t* buffer, uint16_t size)\n{\n  uint16_t byte_count;\n  uint8_t len = 0;\n  uint8_t char_ff = 0xff;\n  volatile uint8_t read_char;\n\n  uint8_t header_master[HEADER_SIZE] = {0x0b, 0x00, 0x00, 0x00, 0x00};\n  uint8_t header_slave[HEADER_SIZE];\n\n  /* CS reset */\n  ATMO_GPIO_SetPinState(BLUENRG_GetConfig()->gpioHandle, BLUENRG_GetConfig()->csPin, ATMO_GPIO_PinState_Low);\n\n  ATMO_SPI_MasterRead(BLUENRG_GetConfig()->spiHandle, BLUENRG_GetConfig()->csPin, header_master, HEADER_SIZE, header_slave, HEADER_SIZE, 1000);\n  \t\n  if(header_slave[0] == 0x02) \n  {\n    /* device is ready */\n    byte_count = (header_slave[4] << 8)| header_slave[3];\n  \n    if(byte_count > 0) {\n  \n      /* avoid to read more data that size of the buffer */\n\n      if (byte_count > size){\n        byte_count = size;\n      }        \n  \n      for(len = 0; len < byte_count; len++)\n      {                                               \n        ATMO_SPI_MasterRead(BLUENRG_GetConfig()->spiHandle, BLUENRG_GetConfig()->csPin, &char_ff, 1, (uint8_t *)&read_char, 1, 1000);\n        buffer[len] = read_char;\n      }      \n    }    \n  }\n\n  ATMO_GPIO_SetPinState(BLUENRG_GetConfig()->gpioHandle, BLUENRG_GetConfig()->csPin, ATMO_GPIO_PinState_High);\n\n  \n#if PRINT_CSV_FORMAT\n  if (len > 0) {\n    print_csv_time();\n    for (int i=0; i<len; i++) {\n      PRINT_CSV(\" %02x\", buffer[i]);\n    }\n    PRINT_CSV(\"\\n\");\n  }\n#endif\n  \n  return len;  \n}\n\n/**\n * @brief  Writes data from local buffer to SPI.\n *\n * @param  buffer : data buffer to be written\n * @param  size   : size of first data buffer to be written\n * @retval int32_t: Number of read bytes\n */\nint32_t HCI_TL_SPI_Send(uint8_t* buffer, uint16_t size)\n{  \n  int32_t result;  \n  \n  uint8_t header_master[HEADER_SIZE] = {0x0a, 0x00, 0x00, 0x00, 0x00};\n  uint8_t header_slave[HEADER_SIZE];\n  \n  static uint8_t read_char_buf[MAX_BUFFER_SIZE];\n  uint64_t tickstart = ATMO_PLATFORM_UptimeMs();\n  \n  do\n  {\n    result = 0;\n    \n    /* CS reset */\n    ATMO_GPIO_SetPinState(BLUENRG_GetConfig()->gpioHandle, BLUENRG_GetConfig()->csPin, ATMO_GPIO_PinState_Low);\n\n    ATMO_SPI_MasterRead(BLUENRG_GetConfig()->spiHandle, BLUENRG_GetConfig()->csPin, header_master, HEADER_SIZE, header_slave, HEADER_SIZE, 1000);\n    \n    if(header_slave[0] == 0x02) \n    {\n      /* SPI is ready */\n      if(header_slave[1] >= size) \n      {\n        ATMO_SPI_MasterRead(BLUENRG_GetConfig()->spiHandle, BLUENRG_GetConfig()->csPin, buffer, size, read_char_buf, size, 1000);\n      } \n      else \n      {\n        /* Buffer is too small */\n        result = -2;\n      }\n    } else {\n      /* SPI is not ready */\n      result = -1;\n    }\n    \n    /* Release CS line */\n    ATMO_GPIO_SetPinState(BLUENRG_GetConfig()->gpioHandle, BLUENRG_GetConfig()->csPin, ATMO_GPIO_PinState_High);\n    \n    if((ATMO_PLATFORM_UptimeMs() - tickstart) > TIMEOUT_DURATION)\n    {\n      result = -3;\n      break;\n    }\n  } while(result < 0);\n  \n  return result;\n}\n\n/**\n * @brief  Reports if the BlueNRG has data for the host micro.\n *\n * @param  None\n * @retval int32_t: 1 if data are present, 0 otherwise\n */\nstatic int32_t IsDataAvailable(void)\n{\n    return (ATMO_GPIO_Read(BLUENRG_GetConfig()->gpioHandle, BLUENRG_GetConfig()->intPin) == ATMO_GPIO_PinState_High);\n} \n\nstatic int32_t _BLUENRG_GetTick()\n{\n    return (int32_t)ATMO_PLATFORM_UptimeMs();\n}\n\n/***************************** hci_tl_interface main functions *****************************/\n/**\n * @brief  Register hci_tl_interface IO bus services\n *\n * @param  None\n * @retval None\n */ \nvoid hci_tl_lowlevel_init(void)\n{\n  /* USER CODE BEGIN hci_tl_lowlevel_init 1 */\n  \n  /* USER CODE END hci_tl_lowlevel_init 1 */\n  tHciIO fops;  \n  \n  /* Register IO bus services */\n  fops.Init    = HCI_TL_SPI_Init;\n  fops.DeInit  = HCI_TL_SPI_DeInit;\n  fops.Send    = HCI_TL_SPI_Send;\n  fops.Receive = HCI_TL_SPI_Receive;\n  fops.Reset   = HCI_TL_SPI_Reset;\n  fops.GetTick = _BLUENRG_GetTick;\n  \n  hci_register_io_bus (&fops);\n}\n\n/**\n  * @brief HCI Transport Layer Low Level Interrupt Service Routine\n  *\n  * @param  None\n  * @retval None\n  */\nvoid hci_tl_lowlevel_isr(void)\n{\n  /* Call hci_notify_asynch_evt() */\n  while(IsDataAvailable())\n  {        \n    if (hci_notify_asynch_evt(NULL))\n    {\n      return;\n    }\n  }\n\n  /* USER CODE BEGIN hci_tl_lowlevel_isr */\n\n  /* USER CODE END hci_tl_lowlevel_isr */ \n}\n\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\n",
                "hci_tl_interface.h": "/**\n  ******************************************************************************\n  * @file    hci_tl_interface_template.h\n  * @author  CL\n  * @version V1.0.0\n  * @date    04-July-2014\n  * @brief   \n  ******************************************************************************\n  * @attention\n  *\n  * <h2><center>&copy; COPYRIGHT(c) 2014 STMicroelectronics</center></h2>\n  *\n  * Redistribution and use in source and binary forms, with or without modification,\n  * are permitted provided that the following conditions are met:\n  *   1. Redistributions of source code must retain the above copyright notice,\n  *      this list of conditions and the following disclaimer.\n  *   2. Redistributions in binary form must reproduce the above copyright notice,\n  *      this list of conditions and the following disclaimer in the documentation\n  *      and/or other materials provided with the distribution.\n  *   3. Neither the name of STMicroelectronics nor the names of its contributors\n  *      may be used to endorse or promote products derived from this software\n  *      without specific prior written permission.\n  *\n  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n  *\n  ******************************************************************************\n  */ \n  \n/* Define to prevent recursive inclusion -------------------------------------*/\n#ifndef __HCI_TL_INTERFACE_H\n#define __HCI_TL_INTERFACE_H\n\n#ifdef __cplusplus\n extern \"C\" {\n#endif \n\n/** \n * @addtogroup LOW_LEVEL_INTERFACE LOW_LEVEL_INTERFACE\n * @{\n */\n \n/** \n * @defgroup LL_HCI_TL_INTERFACE HCI_TL_INTERFACE\n * @{\n */\n \n/** \n * @defgroup LL_HCI_TL_INTERFACE_TEMPLATE TEMPLATE\n * @{\n */ \n\n/* Includes ------------------------------------------------------------------*/\n\n/* Exported Defines ----------------------------------------------------------*/\n\n/* Exported Functions --------------------------------------------------------*/\n/** \n * @defgroup LL_HCI_TL_INTERFACE_TEMPLATE_Functions Exported Functions\n * @{\n */\n/**\n * @brief  Register hci_tl_interface IO bus services and the IRQ handlers.\n *         This function must be implemented by the user at the application level.\n *         E.g., in the following, it is provided an implementation example in the case of the SPI:\n *         @code\n           void hci_tl_lowlevel_init(void)\n           {\n             tHciIO fops;  \n  \n             //Register IO bus services \n             fops.Init    = HCI_TL_SPI_Init;\n             fops.DeInit  = HCI_TL_SPI_DeInit;\n             fops.Send    = HCI_TL_SPI_Send;\n             fops.Receive = HCI_TL_SPI_Receive;\n             fops.Reset   = HCI_TL_SPI_Reset;\n             fops.GetTick = BSP_GetTick;\n  \n             hci_register_io_bus (&fops);\n  \n             //Register event irq handler \n             HAL_EXTI_GetHandle(&hexti0, EXTI_LINE_0);\n             HAL_EXTI_RegisterCallback(&hexti0, HAL_EXTI_COMMON_CB_ID, hci_tl_lowlevel_isr);\n             HAL_NVIC_SetPriority(EXTI0_IRQn, 0, 0);\n             HAL_NVIC_EnableIRQ(EXTI0_IRQn);\n           }\n *         @endcode\n *\n * @param  None\n * @retval None\n */\nvoid hci_tl_lowlevel_init(void);\n\n/**\n * @brief HCI Transport Layer Low Level Interrupt Service Routine.\n *        The Interrupt Service Routine must be called when the BlueNRG-MS \n *        reports a packet received or an event to the host through the \n *        BlueNRG-MS interrupt line.\n *        E.g. in case of data travelling over SPI\n *        @code\n          void hci_tl_lowlevel_isr(void)\n          {\n            while(IsDataAvailable())\n            {        \n              hci_notify_asynch_evt(NULL);\n            }\n          }\n *        @endcode\n *        where IsDataAvailable() checks the status of the SPI external interrupt pin \n *        @code\n          static int32_t IsDataAvailable(void)\n          {\n            return (HAL_GPIO_ReadPin(HCI_TL_SPI_EXTI_PORT, HCI_TL_SPI_EXTI_PIN) == GPIO_PIN_SET);\n          } \n *        @endcode  \n *\n * @param  None\n * @retval None\n */\nvoid hci_tl_lowlevel_isr(void);\n\n/**\n * @}\n */\n \n/**\n * @}\n */\n\n/**\n * @}\n */\n\n/**\n * @}\n */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __HCI_TL_INTERFACE_TEMPLATE_H_ */\n    \n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\n\n",
                "link_layer.h": "/******************** (C) COPYRIGHT 2012 STMicroelectronics ********************\n* File Name          : link_layer.h\n* Author             : AMS - HEA&RF BU\n* Version            : V1.0.0\n* Date               : 19-July-2012\n* Description        : Header file for BlueNRG's link layer. It contains\n*                      definition of functions for link layer, most of which are\n*                      mapped to HCI commands.\n********************************************************************************\n* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\n* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.\n* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,\n* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE\n* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING\n* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\n*******************************************************************************/\n\n#ifndef _LINK_LAYER_H\n#define _LINK_LAYER_H\n\n#include \"bluenrg_def.h\"\n \n/** \n * @addtogroup HIGH_LEVEL_INTERFACE HIGH_LEVEL_INTERFACE\n * @{\n */\n\n/**\n * @addtogroup ACI_GAP ACI_GAP\n * @brief API for GAP layer.\n * @{\n */\n\n/**\n *@name Advertising filter \n *Advertising policy for filtering (white list related) \n *@{\n */\n#define NO_WHITE_LIST_USE           (0x00)  /**< Process scan and connection requests from all devices (i.e., the White List is not in use) */\n#define WHITE_LIST_FOR_ONLY_SCAN    (0x01)  /**< Process connection requests from all devices and only scan requests from devices that are in the White List */\n#define WHITE_LIST_FOR_ONLY_CONN    (0x02)  /**< Process scan requests from all devices and only connection requests from devices that are in the White List */\n#define WHITE_LIST_FOR_ALL          (0x03)  /**< Process scan and connection requests only from devices in the White List. */\n/**\n * @}\n */\n\n\n/**\n * Bluetooth 48 bit address (in little-endian order).\n */\ntypedef\tuint8_t\ttBDAddr[6];\n\n\n/**\n *@name Bluetooth address types\n * Bluetooth address types\n *@{\n */\n#define PUBLIC_ADDR                 (0)\n#define RANDOM_ADDR                 (1)\n#define STATIC_RANDOM_ADDR          (1)\n#define RESOLVABLE_PRIVATE_ADDR     (2)\n#define NON_RESOLVABLE_PRIVATE_ADDR (3)\n/**\n * @}\n */\n   \n/**\n *@name Directed advertising types\n * Type of advertising during directed advertising\n *@{\n */\n#define HIGH_DUTY_CYCLE_DIRECTED_ADV   (1)\n#define LOW_DUTY_CYCLE_DIRECTED_ADV    (4)\n/**\n * @}\n */\n\n/** \n * @name Advertising type\n * @{\n */\n\n/**\n * undirected scannable and connectable \n */ \n#define ADV_IND         (0x00)\n\n/** \n * directed non scannable\n */\n#define ADV_DIRECT_IND  (0x01)\n\n/**\n * scannable non connectable\n */\n#define ADV_SCAN_IND    (0x02)\n\n/**\n * non-connectable and no scan response\n */\n#define ADV_NONCONN_IND (0x03)\n\n/**\n * scan response \n */\n#define SCAN_RSP        (0x04)\n\n/**\n * @}\n */\n\n/* 0X05-0XFF RESERVED */\n\n/**\n * @name Advertising ranges\n * @{\n */\n\n/** \n * lowest allowed interval value for connectable types(20ms)..multiple of 625us\n */\n#define ADV_INTERVAL_LOWEST_CONN    (0X0020)\n\n/** \n * highest allowed interval value (10.24s)..multiple of 625us.\n */\n#define ADV_INTERVAL_HIGHEST        (0X4000)\n\n/** \n * lowest allowed interval value for non connectable types\n * (100ms)..multiple of 625us.\n */\n#define ADV_INTERVAL_LOWEST_NONCONN (0X00a0)\n\n/**\n * @}\n */\n\n/**\n * @name Advertising channels\n * @{\n */\n#define ADV_CH_37 0x01\n#define ADV_CH_38 0x02\n#define ADV_CH_39 0x04\n/**\n * @}\n */\n\n/**\n * @name Scan_types Scan types\n * @{\n */\n#define PASSIVE_SCAN    0\n#define ACTIVE_SCAN     1\n/**\n * @}\n */\n\n/**\n * @}\n */\n \n/**\n * @}\n */\n\n/**\n * @}\n */\n\n/**\n * @}\n */\n\n#endif /* _LINK_LAYER_H */\n",
                "sm.h": "/******************** (C) COPYRIGHT 2012 STMicroelectronics ********************\n* File Name          : sm.h\n* Author             : AMS - HEA&RF BU\n* Version            : V1.0.0\n* Date               : 19-July-2012\n* Description        : Header file for BlueNRG's security manager.\n********************************************************************************\n* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\n* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.\n* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,\n* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE\n* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING\n* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\n*******************************************************************************/\n\n#ifndef __SM_H__\n#define __SM_H__\n\n/******************************************************************************\n* Macros\n*****************************************************************************/\n\n/** \n * @defgroup HIGH_LEVEL_INTERFACE HIGH_LEVEL_INTERFACE\n * @{\n */\n\n/**\n * @addtogroup ACI_GAP ACI_GAP\n * @brief API for GAP layer.\n * @{\n */\n\n/* IO capabilities */\n/**\n * @anchor IO_capabilities\n * @name IO capabilities\n * @{\n */\n#define IO_CAP_DISPLAY_ONLY\t\t\t\t(0x00)\n#define IO_CAP_DISPLAY_YES_NO\t\t\t(0x01)\n#define IO_CAP_KEYBOARD_ONLY\t\t\t(0x02)\n#define IO_CAP_NO_INPUT_NO_OUTPUT\t\t(0x03)\n#define IO_CAP_KEYBOARD_DISPLAY\t\t\t(0x04)\n/**\n * @}\n */\n\n/**\n * @anchor Auth_req\n * @name Authentication requirements\n * @{\n */\n#define BONDING\t\t\t\t            (0x01)\n#define NO_BONDING\t\t\t\t        (0x00)\n/**\n * @}\n */\n\n/**\n * @anchor MITM_req\n * @name MITM protection requirements\n * @{\n */\n#define MITM_PROTECTION_NOT_REQUIRED\t(0x00)\n#define MITM_PROTECTION_REQUIRED        (0x01)\n/**\n * @}\n */\n\n/**\n * @anchor OOB_Data\n * @name Out-Of-Band data\n * @{\n */\n#define OOB_AUTH_DATA_ABSENT\t\t    (0x00)\n#define OOB_AUTH_DATA_PRESENT      \t\t(0x01)\n/**\n * @}\n */\n\n/**\n * @anchor Author_req\n * @name Authorization requirements\n * @{\n */\n#define AUTHORIZATION_NOT_REQUIRED\t     (0x00)\n#define AUTHORIZATION_REQUIRED\t\t\t (0x01)\n/**\n * @}\n */\n\n/**\n * @anchor Conn_authorization\n * @name Connection authorization\n * @{\n */\n#define CONNECTION_AUTHORIZED\t\t\t(0x01)\n#define CONNECTION_REJECTED\t\t\t\t(0x02)\n/**\n * @}\n */\n\n/**\n * @anchor Use_fixed_pin\n * @name Use fixed pin\n * @{\n */\n#define USE_FIXED_PIN_FOR_PAIRING\t\t(0x00)\n#define DONOT_USE_FIXED_PIN_FOR_PAIRING\t(0x01)\n/**\n * @}\n */\n\n/**\n * @anchor link_security_status\n * @name Link security status\n * @{\n */\n#define SM_LINK_AUTHENTICATED               (0x01)\n#define SM_LINK_AUTHORIZED                  (0x02)\n#define SM_LINK_ENCRYPTED                   (0x04)\n/**\n * @}\n */\n\n/**\n * @anchor SMP_pairing_failed_codes\n * @name SMP pairing failed reason codes\n * @{\n */\n#define PASSKEY_ENTRY_FAILED\t\t\t(0x01)\n#define OOB_NOT_AVAILABLE\t\t\t\t(0x02)\n#define AUTH_REQ_CANNOT_BE_MET\t\t\t(0x03)\n#define CONFIRM_VALUE_FAILED\t\t\t(0x04)\n#define PAIRING_NOT_SUPPORTED\t\t\t(0x05)\n#define INSUFF_ENCRYPTION_KEY_SIZE\t\t(0x06)\n#define CMD_NOT_SUPPORTED\t\t\t\t(0x07)\n#define UNSPECIFIED_REASON\t\t\t\t(0x08)\n#define VERY_EARLY_NEXT_ATTEMPT\t\t\t(0x09)\n#define SM_INVALID_PARAMS\t\t\t\t(0x0A)\n/**\n * @}\n */\n\n/**\n * @anchor pairing_failed_codes\n * @name Pairing failed error codes\n * Error codes in @ref EVT_BLUE_GAP_PAIRING_CMPLT event\n * @{\n */\n#define SM_PAIRING_SUCCESS              (0x00)\n#define SM_PAIRING_TIMEOUT              (0x01)\n#define SM_PAIRING_FAILED               (0x02)\n/**\n * @}\n */\n\n/**\n * @}\n */\n\n/**\n * @}\n */\n \n#endif /* __SM_H__ */\n"
              }
            }
          },
          "md5": "2427ffd2e84aaff13e7df11a0ef74e66"
        }
      },
      "drivers": {
        "adc": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_ADC_ADC1"
          }
        ],
        "ble": [
          {
            "name": "ATMO_DRIVERINSTANCE_BLE_BlueNRG"
          }
        ],
        "block": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_BLOCK_BLOCK1"
          }
        ],
        "datetime": [],
        "filesytem": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_FILESYSTEM_FILESYSTEM1"
          }
        ],
        "gpio": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_GPIO_GPIO1"
          }
        ],
        "http": [],
        "i2c": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_I2C_I2C1",
            "primary": true
          }
        ],
        "interval": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_INTERVAL_INTERVAL1"
          }
        ],
        "nfc": [],
        "pwm": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_PWM_PWM1"
          }
        ],
        "spi": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_SPI_SPI1"
          }
        ],
        "uart": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_UART_UART1"
          }
        ],
        "wifi": []
      },
      "static": {
        "header": "",
        "footer": "",
        "functions": {
          "ATMO_Setup": {
            "returnType": "void",
            "code": "",
            "arguments": []
          }
        }
      }
    },
    "Application": {
      "type": "app",
      "compilerVersion": "latest",
      "variants": [],
      "meta": {
        "appViewLayouts": {
          "320": {
            "560": true
          }
        }
      },
      "elements": [
        {
          "name": "BLECharacteristicCustom",
          "type": "AppBLECharacteristicCustom",
          "variants": [
            "app",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "readData": null,
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(BLECharacteristicCustom, instance),\n\t\t&ATMO_VARIABLE(BLECharacteristicCustom, bleServiceHandle), \n\t\tATMO_PROPERTY(BLECharacteristicCustom, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(BLECharacteristicCustom, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(BLECharacteristicCustom, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(BLECharacteristicCustom, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(BLECharacteristicCustom, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(BLECharacteristicCustom, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(BLECharacteristicCustom, writeDataType), ATMO_PROPERTY(BLECharacteristicCustom, readDataType), ATMO_PROPERTY(BLECharacteristicCustom, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(BLECharacteristicCustom, instance),\n\t\t&ATMO_VARIABLE(BLECharacteristicCustom, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(BLECharacteristicCustom, bleServiceHandle), \n\t\tATMO_PROPERTY(BLECharacteristicCustom, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(BLECharacteristicCustom, instance),\n\t\tATMO_VARIABLE(BLECharacteristicCustom, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(BLECharacteristicCustom, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(BLECharacteristicCustom, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(BLECharacteristicCustom, instance),\n\t\tATMO_VARIABLE(BLECharacteristicCustom, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(BLECharacteristicCustom, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "ATMO_DRIVERINSTANCE_BLE_BlueNRG",
            "bleServiceUuid": "49cb301f-1a13-4f28-994d-bb6e0b5330cb",
            "bleCharacteristicUuid": "49cb301f-1a13-4f28-994d-bb6e0b5330cc",
            "read": true,
            "write": true,
            "notify": false,
            "readDataType": "ATMO_DATATYPE_VOID",
            "writeDataType": "ATMO_DATATYPE_VOID",
            "notifyDataType": "ATMO_DATATYPE_VOID"
          },
          "meta": {
            "editorX": 152,
            "editorY": 15,
            "lastTrigger": "read"
          },
          "triggers": {
            "triggered": [],
            "read": [],
            "written": [],
            "notification": [],
            "indication": [],
            "subscribed": [],
            "unsubscribed": []
          },
          "coupledElementName": "BLECharacteristicCustom",
          "coupledElementPlaneName": "NUCLEO-L476RG"
        },
        {
          "name": "Button",
          "type": "AppUIButton",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "320": {
                "560": {
                  "width": 100,
                  "height": 100,
                  "x": 65,
                  "y": 22,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "labelText": "Toogle LED",
            "labelFont": "18px Helvetica",
            "labelColor": "black",
            "pressedData": {
              "x": 0,
              "y": 0
            },
            "releasedData": {
              "x": 0,
              "y": 0
            },
            "overData": {
              "x": 0,
              "y": 0
            },
            "leftData": {
              "x": 0,
              "y": 0
            }
          },
          "meta": {
            "editorX": 35,
            "editorY": 15,
            "lastTrigger": "pressed"
          },
          "triggers": {
            "triggered": [],
            "pressed": [
              {
                "mapping": {
                  "value": {
                    "code": ""
                  }
                },
                "targetOrder": [
                  "value"
                ],
                "targetElement": "BLECharacteristicCustom",
                "targetAbility": "write"
              }
            ],
            "released": [],
            "over": []
          }
        }
      ]
    },
    "Cloud": {
      "type": "cloud",
      "compilerVersion": "latest",
      "variants": [],
      "meta": {},
      "elements": [],
      "layout": {
        "height": 1000,
        "width": 1000,
        "zIndexOrder": []
      }
    }
  }
}