{
  "name": "SensorTile Demo",
  "createVersion": "2017-08-12",
  "description": "Project demonstrating the onboard sensors of the SensorTile, the LSM6DSM, LPS22HB, and the LSM303AGR. The temperature and pressure readings from the LPS22HB are sent to the cloud. The rest of the sensors print out on the serial debug console.",
  "lastModified": "2018-11-02T12:41:03.173Z",
  "created": "2018-11-02T12:41:03.173Z",
  "meta": {
    "projectTypeName": "ST SensorTile",
    "projectTypeId": "sensortile"
  },
  "planes": {
    "ST SensorTile": {
      "type": "stm32",
      "compilerVersion": "latest",
      "variants": [
        "sensortile"
      ],
      "meta": {},
      "elements": [
        {
          "name": "AccelX",
          "type": "EmbeddedLSM6DSM",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "    ATMO_LSM6DSM_Config_t config;\r\n    config.i2cInstance = ATMO_PROPERTY(AccelX, i2cInstance);\r\n    config.i2cAddress = ATMO_PROPERTY(AccelX, i2cAddress);\r\n    config.accelOdr = ATMO_PROPERTY(AccelX, accelOdr);\r\n    config.gyroOdr = ATMO_PROPERTY(AccelX, gyroOdr);\r\n    config.accelFullScale = ATMO_PROPERTY(AccelX, accelFullScale);\r\n    config.gyroFullScale = ATMO_PROPERTY(AccelX, gyroFullScale);\r\n    config.driverType.type = ATMO_PROPERTY(AccelX, communicationMode);\r\n    config.csPin = ATMO_PROPERTY(AccelX, csPin);\r\n    config.spi3Wire = ATMO_PROPERTY(AccelX, spi3Wire);\r\n    config.spiInstance = ATMO_PROPERTY(AccelX, spiInstance);\r\n    config.gpioInstance = ATMO_PROPERTY(AccelX, gpioInstance);\r\n    return ATMO_LSM6DSM_Init(&config) == ATMO_LSM6DSM_Status_Success ? ATMO_Status_Success : ATMO_Status_Fail;",
              "xAcceleration": "    ATMO_LSM6DSM_AccelData_t accelData;\r\n    if(ATMO_LSM6DSM_GetAccelData(&accelData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, accelData.x);\r\n    return ATMO_Status_Success;",
              "yAcceleration": "    ATMO_LSM6DSM_AccelData_t accelData;\r\n    if(ATMO_LSM6DSM_GetAccelData(&accelData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, accelData.y);\r\n    return ATMO_Status_Success;",
              "zAcceleration": "    ATMO_LSM6DSM_AccelData_t accelData;\r\n    if(ATMO_LSM6DSM_GetAccelData(&accelData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, accelData.z);\r\n    return ATMO_Status_Success;",
              "acceleration": "    ATMO_LSM6DSM_AccelData_t accelData;\r\n    ATMO_3dFloatVector_t vec;\r\n    if(ATMO_LSM6DSM_GetAccelData(&accelData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    vec.x = accelData.x;\r\n    vec.y = accelData.y;\r\n    vec.z = accelData.z;\r\n\r\n    ATMO_CreateValue3dVectorFloat(out, &vec);\r\n    return ATMO_Status_Success;",
              "rotSpeed": "    ATMO_LSM6DSM_GyroData_t gyroData;\r\n    ATMO_3dFloatVector_t vec;\r\n    if(ATMO_LSM6DSM_GetGyroData(&gyroData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    vec.x = gyroData.x;\r\n    vec.y = gyroData.y;\r\n    vec.z = gyroData.z;\r\n\r\n    ATMO_CreateValue3dVectorFloat(out, &vec);\r\n    return ATMO_Status_Success;",
              "xRotSpeed": "    ATMO_LSM6DSM_GyroData_t gyroData;\r\n    if(ATMO_LSM6DSM_GetGyroData(&gyroData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, gyroData.x);\r\n    return ATMO_Status_Success;",
              "yRotSpeed": "    ATMO_LSM6DSM_GyroData_t gyroData;\r\n    if(ATMO_LSM6DSM_GetGyroData(&gyroData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, gyroData.y);\r\n    return ATMO_Status_Success;",
              "zRotSpeed": "    ATMO_LSM6DSM_GyroData_t gyroData;\r\n    if(ATMO_LSM6DSM_GetGyroData(&gyroData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, gyroData.z);\r\n    return ATMO_Status_Success;",
              "temperature": "    float temperature = 0;\r\n    if(ATMO_LSM6DSM_GetTempData(&temperature) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, temperature);\r\n    return ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "xAcceleration": false,
              "yAcceleration": false,
              "zAcceleration": false,
              "acceleration": false,
              "rotSpeed": false,
              "xRotSpeed": false,
              "yRotSpeed": false,
              "zRotSpeed": false,
              "temperature": false
            },
            "communicationMode": "ATMO_DRIVERTYPE_SPI",
            "i2cInstance": 0,
            "spiInstance": 1,
            "gpioInstance": 0,
            "csPin": "PB12",
            "spi3Wire": true,
            "i2cAddress": "0x6B",
            "accelOdr": "LSM6DSM_XL_ODR_12Hz5",
            "gyroOdr": "LSM6DSM_GY_ODR_12Hz5",
            "accelFullScale": "LSM6DSM_2g",
            "gyroFullScale": "LSM6DSM_2000dps"
          },
          "meta": {
            "editorX": 292,
            "editorY": 445,
            "lastTrigger": "xAccelerationRead"
          },
          "triggers": {
            "triggered": [],
            "xAccelerationRead": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "SubDeltaX",
                "targetAbility": "trigger"
              }
            ],
            "yAccelerationRead": [],
            "zAccelerationRead": [],
            "accelerationRead": [],
            "rotSpeedRead": [],
            "xRotSpeedRead": [],
            "yRotSpeedRead": [],
            "zRotSpeedRead": [],
            "temperatureRead": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "xAcceleration": false,
            "yAcceleration": false,
            "zAcceleration": false,
            "acceleration": false,
            "rotSpeed": false,
            "xRotSpeed": false,
            "yRotSpeed": false,
            "zRotSpeed": false,
            "temperature": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "xAcceleration",
              "triggers": [
                "xAccelerationRead"
              ]
            },
            {
              "name": "yAcceleration",
              "triggers": [
                "yAccelerationRead"
              ]
            },
            {
              "name": "zAcceleration",
              "triggers": [
                "zAccelerationRead"
              ]
            },
            {
              "name": "acceleration",
              "triggers": [
                "accelerationRead"
              ]
            },
            {
              "name": "rotSpeed",
              "triggers": [
                "rotSpeedRead"
              ]
            },
            {
              "name": "xRotSpeed",
              "triggers": [
                "xRotSpeedRead"
              ]
            },
            {
              "name": "yRotSpeed",
              "triggers": [
                "yRotSpeedRead"
              ]
            },
            {
              "name": "zRotSpeed",
              "triggers": [
                "zRotSpeedRead"
              ]
            },
            {
              "name": "temperature",
              "triggers": [
                "temperatureRead"
              ]
            }
          ]
        },
        {
          "name": "LPS22HBPressure",
          "type": "EmbeddedLPS22HB",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\tATMO_LPS22HB_Config_t config;\n\tconfig.i2cInstance = ATMO_PROPERTY(LPS22HBPressure, i2cInstance);\n\tconfig.spiInstance = ATMO_PROPERTY(LPS22HBPressure, spiInstance);\n\tconfig.gpioInstance = ATMO_PROPERTY(LPS22HBPressure, gpioInstance);\n\tconfig.csPin = ATMO_PROPERTY(LPS22HBPressure, csPin);\n\tconfig.i2cAddress = ATMO_PROPERTY(LPS22HBPressure, i2cAddress);\n\tconfig.spi3Wire = ATMO_PROPERTY(LPS22HBPressure, spi3Wire);\n\tconfig.driverType.type = ATMO_PROPERTY(LPS22HBPressure, communicationMode);\n\treturn ATMO_LPS22HB_Init(&config) == ATMO_LPS22HB_Status_Success ? ATMO_Status_Success : ATMO_Status_Fail;\n\n",
              "readPressure": "\tfloat pressure = 0.0;\n\tif( ATMO_LPS22HB_GetPressure(&pressure) != ATMO_LPS22HB_Status_Success )\n\t{\n\t\treturn ATMO_Status_Fail;\n\t}\n\n\tATMO_CreateValueFloat(out, pressure);\n\t\n\treturn ATMO_Status_Success;\n",
              "readTemperature": "\t\n\tfloat temperature = 0.0;\n\tif( ATMO_LPS22HB_GetTempData(&temperature) != ATMO_LPS22HB_Status_Success )\n\t{\n\t\treturn ATMO_Status_Fail;\n\t}\n\n\tATMO_CreateValueFloat(out, temperature);\n\t\n\treturn ATMO_Status_Success;\n"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "readPressure": false,
              "readTemperature": false
            },
            "communicationMode": "ATMO_DRIVERTYPE_SPI",
            "i2cInstance": "0",
            "spiInstance": 1,
            "gpioInstance": 0,
            "csPin": "PA3",
            "spi3Wire": true,
            "i2cAddress": "0x5D"
          },
          "meta": {
            "editorX": 300,
            "editorY": 790,
            "lastTrigger": "temperatureRead"
          },
          "triggers": {
            "triggered": [],
            "pressureRead": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "PressureChar",
                "targetAbility": "setValue"
              }
            ],
            "temperatureRead": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "TmpChar",
                "targetAbility": "setValue"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "readPressure": false,
            "readTemperature": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "readPressure",
              "triggers": [
                "pressureRead"
              ]
            },
            {
              "name": "readTemperature",
              "triggers": [
                "temperatureRead"
              ]
            }
          ]
        },
        {
          "name": "Interval",
          "type": "EmbeddedInterval",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_INTERVAL_Handle_t intervalHandle;\n    ATMO_INTERVAL_AddAbilityInterval(\n\t\tATMO_PROPERTY(Interval, instance), \n\t\tATMO_ABILITY(Interval, interval), \n\t\tATMO_PROPERTY(Interval, time), \n\t\t&intervalHandle\n\t);\n\t\n\treturn ATMO_Status_Success;\n\t",
              "interval": "\treturn ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "interval": false
            },
            "instance": "ATMO_DRIVERINSTANCE_INTERVAL_INTERVAL1",
            "time": "250"
          },
          "meta": {
            "editorX": 95,
            "editorY": 516,
            "lastTrigger": "interval"
          },
          "triggers": {
            "triggered": [],
            "interval": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "AccelX",
                "targetAbility": "xAcceleration"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "AccelY",
                "targetAbility": "yAcceleration"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "AccelZ",
                "targetAbility": "zAcceleration"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "LPS22HBPressure",
                "targetAbility": "readPressure"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "LPS22HBPressure",
                "targetAbility": "readTemperature"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "interval": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "interval",
              "triggers": [
                "interval"
              ]
            }
          ]
        },
        {
          "name": "PressureChar",
          "type": "EmbeddedBLECharacteristicCustom",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(PressureChar, instance),\n\t\t&ATMO_VARIABLE(PressureChar, bleServiceHandle), \n\t\tATMO_PROPERTY(PressureChar, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(PressureChar, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(PressureChar, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(PressureChar, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(PressureChar, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(PressureChar, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(PressureChar, writeDataType), ATMO_PROPERTY(PressureChar, readDataType), ATMO_PROPERTY(PressureChar, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(PressureChar, instance),\n\t\t&ATMO_VARIABLE(PressureChar, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(PressureChar, bleServiceHandle), \n\t\tATMO_PROPERTY(PressureChar, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(PressureChar, instance),\n\t\tATMO_VARIABLE(PressureChar, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(PressureChar, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(PressureChar, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(PressureChar, instance),\n\t\tATMO_VARIABLE(PressureChar, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(PressureChar, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "ATMO_DRIVERINSTANCE_BLE_BLE1",
            "bleServiceUuid": "4320a275-934d-4c29-9383-c5a1cbdf60e2",
            "bleCharacteristicUuid": "4320a275-934d-4c29-9383-c5a1cbdf60e7",
            "read": true,
            "write": true,
            "notify": false,
            "readDataType": "ATMO_DATATYPE_INT",
            "writeDataType": "ATMO_DATATYPE_INT",
            "notifyDataType": "ATMO_DATATYPE_INT"
          },
          "meta": {
            "editorX": 482,
            "editorY": 763,
            "lastTrigger": "written"
          },
          "triggers": {
            "triggered": [],
            "written": [],
            "subscibed": [],
            "unsubscribed": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setValue": "valueSet",
            "written": true,
            "subscibed": true,
            "unsubscribed": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setValue",
              "triggers": []
            },
            {
              "name": "written",
              "triggers": [
                "written"
              ]
            },
            {
              "name": "subscibed",
              "triggers": [
                "subscibed"
              ]
            },
            {
              "name": "unsubscribed",
              "triggers": [
                "unsubscribed"
              ]
            }
          ]
        },
        {
          "name": "TmpChar",
          "type": "EmbeddedBLECharacteristicCustom",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(TmpChar, instance),\n\t\t&ATMO_VARIABLE(TmpChar, bleServiceHandle), \n\t\tATMO_PROPERTY(TmpChar, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(TmpChar, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(TmpChar, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(TmpChar, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(TmpChar, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(TmpChar, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(TmpChar, writeDataType), ATMO_PROPERTY(TmpChar, readDataType), ATMO_PROPERTY(TmpChar, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(TmpChar, instance),\n\t\t&ATMO_VARIABLE(TmpChar, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(TmpChar, bleServiceHandle), \n\t\tATMO_PROPERTY(TmpChar, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(TmpChar, instance),\n\t\tATMO_VARIABLE(TmpChar, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(TmpChar, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(TmpChar, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(TmpChar, instance),\n\t\tATMO_VARIABLE(TmpChar, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(TmpChar, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "ATMO_DRIVERINSTANCE_BLE_BLE1",
            "bleServiceUuid": "4320a275-934d-4c29-9383-c5a1cbdf60e2",
            "bleCharacteristicUuid": "4320a275-934d-4c29-9383-c5a1cbdf60e8",
            "read": true,
            "write": true,
            "notify": false,
            "readDataType": "ATMO_DATATYPE_FLOAT",
            "writeDataType": "ATMO_DATATYPE_FLOAT",
            "notifyDataType": "ATMO_DATATYPE_FLOAT"
          },
          "meta": {
            "editorX": 483,
            "editorY": 863,
            "lastTrigger": "written"
          },
          "triggers": {
            "triggered": [],
            "written": [],
            "subscibed": [],
            "unsubscribed": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setValue": "valueSet",
            "written": true,
            "subscibed": true,
            "unsubscribed": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setValue",
              "triggers": []
            },
            {
              "name": "written",
              "triggers": [
                "written"
              ]
            },
            {
              "name": "subscibed",
              "triggers": [
                "subscibed"
              ]
            },
            {
              "name": "unsubscribed",
              "triggers": [
                "unsubscribed"
              ]
            }
          ]
        },
        {
          "name": "Calibrat",
          "type": "EmbeddedBLECharacteristicCustom",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(Calibrat, instance),\n\t\t&ATMO_VARIABLE(Calibrat, bleServiceHandle), \n\t\tATMO_PROPERTY(Calibrat, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(Calibrat, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(Calibrat, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(Calibrat, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(Calibrat, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(Calibrat, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(Calibrat, writeDataType), ATMO_PROPERTY(Calibrat, readDataType), ATMO_PROPERTY(Calibrat, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(Calibrat, instance),\n\t\t&ATMO_VARIABLE(Calibrat, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(Calibrat, bleServiceHandle), \n\t\tATMO_PROPERTY(Calibrat, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(Calibrat, instance),\n\t\tATMO_VARIABLE(Calibrat, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(Calibrat, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(Calibrat, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(Calibrat, instance),\n\t\tATMO_VARIABLE(Calibrat, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(Calibrat, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "ATMO_DRIVERINSTANCE_BLE_BLE1",
            "bleServiceUuid": "ec7b5b0c-37dc-4db1-944c-a7f76cf75f55",
            "bleCharacteristicUuid": "ec7b5b0c-37dc-4db1-944c-a7f76cf75f58",
            "read": true,
            "write": true,
            "notify": false,
            "readDataType": "ATMO_DATATYPE_INT",
            "writeDataType": "ATMO_DATATYPE_INT",
            "notifyDataType": "ATMO_DATATYPE_INT"
          },
          "meta": {
            "editorX": 92,
            "editorY": 172,
            "lastTrigger": "written"
          },
          "triggers": {
            "triggered": [],
            "written": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "AccelXDelta",
                "targetAbility": "xAcceleration"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "AccelYDelta",
                "targetAbility": "yAcceleration"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "AccelZDelta",
                "targetAbility": "zAcceleration"
              }
            ],
            "subscibed": [],
            "unsubscribed": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setValue": "valueSet",
            "written": true,
            "subscibed": true,
            "unsubscribed": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setValue",
              "triggers": []
            },
            {
              "name": "written",
              "triggers": [
                "written"
              ]
            },
            {
              "name": "subscibed",
              "triggers": [
                "subscibed"
              ]
            },
            {
              "name": "unsubscribed",
              "triggers": [
                "unsubscribed"
              ]
            }
          ]
        },
        {
          "name": "AccelXDeltaVar",
          "type": "EmbeddedVariable",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n    ATMO_InitValue(&ATMO_VARIABLE(AccelXDeltaVar, value));\n    if(ATMO_PROPERTY(AccelXDeltaVar, initialValue) != NULL)\n    {\n        // Create initial value as string\n        ATMO_Value_t strValue;\n        ATMO_InitValue(&strValue);\n        ATMO_CreateValueString(&strValue, ATMO_PROPERTY(AccelXDeltaVar, initialValue));\n\n        // Convert to desired type\n        ATMO_CreateValueConverted(&ATMO_VARIABLE(AccelXDeltaVar, value), ATMO_PROPERTY(AccelXDeltaVar, initialDataType), &strValue);\n        ATMO_FreeValue(&strValue);\n    }\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n    ATMO_CreateValueCopy(&ATMO_VARIABLE(AccelXDeltaVar, value), in);\n    ATMO_CreateValueCopy(out, in);\n    return ATMO_Status_Success;\n    ",
              "getValue": "\n    ATMO_CreateValueCopy(out, &ATMO_VARIABLE(AccelXDeltaVar, value));\n    return ATMO_Status_Success;\n    "
            },
            "variables": {
              "value": {
                "type": "ATMO_Value_t"
              }
            },
            "embeddedPropertyConversions": {
              "initialValue": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "getValue": false
            },
            "initialValue": "0",
            "initialDataType": "ATMO_DATATYPE_FLOAT"
          },
          "meta": {
            "editorX": 412,
            "editorY": 13,
            "lastTrigger": "valueSet"
          },
          "triggers": {
            "triggered": [],
            "valueSet": [],
            "valueRetrieved": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setValue": false,
            "getValue": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setValue",
              "triggers": [
                "valueSet"
              ]
            },
            {
              "name": "getValue",
              "triggers": [
                "valueRetrieved"
              ]
            }
          ]
        },
        {
          "name": "AccelXDelta",
          "type": "EmbeddedLSM6DSM",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "    ATMO_LSM6DSM_Config_t config;\r\n    config.i2cInstance = ATMO_PROPERTY(AccelXDelta, i2cInstance);\r\n    config.i2cAddress = ATMO_PROPERTY(AccelXDelta, i2cAddress);\r\n    config.accelOdr = ATMO_PROPERTY(AccelXDelta, accelOdr);\r\n    config.gyroOdr = ATMO_PROPERTY(AccelXDelta, gyroOdr);\r\n    config.accelFullScale = ATMO_PROPERTY(AccelXDelta, accelFullScale);\r\n    config.gyroFullScale = ATMO_PROPERTY(AccelXDelta, gyroFullScale);\r\n    config.driverType.type = ATMO_PROPERTY(AccelXDelta, communicationMode);\r\n    config.csPin = ATMO_PROPERTY(AccelXDelta, csPin);\r\n    config.spi3Wire = ATMO_PROPERTY(AccelXDelta, spi3Wire);\r\n    config.spiInstance = ATMO_PROPERTY(AccelXDelta, spiInstance);\r\n    config.gpioInstance = ATMO_PROPERTY(AccelXDelta, gpioInstance);\r\n    return ATMO_LSM6DSM_Init(&config) == ATMO_LSM6DSM_Status_Success ? ATMO_Status_Success : ATMO_Status_Fail;",
              "xAcceleration": "    ATMO_LSM6DSM_AccelData_t accelData;\r\n    if(ATMO_LSM6DSM_GetAccelData(&accelData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, accelData.x);\r\n    return ATMO_Status_Success;",
              "yAcceleration": "    ATMO_LSM6DSM_AccelData_t accelData;\r\n    if(ATMO_LSM6DSM_GetAccelData(&accelData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, accelData.y);\r\n    return ATMO_Status_Success;",
              "zAcceleration": "    ATMO_LSM6DSM_AccelData_t accelData;\r\n    if(ATMO_LSM6DSM_GetAccelData(&accelData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, accelData.z);\r\n    return ATMO_Status_Success;",
              "acceleration": "    ATMO_LSM6DSM_AccelData_t accelData;\r\n    ATMO_3dFloatVector_t vec;\r\n    if(ATMO_LSM6DSM_GetAccelData(&accelData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    vec.x = accelData.x;\r\n    vec.y = accelData.y;\r\n    vec.z = accelData.z;\r\n\r\n    ATMO_CreateValue3dVectorFloat(out, &vec);\r\n    return ATMO_Status_Success;",
              "rotSpeed": "    ATMO_LSM6DSM_GyroData_t gyroData;\r\n    ATMO_3dFloatVector_t vec;\r\n    if(ATMO_LSM6DSM_GetGyroData(&gyroData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    vec.x = gyroData.x;\r\n    vec.y = gyroData.y;\r\n    vec.z = gyroData.z;\r\n\r\n    ATMO_CreateValue3dVectorFloat(out, &vec);\r\n    return ATMO_Status_Success;",
              "xRotSpeed": "    ATMO_LSM6DSM_GyroData_t gyroData;\r\n    if(ATMO_LSM6DSM_GetGyroData(&gyroData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, gyroData.x);\r\n    return ATMO_Status_Success;",
              "yRotSpeed": "    ATMO_LSM6DSM_GyroData_t gyroData;\r\n    if(ATMO_LSM6DSM_GetGyroData(&gyroData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, gyroData.y);\r\n    return ATMO_Status_Success;",
              "zRotSpeed": "    ATMO_LSM6DSM_GyroData_t gyroData;\r\n    if(ATMO_LSM6DSM_GetGyroData(&gyroData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, gyroData.z);\r\n    return ATMO_Status_Success;",
              "temperature": "    float temperature = 0;\r\n    if(ATMO_LSM6DSM_GetTempData(&temperature) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, temperature);\r\n    return ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "xAcceleration": false,
              "yAcceleration": false,
              "zAcceleration": false,
              "acceleration": false,
              "rotSpeed": false,
              "xRotSpeed": false,
              "yRotSpeed": false,
              "zRotSpeed": false,
              "temperature": false
            },
            "communicationMode": "ATMO_DRIVERTYPE_SPI",
            "i2cInstance": 0,
            "spiInstance": 1,
            "gpioInstance": 0,
            "csPin": "PB12",
            "spi3Wire": true,
            "i2cAddress": "0x6B",
            "accelOdr": "LSM6DSM_XL_ODR_12Hz5",
            "gyroOdr": "LSM6DSM_GY_ODR_12Hz5",
            "accelFullScale": "LSM6DSM_2g",
            "gyroFullScale": "LSM6DSM_2000dps"
          },
          "meta": {
            "editorX": 284,
            "editorY": 5,
            "lastTrigger": "xAccelerationRead"
          },
          "triggers": {
            "triggered": [],
            "xAccelerationRead": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "AccelXDeltaVar",
                "targetAbility": "setValue"
              }
            ],
            "yAccelerationRead": [],
            "zAccelerationRead": [],
            "accelerationRead": [],
            "rotSpeedRead": [],
            "xRotSpeedRead": [],
            "yRotSpeedRead": [],
            "zRotSpeedRead": [],
            "temperatureRead": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "xAcceleration": false,
            "yAcceleration": false,
            "zAcceleration": false,
            "acceleration": false,
            "rotSpeed": false,
            "xRotSpeed": false,
            "yRotSpeed": false,
            "zRotSpeed": false,
            "temperature": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "xAcceleration",
              "triggers": [
                "xAccelerationRead"
              ]
            },
            {
              "name": "yAcceleration",
              "triggers": [
                "yAccelerationRead"
              ]
            },
            {
              "name": "zAcceleration",
              "triggers": [
                "zAccelerationRead"
              ]
            },
            {
              "name": "acceleration",
              "triggers": [
                "accelerationRead"
              ]
            },
            {
              "name": "rotSpeed",
              "triggers": [
                "rotSpeedRead"
              ]
            },
            {
              "name": "xRotSpeed",
              "triggers": [
                "xRotSpeedRead"
              ]
            },
            {
              "name": "yRotSpeed",
              "triggers": [
                "yRotSpeedRead"
              ]
            },
            {
              "name": "zRotSpeed",
              "triggers": [
                "zRotSpeedRead"
              ]
            },
            {
              "name": "temperature",
              "triggers": [
                "temperatureRead"
              ]
            }
          ]
        },
        {
          "name": "AccelYDelta",
          "type": "EmbeddedLSM6DSM",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "    ATMO_LSM6DSM_Config_t config;\r\n    config.i2cInstance = ATMO_PROPERTY(AccelYDelta, i2cInstance);\r\n    config.i2cAddress = ATMO_PROPERTY(AccelYDelta, i2cAddress);\r\n    config.accelOdr = ATMO_PROPERTY(AccelYDelta, accelOdr);\r\n    config.gyroOdr = ATMO_PROPERTY(AccelYDelta, gyroOdr);\r\n    config.accelFullScale = ATMO_PROPERTY(AccelYDelta, accelFullScale);\r\n    config.gyroFullScale = ATMO_PROPERTY(AccelYDelta, gyroFullScale);\r\n    config.driverType.type = ATMO_PROPERTY(AccelYDelta, communicationMode);\r\n    config.csPin = ATMO_PROPERTY(AccelYDelta, csPin);\r\n    config.spi3Wire = ATMO_PROPERTY(AccelYDelta, spi3Wire);\r\n    config.spiInstance = ATMO_PROPERTY(AccelYDelta, spiInstance);\r\n    config.gpioInstance = ATMO_PROPERTY(AccelYDelta, gpioInstance);\r\n    return ATMO_LSM6DSM_Init(&config) == ATMO_LSM6DSM_Status_Success ? ATMO_Status_Success : ATMO_Status_Fail;",
              "xAcceleration": "    ATMO_LSM6DSM_AccelData_t accelData;\r\n    if(ATMO_LSM6DSM_GetAccelData(&accelData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, accelData.x);\r\n    return ATMO_Status_Success;",
              "yAcceleration": "    ATMO_LSM6DSM_AccelData_t accelData;\r\n    if(ATMO_LSM6DSM_GetAccelData(&accelData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, accelData.y);\r\n    return ATMO_Status_Success;",
              "zAcceleration": "    ATMO_LSM6DSM_AccelData_t accelData;\r\n    if(ATMO_LSM6DSM_GetAccelData(&accelData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, accelData.z);\r\n    return ATMO_Status_Success;",
              "acceleration": "    ATMO_LSM6DSM_AccelData_t accelData;\r\n    ATMO_3dFloatVector_t vec;\r\n    if(ATMO_LSM6DSM_GetAccelData(&accelData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    vec.x = accelData.x;\r\n    vec.y = accelData.y;\r\n    vec.z = accelData.z;\r\n\r\n    ATMO_CreateValue3dVectorFloat(out, &vec);\r\n    return ATMO_Status_Success;",
              "rotSpeed": "    ATMO_LSM6DSM_GyroData_t gyroData;\r\n    ATMO_3dFloatVector_t vec;\r\n    if(ATMO_LSM6DSM_GetGyroData(&gyroData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    vec.x = gyroData.x;\r\n    vec.y = gyroData.y;\r\n    vec.z = gyroData.z;\r\n\r\n    ATMO_CreateValue3dVectorFloat(out, &vec);\r\n    return ATMO_Status_Success;",
              "xRotSpeed": "    ATMO_LSM6DSM_GyroData_t gyroData;\r\n    if(ATMO_LSM6DSM_GetGyroData(&gyroData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, gyroData.x);\r\n    return ATMO_Status_Success;",
              "yRotSpeed": "    ATMO_LSM6DSM_GyroData_t gyroData;\r\n    if(ATMO_LSM6DSM_GetGyroData(&gyroData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, gyroData.y);\r\n    return ATMO_Status_Success;",
              "zRotSpeed": "    ATMO_LSM6DSM_GyroData_t gyroData;\r\n    if(ATMO_LSM6DSM_GetGyroData(&gyroData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, gyroData.z);\r\n    return ATMO_Status_Success;",
              "temperature": "    float temperature = 0;\r\n    if(ATMO_LSM6DSM_GetTempData(&temperature) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, temperature);\r\n    return ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "xAcceleration": false,
              "yAcceleration": false,
              "zAcceleration": false,
              "acceleration": false,
              "rotSpeed": false,
              "xRotSpeed": false,
              "yRotSpeed": false,
              "zRotSpeed": false,
              "temperature": false
            },
            "communicationMode": "ATMO_DRIVERTYPE_SPI",
            "i2cInstance": 0,
            "spiInstance": 1,
            "gpioInstance": 0,
            "csPin": "PB12",
            "spi3Wire": true,
            "i2cAddress": "0x6B",
            "accelOdr": "LSM6DSM_XL_ODR_12Hz5",
            "gyroOdr": "LSM6DSM_GY_ODR_12Hz5",
            "accelFullScale": "LSM6DSM_2g",
            "gyroFullScale": "LSM6DSM_2000dps"
          },
          "meta": {
            "editorX": 300,
            "editorY": 190,
            "lastTrigger": "yAccelerationRead"
          },
          "triggers": {
            "triggered": [],
            "xAccelerationRead": [],
            "yAccelerationRead": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "AccelYDeltaVar",
                "targetAbility": "setValue"
              }
            ],
            "zAccelerationRead": [],
            "accelerationRead": [],
            "rotSpeedRead": [],
            "xRotSpeedRead": [],
            "yRotSpeedRead": [],
            "zRotSpeedRead": [],
            "temperatureRead": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "xAcceleration": false,
            "yAcceleration": false,
            "zAcceleration": false,
            "acceleration": false,
            "rotSpeed": false,
            "xRotSpeed": false,
            "yRotSpeed": false,
            "zRotSpeed": false,
            "temperature": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "xAcceleration",
              "triggers": [
                "xAccelerationRead"
              ]
            },
            {
              "name": "yAcceleration",
              "triggers": [
                "yAccelerationRead"
              ]
            },
            {
              "name": "zAcceleration",
              "triggers": [
                "zAccelerationRead"
              ]
            },
            {
              "name": "acceleration",
              "triggers": [
                "accelerationRead"
              ]
            },
            {
              "name": "rotSpeed",
              "triggers": [
                "rotSpeedRead"
              ]
            },
            {
              "name": "xRotSpeed",
              "triggers": [
                "xRotSpeedRead"
              ]
            },
            {
              "name": "yRotSpeed",
              "triggers": [
                "yRotSpeedRead"
              ]
            },
            {
              "name": "zRotSpeed",
              "triggers": [
                "zRotSpeedRead"
              ]
            },
            {
              "name": "temperature",
              "triggers": [
                "temperatureRead"
              ]
            }
          ]
        },
        {
          "name": "AccelZDelta",
          "type": "EmbeddedLSM6DSM",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "    ATMO_LSM6DSM_Config_t config;\r\n    config.i2cInstance = ATMO_PROPERTY(AccelZDelta, i2cInstance);\r\n    config.i2cAddress = ATMO_PROPERTY(AccelZDelta, i2cAddress);\r\n    config.accelOdr = ATMO_PROPERTY(AccelZDelta, accelOdr);\r\n    config.gyroOdr = ATMO_PROPERTY(AccelZDelta, gyroOdr);\r\n    config.accelFullScale = ATMO_PROPERTY(AccelZDelta, accelFullScale);\r\n    config.gyroFullScale = ATMO_PROPERTY(AccelZDelta, gyroFullScale);\r\n    config.driverType.type = ATMO_PROPERTY(AccelZDelta, communicationMode);\r\n    config.csPin = ATMO_PROPERTY(AccelZDelta, csPin);\r\n    config.spi3Wire = ATMO_PROPERTY(AccelZDelta, spi3Wire);\r\n    config.spiInstance = ATMO_PROPERTY(AccelZDelta, spiInstance);\r\n    config.gpioInstance = ATMO_PROPERTY(AccelZDelta, gpioInstance);\r\n    return ATMO_LSM6DSM_Init(&config) == ATMO_LSM6DSM_Status_Success ? ATMO_Status_Success : ATMO_Status_Fail;",
              "xAcceleration": "    ATMO_LSM6DSM_AccelData_t accelData;\r\n    if(ATMO_LSM6DSM_GetAccelData(&accelData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, accelData.x);\r\n    return ATMO_Status_Success;",
              "yAcceleration": "    ATMO_LSM6DSM_AccelData_t accelData;\r\n    if(ATMO_LSM6DSM_GetAccelData(&accelData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, accelData.y);\r\n    return ATMO_Status_Success;",
              "zAcceleration": "    ATMO_LSM6DSM_AccelData_t accelData;\r\n    if(ATMO_LSM6DSM_GetAccelData(&accelData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, accelData.z);\r\n    return ATMO_Status_Success;",
              "acceleration": "    ATMO_LSM6DSM_AccelData_t accelData;\r\n    ATMO_3dFloatVector_t vec;\r\n    if(ATMO_LSM6DSM_GetAccelData(&accelData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    vec.x = accelData.x;\r\n    vec.y = accelData.y;\r\n    vec.z = accelData.z;\r\n\r\n    ATMO_CreateValue3dVectorFloat(out, &vec);\r\n    return ATMO_Status_Success;",
              "rotSpeed": "    ATMO_LSM6DSM_GyroData_t gyroData;\r\n    ATMO_3dFloatVector_t vec;\r\n    if(ATMO_LSM6DSM_GetGyroData(&gyroData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    vec.x = gyroData.x;\r\n    vec.y = gyroData.y;\r\n    vec.z = gyroData.z;\r\n\r\n    ATMO_CreateValue3dVectorFloat(out, &vec);\r\n    return ATMO_Status_Success;",
              "xRotSpeed": "    ATMO_LSM6DSM_GyroData_t gyroData;\r\n    if(ATMO_LSM6DSM_GetGyroData(&gyroData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, gyroData.x);\r\n    return ATMO_Status_Success;",
              "yRotSpeed": "    ATMO_LSM6DSM_GyroData_t gyroData;\r\n    if(ATMO_LSM6DSM_GetGyroData(&gyroData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, gyroData.y);\r\n    return ATMO_Status_Success;",
              "zRotSpeed": "    ATMO_LSM6DSM_GyroData_t gyroData;\r\n    if(ATMO_LSM6DSM_GetGyroData(&gyroData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, gyroData.z);\r\n    return ATMO_Status_Success;",
              "temperature": "    float temperature = 0;\r\n    if(ATMO_LSM6DSM_GetTempData(&temperature) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, temperature);\r\n    return ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "xAcceleration": false,
              "yAcceleration": false,
              "zAcceleration": false,
              "acceleration": false,
              "rotSpeed": false,
              "xRotSpeed": false,
              "yRotSpeed": false,
              "zRotSpeed": false,
              "temperature": false
            },
            "communicationMode": "ATMO_DRIVERTYPE_SPI",
            "i2cInstance": 0,
            "spiInstance": 1,
            "gpioInstance": 0,
            "csPin": "PB12",
            "spi3Wire": true,
            "i2cAddress": "0x6B",
            "accelOdr": "LSM6DSM_XL_ODR_12Hz5",
            "gyroOdr": "LSM6DSM_GY_ODR_12Hz5",
            "accelFullScale": "LSM6DSM_2g",
            "gyroFullScale": "LSM6DSM_2000dps"
          },
          "meta": {
            "editorX": 298,
            "editorY": 339,
            "lastTrigger": "zAccelerationRead"
          },
          "triggers": {
            "triggered": [],
            "xAccelerationRead": [],
            "yAccelerationRead": [],
            "zAccelerationRead": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "AccelZDeltaVar",
                "targetAbility": "setValue"
              }
            ],
            "accelerationRead": [],
            "rotSpeedRead": [],
            "xRotSpeedRead": [],
            "yRotSpeedRead": [],
            "zRotSpeedRead": [],
            "temperatureRead": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "xAcceleration": false,
            "yAcceleration": false,
            "zAcceleration": false,
            "acceleration": false,
            "rotSpeed": false,
            "xRotSpeed": false,
            "yRotSpeed": false,
            "zRotSpeed": false,
            "temperature": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "xAcceleration",
              "triggers": [
                "xAccelerationRead"
              ]
            },
            {
              "name": "yAcceleration",
              "triggers": [
                "yAccelerationRead"
              ]
            },
            {
              "name": "zAcceleration",
              "triggers": [
                "zAccelerationRead"
              ]
            },
            {
              "name": "acceleration",
              "triggers": [
                "accelerationRead"
              ]
            },
            {
              "name": "rotSpeed",
              "triggers": [
                "rotSpeedRead"
              ]
            },
            {
              "name": "xRotSpeed",
              "triggers": [
                "xRotSpeedRead"
              ]
            },
            {
              "name": "yRotSpeed",
              "triggers": [
                "yRotSpeedRead"
              ]
            },
            {
              "name": "zRotSpeed",
              "triggers": [
                "zRotSpeedRead"
              ]
            },
            {
              "name": "temperature",
              "triggers": [
                "temperatureRead"
              ]
            }
          ]
        },
        {
          "name": "AccelY",
          "type": "EmbeddedLSM6DSM",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "    ATMO_LSM6DSM_Config_t config;\r\n    config.i2cInstance = ATMO_PROPERTY(AccelY, i2cInstance);\r\n    config.i2cAddress = ATMO_PROPERTY(AccelY, i2cAddress);\r\n    config.accelOdr = ATMO_PROPERTY(AccelY, accelOdr);\r\n    config.gyroOdr = ATMO_PROPERTY(AccelY, gyroOdr);\r\n    config.accelFullScale = ATMO_PROPERTY(AccelY, accelFullScale);\r\n    config.gyroFullScale = ATMO_PROPERTY(AccelY, gyroFullScale);\r\n    config.driverType.type = ATMO_PROPERTY(AccelY, communicationMode);\r\n    config.csPin = ATMO_PROPERTY(AccelY, csPin);\r\n    config.spi3Wire = ATMO_PROPERTY(AccelY, spi3Wire);\r\n    config.spiInstance = ATMO_PROPERTY(AccelY, spiInstance);\r\n    config.gpioInstance = ATMO_PROPERTY(AccelY, gpioInstance);\r\n    return ATMO_LSM6DSM_Init(&config) == ATMO_LSM6DSM_Status_Success ? ATMO_Status_Success : ATMO_Status_Fail;",
              "xAcceleration": "    ATMO_LSM6DSM_AccelData_t accelData;\r\n    if(ATMO_LSM6DSM_GetAccelData(&accelData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, accelData.x);\r\n    return ATMO_Status_Success;",
              "yAcceleration": "    ATMO_LSM6DSM_AccelData_t accelData;\r\n    if(ATMO_LSM6DSM_GetAccelData(&accelData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, accelData.y);\r\n    return ATMO_Status_Success;",
              "zAcceleration": "    ATMO_LSM6DSM_AccelData_t accelData;\r\n    if(ATMO_LSM6DSM_GetAccelData(&accelData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, accelData.z);\r\n    return ATMO_Status_Success;",
              "acceleration": "    ATMO_LSM6DSM_AccelData_t accelData;\r\n    ATMO_3dFloatVector_t vec;\r\n    if(ATMO_LSM6DSM_GetAccelData(&accelData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    vec.x = accelData.x;\r\n    vec.y = accelData.y;\r\n    vec.z = accelData.z;\r\n\r\n    ATMO_CreateValue3dVectorFloat(out, &vec);\r\n    return ATMO_Status_Success;",
              "rotSpeed": "    ATMO_LSM6DSM_GyroData_t gyroData;\r\n    ATMO_3dFloatVector_t vec;\r\n    if(ATMO_LSM6DSM_GetGyroData(&gyroData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    vec.x = gyroData.x;\r\n    vec.y = gyroData.y;\r\n    vec.z = gyroData.z;\r\n\r\n    ATMO_CreateValue3dVectorFloat(out, &vec);\r\n    return ATMO_Status_Success;",
              "xRotSpeed": "    ATMO_LSM6DSM_GyroData_t gyroData;\r\n    if(ATMO_LSM6DSM_GetGyroData(&gyroData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, gyroData.x);\r\n    return ATMO_Status_Success;",
              "yRotSpeed": "    ATMO_LSM6DSM_GyroData_t gyroData;\r\n    if(ATMO_LSM6DSM_GetGyroData(&gyroData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, gyroData.y);\r\n    return ATMO_Status_Success;",
              "zRotSpeed": "    ATMO_LSM6DSM_GyroData_t gyroData;\r\n    if(ATMO_LSM6DSM_GetGyroData(&gyroData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, gyroData.z);\r\n    return ATMO_Status_Success;",
              "temperature": "    float temperature = 0;\r\n    if(ATMO_LSM6DSM_GetTempData(&temperature) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, temperature);\r\n    return ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "xAcceleration": false,
              "yAcceleration": false,
              "zAcceleration": false,
              "acceleration": false,
              "rotSpeed": false,
              "xRotSpeed": false,
              "yRotSpeed": false,
              "zRotSpeed": false,
              "temperature": false
            },
            "communicationMode": "ATMO_DRIVERTYPE_SPI",
            "i2cInstance": 0,
            "spiInstance": 1,
            "gpioInstance": 0,
            "csPin": "PB12",
            "spi3Wire": true,
            "i2cAddress": "0x6B",
            "accelOdr": "LSM6DSM_XL_ODR_12Hz5",
            "gyroOdr": "LSM6DSM_GY_ODR_12Hz5",
            "accelFullScale": "LSM6DSM_2g",
            "gyroFullScale": "LSM6DSM_2000dps"
          },
          "meta": {
            "editorX": 292,
            "editorY": 527,
            "lastTrigger": "yAccelerationRead"
          },
          "triggers": {
            "triggered": [],
            "xAccelerationRead": [],
            "yAccelerationRead": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "SubDeltaY",
                "targetAbility": "trigger"
              }
            ],
            "zAccelerationRead": [],
            "accelerationRead": [],
            "rotSpeedRead": [],
            "xRotSpeedRead": [],
            "yRotSpeedRead": [],
            "zRotSpeedRead": [],
            "temperatureRead": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "xAcceleration": false,
            "yAcceleration": false,
            "zAcceleration": false,
            "acceleration": false,
            "rotSpeed": false,
            "xRotSpeed": false,
            "yRotSpeed": false,
            "zRotSpeed": false,
            "temperature": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "xAcceleration",
              "triggers": [
                "xAccelerationRead"
              ]
            },
            {
              "name": "yAcceleration",
              "triggers": [
                "yAccelerationRead"
              ]
            },
            {
              "name": "zAcceleration",
              "triggers": [
                "zAccelerationRead"
              ]
            },
            {
              "name": "acceleration",
              "triggers": [
                "accelerationRead"
              ]
            },
            {
              "name": "rotSpeed",
              "triggers": [
                "rotSpeedRead"
              ]
            },
            {
              "name": "xRotSpeed",
              "triggers": [
                "xRotSpeedRead"
              ]
            },
            {
              "name": "yRotSpeed",
              "triggers": [
                "yRotSpeedRead"
              ]
            },
            {
              "name": "zRotSpeed",
              "triggers": [
                "zRotSpeedRead"
              ]
            },
            {
              "name": "temperature",
              "triggers": [
                "temperatureRead"
              ]
            }
          ]
        },
        {
          "name": "AccelZ",
          "type": "EmbeddedLSM6DSM",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "    ATMO_LSM6DSM_Config_t config;\r\n    config.i2cInstance = ATMO_PROPERTY(AccelZ, i2cInstance);\r\n    config.i2cAddress = ATMO_PROPERTY(AccelZ, i2cAddress);\r\n    config.accelOdr = ATMO_PROPERTY(AccelZ, accelOdr);\r\n    config.gyroOdr = ATMO_PROPERTY(AccelZ, gyroOdr);\r\n    config.accelFullScale = ATMO_PROPERTY(AccelZ, accelFullScale);\r\n    config.gyroFullScale = ATMO_PROPERTY(AccelZ, gyroFullScale);\r\n    config.driverType.type = ATMO_PROPERTY(AccelZ, communicationMode);\r\n    config.csPin = ATMO_PROPERTY(AccelZ, csPin);\r\n    config.spi3Wire = ATMO_PROPERTY(AccelZ, spi3Wire);\r\n    config.spiInstance = ATMO_PROPERTY(AccelZ, spiInstance);\r\n    config.gpioInstance = ATMO_PROPERTY(AccelZ, gpioInstance);\r\n    return ATMO_LSM6DSM_Init(&config) == ATMO_LSM6DSM_Status_Success ? ATMO_Status_Success : ATMO_Status_Fail;",
              "xAcceleration": "    ATMO_LSM6DSM_AccelData_t accelData;\r\n    if(ATMO_LSM6DSM_GetAccelData(&accelData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, accelData.x);\r\n    return ATMO_Status_Success;",
              "yAcceleration": "    ATMO_LSM6DSM_AccelData_t accelData;\r\n    if(ATMO_LSM6DSM_GetAccelData(&accelData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, accelData.y);\r\n    return ATMO_Status_Success;",
              "zAcceleration": "    ATMO_LSM6DSM_AccelData_t accelData;\r\n    if(ATMO_LSM6DSM_GetAccelData(&accelData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, accelData.z);\r\n    return ATMO_Status_Success;",
              "acceleration": "    ATMO_LSM6DSM_AccelData_t accelData;\r\n    ATMO_3dFloatVector_t vec;\r\n    if(ATMO_LSM6DSM_GetAccelData(&accelData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    vec.x = accelData.x;\r\n    vec.y = accelData.y;\r\n    vec.z = accelData.z;\r\n\r\n    ATMO_CreateValue3dVectorFloat(out, &vec);\r\n    return ATMO_Status_Success;",
              "rotSpeed": "    ATMO_LSM6DSM_GyroData_t gyroData;\r\n    ATMO_3dFloatVector_t vec;\r\n    if(ATMO_LSM6DSM_GetGyroData(&gyroData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    vec.x = gyroData.x;\r\n    vec.y = gyroData.y;\r\n    vec.z = gyroData.z;\r\n\r\n    ATMO_CreateValue3dVectorFloat(out, &vec);\r\n    return ATMO_Status_Success;",
              "xRotSpeed": "    ATMO_LSM6DSM_GyroData_t gyroData;\r\n    if(ATMO_LSM6DSM_GetGyroData(&gyroData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, gyroData.x);\r\n    return ATMO_Status_Success;",
              "yRotSpeed": "    ATMO_LSM6DSM_GyroData_t gyroData;\r\n    if(ATMO_LSM6DSM_GetGyroData(&gyroData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, gyroData.y);\r\n    return ATMO_Status_Success;",
              "zRotSpeed": "    ATMO_LSM6DSM_GyroData_t gyroData;\r\n    if(ATMO_LSM6DSM_GetGyroData(&gyroData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, gyroData.z);\r\n    return ATMO_Status_Success;",
              "temperature": "    float temperature = 0;\r\n    if(ATMO_LSM6DSM_GetTempData(&temperature) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, temperature);\r\n    return ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "xAcceleration": false,
              "yAcceleration": false,
              "zAcceleration": false,
              "acceleration": false,
              "rotSpeed": false,
              "xRotSpeed": false,
              "yRotSpeed": false,
              "zRotSpeed": false,
              "temperature": false
            },
            "communicationMode": "ATMO_DRIVERTYPE_SPI",
            "i2cInstance": 0,
            "spiInstance": 1,
            "gpioInstance": 0,
            "csPin": "PB12",
            "spi3Wire": true,
            "i2cAddress": "0x6B",
            "accelOdr": "LSM6DSM_XL_ODR_12Hz5",
            "gyroOdr": "LSM6DSM_GY_ODR_12Hz5",
            "accelFullScale": "LSM6DSM_2g",
            "gyroFullScale": "LSM6DSM_2000dps"
          },
          "meta": {
            "editorX": 287,
            "editorY": 619,
            "lastTrigger": "zAccelerationRead"
          },
          "triggers": {
            "triggered": [],
            "xAccelerationRead": [],
            "yAccelerationRead": [],
            "zAccelerationRead": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "SubDeltaZ",
                "targetAbility": "trigger"
              }
            ],
            "accelerationRead": [],
            "rotSpeedRead": [],
            "xRotSpeedRead": [],
            "yRotSpeedRead": [],
            "zRotSpeedRead": [],
            "temperatureRead": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "xAcceleration": false,
            "yAcceleration": false,
            "zAcceleration": false,
            "acceleration": false,
            "rotSpeed": false,
            "xRotSpeed": false,
            "yRotSpeed": false,
            "zRotSpeed": false,
            "temperature": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "xAcceleration",
              "triggers": [
                "xAccelerationRead"
              ]
            },
            {
              "name": "yAcceleration",
              "triggers": [
                "yAccelerationRead"
              ]
            },
            {
              "name": "zAcceleration",
              "triggers": [
                "zAccelerationRead"
              ]
            },
            {
              "name": "acceleration",
              "triggers": [
                "accelerationRead"
              ]
            },
            {
              "name": "rotSpeed",
              "triggers": [
                "rotSpeedRead"
              ]
            },
            {
              "name": "xRotSpeed",
              "triggers": [
                "xRotSpeedRead"
              ]
            },
            {
              "name": "yRotSpeed",
              "triggers": [
                "yRotSpeedRead"
              ]
            },
            {
              "name": "zRotSpeed",
              "triggers": [
                "zRotSpeedRead"
              ]
            },
            {
              "name": "temperature",
              "triggers": [
                "temperatureRead"
              ]
            }
          ]
        },
        {
          "name": "BLEAccelX",
          "type": "EmbeddedBLECharacteristicCustom",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(BLEAccelX, instance),\n\t\t&ATMO_VARIABLE(BLEAccelX, bleServiceHandle), \n\t\tATMO_PROPERTY(BLEAccelX, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(BLEAccelX, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(BLEAccelX, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(BLEAccelX, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(BLEAccelX, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(BLEAccelX, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(BLEAccelX, writeDataType), ATMO_PROPERTY(BLEAccelX, readDataType), ATMO_PROPERTY(BLEAccelX, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(BLEAccelX, instance),\n\t\t&ATMO_VARIABLE(BLEAccelX, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(BLEAccelX, bleServiceHandle), \n\t\tATMO_PROPERTY(BLEAccelX, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(BLEAccelX, instance),\n\t\tATMO_VARIABLE(BLEAccelX, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(BLEAccelX, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(BLEAccelX, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(BLEAccelX, instance),\n\t\tATMO_VARIABLE(BLEAccelX, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(BLEAccelX, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "ATMO_DRIVERINSTANCE_BLE_BLE1",
            "bleServiceUuid": "ec7b5b0c-37dc-4db1-944c-a7f76cf75f55",
            "bleCharacteristicUuid": "ec7b5b0c-37dc-4db1-944c-a7f76cf75f56",
            "read": true,
            "write": true,
            "notify": false,
            "readDataType": "ATMO_DATATYPE_FLOAT",
            "writeDataType": "ATMO_DATATYPE_FLOAT",
            "notifyDataType": "ATMO_DATATYPE_STRING"
          },
          "meta": {
            "editorX": 657,
            "editorY": 454,
            "lastTrigger": "written"
          },
          "triggers": {
            "triggered": [],
            "written": [],
            "subscibed": [],
            "unsubscribed": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setValue": "valueSet",
            "written": true,
            "subscibed": true,
            "unsubscribed": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setValue",
              "triggers": []
            },
            {
              "name": "written",
              "triggers": [
                "written"
              ]
            },
            {
              "name": "subscibed",
              "triggers": [
                "subscibed"
              ]
            },
            {
              "name": "unsubscribed",
              "triggers": [
                "unsubscribed"
              ]
            }
          ]
        },
        {
          "name": "BLEAccelY",
          "type": "EmbeddedBLECharacteristicCustom",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(BLEAccelY, instance),\n\t\t&ATMO_VARIABLE(BLEAccelY, bleServiceHandle), \n\t\tATMO_PROPERTY(BLEAccelY, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(BLEAccelY, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(BLEAccelY, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(BLEAccelY, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(BLEAccelY, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(BLEAccelY, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(BLEAccelY, writeDataType), ATMO_PROPERTY(BLEAccelY, readDataType), ATMO_PROPERTY(BLEAccelY, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(BLEAccelY, instance),\n\t\t&ATMO_VARIABLE(BLEAccelY, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(BLEAccelY, bleServiceHandle), \n\t\tATMO_PROPERTY(BLEAccelY, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(BLEAccelY, instance),\n\t\tATMO_VARIABLE(BLEAccelY, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(BLEAccelY, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(BLEAccelY, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(BLEAccelY, instance),\n\t\tATMO_VARIABLE(BLEAccelY, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(BLEAccelY, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "ATMO_DRIVERINSTANCE_BLE_BLE1",
            "bleServiceUuid": "ec7b5b0c-37dc-4db1-944c-a7f76cf75f55",
            "bleCharacteristicUuid": "ec7b5b0c-37dc-4db1-944c-a7f76cf75f59",
            "read": true,
            "write": true,
            "notify": false,
            "readDataType": "ATMO_DATATYPE_FLOAT",
            "writeDataType": "ATMO_DATATYPE_FLOAT",
            "notifyDataType": "ATMO_DATATYPE_STRING"
          },
          "meta": {
            "editorX": 660,
            "editorY": 537,
            "lastTrigger": "written"
          },
          "triggers": {
            "triggered": [],
            "written": [],
            "subscibed": [],
            "unsubscribed": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setValue": "valueSet",
            "written": true,
            "subscibed": true,
            "unsubscribed": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setValue",
              "triggers": []
            },
            {
              "name": "written",
              "triggers": [
                "written"
              ]
            },
            {
              "name": "subscibed",
              "triggers": [
                "subscibed"
              ]
            },
            {
              "name": "unsubscribed",
              "triggers": [
                "unsubscribed"
              ]
            }
          ]
        },
        {
          "name": "BLEAccelZ",
          "type": "EmbeddedBLECharacteristicCustom",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(BLEAccelZ, instance),\n\t\t&ATMO_VARIABLE(BLEAccelZ, bleServiceHandle), \n\t\tATMO_PROPERTY(BLEAccelZ, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(BLEAccelZ, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(BLEAccelZ, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(BLEAccelZ, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(BLEAccelZ, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(BLEAccelZ, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(BLEAccelZ, writeDataType), ATMO_PROPERTY(BLEAccelZ, readDataType), ATMO_PROPERTY(BLEAccelZ, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(BLEAccelZ, instance),\n\t\t&ATMO_VARIABLE(BLEAccelZ, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(BLEAccelZ, bleServiceHandle), \n\t\tATMO_PROPERTY(BLEAccelZ, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(BLEAccelZ, instance),\n\t\tATMO_VARIABLE(BLEAccelZ, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(BLEAccelZ, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(BLEAccelZ, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(BLEAccelZ, instance),\n\t\tATMO_VARIABLE(BLEAccelZ, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(BLEAccelZ, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "ATMO_DRIVERINSTANCE_BLE_BLE1",
            "bleServiceUuid": "ec7b5b0c-37dc-4db1-944c-a7f76cf75f55",
            "bleCharacteristicUuid": "ec7b5b0c-37dc-4db1-944c-a7f76cf75f5a",
            "read": true,
            "write": true,
            "notify": false,
            "readDataType": "ATMO_DATATYPE_FLOAT",
            "writeDataType": "ATMO_DATATYPE_FLOAT",
            "notifyDataType": "ATMO_DATATYPE_STRING"
          },
          "meta": {
            "editorX": 662,
            "editorY": 614,
            "lastTrigger": "written"
          },
          "triggers": {
            "triggered": [],
            "written": [],
            "subscibed": [],
            "unsubscribed": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setValue": "valueSet",
            "written": true,
            "subscibed": true,
            "unsubscribed": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setValue",
              "triggers": []
            },
            {
              "name": "written",
              "triggers": [
                "written"
              ]
            },
            {
              "name": "subscibed",
              "triggers": [
                "subscibed"
              ]
            },
            {
              "name": "unsubscribed",
              "triggers": [
                "unsubscribed"
              ]
            }
          ]
        },
        {
          "name": "AccelYDeltaVar",
          "type": "EmbeddedVariable",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n    ATMO_InitValue(&ATMO_VARIABLE(AccelYDeltaVar, value));\n    if(ATMO_PROPERTY(AccelYDeltaVar, initialValue) != NULL)\n    {\n        // Create initial value as string\n        ATMO_Value_t strValue;\n        ATMO_InitValue(&strValue);\n        ATMO_CreateValueString(&strValue, ATMO_PROPERTY(AccelYDeltaVar, initialValue));\n\n        // Convert to desired type\n        ATMO_CreateValueConverted(&ATMO_VARIABLE(AccelYDeltaVar, value), ATMO_PROPERTY(AccelYDeltaVar, initialDataType), &strValue);\n        ATMO_FreeValue(&strValue);\n    }\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n    ATMO_CreateValueCopy(&ATMO_VARIABLE(AccelYDeltaVar, value), in);\n    ATMO_CreateValueCopy(out, in);\n    return ATMO_Status_Success;\n    ",
              "getValue": "\n    ATMO_CreateValueCopy(out, &ATMO_VARIABLE(AccelYDeltaVar, value));\n    return ATMO_Status_Success;\n    "
            },
            "variables": {
              "value": {
                "type": "ATMO_Value_t"
              }
            },
            "embeddedPropertyConversions": {
              "initialValue": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "getValue": false
            },
            "initialValue": "0",
            "initialDataType": "ATMO_DATATYPE_FLOAT"
          },
          "meta": {
            "editorX": 410,
            "editorY": 186,
            "lastTrigger": "valueRetrieved"
          },
          "triggers": {
            "triggered": [],
            "valueSet": [],
            "valueRetrieved": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setValue": false,
            "getValue": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setValue",
              "triggers": [
                "valueSet"
              ]
            },
            {
              "name": "getValue",
              "triggers": [
                "valueRetrieved"
              ]
            }
          ]
        },
        {
          "name": "AccelZDeltaVar",
          "type": "EmbeddedVariable",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n    ATMO_InitValue(&ATMO_VARIABLE(AccelZDeltaVar, value));\n    if(ATMO_PROPERTY(AccelZDeltaVar, initialValue) != NULL)\n    {\n        // Create initial value as string\n        ATMO_Value_t strValue;\n        ATMO_InitValue(&strValue);\n        ATMO_CreateValueString(&strValue, ATMO_PROPERTY(AccelZDeltaVar, initialValue));\n\n        // Convert to desired type\n        ATMO_CreateValueConverted(&ATMO_VARIABLE(AccelZDeltaVar, value), ATMO_PROPERTY(AccelZDeltaVar, initialDataType), &strValue);\n        ATMO_FreeValue(&strValue);\n    }\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n    ATMO_CreateValueCopy(&ATMO_VARIABLE(AccelZDeltaVar, value), in);\n    ATMO_CreateValueCopy(out, in);\n    return ATMO_Status_Success;\n    ",
              "getValue": "\n    ATMO_CreateValueCopy(out, &ATMO_VARIABLE(AccelZDeltaVar, value));\n    return ATMO_Status_Success;\n    "
            },
            "variables": {
              "value": {
                "type": "ATMO_Value_t"
              }
            },
            "embeddedPropertyConversions": {
              "initialValue": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "getValue": false
            },
            "initialValue": "AccelZDelta",
            "initialDataType": "ATMO_DATATYPE_STRING"
          },
          "meta": {
            "editorX": 411,
            "editorY": 332,
            "lastTrigger": "valueRetrieved"
          },
          "triggers": {
            "triggered": [],
            "valueSet": [],
            "valueRetrieved": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setValue": false,
            "getValue": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setValue",
              "triggers": [
                "valueSet"
              ]
            },
            {
              "name": "getValue",
              "triggers": [
                "valueRetrieved"
              ]
            }
          ]
        },
        {
          "name": "SubDeltaX",
          "type": "EmbeddedFunction",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\tfloat reading = 0;\n\tATMO_GetFloat(in, &reading);\n\t\n\tfloat delta = 0;\n\tATMO_GetFloat(&ATMO_AccelXDeltaVar_VARIABLE_value, &delta);\n\t\n\tATMO_CreateValueFloat(out, reading - delta);\n\treturn ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "trigger": true
            }
          },
          "meta": {
            "editorX": 456,
            "editorY": 441,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "BLEAccelX",
                "targetAbility": "setValue"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            }
          ]
        },
        {
          "name": "SubDeltaY",
          "type": "EmbeddedFunction",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\tfloat reading = 0;\n\tATMO_GetFloat(in, &reading);\n\t\n\tfloat delta = 0;\n\tATMO_GetFloat(&ATMO_AccelYDeltaVar_VARIABLE_value, &delta);\n\t\n\tATMO_CreateValueFloat(out, reading - delta);\n\treturn ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "trigger": true
            }
          },
          "meta": {
            "editorX": 461,
            "editorY": 529,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "BLEAccelY",
                "targetAbility": "setValue"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            }
          ]
        },
        {
          "name": "SubDeltaZ",
          "type": "EmbeddedFunction",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\tfloat reading = 0;\n\tATMO_GetFloat(in, &reading);\n\t\n\tfloat delta = 0;\n\tATMO_GetFloat(&ATMO_AccelZDeltaVar_VARIABLE_value, &delta);\n\t\n\tATMO_CreateValueFloat(out, reading - delta);\n\treturn ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "trigger": true
            }
          },
          "meta": {
            "editorX": 461,
            "editorY": 611,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "BLEAccelZ",
                "targetAbility": "setValue"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            }
          ]
        }
      ],
      "libraries": {
        "lsm303agr": {
          "libName": "lsm303agr",
          "manufacturer": "STMicroelectronics",
          "description": "3D Inertial Module",
          "type": "Accelerometer Magnetometer",
          "icon": "",
          "image": "",
          "version": "",
          "eelVersion": "3",
          "shoppingCartLinks": {
            "digikey": {
              "links": {
                "info": "https://www.digikey.com/product-detail/en/stmicroelectronics/LSM303AGRTR/497-16527-1-ND/6006105"
              },
              "cartData": {
                "part": "497-16527-1-ND",
                "partid": "6006105",
                "source": "dkstudio",
                "qty": "1"
              }
            }
          },
          "requires": [
            "embedded",
            "i2c",
            "gpio",
            "fpmath"
          ],
          "elements": [
            {
              "name": "EmbeddedLSM303AGR",
              "type": "EmbeddedLSM303AGR",
              "icon": "EmbeddedAccelerometerMagnetometer.svg",
              "defaultAbility": "xAcceleration",
              "defaultTrigger": "xAccelerationRead",
              "hidden": false,
              "helpPageHref": "https://developer.atmosphereiot.com/documents/elements/stmicroelectronicslsm303agrelement.html",
              "abilities": [
                {
                  "name": "setup",
                  "hidden": true,
                  "code": "    ATMO_LSM303AGR_Config_t config;\r\n    config.i2cInstance = ATMO_PROPERTY(undefined, i2cInstance);\r\n    config.accelI2CAddress = ATMO_PROPERTY(undefined, accelI2CAddress);\r\n    config.magI2CAddress = ATMO_PROPERTY(undefined, magI2CAddress);\r\n    config.accelOdr = ATMO_PROPERTY(undefined, accelOdr);\r\n    config.magOdr = ATMO_PROPERTY(undefined, magOdr);\r\n    config.accelFullScale = ATMO_PROPERTY(undefined, accelFullScale);\r\n    config.magRstMode = ATMO_PROPERTY(undefined, magRstMode);\r\n    config.magTempCompensation = ATMO_PROPERTY(undefined, magTempCompensation);\r\n    config.accelOperatingMode = ATMO_PROPERTY(undefined, accelOperatingMode);\r\n    config.magOperatingMode = ATMO_PROPERTY(undefined, magOperatingMode);\r\n    config.driverType.type = ATMO_PROPERTY(undefined, communicationMode);\r\n    config.accelCsPin = ATMO_PROPERTY(undefined, accelCsPin);\r\n    config.magCsPin = ATMO_PROPERTY(undefined, magCsPin);\r\n    config.spi3Wire = ATMO_PROPERTY(undefined, spi3Wire);\r\n    config.spiInstance = ATMO_PROPERTY(undefined, spiInstance);\r\n    config.gpioInstance = ATMO_PROPERTY(undefined, gpioInstance);\r\n    return ATMO_LSM303AGR_Init(&config) == ATMO_LSM303AGR_Status_Success ? ATMO_Status_Success : ATMO_Status_Fail;"
                },
                {
                  "name": "xAcceleration",
                  "triggers": [
                    "xAccelerationRead"
                  ],
                  "code": "    ATMO_LSM303AGR_AccelData_t accelData;\r\n    if(ATMO_LSM303AGR_GetAccelData(&accelData) != ATMO_LSM303AGR_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, accelData.x);\r\n    return ATMO_Status_Success;"
                },
                {
                  "name": "yAcceleration",
                  "triggers": [
                    "yAccelerationRead"
                  ],
                  "code": "    ATMO_LSM303AGR_AccelData_t accelData;\r\n    if(ATMO_LSM303AGR_GetAccelData(&accelData) != ATMO_LSM303AGR_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, accelData.y);\r\n    return ATMO_Status_Success;"
                },
                {
                  "name": "zAcceleration",
                  "triggers": [
                    "zAccelerationRead"
                  ],
                  "code": "    ATMO_LSM303AGR_AccelData_t accelData;\r\n    if(ATMO_LSM303AGR_GetAccelData(&accelData) != ATMO_LSM303AGR_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, accelData.z);\r\n    return ATMO_Status_Success;"
                },
                {
                  "name": "acceleration",
                  "triggers": [
                    "accelerationRead"
                  ],
                  "code": "    ATMO_LSM303AGR_AccelData_t accelData;\r\n    ATMO_3dFloatVector_t vec;\r\n    if(ATMO_LSM303AGR_GetAccelData(&accelData) != ATMO_LSM303AGR_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    vec.x = accelData.x;\r\n    vec.y = accelData.y;\r\n    vec.z = accelData.z;\r\n\r\n    ATMO_CreateValue3dVectorFloat(out, &vec);\r\n    return ATMO_Status_Success;"
                },
                {
                  "name": "magneticField",
                  "triggers": [
                    "magneticFieldRead"
                  ],
                  "code": "    ATMO_LSM303AGR_MagData_t magData;\r\n    ATMO_3dFloatVector_t vec;\r\n    if(ATMO_LSM303AGR_GetMagData(&magData) != ATMO_LSM303AGR_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n\r\n    vec.x = magData.x;\r\n    vec.y = magData.y;\r\n    vec.z = magData.z;\r\n\r\n    ATMO_CreateValue3dVectorFloat(out, &vec);\r\n    return ATMO_Status_Success;"
                },
                {
                  "name": "xMagneticField",
                  "triggers": [
                    "xMagneticFieldRead"
                  ],
                  "code": "    ATMO_LSM303AGR_MagData_t magData;\r\n    if(ATMO_LSM303AGR_GetMagData(&magData) != ATMO_LSM303AGR_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, magData.x);\r\n    return ATMO_Status_Success;"
                },
                {
                  "name": "yMagneticField",
                  "triggers": [
                    "yMagneticFieldRead"
                  ],
                  "code": "    ATMO_LSM303AGR_MagData_t magData;\r\n    if(ATMO_LSM303AGR_GetMagData(&magData) != ATMO_LSM303AGR_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, magData.y);\r\n    return ATMO_Status_Success;"
                },
                {
                  "name": "zMagneticField",
                  "triggers": [
                    "zMagneticFieldRead"
                  ],
                  "code": "    ATMO_LSM303AGR_MagData_t magData;\r\n    if(ATMO_LSM303AGR_GetMagData(&magData) != ATMO_LSM303AGR_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, magData.z);\r\n    return ATMO_Status_Success;"
                },
                {
                  "name": "temperature",
                  "triggers": [
                    "temperatureRead"
                  ],
                  "code": "    float temperature = 0;\r\n    if(ATMO_LSM303AGR_GetTempData(&temperature) != ATMO_LSM303AGR_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, temperature);\r\n    return ATMO_Status_Success;"
                }
              ],
              "properties": [
                {
                  "name": "communicationMode",
                  "input": "select",
                  "inputOptions": [
                    "ATMO_DRIVERTYPE_SPI",
                    "ATMO_DRIVERTYPE_I2C"
                  ],
                  "value": "ATMO_DRIVERTYPE_SPI"
                },
                {
                  "name": "i2cInstance",
                  "input": "number",
                  "value": "0"
                },
                {
                  "name": "spiInstance",
                  "input": "number",
                  "value": "0"
                },
                {
                  "name": "gpioInstance",
                  "input": "number",
                  "value": "0"
                },
                {
                  "name": "magCsPin",
                  "input": "number",
                  "value": "0"
                },
                {
                  "name": "accelCsPin",
                  "input": "number",
                  "value": "0"
                },
                {
                  "name": "spi3Wire",
                  "input": "checkbox",
                  "value": true
                },
                {
                  "name": "accelI2CAddress",
                  "input": "select",
                  "inputOptions": [
                    "0x19"
                  ],
                  "value": "0x19"
                },
                {
                  "name": "magI2CAddress",
                  "input": "select",
                  "inputOptions": [
                    "0x1E"
                  ],
                  "value": "0x1E"
                },
                {
                  "name": "accelOdr",
                  "input": "select",
                  "inputOptions": [
                    "LSM303AGR_XL_POWER_DOWN",
                    "LSM303AGR_XL_ODR_1Hz",
                    "LSM303AGR_XL_ODR_10Hz",
                    "LSM303AGR_XL_ODR_25Hz",
                    "LSM303AGR_XL_ODR_50Hz",
                    "LSM303AGR_XL_ODR_100Hz",
                    "LSM303AGR_XL_ODR_200Hz",
                    "LSM303AGR_XL_ODR_400Hz",
                    "LSM303AGR_XL_ODR_1kHz620_LP",
                    "LSM303AGR_XL_ODR_5kHz376_LP",
                    "LSM303AGR_XL_ODR_1kHz344_NM_HP"
                  ],
                  "value": "LSM303AGR_XL_ODR_10Hz"
                },
                {
                  "name": "magOdr",
                  "input": "select",
                  "inputOptions": [
                    "LSM303AGR_MG_ODR_10Hz",
                    "LSM303AGR_MG_ODR_20Hz",
                    "LSM303AGR_MG_ODR_50Hz",
                    "LSM303AGR_MG_ODR_100Hz"
                  ],
                  "value": "LSM303AGR_MG_ODR_10Hz"
                },
                {
                  "name": "accelFullScale",
                  "input": "select",
                  "inputOptions": [
                    "LSM303AGR_2g",
                    "LSM303AGR_4g",
                    "LSM303AGR_8g",
                    "LSM303AGR_16g"
                  ],
                  "value": "LSM303AGR_2g"
                },
                {
                  "name": "magRstMode",
                  "input": "select",
                  "inputOptions": [
                    "LSM303AGR_SET_SENS_ODR_DIV_63",
                    "LSM303AGR_SENS_OFF_CANC_EVERY_ODR",
                    "LSM303AGR_SET_SENS_ONLY_AT_POWER_ON"
                  ],
                  "value": "LSM303AGR_SENS_OFF_CANC_EVERY_ODR"
                },
                {
                  "name": "magTempCompensation",
                  "input": "checkbox",
                  "value": true
                },
                {
                  "name": "accelOperatingMode",
                  "input": "select",
                  "inputOptions": [
                    "LSM303AGR_HR_12bit",
                    "LSM303AGR_NM_10bit",
                    "LSM303AGR_LP_8bit"
                  ],
                  "value": "LSM303AGR_HR_12bit"
                },
                {
                  "name": "magOperatingMode",
                  "input": "select",
                  "inputOptions": [
                    "LSM303AGR_CONTINUOUS_MODE",
                    "LSM303AGR_SINGLE_TRIGGER",
                    "LSM303AGR_POWER_DOWN"
                  ],
                  "value": "LSM303AGR_CONTINUOUS_MODE"
                }
              ],
              "triggers": [],
              "variables": [],
              "language": {
                "en-US": {
                  "EmbeddedLSM303AGR": "LSM303AGR Accelerometer",
                  "xAcceleration": "Read X Acceleration (mg)",
                  "yAcceleration": "Read Y Acceleration (mg)",
                  "zAcceleration": "Read Z Acceleration (mg)",
                  "xMagneticField": "Read X Magnetic Field (mGa)",
                  "yMagneticField": "Read Y Magnetic Field (mGa)",
                  "zMagneticField": "Read Z Magnetic Field (mGa)",
                  "xAccelerationRead": "X Acceleration Read",
                  "yAccelerationRead": "Y Acceleration Read",
                  "zAccelerationRead": "Z Acceleration Read",
                  "xMagneticFieldRead": "X Magnetic Field Read",
                  "yMagneticFieldRead": "Y Magnetic Field Read",
                  "zMagneticFieldRead": "Z Magnetic Field Read",
                  "acceleration": "Read Acceleration",
                  "accelerationRead": "Acceleration Read",
                  "magneticField": "Read Magnetic Field",
                  "magneticFieldRead": "Magnetic Field Read",
                  "magOdr": "Magnetometer Output Data Rate",
                  "accelOdr": "Accelerometer Output Data Rate",
                  "accelI2CAddress": "Accelerometer I2C Address",
                  "magI2CAddress": "Magnetometer I2C Address",
                  "accelFullScale": "Accelerometer Full-Scale",
                  "magRstMode": "Magnetometer Reset Mode",
                  "magTempCompensation": "Magnetometer Temperature Compensation",
                  "accelOperatingMode": "Accelerometer Operating Mode",
                  "magOperatingMode": "Magnetometer Operating Mode",
                  "LSM303AGR_XL_POWER_DOWN": "Power Down",
                  "LSM303AGR_XL_ODR_1Hz": "1 Hz",
                  "LSM303AGR_XL_ODR_10Hz": "10 Hz",
                  "LSM303AGR_XL_ODR_25Hz": "25 Hz",
                  "LSM303AGR_XL_ODR_50Hz": "50 Hz",
                  "LSM303AGR_XL_ODR_100Hz": "100 Hz",
                  "LSM303AGR_XL_ODR_200Hz": "200 Hz",
                  "LSM303AGR_XL_ODR_400Hz": "400 Hz",
                  "LSM303AGR_XL_ODR_1kHz344_NM_HP": "1.344 kHz",
                  "LSM303AGR_XL_ODR_1kHz620_LP": "1.620 kHz Low Power",
                  "LSM303AGR_XL_ODR_5kHz376_LP": "5.376 kHz Low Power",
                  "LSM303AGR_MG_ODR_10Hz": "10 Hz",
                  "LSM303AGR_MG_ODR_20Hz": "20 Hz",
                  "LSM303AGR_MG_ODR_50Hz": "50 Hz",
                  "LSM303AGR_MG_ODR_100Hz": "100Hz",
                  "LSM303AGR_2g": "2g",
                  "LSM303AGR_4g": "4g",
                  "LSM303AGR_8g": "8g",
                  "LSM303AGR_16g": "16g",
                  "LSM303AGR_SET_SENS_ODR_DIV_63": "Released Every 63 ODR",
                  "LSM303AGR_SENS_OFF_CANC_EVERY_ODR": "Offset cancelation enabled",
                  "LSM303AGR_SET_SENS_ONLY_AT_POWER_ON": "Released only at power on",
                  "LSM303AGR_HR_12bit": "High Resolution (12 bit)",
                  "LSM303AGR_NM_10bit": "Normal (10 bit)",
                  "LSM303AGR_LP_8bit": "Low Power (8 bit)",
                  "LSM303AGR_CONTINUOUS_MODE": "Continuous Mode",
                  "LSM303AGR_SINGLE_TRIGGER": "Single Trigger",
                  "LSM303AGR_POWER_DOWN": "Power Down",
                  "communicationMode": "Communication Mode",
                  "ATMO_DRIVERTYPE_SPI": "SPI",
                  "ATMO_DRIVERTYPE_I2C": "I2C",
                  "spiInstance": "SPI Driver Instance",
                  "gpioInstance": "GPIO Driver Instance",
                  "magCsPin": "Magnetometer Chip Select Pin",
                  "accelCsPin": "Accelerometer Chip Select Pin",
                  "spi3Wire": "3 Wire SPI Mode",
                  "temperature": "Read Temperature",
                  "temperatureRead": "Temperature Read"
                }
              }
            }
          ],
          "files": {
            "common": {
              "headers": {
                "lsm303agr.h": "/**\r\n ******************************************************************************\r\n * @file    lsm303agr.h\r\n * @author\r\n * @version\r\n * @date\r\n * @brief   Atmosphere API - lsm303agr header file\r\n ******************************************************************************\r\n * @attention\r\n *\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *   1. Redistributions of source code must retain the above copyright notice,\r\n *      this list of conditions and the following disclaimer.\r\n *   2. Redistributions in binary form must reproduce the above copyright notice,\r\n *      this list of conditions and the following disclaimer in the documentation\r\n *      and/or other materials provided with the distribution.\r\n *   3. Neither the name of Atmosphere IoT Corp. nor the names of its contributors\r\n *      may be used to endorse or promote products derived from this software\r\n *      without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n ******************************************************************************\r\n */\r\n#ifndef _ATMO_LSM303AGR_H_\r\n#define _ATMO_LSM303AGR_H_\r\n\r\n#include \"../app_src/atmosphere_platform.h\"\r\n\r\ntypedef struct {\r\n    ATMO_DriverInstanceHandle_t i2cInstance;\r\n    ATMO_DriverInstanceHandle_t spiInstance;\r\n    ATMO_DriverInstanceHandle_t gpioInstance;\r\n    uint8_t accelI2CAddress;\r\n    uint8_t magI2CAddress;\r\n    uint8_t accelOdr;\r\n    uint8_t magOdr;\r\n    uint8_t accelFullScale;\r\n    uint8_t magRstMode;\r\n    bool magTempCompensation;\r\n    uint8_t accelOperatingMode;\r\n    uint8_t magOperatingMode;\r\n    bool spi3Wire;\r\n    ATMO_GPIO_Device_Pin_t accelCsPin; // Only used for SPI\r\n    ATMO_GPIO_Device_Pin_t magCsPin;\r\n    ATMO_CORE_DeviceHandle_t driverType;\r\n}ATMO_LSM303AGR_Config_t;\r\n\r\ntypedef enum {\r\n    ATMO_LSM303AGR_Status_Success = 0 ,\r\n    ATMO_LSM303AGR_Status_Fail\r\n} ATMO_LSM303AGR_Status_t;\r\n\r\ntypedef struct {\r\n    float x;\r\n    float y;\r\n    float z;\r\n} ATMO_LSM303AGR_AccelData_t;\r\n\r\ntypedef ATMO_LSM303AGR_AccelData_t ATMO_LSM303AGR_MagData_t;\r\n\r\nATMO_LSM303AGR_Status_t ATMO_LSM303AGR_Init(ATMO_LSM303AGR_Config_t *config);\r\n\r\n/**\r\n * @brief Get acceleration data. Each axis is in mg\r\n * \r\n * @param data \r\n * @return ATMO_LSM303AGR_Status_t \r\n */\r\nATMO_LSM303AGR_Status_t ATMO_LSM303AGR_GetAccelData(ATMO_LSM303AGR_AccelData_t *data);\r\n\r\n/**\r\n * @brief Get magnetometer data. Each axis is in mG\r\n * \r\n * @param data \r\n * @return ATMO_LSM303AGR_Status_t \r\n */\r\nATMO_LSM303AGR_Status_t ATMO_LSM303AGR_GetMagData(ATMO_LSM303AGR_MagData_t *data);\r\n\r\n/**\r\n * @brief Get temperature data in degrees C\r\n * \r\n * @param tempC \r\n * @return ATMO_LSM303AGR_Status_t \r\n */\r\nATMO_LSM303AGR_Status_t ATMO_LSM303AGR_GetTempData(float *tempC);\r\n\r\n#endif\r\n",
                "lsm303agr_reg.h": "/*\n ******************************************************************************\n * @file    lsm303agr_reg.h\n * @author  MEMS Software Solution Team\n * @date    12-October-2017\n * @brief   This file contains all the functions prototypes for the\n *          lsm303agr_reg.c driver.\n ******************************************************************************\n * @attention\n *\n * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *   1. Redistributions of source code must retain the above copyright notice,\n *      this list of conditions and the following disclaimer.\n *   2. Redistributions in binary form must reproduce the above copyright notice,\n *      this list of conditions and the following disclaimer in the documentation\n *      and/or other materials provided with the distribution.\n *   3. Neither the name of STMicroelectronics nor the names of its contributors\n *      may be used to endorse or promote products derived from this software\n *      without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n/* Define to prevent recursive inclusion -------------------------------------*/\n#ifndef __LSM303AGR_DRIVER__H\n#define __LSM303AGR_DRIVER__H\n\n#ifdef __cplusplus\n  extern \"C\" {\n#endif\n\n/* Includes ------------------------------------------------------------------*/\n#include <stdint.h>\n\n/** @addtogroup lsm303agr\n * @{\n */\n\n#ifndef __MEMS_SHARED__TYPES\n#define __MEMS_SHARED__TYPES\n\n/** @defgroup ST_MEMS_common_types\n  * @{\n  */\n\ntypedef union{\n\tint16_t i16bit[3];\n\tuint8_t u8bit[6];\n} axis3bit16_t;\n\ntypedef union{\n\tint16_t i16bit;\n\tuint8_t u8bit[2];\n} axis1bit16_t;\n\ntypedef union{\n\tint32_t i32bit[3];\n\tuint8_t u8bit[12];\n} axis3bit32_t;\n\ntypedef union{\n\tint32_t i32bit;\n\tuint8_t u8bit[4];\n} axis1bit32_t;\n\ntypedef struct {\n   uint8_t bit0       : 1;\n   uint8_t bit1       : 1;\n   uint8_t bit2       : 1;\n   uint8_t bit3       : 1;\n   uint8_t bit4       : 1;\n   uint8_t bit5       : 1;\n   uint8_t bit6       : 1;\n   uint8_t bit7       : 1;\n} bitwise_t;\n\n#define PROPERTY_DISABLE                (0)\n#define PROPERTY_ENABLE                 (1)\n\n#endif /*__MEMS_SHARED__TYPES*/\n\n/**\n  * @}\n  */\n\n/** @defgroup lsm303agr_interface\n  * @{\n  */\n\ntypedef int32_t (*lsm303agr_write_ptr)(void *, uint8_t, uint8_t*, uint16_t);\ntypedef int32_t (*lsm303agr_read_ptr) (void *, uint8_t, uint8_t*, uint16_t);\n\ntypedef struct {\n  /** Component mandatory fields **/\n  lsm303agr_write_ptr  write_reg;\n  lsm303agr_read_ptr   read_reg;\n  /** Customizable optional pointer **/\n  void *handle;\n} lsm303agr_ctx_t;\n\n/**\n  * @}\n  */\n\n/** @defgroup lsm303agr_Infos\n  * @{\n  */\n  /** I2C Device Address 8 bit format**/\n#define LSM303AGR_I2C_ADD_XL       0x33\n#define LSM303AGR_I2C_ADD_MG       0x3D\n\n/** Device Identification (Who am I) **/\n#define LSM303AGR_ID_XL            0x33\n#define LSM303AGR_ID_MG            0x40\n\n/**\n  * @}\n  */\n\n/**\n  * @defgroup lsm303agr_Sensitivity\n  * @{\n  */\n\n#define LSM303AGR_FROM_FS_2g_HR_TO_mg(lsb)  (float)((int16_t)lsb>>4)* 1.0f\n#define LSM303AGR_FROM_FS_4g_HR_TO_mg(lsb)  (float)((int16_t)lsb>>4)* 2.0f\n#define LSM303AGR_FROM_FS_8g_HR_TO_mg(lsb)  (float)((int16_t)lsb>>4)* 4.0f\n#define LSM303AGR_FROM_FS_16g_HR_TO_mg(lsb) (float)((int16_t)lsb>>4)*12.0f\n#define LSM303AGR_FROM_LSB_TO_degC_HR(lsb) (float)((int16_t)lsb>>6)/4.0f+25.0f\n\n#define LSM303AGR_FROM_FS_2g_NM_TO_mg(lsb)  (float)((int16_t)lsb>>6)*  4.0f\n#define LSM303AGR_FROM_FS_4g_NM_TO_mg(lsb)  (float)((int16_t)lsb>>6)*  8.0f\n#define LSM303AGR_FROM_FS_8g_NM_TO_mg(lsb)  (float)((int16_t)lsb>>6)* 16.0f\n#define LSM303AGR_FROM_FS_16g_NM_TO_mg(lsb) (float)((int16_t)lsb>>6)* 48.0f\n#define LSM303AGR_FROM_LSB_TO_degC_NM(lsb) (float)((int16_t)lsb>>6)/4.0f+25.0f\n\n#define LSM303AGR_FROM_FS_2g_LP_TO_mg(lsb)  (float)((int16_t)lsb>>8)*16.0f\n#define LSM303AGR_FROM_FS_4g_LP_TO_mg(lsb)  (float)((int16_t)lsb>>8)*32.0f\n#define LSM303AGR_FROM_FS_8g_LP_TO_mg(lsb)  (float)((int16_t)lsb>>8)*64.0f\n#define LSM303AGR_FROM_FS_16g_LP_TO_mg(lsb) (float)((int16_t)lsb>>8)*192.0f\n\n#define LSM303AGR_FROM_LSB_TO_mG(lsb)     (float)(lsb * 1.5f)\n\n#define LSM303AGR_FROM_LSB_TO_degC_LP(lsb) (float)((int16_t)lsb>>8)*1.0f + 25.0f\n\n/**\n  * @}\n  */\n\n#define LSM303AGR_STATUS_REG_AUX_A           0x07\ntypedef struct {\n  uint8_t not_used_01            : 2;\n  uint8_t tda                    : 1;\n  uint8_t not_used_02            : 3;\n  uint8_t tor                    : 1;\n  uint8_t not_used_03            : 1;\n} lsm303agr_status_reg_aux_a_t;\n\n#define LSM303AGR_OUT_TEMP_L_A               0x0C\n#define LSM303AGR_OUT_TEMP_H_A               0x0D\n#define LSM303AGR_INT_COUNTER_REG_A          0x0E\n#define LSM303AGR_WHO_AM_I_A                 0x0F\n\n#define LSM303AGR_TEMP_CFG_REG_A             0x1F\ntypedef struct {\n  uint8_t not_used_01            : 6;\n  uint8_t temp_en                : 2;\n} lsm303agr_temp_cfg_reg_a_t;\n\n#define LSM303AGR_CTRL_REG1_A                0x20\ntypedef struct {\n  uint8_t xen                    : 1;\n  uint8_t yen                    : 1;\n  uint8_t zen                    : 1;\n  uint8_t lpen                   : 1;\n  uint8_t odr                    : 4;\n} lsm303agr_ctrl_reg1_a_t;\n\n#define LSM303AGR_CTRL_REG2_A                0x21\ntypedef struct {\n  uint8_t hp                     : 3; /* HPCLICK + HPIS2 + HPIS1 -> HP */\n  uint8_t fds                    : 1;\n  uint8_t hpcf                   : 2;\n  uint8_t hpm                    : 2;\n} lsm303agr_ctrl_reg2_a_t;\n\n#define LSM303AGR_CTRL_REG3_A                0x22\ntypedef struct {\n  uint8_t not_used_01            : 1;\n  uint8_t i1_overrun             : 1;\n  uint8_t i1_wtm                 : 1;\n  uint8_t i1_drdy2               : 1;\n  uint8_t i1_drdy1               : 1;\n  uint8_t i1_aoi2                : 1;\n  uint8_t i1_aoi1                : 1;\n  uint8_t i1_click               : 1;\n} lsm303agr_ctrl_reg3_a_t;\n\n#define LSM303AGR_CTRL_REG4_A                0x23\ntypedef struct {\n  uint8_t spi_enable             : 1;\n  uint8_t st                     : 2;\n  uint8_t hr                     : 1;\n  uint8_t fs                     : 2;\n  uint8_t ble                    : 1;\n  uint8_t bdu                    : 1;\n} lsm303agr_ctrl_reg4_a_t;\n\n#define LSM303AGR_CTRL_REG5_A                0x24\ntypedef struct {\n  uint8_t d4d_int2               : 1;\n  uint8_t lir_int2               : 1;\n  uint8_t d4d_int1               : 1;\n  uint8_t lir_int1               : 1;\n  uint8_t not_used_01            : 2;\n  uint8_t fifo_en                : 1;\n  uint8_t boot                   : 1;\n} lsm303agr_ctrl_reg5_a_t;\n\n#define LSM303AGR_CTRL_REG6_A               0x25\ntypedef struct {\n  uint8_t not_used_01            : 1;\n  uint8_t h_lactive              : 1;\n  uint8_t not_used_02            : 1;\n  uint8_t p2_act                 : 1;\n  uint8_t boot_i2                : 1;\n  uint8_t i2_int2                : 1;\n  uint8_t i2_int1                : 1;\n  uint8_t i2_clicken             : 1;\n} lsm303agr_ctrl_reg6_a_t;\n\n#define LSM303AGR_REFERENCE_A               0x26\n#define LSM303AGR_STATUS_REG_A              0x27\ntypedef struct {\n  uint8_t xda                    : 1;\n  uint8_t yda                    : 1;\n  uint8_t zda                    : 1;\n  uint8_t zyxda                  : 1;\n  uint8_t b_xor                    : 1;\n  uint8_t yor                    : 1;\n  uint8_t zor                    : 1;\n  uint8_t zyxor                  : 1;\n} lsm303agr_status_reg_a_t;\n\n#define LSM303AGR_OUT_X_L_A                 0x28\n#define LSM303AGR_OUT_X_H_A                 0x29\n#define LSM303AGR_OUT_Y_L_A                 0x2A\n#define LSM303AGR_OUT_Y_H_A                 0x2B\n#define LSM303AGR_OUT_Z_L_A                 0x2C\n#define LSM303AGR_OUT_Z_H_A                 0x2D\n#define LSM303AGR_FIFO_CTRL_REG_A           0x2E\ntypedef struct {\n  uint8_t fth                    : 5;\n  uint8_t tr                     : 1;\n  uint8_t fm                     : 2;\n} lsm303agr_fifo_ctrl_reg_a_t;\n\n#define LSM303AGR_FIFO_SRC_REG_A            0x2F\ntypedef struct {\n  uint8_t fss                    : 5;\n  uint8_t empty                  : 1;\n  uint8_t ovrn_fifo              : 1;\n  uint8_t wtm                    : 1;\n} lsm303agr_fifo_src_reg_a_t;\n\n#define LSM303AGR_INT1_CFG_A                0x30\ntypedef struct {\n  uint8_t xlie                   : 1; /* or XDOWNE */\n  uint8_t xhie                   : 1; /* or XUPE */\n  uint8_t ylie                   : 1; /* or YDOWNE */\n  uint8_t yhie                   : 1; /* or YUPE */\n  uint8_t zlie                   : 1; /* or ZDOWNE */\n  uint8_t zhie                   : 1; /* or ZUPE */\n  uint8_t _6d                    : 1;\n  uint8_t aoi                    : 1;\n} lsm303agr_int1_cfg_a_t;\n\n#define LSM303AGR_INT1_SRC_A                0x31\ntypedef struct {\n  uint8_t xl                     : 1;\n  uint8_t xh                     : 1;\n  uint8_t yl                     : 1;\n  uint8_t yh                     : 1;\n  uint8_t zl                     : 1;\n  uint8_t zh                     : 1;\n  uint8_t ia                     : 1;\n  uint8_t not_used_01            : 1;\n} lsm303agr_int1_src_a_t;\n\n#define LSM303AGR_INT1_THS_A                0x32\ntypedef struct {\n  uint8_t ths                    : 7;\n  uint8_t not_used_01            : 1;\n} lsm303agr_int1_ths_a_t;\n\n#define LSM303AGR_INT1_DURATION_A           0x33\ntypedef struct {\n  uint8_t d                      : 7;\n  uint8_t not_used_01            : 1;\n} lsm303agr_int1_duration_a_t;\n\n#define LSM303AGR_INT2_CFG_A                0x34\ntypedef struct {\n  uint8_t xlie                   : 1;\n  uint8_t xhie                   : 1;\n  uint8_t ylie                   : 1;\n  uint8_t yhie                   : 1;\n  uint8_t zlie                   : 1;\n  uint8_t zhie                   : 1;\n  uint8_t _6d                    : 1;\n  uint8_t aoi                    : 1;\n} lsm303agr_int2_cfg_a_t;\n\n#define LSM303AGR_INT2_SRC_A                0x35\ntypedef struct {\n  uint8_t xl                     : 1;\n  uint8_t xh                     : 1;\n  uint8_t yl                     : 1;\n  uint8_t yh                     : 1;\n  uint8_t zl                     : 1;\n  uint8_t zh                     : 1;\n  uint8_t ia                     : 1;\n  uint8_t not_used_01            : 1;\n} lsm303agr_int2_src_a_t;\n\n#define LSM303AGR_INT2_THS_A                0x36\ntypedef struct {\n  uint8_t ths                    : 7;\n  uint8_t not_used_01            : 1;\n} lsm303agr_int2_ths_a_t;\n\n#define LSM303AGR_INT2_DURATION_A           0x37\ntypedef struct {\n  uint8_t d                      : 7;\n  uint8_t not_used_01            : 1;\n} lsm303agr_int2_duration_a_t;\n\n#define LSM303AGR_CLICK_CFG_A               0x38\ntypedef struct {\n  uint8_t xs                     : 1;\n  uint8_t xd                     : 1;\n  uint8_t ys                     : 1;\n  uint8_t yd                     : 1;\n  uint8_t zs                     : 1;\n  uint8_t zd                     : 1;\n  uint8_t not_used_01            : 2;\n} lsm303agr_click_cfg_a_t;\n\n#define LSM303AGR_CLICK_SRC_A               0x39\ntypedef struct {\n  uint8_t x                      : 1;\n  uint8_t y                      : 1;\n  uint8_t z                      : 1;\n  uint8_t sign                   : 1;\n  uint8_t sclick                 : 1;\n  uint8_t dclick                 : 1;\n  uint8_t ia                     : 1;\n  uint8_t not_used_01            : 1;\n} lsm303agr_click_src_a_t;\n\n#define LSM303AGR_CLICK_THS_A               0x3A\ntypedef struct {\n  uint8_t ths                    : 7;\n  uint8_t not_used_01            : 1;\n} lsm303agr_click_ths_a_t;\n\n#define LSM303AGR_TIME_LIMIT_A              0x3B\ntypedef struct {\n  uint8_t tli                    : 7;\n  uint8_t not_used_01            : 1;\n} lsm303agr_time_limit_a_t;\n\n#define LSM303AGR_TIME_LATENCY_A            0x3C\ntypedef struct {\n  uint8_t tla                    : 8;\n} lsm303agr_time_latency_a_t;\n\n#define LSM303AGR_TIME_WINDOW_A             0x3D\ntypedef struct {\n  uint8_t tw                     : 8;\n} lsm303agr_time_window_a_t;\n\n#define LSM303AGR_ACT_THS_A                 0x3E\ntypedef struct {\n  uint8_t acth                   : 7;\n  uint8_t not_used_01            : 1;\n} lsm303agr_act_ths_a_t;\n\n#define LSM303AGR_ACT_DUR_A                 0x3F\ntypedef struct {\n  uint8_t actd                   : 8;\n} lsm303agr_act_dur_a_t;\n\n#define LSM303AGR_OFFSET_X_REG_L_M          0x45\n#define LSM303AGR_OFFSET_X_REG_H_M          0x46\n#define LSM303AGR_OFFSET_Y_REG_L_M          0x47\n#define LSM303AGR_OFFSET_Y_REG_H_M          0x48\n#define LSM303AGR_OFFSET_Z_REG_L_M          0x49\n#define LSM303AGR_OFFSET_Z_REG_H_M          0x4A\n#define LSM303AGR_WHO_AM_I_M                0x4F\n#define LSM303AGR_CFG_REG_A_M               0x60\ntypedef struct {\n  uint8_t md                     : 2;\n  uint8_t odr                    : 2;\n  uint8_t lp                     : 1;\n  uint8_t soft_rst               : 1;\n  uint8_t reboot                 : 1;\n  uint8_t comp_temp_en           : 1;\n} lsm303agr_cfg_reg_a_m_t;\n\n#define LSM303AGR_CFG_REG_B_M               0x61\ntypedef struct {\n  uint8_t lpf                    : 1;\n  uint8_t set_rst                : 2; /* OFF_CANC + Set_FREQ */\n  uint8_t int_on_dataoff         : 1;\n  uint8_t off_canc_one_shot      : 1;\n  uint8_t not_used_01            : 3;\n} lsm303agr_cfg_reg_b_m_t;\n\n#define LSM303AGR_CFG_REG_C_M               0x62\ntypedef struct {\n  uint8_t int_mag                : 1;\n  uint8_t self_test              : 1;\n  uint8_t not_used_01            : 1;\n  uint8_t ble                    : 1;\n  uint8_t bdu                    : 1;\n  uint8_t i2c_dis                : 1;\n  uint8_t int_mag_pin            : 1;\n  uint8_t not_used_02            : 1;\n} lsm303agr_cfg_reg_c_m_t;\n\n#define LSM303AGR_INT_CRTL_REG_M            0x63\ntypedef struct {\n  uint8_t ien                    : 1;\n  uint8_t iel                    : 1;\n  uint8_t iea                    : 1;\n  uint8_t not_used_01            : 2;\n  uint8_t zien                   : 1;\n  uint8_t yien                   : 1;\n  uint8_t xien                   : 1;\n} lsm303agr_int_crtl_reg_m_t;\n\n#define LSM303AGR_INT_SOURCE_REG_M          0x64\ntypedef struct {\n  uint8_t _int                    : 1;\n  uint8_t mroi                   : 1;\n  uint8_t n_th_s_z               : 1;\n  uint8_t n_th_s_y               : 1;\n  uint8_t n_th_s_x               : 1;\n  uint8_t p_th_s_z               : 1;\n  uint8_t p_th_s_y               : 1;\n  uint8_t p_th_s_x               : 1;\n} lsm303agr_int_source_reg_m_t;\n\n#define LSM303AGR_INT_THS_L_REG_M           0x65\n#define LSM303AGR_INT_THS_H_REG_M           0x66\n#define LSM303AGR_STATUS_REG_M              0x67\ntypedef struct {\n  uint8_t xda                    : 1;\n  uint8_t yda                    : 1;\n  uint8_t zda                    : 1;\n  uint8_t zyxda                  : 1;\n  uint8_t b_xor                    : 1;\n  uint8_t yor                    : 1;\n  uint8_t zor                    : 1;\n  uint8_t zyxor                  : 1;\n} lsm303agr_status_reg_m_t;\n\n#define LSM303AGR_OUTX_L_REG_M              0x68\n#define LSM303AGR_OUTX_H_REG_M              0x69\n#define LSM303AGR_OUTY_L_REG_M              0x6A\n#define LSM303AGR_OUTY_H_REG_M              0x6B\n#define LSM303AGR_OUTZ_L_REG_M              0x6C\n#define LSM303AGR_OUTZ_H_REG_M              0x6D\n\ntypedef union{\n  lsm303agr_status_reg_aux_a_t       status_reg_aux_a;\n  lsm303agr_temp_cfg_reg_a_t         temp_cfg_reg_a;\n  lsm303agr_ctrl_reg1_a_t            ctrl_reg1_a;\n  lsm303agr_ctrl_reg2_a_t            ctrl_reg2_a;\n  lsm303agr_ctrl_reg3_a_t            ctrl_reg3_a;\n  lsm303agr_ctrl_reg4_a_t            ctrl_reg4_a;\n  lsm303agr_ctrl_reg5_a_t            ctrl_reg5_a;\n  lsm303agr_ctrl_reg6_a_t            ctrl_reg6_a;\n  lsm303agr_status_reg_a_t           status_reg_a;\n  lsm303agr_fifo_ctrl_reg_a_t        fifo_ctrl_reg_a;\n  lsm303agr_fifo_src_reg_a_t         fifo_src_reg_a;\n  lsm303agr_int1_cfg_a_t             int1_cfg_a;\n  lsm303agr_int1_src_a_t             int1_src_a;\n  lsm303agr_int1_ths_a_t             int1_ths_a;\n  lsm303agr_int1_duration_a_t        int1_duration_a;\n  lsm303agr_int2_cfg_a_t             int2_cfg_a;\n  lsm303agr_int2_src_a_t             int2_src_a;\n  lsm303agr_int2_ths_a_t             int2_ths_a;\n  lsm303agr_int2_duration_a_t        int2_duration_a;\n  lsm303agr_click_cfg_a_t            click_cfg_a;\n  lsm303agr_click_src_a_t            click_src_a;\n  lsm303agr_click_ths_a_t            click_ths_a;\n  lsm303agr_time_limit_a_t           time_limit_a;\n  lsm303agr_time_latency_a_t         time_latency_a;\n  lsm303agr_time_window_a_t          time_window_a;\n  lsm303agr_act_ths_a_t              act_ths_a;\n  lsm303agr_act_dur_a_t              act_dur_a;\n  lsm303agr_cfg_reg_a_m_t            cfg_reg_a_m;\n  lsm303agr_cfg_reg_b_m_t            cfg_reg_b_m;\n  lsm303agr_cfg_reg_c_m_t            cfg_reg_c_m;\n  lsm303agr_int_crtl_reg_m_t         int_crtl_reg_m;\n  lsm303agr_int_source_reg_m_t       int_source_reg_m;\n  lsm303agr_status_reg_m_t           status_reg_m;  \n  bitwise_t                          bitwise;\n  uint8_t                            byte;\n} lsm303agr_reg_t;\n\nint32_t lsm303agr_read_reg(lsm303agr_ctx_t *ctx, uint8_t reg, uint8_t* data,\n                          uint16_t len);\nint32_t lsm303agr_write_reg(lsm303agr_ctx_t *ctx, uint8_t reg, uint8_t* data,\n                           uint16_t len);\n\nint32_t lsm303agr_temp_status_reg_get(lsm303agr_ctx_t *ctx, uint8_t *buff);\n\nint32_t lsm303agr_temp_data_ready_get(lsm303agr_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm303agr_temp_data_ovr_get(lsm303agr_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm303agr_temperature_raw_get(lsm303agr_ctx_t *ctx, uint8_t *buff);\n\ntypedef enum {\n  LSM303AGR_TEMP_DISABLE  = 0,\n  LSM303AGR_TEMP_ENABLE   = 3,\n} lsm303agr_temp_en_a_t;\nint32_t lsm303agr_temperature_meas_set(lsm303agr_ctx_t *ctx,\n                                      lsm303agr_temp_en_a_t val);\nint32_t lsm303agr_temperature_meas_get(lsm303agr_ctx_t *ctx,\n                                      lsm303agr_temp_en_a_t *val);\n\ntypedef enum {\n  LSM303AGR_HR_12bit   = 0,\n  LSM303AGR_NM_10bit   = 1,\n  LSM303AGR_LP_8bit    = 2,\n} lsm303agr_op_md_a_t;\nint32_t lsm303agr_xl_operating_mode_set(lsm303agr_ctx_t *ctx,\n                                    lsm303agr_op_md_a_t val);\nint32_t lsm303agr_xl_operating_mode_get(lsm303agr_ctx_t *ctx,\n                                    lsm303agr_op_md_a_t *val);\n\ntypedef enum {\n  LSM303AGR_XL_POWER_DOWN        = 0,\n  LSM303AGR_XL_ODR_1Hz           = 1,\n  LSM303AGR_XL_ODR_10Hz          = 2,\n  LSM303AGR_XL_ODR_25Hz          = 3,\n  LSM303AGR_XL_ODR_50Hz          = 4,\n  LSM303AGR_XL_ODR_100Hz         = 5,\n  LSM303AGR_XL_ODR_200Hz         = 6,\n  LSM303AGR_XL_ODR_400Hz         = 7,\n  LSM303AGR_XL_ODR_1kHz620_LP    = 8,\n  LSM303AGR_XL_ODR_5kHz376_LP    = 9,\n  LSM303AGR_XL_ODR_1kHz344_NM_HP = 9,\n} lsm303agr_odr_a_t;\nint32_t lsm303agr_xl_data_rate_set(lsm303agr_ctx_t *ctx,\n                                   lsm303agr_odr_a_t val);\nint32_t lsm303agr_xl_data_rate_get(lsm303agr_ctx_t *ctx,\n                                   lsm303agr_odr_a_t *val);\n\nint32_t lsm303agr_xl_high_pass_on_outputs_set(lsm303agr_ctx_t *ctx,\n                                              uint8_t val);\nint32_t lsm303agr_xl_high_pass_on_outputs_get(lsm303agr_ctx_t *ctx,\n                                              uint8_t *val);\n\ntypedef enum {\n  LSM303AGR_AGGRESSIVE  = 0,\n  LSM303AGR_STRONG      = 1,\n  LSM303AGR_MEDIUM      = 2,\n  LSM303AGR_LIGHT       = 3,\n} lsm303agr_hpcf_a_t;\nint32_t lsm303agr_xl_high_pass_bandwidth_set(lsm303agr_ctx_t *ctx,\n                                             lsm303agr_hpcf_a_t val);\nint32_t lsm303agr_xl_high_pass_bandwidth_get(lsm303agr_ctx_t *ctx,\n                                             lsm303agr_hpcf_a_t *val);\n\ntypedef enum {\n  LSM303AGR_NORMAL_WITH_RST  = 0,\n  LSM303AGR_REFERENCE_MODE   = 1,\n  LSM303AGR_NORMAL           = 2,\n  LSM303AGR_AUTORST_ON_INT   = 3,\n} lsm303agr_hpm_a_t;\nint32_t lsm303agr_xl_high_pass_mode_set(lsm303agr_ctx_t *ctx,\n                                        lsm303agr_hpm_a_t val);\nint32_t lsm303agr_xl_high_pass_mode_get(lsm303agr_ctx_t *ctx,\n                                        lsm303agr_hpm_a_t *val);\n\ntypedef enum {\n  LSM303AGR_2g   = 0,\n  LSM303AGR_4g   = 1,\n  LSM303AGR_8g   = 2,\n  LSM303AGR_16g  = 3,\n} lsm303agr_fs_a_t;\nint32_t lsm303agr_xl_full_scale_set(lsm303agr_ctx_t *ctx,\n                                    lsm303agr_fs_a_t val);\nint32_t lsm303agr_xl_full_scale_get(lsm303agr_ctx_t *ctx,\n                                    lsm303agr_fs_a_t *val);\n\nint32_t lsm303agr_xl_block_data_update_set(lsm303agr_ctx_t *ctx, uint8_t val);\nint32_t lsm303agr_xl_block_data_update_get(lsm303agr_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm303agr_xl_filter_reference_set(lsm303agr_ctx_t *ctx, uint8_t *buff);\nint32_t lsm303agr_xl_filter_reference_get(lsm303agr_ctx_t *ctx, uint8_t *buff);\n\nint32_t lsm303agr_xl_data_ready_get(lsm303agr_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm303agr_xl_data_ovr_get(lsm303agr_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm303agr_acceleration_raw_get(lsm303agr_ctx_t *ctx, uint8_t *buff);\n\nint32_t lsm303agr_xl_device_id_get(lsm303agr_ctx_t *ctx, uint8_t *buff);\n\ntypedef enum {\n  LSM303AGR_ST_DISABLE   = 0,\n  LSM303AGR_ST_POSITIVE  = 1,\n  LSM303AGR_ST_NEGATIVE  = 2,\n} lsm303agr_st_a_t;\nint32_t lsm303agr_xl_self_test_set(lsm303agr_ctx_t *ctx,\n                                   lsm303agr_st_a_t val);\nint32_t lsm303agr_xl_self_test_get(lsm303agr_ctx_t *ctx,\n                                   lsm303agr_st_a_t *val);\n\ntypedef enum {\n  LSM303AGR_XL_LSB_AT_LOW_ADD = 0,\n  LSM303AGR_XL_MSB_AT_LOW_ADD = 1,\n} lsm303agr_ble_a_t;\nint32_t lsm303agr_xl_data_format_set(lsm303agr_ctx_t *ctx,\n                                     lsm303agr_ble_a_t val);\nint32_t lsm303agr_xl_data_format_get(lsm303agr_ctx_t *ctx,\n                                     lsm303agr_ble_a_t *val);\n\nint32_t lsm303agr_xl_boot_set(lsm303agr_ctx_t *ctx, uint8_t val);\nint32_t lsm303agr_xl_boot_get(lsm303agr_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm303agr_xl_status_get(lsm303agr_ctx_t *ctx,\n                                lsm303agr_status_reg_a_t *val);\n\nint32_t lsm303agr_xl_int1_gen_conf_set(lsm303agr_ctx_t *ctx,\n                                       lsm303agr_int1_cfg_a_t *val);\nint32_t lsm303agr_xl_int1_gen_conf_get(lsm303agr_ctx_t *ctx,\n                                       lsm303agr_int1_cfg_a_t *val);\n\nint32_t lsm303agr_xl_int1_gen_source_get(lsm303agr_ctx_t *ctx,\n                                         lsm303agr_int1_src_a_t *val);\n\nint32_t lsm303agr_xl_int1_gen_threshold_set(lsm303agr_ctx_t *ctx,\n                                            uint8_t val);\nint32_t lsm303agr_xl_int1_gen_threshold_get(lsm303agr_ctx_t *ctx,\n                                            uint8_t *val);\n\nint32_t lsm303agr_xl_int1_gen_duration_set(lsm303agr_ctx_t *ctx,\n                                           uint8_t val);\nint32_t lsm303agr_xl_int1_gen_duration_get(lsm303agr_ctx_t *ctx,\n                                           uint8_t *val);\n\nint32_t lsm303agr_xl_int2_gen_conf_set(lsm303agr_ctx_t *ctx,\n                                       lsm303agr_int2_cfg_a_t *val);\nint32_t lsm303agr_xl_int2_gen_conf_get(lsm303agr_ctx_t *ctx,\n                                       lsm303agr_int2_cfg_a_t *val);\n\nint32_t lsm303agr_xl_int2_gen_source_get(lsm303agr_ctx_t *ctx,\n                                         lsm303agr_int2_src_a_t *val);\n\nint32_t lsm303agr_xl_int2_gen_threshold_set(lsm303agr_ctx_t *ctx,\n                                            uint8_t val);\nint32_t lsm303agr_xl_int2_gen_threshold_get(lsm303agr_ctx_t *ctx,\n                                            uint8_t *val);\n\nint32_t lsm303agr_xl_int2_gen_duration_set(lsm303agr_ctx_t *ctx,\n                                           uint8_t val);\nint32_t lsm303agr_xl_int2_gen_duration_get(lsm303agr_ctx_t *ctx,\n                                           uint8_t *val);\n\ntypedef enum {\n  LSM303AGR_DISC_FROM_INT_GENERATOR  = 0,\n  LSM303AGR_ON_INT1_GEN              = 1,\n  LSM303AGR_ON_INT2_GEN              = 2,\n  LSM303AGR_ON_TAP_GEN               = 4,\n  LSM303AGR_ON_INT1_INT2_GEN         = 3,\n  LSM303AGR_ON_INT1_TAP_GEN          = 5,\n  LSM303AGR_ON_INT2_TAP_GEN          = 6,\n  LSM303AGR_ON_INT1_INT2_TAP_GEN     = 7,\n} lsm303agr_hp_a_t;\nint32_t lsm303agr_xl_high_pass_int_conf_set(lsm303agr_ctx_t *ctx,\n                                            lsm303agr_hp_a_t val);\nint32_t lsm303agr_xl_high_pass_int_conf_get(lsm303agr_ctx_t *ctx,\n                                            lsm303agr_hp_a_t *val);\n\nint32_t lsm303agr_xl_pin_int1_config_set(lsm303agr_ctx_t *ctx,\n                                         lsm303agr_ctrl_reg3_a_t *val);\nint32_t lsm303agr_xl_pin_int1_config_get(lsm303agr_ctx_t *ctx,\n                                         lsm303agr_ctrl_reg3_a_t *val);\n\nint32_t lsm303agr_xl_int2_pin_detect_4d_set(lsm303agr_ctx_t *ctx,\n                                            uint8_t val);\nint32_t lsm303agr_xl_int2_pin_detect_4d_get(lsm303agr_ctx_t *ctx,\n                                            uint8_t *val);\n\ntypedef enum {\n  LSM303AGR_INT2_PULSED   = 0,\n  LSM303AGR_INT2_LATCHED  = 1,\n} lsm303agr_lir_int2_a_t;\nint32_t lsm303agr_xl_int2pin_notification_mode_set(lsm303agr_ctx_t *ctx,\n                                                   lsm303agr_lir_int2_a_t val);\nint32_t lsm303agr_xl_int2pin_notification_mode_get(lsm303agr_ctx_t *ctx,\n                                                   lsm303agr_lir_int2_a_t *val);\n\nint32_t lsm303agr_xl_int1_pin_detect_4d_set(lsm303agr_ctx_t *ctx,\n                                            uint8_t val);\nint32_t lsm303agr_xl_int1_pin_detect_4d_get(lsm303agr_ctx_t *ctx,\n                                            uint8_t *val);\n\ntypedef enum {\n  LSM303AGR_INT1_PULSED   = 0,\n  LSM303AGR_INT1_LATCHED  = 1,\n} lsm303agr_lir_int1_a_t;\nint32_t lsm303agr_xl_int1pin_notification_mode_set(lsm303agr_ctx_t *ctx,\n                                                   lsm303agr_lir_int1_a_t val);\nint32_t lsm303agr_xl_int1pin_notification_mode_get(lsm303agr_ctx_t *ctx,\n                                                   lsm303agr_lir_int1_a_t *val);\n\nint32_t lsm303agr_xl_pin_int2_config_set(lsm303agr_ctx_t *ctx,\n                                         lsm303agr_ctrl_reg6_a_t *val);\nint32_t lsm303agr_xl_pin_int2_config_get(lsm303agr_ctx_t *ctx,\n                                         lsm303agr_ctrl_reg6_a_t *val);\n\nint32_t lsm303agr_xl_fifo_set(lsm303agr_ctx_t *ctx, uint8_t val);\nint32_t lsm303agr_xl_fifo_get(lsm303agr_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm303agr_xl_fifo_watermark_set(lsm303agr_ctx_t *ctx, uint8_t val);\nint32_t lsm303agr_xl_fifo_watermark_get(lsm303agr_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM303AGR_INT1_GEN = 0,\n  LSM303AGR_INT2_GEN = 1,\n} lsm303agr_tr_a_t;\nint32_t lsm303agr_xl_fifo_trigger_event_set(lsm303agr_ctx_t *ctx,\n                                            lsm303agr_tr_a_t val);\nint32_t lsm303agr_xl_fifo_trigger_event_get(lsm303agr_ctx_t *ctx,\n                                            lsm303agr_tr_a_t *val);\n\ntypedef enum {\n  LSM303AGR_BYPASS_MODE           = 0,\n  LSM303AGR_FIFO_MODE             = 1,\n  LSM303AGR_DYNAMIC_STREAM_MODE   = 2,\n  LSM303AGR_STREAM_TO_FIFO_MODE   = 3,\n} lsm303agr_fm_a_t;\nint32_t lsm303agr_xl_fifo_mode_set(lsm303agr_ctx_t *ctx,\n                                   lsm303agr_fm_a_t val);\nint32_t lsm303agr_xl_fifo_mode_get(lsm303agr_ctx_t *ctx,\n                                   lsm303agr_fm_a_t *val);\n\nint32_t lsm303agr_xl_fifo_status_get(lsm303agr_ctx_t *ctx,\n                                     lsm303agr_fifo_src_reg_a_t *val);\n\nint32_t lsm303agr_xl_fifo_data_level_get(lsm303agr_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm303agr_xl_fifo_empty_flag_get(lsm303agr_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm303agr_xl_fifo_ovr_flag_get(lsm303agr_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm303agr_xl_fifo_fth_flag_get(lsm303agr_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm303agr_tap_conf_set(lsm303agr_ctx_t *ctx,\n                               lsm303agr_click_cfg_a_t *val);\nint32_t lsm303agr_tap_conf_get(lsm303agr_ctx_t *ctx,\n                               lsm303agr_click_cfg_a_t *val);\n\nint32_t lsm303agr_tap_source_get(lsm303agr_ctx_t *ctx,\n                                lsm303agr_click_src_a_t *val);\n\nint32_t lsm303agr_tap_threshold_set(lsm303agr_ctx_t *ctx, uint8_t val);\nint32_t lsm303agr_tap_threshold_get(lsm303agr_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm303agr_shock_dur_set(lsm303agr_ctx_t *ctx, uint8_t val);\nint32_t lsm303agr_shock_dur_get(lsm303agr_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm303agr_quiet_dur_set(lsm303agr_ctx_t *ctx, uint8_t val);\nint32_t lsm303agr_quiet_dur_get(lsm303agr_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm303agr_double_tap_timeout_set(lsm303agr_ctx_t *ctx,\n                                         uint8_t val);\nint32_t lsm303agr_double_tap_timeout_get(lsm303agr_ctx_t *ctx,\n                                         uint8_t *val);\n\nint32_t lsm303agr_act_threshold_set(lsm303agr_ctx_t *ctx, uint8_t val);\nint32_t lsm303agr_act_threshold_get(lsm303agr_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm303agr_act_timeout_set(lsm303agr_ctx_t *ctx, uint8_t val);\nint32_t lsm303agr_act_timeout_get(lsm303agr_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM303AGR_SPI_4_WIRE = 0,\n  LSM303AGR_SPI_3_WIRE = 1,\n} lsm303agr_sim_a_t;\nint32_t lsm303agr_xl_spi_mode_set(lsm303agr_ctx_t *ctx,\n                                  lsm303agr_sim_a_t val);\nint32_t lsm303agr_xl_spi_mode_get(lsm303agr_ctx_t *ctx,\n                                  lsm303agr_sim_a_t *val);\n\nint32_t lsm303agr_mag_user_offset_set(lsm303agr_ctx_t *ctx,\n                                      uint8_t *buff);\nint32_t lsm303agr_mag_user_offset_get(lsm303agr_ctx_t *ctx,\n                                      uint8_t *buff);\n                      \ntypedef enum {\n  LSM303AGR_CONTINUOUS_MODE  = 0,\n  LSM303AGR_SINGLE_TRIGGER   = 1,\n  LSM303AGR_POWER_DOWN       = 2,\n} lsm303agr_md_m_t;\nint32_t lsm303agr_mag_operating_mode_set(lsm303agr_ctx_t *ctx,\n                                         lsm303agr_md_m_t val);\nint32_t lsm303agr_mag_operating_mode_get(lsm303agr_ctx_t *ctx,\n                                         lsm303agr_md_m_t *val);\n\ntypedef enum {\n  LSM303AGR_MG_ODR_10Hz   = 0,\n  LSM303AGR_MG_ODR_20Hz   = 1,\n  LSM303AGR_MG_ODR_50Hz   = 2,\n  LSM303AGR_MG_ODR_100Hz  = 3,\n} lsm303agr_mg_odr_m_t;\nint32_t lsm303agr_mag_data_rate_set(lsm303agr_ctx_t *ctx,\n                                    lsm303agr_mg_odr_m_t val);\nint32_t lsm303agr_mag_data_rate_get(lsm303agr_ctx_t *ctx,\n                                    lsm303agr_mg_odr_m_t *val);\n\ntypedef enum {\n  LSM303AGR_HIGH_RESOLUTION  = 0,\n  LSM303AGR_LOW_POWER        = 1,\n} lsm303agr_lp_m_t;\nint32_t lsm303agr_mag_power_mode_set(lsm303agr_ctx_t *ctx,\n                                     lsm303agr_lp_m_t val);\nint32_t lsm303agr_mag_power_mode_get(lsm303agr_ctx_t *ctx,\n                                     lsm303agr_lp_m_t *val);\n\nint32_t lsm303agr_mag_offset_temp_comp_set(lsm303agr_ctx_t *ctx,\n                                           uint8_t val);\nint32_t lsm303agr_mag_offset_temp_comp_get(lsm303agr_ctx_t *ctx,\n                                           uint8_t *val);\n\ntypedef enum {\n  LSM303AGR_ODR_DIV_2  = 0,\n  LSM303AGR_ODR_DIV_4  = 1,\n} lsm303agr_lpf_m_t;\nint32_t lsm303agr_mag_low_pass_bandwidth_set(lsm303agr_ctx_t *ctx,\n                                             lsm303agr_lpf_m_t val);\nint32_t lsm303agr_mag_low_pass_bandwidth_get(lsm303agr_ctx_t *ctx,\n                                             lsm303agr_lpf_m_t *val);\n\ntypedef enum {\n  LSM303AGR_SET_SENS_ODR_DIV_63        = 0,\n  LSM303AGR_SENS_OFF_CANC_EVERY_ODR    = 1,\n  LSM303AGR_SET_SENS_ONLY_AT_POWER_ON  = 2,\n} lsm303agr_set_rst_m_t;\nint32_t lsm303agr_mag_set_rst_mode_set(lsm303agr_ctx_t *ctx,\n                                       lsm303agr_set_rst_m_t val);\nint32_t lsm303agr_mag_set_rst_mode_get(lsm303agr_ctx_t *ctx,\n                                       lsm303agr_set_rst_m_t *val);\n\nint32_t lsm303agr_mag_set_rst_sensor_single_set(lsm303agr_ctx_t *ctx,\n                                                uint8_t val);\nint32_t lsm303agr_mag_set_rst_sensor_single_get(lsm303agr_ctx_t *ctx,\n                                                uint8_t *val);\n\nint32_t lsm303agr_mag_block_data_update_set(lsm303agr_ctx_t *ctx,\n                                            uint8_t val);\nint32_t lsm303agr_mag_block_data_update_get(lsm303agr_ctx_t *ctx,\n                                            uint8_t *val);\n\nint32_t lsm303agr_mag_data_ready_get(lsm303agr_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm303agr_mag_data_ovr_get(lsm303agr_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm303agr_magnetic_raw_get(lsm303agr_ctx_t *ctx, uint8_t *buff);\n\nint32_t lsm303agr_mag_device_id_get(lsm303agr_ctx_t *ctx, uint8_t *buff);\n\nint32_t lsm303agr_mag_reset_set(lsm303agr_ctx_t *ctx, uint8_t val);\nint32_t lsm303agr_mag_reset_get(lsm303agr_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm303agr_mag_boot_set(lsm303agr_ctx_t *ctx, uint8_t val);\nint32_t lsm303agr_mag_boot_get(lsm303agr_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm303agr_mag_self_test_set(lsm303agr_ctx_t *ctx,\n                                    uint8_t val);\nint32_t lsm303agr_mag_self_test_get(lsm303agr_ctx_t *ctx,\n                                    uint8_t *val);\n\ntypedef enum {\n  LSM303AGR_MG_LSB_AT_LOW_ADD  = 0,\n  LSM303AGR_MG_MSB_AT_LOW_ADD  = 1,\n} lsm303agr_ble_m_t;\nint32_t lsm303agr_mag_data_format_set(lsm303agr_ctx_t *ctx,\n                                      lsm303agr_ble_m_t val);\nint32_t lsm303agr_mag_data_format_get(lsm303agr_ctx_t *ctx,\n                                      lsm303agr_ble_m_t *val);\n\nint32_t lsm303agr_mag_status_get(lsm303agr_ctx_t *ctx,\n                                 lsm303agr_status_reg_m_t *val);\n\ntypedef enum {\n  LSM303AGR_CHECK_BEFORE  = 0,\n  LSM303AGR_CHECK_AFTER   = 1,\n} lsm303agr_int_on_dataoff_m_t;\nint32_t lsm303agr_mag_offset_int_conf_set(lsm303agr_ctx_t *ctx,\n                                          lsm303agr_int_on_dataoff_m_t val);\nint32_t lsm303agr_mag_offset_int_conf_get(lsm303agr_ctx_t *ctx,\n                                          lsm303agr_int_on_dataoff_m_t *val);\n\nint32_t lsm303agr_mag_drdy_on_pin_set(lsm303agr_ctx_t *ctx, uint8_t val);\nint32_t lsm303agr_mag_drdy_on_pin_get(lsm303agr_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm303agr_mag_int_on_pin_set(lsm303agr_ctx_t *ctx, uint8_t val);\nint32_t lsm303agr_mag_int_on_pin_get(lsm303agr_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm303agr_mag_int_gen_conf_set(lsm303agr_ctx_t *ctx,\n                                       lsm303agr_int_crtl_reg_m_t *val);\nint32_t lsm303agr_mag_int_gen_conf_get(lsm303agr_ctx_t *ctx,\n                                       lsm303agr_int_crtl_reg_m_t *val);\n\nint32_t lsm303agr_mag_int_gen_source_get(lsm303agr_ctx_t *ctx,\n                                         lsm303agr_int_source_reg_m_t *val);\n\nint32_t lsm303agr_mag_int_gen_treshold_set(lsm303agr_ctx_t *ctx,\n                                           uint8_t *buff);\nint32_t lsm303agr_mag_int_gen_treshold_get(lsm303agr_ctx_t *ctx,\n                                           uint8_t *buff);\ntypedef enum {\n  LSM303AGR_I2C_ENABLE   = 0,\n  LSM303AGR_I2C_DISABLE  = 1,\n} lsm303agr_i2c_dis_m_t;\nint32_t lsm303agr_mag_i2c_interface_set(lsm303agr_ctx_t *ctx,\n                                        lsm303agr_i2c_dis_m_t val);\nint32_t lsm303agr_mag_i2c_interface_get(lsm303agr_ctx_t *ctx,\n                                        lsm303agr_i2c_dis_m_t *val);\n\n/**\n  * @}\n  */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /*__LSM303AGR_DRIVER__H */\n\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\n"
              },
              "objects": {
                "lsm303agr.c": "#include \"lsm303agr.h\"\r\n#include \"lsm303agr_reg.h\"\r\n\r\nstatic ATMO_LSM303AGR_Config_t _LSM303AGR_PrivConfig;\r\nstatic lsm303agr_ctx_t _LSM303AGR_AccelCtx;\r\nstatic lsm303agr_ctx_t _LSM303AGR_MagCtx;\r\n\r\nstatic int32_t _ATMO_LSM303AGR_PlatformWrite(void *handle, uint8_t Reg, uint8_t *Bufp,\r\n                              uint16_t len)\r\n{\r\n\tif(_LSM303AGR_PrivConfig.driverType.type == ATMO_DRIVERTYPE_I2C )\r\n\t{\r\n\t\tuint8_t i2cAddress = *((uint8_t*)handle);\r\n\t\tATMO_I2C_Status_t status = ATMO_I2C_MasterWrite(_LSM303AGR_PrivConfig.i2cInstance, i2cAddress,\r\n\t\t&Reg, 1, Bufp, len, 1000);\r\n\t\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tATMO_GPIO_Device_Pin_t csPin = *((ATMO_GPIO_Device_Pin_t *)handle);\r\n\t\tATMO_GPIO_SetPinState(_LSM303AGR_PrivConfig.gpioInstance, csPin, ATMO_GPIO_PinState_Low);\r\n\t\tATMO_SPI_Status_t status = ATMO_SPI_MasterWrite(_LSM303AGR_PrivConfig.spiInstance, ATMO_SPI_CS_NONE, &Reg, 1, Bufp, len, 1000);\r\n\t\tATMO_GPIO_SetPinState(_LSM303AGR_PrivConfig.gpioInstance, csPin, ATMO_GPIO_PinState_High);\r\n\t\treturn (status == ATMO_SPI_Status_Success) ? 0 : 1;\r\n\t}\r\n  \r\n\r\n}\r\n\r\nstatic int32_t _ATMO_LSM303AGR_PlatformRead(void *handle, uint8_t Reg, uint8_t *Bufp,\r\n                             uint16_t len)\r\n{\r\n\tif(_LSM303AGR_PrivConfig.driverType.type == ATMO_DRIVERTYPE_I2C )\r\n\t{\r\n\t\tuint8_t i2cAddress = *((uint8_t*)handle);\r\n\t\tATMO_I2C_Status_t status = ATMO_I2C_Status_Success;\r\n\t\tuint8_t currentReg = Reg;\r\n\r\n\t\t// Need to do discrete reads or block update doesn't work\r\n\t\tfor(unsigned int i = 0; (i < len) && (status == ATMO_I2C_Status_Success); i++)\r\n\t\t{\r\n\t\t\tstatus = ATMO_I2C_MasterRead(_LSM303AGR_PrivConfig.i2cInstance, i2cAddress,\r\n\t\t\t\t&currentReg, 1, &Bufp[i], 1, 1000);\r\n\t\t\tcurrentReg++;\r\n\t\t}\r\n\r\n\t\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tATMO_GPIO_Device_Pin_t csPin = *((ATMO_GPIO_Device_Pin_t *)handle);\r\n\t\tATMO_GPIO_SetPinState(_LSM303AGR_PrivConfig.gpioInstance, csPin, ATMO_GPIO_PinState_Low);\r\n\r\n\t\tATMO_SPI_Status_t status = ATMO_SPI_Status_Success;\r\n\r\n\t\tfor(unsigned int i = 0; (i < len) && (status == ATMO_SPI_Status_Success); i++)\r\n\t\t{\r\n\t\t\tATMO_GPIO_SetPinState(_LSM303AGR_PrivConfig.gpioInstance, csPin, ATMO_GPIO_PinState_Low);\r\n\t\t\tuint8_t readReg = (Reg + i) | 0x80;\r\n\t\t\tstatus = ATMO_SPI_MasterRead(_LSM303AGR_PrivConfig.spiInstance, ATMO_SPI_CS_NONE, &readReg, 1, &Bufp[i], 1, 1000);\r\n\t\t\tATMO_GPIO_SetPinState(_LSM303AGR_PrivConfig.gpioInstance, csPin, ATMO_GPIO_PinState_High);\r\n\t\t}\r\n\r\n\r\n\t\treturn (status == ATMO_SPI_Status_Success) ? 0 : 1;\r\n\t}\r\n}\r\n\r\nATMO_LSM303AGR_Status_t ATMO_LSM303AGR_Init(ATMO_LSM303AGR_Config_t *config)\r\n{\r\n    if(config == NULL)\r\n    {\r\n        return ATMO_LSM303AGR_Status_Fail;\r\n    }\r\n\r\n    memcpy(&_LSM303AGR_PrivConfig, config, sizeof(_LSM303AGR_PrivConfig));\r\n\r\n    _LSM303AGR_AccelCtx.write_reg = _ATMO_LSM303AGR_PlatformWrite;\r\n    _LSM303AGR_AccelCtx.read_reg = _ATMO_LSM303AGR_PlatformRead;\r\n    \r\n\r\n    _LSM303AGR_MagCtx.write_reg = _ATMO_LSM303AGR_PlatformWrite;\r\n    _LSM303AGR_MagCtx.read_reg = _ATMO_LSM303AGR_PlatformRead;\r\n\r\n\r\n    if(config->driverType.type == ATMO_DRIVERTYPE_SPI)\r\n    {\r\n        ATMO_SPI_Peripheral_t spiConf;\r\n\t\tspiConf.operatingMode = ATMO_SPI_OperatingMode_Master;\r\n\t\tspiConf.deviceConfig.baudRate = 2500000;\r\n\t\tspiConf.deviceConfig.clockContinuous = false;\r\n\t\tspiConf.deviceConfig.clockMode = ATMO_SPI_ClockMode_3;\r\n\t\tspiConf.deviceConfig.msbFirst = true;\r\n\t\tspiConf.deviceConfig.ssActiveLow = true;\r\n\t\tATMO_SPI_SetConfiguration(config->spiInstance, &spiConf);\r\n\r\n    \t_LSM303AGR_AccelCtx.handle = (void*)&_LSM303AGR_PrivConfig.accelCsPin;\r\n    \t_LSM303AGR_MagCtx.handle = (void*)&_LSM303AGR_PrivConfig.magCsPin;\r\n\r\n    \tATMO_GPIO_Config_t gpioConfig;\r\n    \tgpioConfig.initialState = ATMO_GPIO_PinState_High;\r\n    \tgpioConfig.pinMode = ATMO_GPIO_PinMode_Output_PushPull;\r\n    \tATMO_GPIO_SetPinConfiguration(config->gpioInstance, config->accelCsPin, &gpioConfig);\r\n    \tATMO_GPIO_SetPinConfiguration(config->gpioInstance, config->magCsPin, &gpioConfig);\r\n\r\n        uint8_t spiByte = 0x1; // Set to 3 wire mode\r\n        if(!config->spi3Wire)\r\n        {\r\n            spiByte = 0;\r\n        }\r\n\r\n        lsm303agr_write_reg(&_LSM303AGR_AccelCtx, LSM303AGR_CTRL_REG4_A, &spiByte, 1);\r\n    }\r\n    else\r\n    {\r\n        ATMO_I2C_Peripheral_t i2cConfig;\r\n\t\ti2cConfig.operatingMode = ATMO_I2C_OperatingMode_Master;\r\n\t\ti2cConfig.baudRate = ATMO_I2C_BaudRate_Standard_Mode;\r\n\t\tATMO_I2C_SetConfiguration(config->i2cInstance, &i2cConfig);\r\n        \r\n    \t_LSM303AGR_AccelCtx.handle = (void*)&_LSM303AGR_PrivConfig.accelI2CAddress;\r\n    \t_LSM303AGR_MagCtx.handle = (void*)&_LSM303AGR_PrivConfig.magI2CAddress;\r\n    }\r\n\r\n    // For some reason, need to get this twice for it to work the first time\r\n    uint8_t whoamI = 0;\r\n    lsm303agr_mag_device_id_get(&_LSM303AGR_MagCtx, &whoamI);\r\n\r\n    whoamI = 0;\r\n    lsm303agr_xl_device_id_get(&_LSM303AGR_AccelCtx, &whoamI);\r\n    if ( whoamI != LSM303AGR_ID_XL )\r\n    {\r\n        ATMO_PLATFORM_DebugPrint(\"Invalid LSM303AGR Accel WhoAmI (Rcv %02X Expect %02X\\r\\n\", whoamI, LSM303AGR_ID_XL);\r\n        return ATMO_LSM303AGR_Status_Fail;\r\n    }\r\n\r\n    whoamI = 0;\r\n    lsm303agr_mag_device_id_get(&_LSM303AGR_MagCtx, &whoamI);\r\n    if ( whoamI != LSM303AGR_ID_MG )\r\n    {\r\n        ATMO_PLATFORM_DebugPrint(\"Invalid LSM303AGR Mag WhoAmI (Rcv %02X Expect %02X\\r\\n\", whoamI, LSM303AGR_ID_MG);\r\n        return ATMO_LSM303AGR_Status_Fail;  \r\n    }\r\n\r\n    // Reset device settings\r\n    uint8_t rst = 0;\r\n    lsm303agr_mag_reset_set(&_LSM303AGR_MagCtx, PROPERTY_ENABLE);\r\n    do {\r\n        lsm303agr_mag_reset_get(&_LSM303AGR_MagCtx, &rst);\r\n    } while (rst);  \r\n\r\n    // Enable block update\r\n    lsm303agr_xl_block_data_update_set(&_LSM303AGR_AccelCtx, PROPERTY_ENABLE);\r\n    lsm303agr_mag_block_data_update_set(&_LSM303AGR_MagCtx, PROPERTY_ENABLE);\r\n\r\n    // Set ODR\r\n    lsm303agr_xl_data_rate_set(&_LSM303AGR_AccelCtx, config->accelOdr);\r\n    lsm303agr_mag_data_rate_set(&_LSM303AGR_MagCtx, config->magOdr);\r\n\r\n    // Set Full Scale\r\n    lsm303agr_xl_full_scale_set(&_LSM303AGR_AccelCtx, config->accelFullScale);\r\n\r\n    // Set Mag Sensor Mode\r\n    lsm303agr_mag_set_rst_mode_set(&_LSM303AGR_MagCtx, config->magRstMode);\r\n\r\n    // Enable/Disable Temp Sensor\r\n    lsm303agr_temperature_meas_set(&_LSM303AGR_AccelCtx, LSM303AGR_TEMP_ENABLE);  \r\n\r\n    // Device Operating Mode\r\n    lsm303agr_xl_operating_mode_set(&_LSM303AGR_AccelCtx, config->accelOperatingMode);\r\n    lsm303agr_mag_operating_mode_set(&_LSM303AGR_MagCtx, config->magOperatingMode);\r\n    \r\n \r\n    return ATMO_LSM303AGR_Status_Success;\r\n}\r\n\r\n/**\r\n * @brief Get acceleration data. Each axis is in mg\r\n * \r\n * @param data \r\n * @return ATMO_LSM303AGR_Status_t \r\n */\r\nATMO_LSM303AGR_Status_t ATMO_LSM303AGR_GetAccelData(ATMO_LSM303AGR_AccelData_t *data)\r\n{\r\n    uint8_t rawData[6] = {0};\r\n    lsm303agr_acceleration_raw_get(&_LSM303AGR_AccelCtx, rawData);\r\n\r\n    int16_t rawDataInt[3] = {0};\r\n    rawDataInt[0] = (rawData[1] << 8) | rawData[0];\r\n    rawDataInt[1] = (rawData[3] << 8) | rawData[2];\r\n    rawDataInt[2] = (rawData[5] << 8) | rawData[4];\r\n\r\n    switch(_LSM303AGR_PrivConfig.accelFullScale)\r\n    {\r\n        case LSM303AGR_2g:\r\n        {\r\n            data->x = LSM303AGR_FROM_FS_2g_HR_TO_mg( rawDataInt[0] );\r\n            data->y = LSM303AGR_FROM_FS_2g_HR_TO_mg( rawDataInt[1] );\r\n            data->z = LSM303AGR_FROM_FS_2g_HR_TO_mg( rawDataInt[2] );\r\n            break;\r\n        }\r\n        case LSM303AGR_4g:\r\n        {\r\n            data->x = LSM303AGR_FROM_FS_4g_HR_TO_mg( rawDataInt[0] );\r\n            data->y = LSM303AGR_FROM_FS_4g_HR_TO_mg( rawDataInt[1] );\r\n            data->z = LSM303AGR_FROM_FS_4g_HR_TO_mg( rawDataInt[2] );\r\n            break;\r\n        }\r\n        case LSM303AGR_8g:\r\n        {\r\n            data->x = LSM303AGR_FROM_FS_8g_HR_TO_mg( rawDataInt[0] );\r\n            data->y = LSM303AGR_FROM_FS_8g_HR_TO_mg( rawDataInt[1] );\r\n            data->z = LSM303AGR_FROM_FS_8g_HR_TO_mg( rawDataInt[2] );\r\n            break;\r\n        }\r\n        case LSM303AGR_16g:\r\n        {\r\n            data->x = LSM303AGR_FROM_FS_16g_HR_TO_mg( rawDataInt[0] );\r\n            data->y = LSM303AGR_FROM_FS_16g_HR_TO_mg( rawDataInt[1] );\r\n            data->z = LSM303AGR_FROM_FS_16g_HR_TO_mg( rawDataInt[2] );\r\n            break;\r\n        }\r\n        default:\r\n        {\r\n            memset(data, 0, sizeof(ATMO_LSM303AGR_AccelData_t));\r\n            return ATMO_LSM303AGR_Status_Fail;\r\n            break;\r\n        }\r\n\r\n    }\r\n\r\n    return ATMO_LSM303AGR_Status_Success;\r\n}\r\n\r\n/**\r\n * @brief Get magnetometer data. Each axis is in mG\r\n * \r\n * @param data \r\n * @return ATMO_LSM303AGR_Status_t \r\n */\r\nATMO_LSM303AGR_Status_t ATMO_LSM303AGR_GetMagData(ATMO_LSM303AGR_MagData_t *data)\r\n{\r\n    uint8_t rawData[6] = {0};\r\n    lsm303agr_magnetic_raw_get(&_LSM303AGR_MagCtx, rawData);\r\n\r\n    int16_t rawDataInt[3] = {0};\r\n    rawDataInt[0] = (rawData[1] << 8) | rawData[0];\r\n    rawDataInt[1] = (rawData[3] << 8) | rawData[2];\r\n    rawDataInt[2] = (rawData[5] << 8) | rawData[4];\r\n\r\n    data->x = LSM303AGR_FROM_LSB_TO_mG( rawDataInt[0] );\r\n    data->y = LSM303AGR_FROM_LSB_TO_mG( rawDataInt[1] );\r\n    data->z = LSM303AGR_FROM_LSB_TO_mG( rawDataInt[2] );\r\n\r\n    return ATMO_LSM303AGR_Status_Success;\r\n}\r\n\r\n/**\r\n * @brief Get temperature data in degrees C\r\n * \r\n * @param data \r\n * @return ATMO_LSM303AGR_Status_t \r\n */\r\nATMO_LSM303AGR_Status_t ATMO_LSM303AGR_GetTempData(float *tempC)\r\n{\r\n    uint8_t rawData[2] = {0};\r\n    lsm303agr_temperature_raw_get(&_LSM303AGR_AccelCtx, rawData);\r\n\r\n    int16_t tempDataInt = (rawData[1] << 8) | rawData[0];\r\n    *tempC = LSM303AGR_FROM_LSB_TO_degC_HR( tempDataInt );\r\n    return ATMO_LSM303AGR_Status_Success;\r\n}\r\n",
                "lsm303agr_reg.c": "/*\n ******************************************************************************\n * @file    lsm303agr_reg.c\n * @author  MEMS Software Solution Team\n * @date    12-October-2017\n * @brief   LSM303AGR driver file\n ******************************************************************************\n * @attention\n *\n * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *   1. Redistributions of source code must retain the above copyright notice,\n *      this list of conditions and the following disclaimer.\n *   2. Redistributions in binary form must reproduce the above copyright notice,\n *      this list of conditions and the following disclaimer in the documentation\n *      and/or other materials provided with the distribution.\n *   3. Neither the name of STMicroelectronics nor the names of its contributors\n *      may be used to endorse or promote products derived from this software\n *      without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n#include \"lsm303agr_reg.h\"\n\n/**\n  * @addtogroup  lsm303agr\n  * @brief  This file provides a set of functions needed to drive the\n  *         lsm303agr enanced inertial module.\n  * @{\n  */\n\n/**\n  * @addtogroup  interfaces_functions\n  * @brief  This section provide a set of functions used to read and write\n  *         a generic register of the device.\n  * @{\n  */\n\n/**\n  * @brief  Read generic device register\n  *\n  * @param  lsm303agr_ctx_t* ctx: read / write interface definitions\n  * @param  uint8_t reg: register to read\n  * @param  uint8_t* data: pointer to buffer that store the data read\n  * @param  uint16_t len: number of consecutive register to read\n  *\n  */\nint32_t lsm303agr_read_reg(lsm303agr_ctx_t* ctx, uint8_t reg, uint8_t* data,\n                          uint16_t len)\n{\n  return ctx->read_reg(ctx->handle, reg, data, len);\n}\n\n/**\n  * @brief  Write generic device register\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t reg: register to write\n  * @param  uint8_t* data: pointer to data to write in register reg\n  * @param  uint16_t len: number of consecutive register to write\n  *\n*/\nint32_t lsm303agr_write_reg(lsm303agr_ctx_t* ctx, uint8_t reg, uint8_t* data,\n                           uint16_t len)\n{\n  return ctx->write_reg(ctx->handle, reg, data, len);\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  data_generation_c\n  * @brief   This section group all the functions concerning data generation\n  * @{\n  */\n\n/**\n  * @brief  temp_status_reg: [get]  Temperature status register.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lsm303agr_temp_status_reg_get(lsm303agr_ctx_t *ctx, uint8_t *buff)\n{\n  return lsm303agr_read_reg(ctx, LSM303AGR_STATUS_REG_AUX_A, buff, 1);\n}\n/**\n  * @brief  temp_data_ready: [get]  Temperature data available.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of tda in reg STATUS_REG_AUX_A\n  *\n  */\nint32_t lsm303agr_temp_data_ready_get(lsm303agr_ctx_t *ctx, uint8_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_STATUS_REG_AUX_A,\n                                &reg.byte, 1);\n  *val = reg.status_reg_aux_a.tda;\n\n  return mm_error;\n}\n/**\n  * @brief  temp_data_ovr: [get]  Temperature data overrun.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of tor in reg STATUS_REG_AUX_A\n  *\n  */\nint32_t lsm303agr_temp_data_ovr_get(lsm303agr_ctx_t *ctx, uint8_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_STATUS_REG_AUX_A,\n                                &reg.byte, 1);\n  *val = reg.status_reg_aux_a.tor;\n\n  return mm_error;\n}\n/**\n  * @brief  temperature_raw: [get]  Temperature output value.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lsm303agr_temperature_raw_get(lsm303agr_ctx_t *ctx, uint8_t *buff)\n{\n  return lsm303agr_read_reg(ctx, LSM303AGR_OUT_TEMP_L_A, buff, 2);\n}\n/**\n  * @brief  temperature_meas: [set]  Temperature sensor enable.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_temp_en_a_t: change the values of temp_en in\n  *                             reg TEMP_CFG_REG_A\n  *\n  */\nint32_t lsm303agr_temperature_meas_set(lsm303agr_ctx_t *ctx,\n                                      lsm303agr_temp_en_a_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_TEMP_CFG_REG_A,\n                                &reg.byte, 1);\n  reg.temp_cfg_reg_a.temp_en = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_TEMP_CFG_REG_A,\n                                 &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  temperature_meas: [get]  Temperature sensor enable.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_temp_en_a_t: Get the values of temp_en in\n  *                                reg TEMP_CFG_REG_A\n  *\n  */\nint32_t lsm303agr_temperature_meas_get(lsm303agr_ctx_t *ctx,\n                                      lsm303agr_temp_en_a_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_TEMP_CFG_REG_A, &reg.byte, 1);\n  *val = (lsm303agr_temp_en_a_t) reg.temp_cfg_reg_a.temp_en;\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_operating_mode: [set]  Operating mode selection.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_op_md_a_t val: change the values of lpen in reg \n  *                                  CTRL_REG1_A and HR in reg CTRL_REG4_A\n  *\n  */\nint32_t lsm303agr_xl_operating_mode_set(lsm303agr_ctx_t *ctx,\n                                        lsm303agr_op_md_a_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n  uint8_t lpen, hr;\n\n  if ( val == LSM303AGR_HR_12bit ){\n    lpen = 0;\n    hr   = 1;\n  } else if (val == LSM303AGR_NM_10bit) {\n    lpen = 0;\n    hr   = 0;\n  } else {\n    lpen = 1;\n    hr   = 0;\n  }\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG1_A, &reg.byte, 1);\n  reg.ctrl_reg1_a.lpen = lpen;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG1_A, &reg.byte, 1);\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG4_A, &reg.byte, 1);\n  reg.ctrl_reg4_a.hr = hr;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG4_A, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_operating_mode: [get]  Operating mode selection.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_op_md_a_t val: get the values of lpen in reg \n  *                                  CTRL_REG1_A and HR in \n  *                                  reg CTRL_REG4_AG1_A\n  *\n  */\nint32_t lsm303agr_xl_operating_mode_get(lsm303agr_ctx_t *ctx,\n                                        lsm303agr_op_md_a_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n  uint8_t lpen, hr;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG1_A, &reg.byte, 1);\n  lpen = reg.ctrl_reg1_a.lpen;\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG4_A, &reg.byte, 1);\n  hr = reg.ctrl_reg4_a.hr;\n\n  if ( lpen ){\n    *val = LSM303AGR_LP_8bit;\n  } else if (hr) {\n    *val = LSM303AGR_HR_12bit;\n  } else{\n    *val = LSM303AGR_NM_10bit;\n  }\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_data_rate: [set]  Output data rate selection.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_odr_a_t: change the values of odr in reg CTRL_REG1_A\n  *\n  */\nint32_t lsm303agr_xl_data_rate_set(lsm303agr_ctx_t *ctx,\n                                   lsm303agr_odr_a_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG1_A,\n                                &reg.byte, 1);\n  reg.ctrl_reg1_a.odr = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG1_A,\n                                 &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_data_rate: [get]  Output data rate selection.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_odr_a_t: Get the values of odr in reg CTRL_REG1_A\n  *\n  */\nint32_t lsm303agr_xl_data_rate_get(lsm303agr_ctx_t *ctx,\n                                   lsm303agr_odr_a_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG1_A, &reg.byte, 1);\n  *val = (lsm303agr_odr_a_t) reg.ctrl_reg1_a.odr;\n\n  return mm_error;\n}\n\n/**\n  * @brief   xl_high_pass_on_outputs: [set] High pass data from internal\n  *                                         filter sent to output register\n  *                                         and FIFO\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of fds in reg CTRL_REG2_A\n  *\n  */\nint32_t lsm303agr_xl_high_pass_on_outputs_set(lsm303agr_ctx_t *ctx,\n                                              uint8_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG2_A, &reg.byte, 1);\n  reg.ctrl_reg2_a.fds = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG2_A, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief   xl_high_pass_on_outputs: [get] High pass data from internal\n  *                                         filter sent to output register\n  *                                         and FIFO\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of fds in reg CTRL_REG2_A\n  *\n  */\nint32_t lsm303agr_xl_high_pass_on_outputs_get(lsm303agr_ctx_t *ctx,\n                                              uint8_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG2_A, &reg.byte, 1);\n  *val = reg.ctrl_reg2_a.fds;\n\n  return mm_error;\n}\n\n/**\n  * @brief   xl_high_pass_bandwidth: [set]  High-pass filter cutoff\n  *                                         frequency selection\n  *\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_hpcf_a_t: change the values of hpcf in reg CTRL_REG2_A\n  *\n  * HPCF[2:1]\\ft @1Hz    @10Hz  @25Hz  @50Hz @100Hz @200Hz @400Hz @1kHz6 ft@5kHz\n  * AGGRESSIVE   0.02Hz  0.2Hz  0.5Hz  1Hz   2Hz    4Hz    8Hz    32Hz   100Hz\n  * STRONG       0.008Hz 0.08Hz 0.2Hz  0.5Hz 1Hz    2Hz    4Hz    16Hz   50Hz\n  * MEDIUM       0.004Hz 0.04Hz 0.1Hz  0.2Hz 0.5Hz  1Hz    2Hz    8Hz    25Hz\n  * LIGHT        0.002Hz 0.02Hz 0.05Hz 0.1Hz 0.2Hz  0.5Hz  1Hz    4Hz    12Hz\n  *\n  */\nint32_t lsm303agr_xl_high_pass_bandwidth_set(lsm303agr_ctx_t *ctx,\n                                             lsm303agr_hpcf_a_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG2_A, &reg.byte, 1);\n  reg.ctrl_reg2_a.hpcf = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG2_A, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief   xl_high_pass_bandwidth: [get]  High-pass filter cutoff\n  *                                         frequency selection\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_hpcf_a_t: Get the values of hpcf in reg CTRL_REG2_A\n  *\n  * HPCF[2:1]\\ft @1Hz    @10Hz  @25Hz  @50Hz @100Hz @200Hz @400Hz @1kHz6 ft@5kHz\n  * AGGRESSIVE   0.02Hz  0.2Hz  0.5Hz  1Hz   2Hz    4Hz    8Hz    32Hz   100Hz\n  * STRONG       0.008Hz 0.08Hz 0.2Hz  0.5Hz 1Hz    2Hz    4Hz    16Hz   50Hz\n  * MEDIUM       0.004Hz 0.04Hz 0.1Hz  0.2Hz 0.5Hz  1Hz    2Hz    8Hz    25Hz\n  * LIGHT        0.002Hz 0.02Hz 0.05Hz 0.1Hz 0.2Hz  0.5Hz  1Hz    4Hz    12Hz\n  *\n  */\nint32_t lsm303agr_xl_high_pass_bandwidth_get(lsm303agr_ctx_t *ctx,\n                                             lsm303agr_hpcf_a_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG2_A, &reg.byte, 1);\n  *val = (lsm303agr_hpcf_a_t) reg.ctrl_reg2_a.hpcf;\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_high_pass_mode: [set]  High-pass filter mode selection.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_hpcf_a_t: change the values of hpm in reg CTRL_REG2_A\n  *\n  */\nint32_t lsm303agr_xl_high_pass_mode_set(lsm303agr_ctx_t *ctx,\n                                        lsm303agr_hpm_a_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG2_A, &reg.byte, 1);\n  reg.ctrl_reg2_a.hpm = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG2_A, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_high_pass_mode: [get]  High-pass filter mode selection.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_hpcf_a_t: Get the values of hpm in reg CTRL_REG2_A\n  *\n  */\nint32_t lsm303agr_xl_high_pass_mode_get(lsm303agr_ctx_t *ctx,\n                                        lsm303agr_hpm_a_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG2_A, &reg.byte, 1);\n  *val = (lsm303agr_hpm_a_t) reg.ctrl_reg2_a.hpm;\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_full_scale: [set]  Full-scale configuration.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_fs_a_t: change the values of fs in reg CTRL_REG4_A\n  *\n  */\nint32_t lsm303agr_xl_full_scale_set(lsm303agr_ctx_t *ctx,\n                                    lsm303agr_fs_a_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG4_A, &reg.byte, 1);\n  reg.ctrl_reg4_a.fs = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG4_A, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_full_scale: [get]  Full-scale configuration.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_fs_a_t: Get the values of fs in reg CTRL_REG4_A\n  *\n  */\nint32_t lsm303agr_xl_full_scale_get(lsm303agr_ctx_t *ctx,\n                                    lsm303agr_fs_a_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG4_A, &reg.byte, 1);\n  *val = (lsm303agr_fs_a_t) reg.ctrl_reg4_a.fs;\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_block_data_update: [set] Blockdataupdate.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of bdu in reg CTRL_REG4_A\n  *\n  */\nint32_t lsm303agr_xl_block_data_update_set(lsm303agr_ctx_t *ctx,\n                                           uint8_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG4_A, &reg.byte, 1);\n  reg.ctrl_reg4_a.bdu = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG4_A, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_block_data_update: [get] Blockdataupdate.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of bdu in reg CTRL_REG4_A\n  *\n  */\nint32_t lsm303agr_xl_block_data_update_get(lsm303agr_ctx_t *ctx,\n                                           uint8_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG4_A, &reg.byte, 1);\n  *val = reg.ctrl_reg4_a.bdu;\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_filter_reference: [set]Reference value for interrupt generation.\n  *                                   LSB = ~16@2g / ~31@4g / ~63@8g / ~127@16g\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that contains data to write\n  *\n  */\nint32_t lsm303agr_xl_filter_reference_set(lsm303agr_ctx_t *ctx,\n                                          uint8_t *buff)\n{\n  return lsm303agr_write_reg(ctx, LSM303AGR_REFERENCE_A, buff, 1);\n}\n\n/**\n  * @brief  xl_filter_reference: [get]Reference value for interrupt generation.\n  *                                   LSB = ~16@2g / ~31@4g / ~63@8g / ~127@16g\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lsm303agr_xl_filter_reference_get(lsm303agr_ctx_t *ctx,\n                                          uint8_t *buff)\n{\n  return lsm303agr_read_reg(ctx, LSM303AGR_REFERENCE_A, buff, 1);\n}\n/**\n  * @brief  xl_data_ready: [get]  Acceleration set of data available.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of zyxda in reg STATUS_REG_A\n  *\n  */\nint32_t lsm303agr_xl_data_ready_get(lsm303agr_ctx_t *ctx, uint8_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_STATUS_REG_A, &reg.byte, 1);\n  *val = reg.status_reg_a.zyxda;\n\n  return mm_error;\n}\n/**\n  * @brief  xl_data_ovr: [get]  Acceleration set of data overrun.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of zyxor in reg STATUS_REG_A\n  *\n  */\nint32_t lsm303agr_xl_data_ovr_get(lsm303agr_ctx_t *ctx, uint8_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_STATUS_REG_A, &reg.byte, 1);\n  *val = reg.status_reg_a.zyxor;\n\n  return mm_error;\n}\n/**\n  * @brief  acceleration_raw: [get]  Acceleration output value.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lsm303agr_acceleration_raw_get(lsm303agr_ctx_t *ctx, uint8_t *buff)\n{\n  return lsm303agr_read_reg(ctx, LSM303AGR_OUT_X_L_A, buff, 6);\n}\n\n/**\n  * @brief  mag_user_offset: [set]  These registers comprise a 3 group of\n  *                                 16-bit number and represent hard-iron\n  *                                 offset in order to compensate environmental\n  *                                 effects. Data format is the same of\n  *                                 output data raw: twos complement with\n  *                                 1LSb = 1.5mG. These values act on the\n  *                                 magnetic output data value in order to\n  *                                 delete the environmental offset.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that contains data to write\n  *\n  */\nint32_t lsm303agr_mag_user_offset_set(lsm303agr_ctx_t *ctx, uint8_t *buff)\n{\n  return lsm303agr_write_reg(ctx, LSM303AGR_OFFSET_X_REG_L_M, buff, 6);\n}\n\n/**\n  * @brief  mag_user_offset: [get]  These registers comprise a 3 group of\n  *                                 16-bit number and represent hard-iron\n  *                                 offset in order to compensate environmental\n  *                                 effects. Data format is the same of\n  *                                 output data raw: twos complement with\n  *                                 1LSb = 1.5mG. These values act on the\n  *                                 magnetic output data value in order to\n  *                                 delete the environmental offset.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lsm303agr_mag_user_offset_get(lsm303agr_ctx_t *ctx, uint8_t *buff)\n{\n  return lsm303agr_read_reg(ctx, LSM303AGR_OFFSET_X_REG_L_M, buff, 6);\n}\n\n/**\n  * @brief  operating_mode: [set]  Operating mode selection.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_md_t: change the values of md in reg CFG_REG_A_M\n  *\n  */\nint32_t lsm303agr_mag_operating_mode_set(lsm303agr_ctx_t *ctx,\n                                         lsm303agr_md_m_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_A_M, &reg.byte, 1);\n  reg.cfg_reg_a_m.md = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_CFG_REG_A_M, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  operating_mode: [get]  Operating mode selection.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_md_t: Get the values of md in reg CFG_REG_A_M\n  *\n  */\nint32_t lsm303agr_mag_operating_mode_get(lsm303agr_ctx_t *ctx,\n                                         lsm303agr_md_m_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_A_M, &reg.byte, 1);\n  *val = (lsm303agr_md_m_t) reg.cfg_reg_a_m.md;\n\n  return mm_error;\n}\n\n/**\n  * @brief  data_rate: [set]  Output data rate selection.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_mg_odr_m_t: change the values of odr in reg CFG_REG_A_M\n  *\n  */\nint32_t lsm303agr_mag_data_rate_set(lsm303agr_ctx_t *ctx,\n                                    lsm303agr_mg_odr_m_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_A_M, &reg.byte, 1);\n  reg.cfg_reg_a_m.odr = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_CFG_REG_A_M, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  data_rate: [get]  Output data rate selection.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_mg_odr_m_tv: Get the values of odr in reg CFG_REG_A_M\n  *\n  */\nint32_t lsm303agr_mag_data_rate_get(lsm303agr_ctx_t *ctx,\n                                    lsm303agr_mg_odr_m_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_A_M, &reg.byte, 1);\n  *val = (lsm303agr_mg_odr_m_t) reg.cfg_reg_a_m.odr;\n\n  return mm_error;\n}\n\n/**\n  * @brief  power_mode: [set]  Enables high-resolution/low-power mode.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_lp_m_t: change the values of lp in reg CFG_REG_A_M\n  *\n  */\nint32_t lsm303agr_mag_power_mode_set(lsm303agr_ctx_t *ctx,\n                                     lsm303agr_lp_m_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_A_M, &reg.byte, 1);\n  reg.cfg_reg_a_m.lp = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_CFG_REG_A_M, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  power_mode: [get]  Enables high-resolution/low-power mode.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_lp_m_t: Get the values of lp in reg CFG_REG_A_M\n  *\n  */\nint32_t lsm303agr_mag_power_mode_get(lsm303agr_ctx_t *ctx,\n                                     lsm303agr_lp_m_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_A_M, &reg.byte, 1);\n  *val = (lsm303agr_lp_m_t) reg.cfg_reg_a_m.lp;\n\n  return mm_error;\n}\n\n/**\n  * @brief  mag_offset_temp_comp: [set]  Enables the magnetometer temperature\n  *                                  compensation.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of comp_temp_en in reg CFG_REG_A_M\n  *\n  */\nint32_t lsm303agr_mag_offset_temp_comp_set(lsm303agr_ctx_t *ctx, uint8_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_A_M, &reg.byte, 1);\n  reg.cfg_reg_a_m.comp_temp_en = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_CFG_REG_A_M, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  mag_offset_temp_comp: [get]  Enables the magnetometer temperature\n  *                                  compensation.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of comp_temp_en in reg CFG_REG_A_M\n  *\n  */\nint32_t lsm303agr_mag_offset_temp_comp_get(lsm303agr_ctx_t *ctx, uint8_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_A_M, &reg.byte, 1);\n  *val = reg.cfg_reg_a_m.comp_temp_en;\n\n  return mm_error;\n}\n\n/**\n  * @brief  mag_low_pass_bandwidth: [set]  Low-pass bandwidth selection.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_lpf_t: change the values of lpf in reg CFG_REG_B_M\n  *\n  */\nint32_t lsm303agr_mag_low_pass_bandwidth_set(lsm303agr_ctx_t *ctx,\n                                             lsm303agr_lpf_m_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_B_M, &reg.byte, 1);\n  reg.cfg_reg_b_m.lpf = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_CFG_REG_B_M, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  mag_low_pass_bandwidth: [get]  Low-pass bandwidth selection.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_lpf_t: Get the values of lpf in reg CFG_REG_B_M\n  *\n  */\nint32_t lsm303agr_mag_low_pass_bandwidth_get(lsm303agr_ctx_t *ctx,\n                                             lsm303agr_lpf_m_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_B_M, &reg.byte, 1);\n  *val = (lsm303agr_lpf_m_t) reg.cfg_reg_b_m.lpf;\n\n  return mm_error;\n}\n\n/**\n  * @brief  mag_set_rst_mode: [set]\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_set_rst_m_t: change the values of set_rst in\n  *                                reg CFG_REG_B_M\n  *\n  */\nint32_t lsm303agr_mag_set_rst_mode_set(lsm303agr_ctx_t *ctx,\n                                       lsm303agr_set_rst_m_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_B_M, &reg.byte, 1);\n  reg.cfg_reg_b_m.set_rst = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_CFG_REG_B_M, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  mag_set_rst_mode: [get]\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_set_rst_m_t: Get the values of set_rst in\n  *                                reg CFG_REG_B_M\n  *\n  */\nint32_t lsm303agr_mag_set_rst_mode_get(lsm303agr_ctx_t *ctx,\n                                       lsm303agr_set_rst_m_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_B_M, &reg.byte, 1);\n  *val = (lsm303agr_set_rst_m_t) reg.cfg_reg_b_m.set_rst;\n\n  return mm_error;\n}\n\n/**\n  * @brief   mag_set_rst_sensor_single: [set] Enables offset cancellation\n  *                                       in single measurement mode.\n  *                                       The OFF_CANC bit must be set\n  *                                       to 1 when enabling offset\n  *                                       cancellation in single measurement\n  *                                       mode this means a call function:\n  *                                       mag_set_rst_mode\n  *                                       (SENS_OFF_CANC_EVERY_ODR) is need.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of off_canc_one_shot in\n  *                      reg CFG_REG_B_M\n  *\n  */\nint32_t lsm303agr_mag_set_rst_sensor_single_set(lsm303agr_ctx_t *ctx,\n                                                uint8_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_B_M, &reg.byte, 1);\n  reg.cfg_reg_b_m.off_canc_one_shot = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_CFG_REG_B_M, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief   mag_set_rst_sensor_single: [get] Enables offset cancellation\n  *                                       in single measurement mode.\n  *                                       The OFF_CANC bit must be set to\n  *                                       1 when enabling offset cancellation\n  *                                       in single measurement mode this\n  *                                       means a call function:\n  *                                       mag_set_rst_mode\n  *                                       (SENS_OFF_CANC_EVERY_ODR) is need.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of off_canc_one_shot in reg CFG_REG_B_M\n  *\n  */\nint32_t lsm303agr_mag_set_rst_sensor_single_get(lsm303agr_ctx_t *ctx,\n                                                uint8_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_B_M, &reg.byte, 1);\n  *val = reg.cfg_reg_b_m.off_canc_one_shot;\n\n  return mm_error;\n}\n\n/**\n  * @brief  mag_block_data_update: [set] Blockdataupdate.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of bdu in reg CFG_REG_C_M\n  *\n  */\nint32_t lsm303agr_mag_block_data_update_set(lsm303agr_ctx_t *ctx,\n                                            uint8_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_C_M, &reg.byte, 1);\n  reg.cfg_reg_c_m.bdu = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_CFG_REG_C_M, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  mag_block_data_update: [get] Blockdataupdate.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of bdu in reg CFG_REG_C_M\n  *\n  */\nint32_t lsm303agr_mag_block_data_update_get(lsm303agr_ctx_t *ctx,\n                                            uint8_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_C_M, &reg.byte, 1);\n  *val = reg.cfg_reg_c_m.bdu;\n\n  return mm_error;\n}\n\n/**\n  * @brief  mag_data_ready: [get]  Magnetic set of data available.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of zyxda in reg STATUS_REG_M\n  *\n  */\nint32_t lsm303agr_mag_data_ready_get(lsm303agr_ctx_t *ctx, uint8_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_STATUS_REG_M, &reg.byte, 1);\n  *val = reg.status_reg_m.zyxda;\n\n  return mm_error;\n}\n\n/**\n  * @brief  mag_data_ovr: [get]  Magnetic set of data overrun.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of zyxor in reg STATUS_REG_M\n  *\n  */\nint32_t lsm303agr_mag_data_ovr_get(lsm303agr_ctx_t *ctx, uint8_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_STATUS_REG_M, &reg.byte, 1);\n  *val = reg.status_reg_m.zyxor;\n\n  return mm_error;\n}\n\n/**\n  * @brief  magnetic_raw: [get]  Magnetic output value.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lsm303agr_magnetic_raw_get(lsm303agr_ctx_t *ctx, uint8_t *buff)\n{\n  return lsm303agr_read_reg(ctx, LSM303AGR_OUTX_L_REG_M, buff, 6);\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  common\n  * @brief   This section group common usefull functions\n  * @{\n  */\n\n/**\n  * @brief  xl_device_id: [get] DeviceWhoamI.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lsm303agr_xl_device_id_get(lsm303agr_ctx_t *ctx, uint8_t *buff)\n{\n  return lsm303agr_read_reg(ctx, LSM303AGR_WHO_AM_I_A, buff, 1);\n}\n/**\n  * @brief  xl_self_test: [set] Selftest.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_st_a_t: change the values of st in reg CTRL_REG4_A\n  *\n  */\nint32_t lsm303agr_xl_self_test_set(lsm303agr_ctx_t *ctx,\n                                   lsm303agr_st_a_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG4_A, &reg.byte, 1);\n  reg.ctrl_reg4_a.st = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG4_A, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_self_test: [get] Selftest.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_st_a_t: Get the values of st in reg CTRL_REG4_A\n  *\n  */\nint32_t lsm303agr_xl_self_test_get(lsm303agr_ctx_t *ctx,\n                                   lsm303agr_st_a_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG4_A, &reg.byte, 1);\n  *val = (lsm303agr_st_a_t) reg.ctrl_reg4_a.st;\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_data_format: [set]  Big/Little Endian data selection.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_ble_a_t: change the values of ble in reg CTRL_REG4_A\n  *\n  */\nint32_t lsm303agr_xl_data_format_set(lsm303agr_ctx_t *ctx,\n                                     lsm303agr_ble_a_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG4_A, &reg.byte, 1);\n  reg.ctrl_reg4_a.ble = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG4_A, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_data_format: [get]  Big/Little Endian data selection.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_ble_a_t: Get the values of ble in reg CTRL_REG4_A\n  *\n  */\nint32_t lsm303agr_xl_data_format_get(lsm303agr_ctx_t *ctx,\n                                     lsm303agr_ble_a_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG4_A, &reg.byte, 1);\n  *val = (lsm303agr_ble_a_t) reg.ctrl_reg4_a.ble;\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_boot: [set]  Reboot memory content. Reload the\n  *                      calibration parameters\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of boot in reg CTRL_REG5_A\n  *\n  */\nint32_t lsm303agr_xl_boot_set(lsm303agr_ctx_t *ctx, uint8_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG5_A, &reg.byte, 1);\n  reg.ctrl_reg5_a.boot = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG5_A, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_boot: [get]  Reboot memory content. Reload the calibration\n  *                      parameters\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of boot in reg CTRL_REG5_A\n  *\n  */\nint32_t lsm303agr_xl_boot_get(lsm303agr_ctx_t *ctx, uint8_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG5_A, &reg.byte, 1);\n  *val = reg.ctrl_reg5_a.boot;\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_status: [get]  Info about device status.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_status_reg_a_t: register STATUS_REG_A\n  *\n  */\nint32_t lsm303agr_xl_status_get(lsm303agr_ctx_t *ctx,\n                                lsm303agr_status_reg_a_t *val)\n{\n  return lsm303agr_read_reg(ctx, LSM303AGR_STATUS_REG_A, (uint8_t*) val, 1);\n}\n\n/**\n  * @brief  mag_device_id: [get] DeviceWhoamI.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lsm303agr_mag_device_id_get(lsm303agr_ctx_t *ctx, uint8_t *buff)\n{\n  return lsm303agr_read_reg(ctx, LSM303AGR_WHO_AM_I_M, buff, 1);\n}\n\n/**\n  * @brief  mag_reset: [set]  Software reset. Restore the default values in\n  *                       user registers.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of soft_rst in reg CFG_REG_A_M\n  *\n  */\nint32_t lsm303agr_mag_reset_set(lsm303agr_ctx_t *ctx, uint8_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_A_M, &reg.byte, 1);\n  reg.cfg_reg_a_m.soft_rst = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_CFG_REG_A_M, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  mag_reset: [get]  Software reset. Restore the default values\n  *                       in user registers.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of soft_rst in reg CFG_REG_A_M\n  *\n  */\nint32_t lsm303agr_mag_reset_get(lsm303agr_ctx_t *ctx, uint8_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_A_M, &reg.byte, 1);\n  *val = reg.cfg_reg_a_m.soft_rst;\n\n  return mm_error;\n}\n\n/**\n  * @brief  mag_boot: [set]  Reboot memory content. Reload the calibration\n  *                      parameters.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of reboot in reg CFG_REG_A_M\n  *\n  */\nint32_t lsm303agr_mag_boot_set(lsm303agr_ctx_t *ctx, uint8_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_A_M, &reg.byte, 1);\n  reg.cfg_reg_a_m.reboot = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_CFG_REG_A_M, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  mag_boot: [get]  Reboot memory content. Reload the\n  *                      calibration parameters.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of reboot in reg CFG_REG_A_M\n  *\n  */\nint32_t lsm303agr_mag_boot_get(lsm303agr_ctx_t *ctx, uint8_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_A_M, &reg.byte, 1);\n  *val = reg.cfg_reg_a_m.reboot;\n\n  return mm_error;\n}\n\n/**\n  * @brief  mag_self_test: [set] Selftest.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of self_test in reg CFG_REG_C_M\n  *\n  */\nint32_t lsm303agr_mag_self_test_set(lsm303agr_ctx_t *ctx, uint8_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_C_M, &reg.byte, 1);\n  reg.cfg_reg_c_m.self_test = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_CFG_REG_C_M, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  mag_self_test: [get] Selftest.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of self_test in reg CFG_REG_C_M\n  *\n  */\nint32_t lsm303agr_mag_self_test_get(lsm303agr_ctx_t *ctx, uint8_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_C_M, &reg.byte, 1);\n  *val = reg.cfg_reg_c_m.self_test;\n\n  return mm_error;\n}\n\n/**\n  * @brief  data_format: [set]  Big/Little Endian data selection.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_ble_m_t: change the values of ble in reg CFG_REG_C_M\n  *\n  */\nint32_t lsm303agr_mag_data_format_set(lsm303agr_ctx_t *ctx,\n                                      lsm303agr_ble_m_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_C_M, &reg.byte, 1);\n  reg.cfg_reg_c_m.ble = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_CFG_REG_C_M, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  data_format: [get]  Big/Little Endian data selection.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_ble_m_t: Get the values of ble in reg CFG_REG_C_M\n  *\n  */\nint32_t lsm303agr_mag_data_format_get(lsm303agr_ctx_t *ctx,\n                                      lsm303agr_ble_m_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_C_M, &reg.byte, 1);\n  *val = (lsm303agr_ble_m_t) reg.cfg_reg_c_m.ble;\n\n  return mm_error;\n}\n\n/**\n  * @brief  status: [get]  Info about device status.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_status_reg_m_t: registers STATUS_REG_M\n  *\n  */\nint32_t lsm303agr_mag_status_get(lsm303agr_ctx_t *ctx,\n                                 lsm303agr_status_reg_m_t *val)\n{\n  return lsm303agr_read_reg(ctx, LSM303AGR_STATUS_REG_M, (uint8_t*) val, 1);\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup   interrupts_generator_1_for_xl\n  * @brief   This section group all the functions that manage the first\n  *          interrupts generator of accelerometer\n  * @{\n  */\n\n/**\n  * @brief  xl_int1_gen_conf: [set]  Interrupt generator 1 configuration\n  *                                  register\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_int1_cfg_a_t: register INT1_CFG_A\n  *\n  */\nint32_t lsm303agr_xl_int1_gen_conf_set(lsm303agr_ctx_t *ctx,\n                                   lsm303agr_int1_cfg_a_t *val)\n{\n  return lsm303agr_write_reg(ctx, LSM303AGR_INT1_CFG_A, (uint8_t*) val, 1);\n}\n\n/**\n  * @brief  xl_int1_gen_conf: [get]  Interrupt generator 1 configuration\n  *                                  register\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_int1_cfg_a_t: register INT1_CFG_A\n  *\n  */\nint32_t lsm303agr_xl_int1_gen_conf_get(lsm303agr_ctx_t *ctx,\n                                   lsm303agr_int1_cfg_a_t *val)\n{\n  return lsm303agr_read_reg(ctx, LSM303AGR_INT1_CFG_A, (uint8_t*) val, 1);\n}\n\n/**\n  * @brief  xl_int1_gen_source: [get]  Interrupt generator 1 source register\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_int1_src_a_t: Registers INT1_SRC_A\n  *\n  */\nint32_t lsm303agr_xl_int1_gen_source_get(lsm303agr_ctx_t *ctx,\n                                     lsm303agr_int1_src_a_t *val)\n{\n  return lsm303agr_read_reg(ctx, LSM303AGR_INT1_SRC_A, (uint8_t*) val, 1);\n}\n/**\n  * @brief  xl_int1_gen_threshold: [set]  User-defined threshold value for xl\n  *                                    interrupt event on generator 1.\n  *                             LSb = 16mg@2g / 32mg@4g / 62mg@8g / 186mg@16g\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of ths in reg INT1_THS_A\n  *\n  */\nint32_t lsm303agr_xl_int1_gen_threshold_set(lsm303agr_ctx_t *ctx,\n                                            uint8_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_INT1_THS_A, &reg.byte, 1);\n  reg.int1_ths_a.ths = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_INT1_THS_A, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_int1_gen_threshold: [get]  User-defined threshold value for xl\n  *                                    interrupt event on generator 1.\n  *                             LSb = 16mg@2g / 32mg@4g / 62mg@8g / 186mg@16g\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of ths in reg INT1_THS_A\n  *\n  */\nint32_t lsm303agr_xl_int1_gen_threshold_get(lsm303agr_ctx_t *ctx,\n                                            uint8_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_INT1_THS_A, &reg.byte, 1);\n  *val = reg.int1_ths_a.ths;\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_int1_gen_duration: [set]  The minimum duration (LSb = 1/ODR)\n  *                                   of the Interrupt 1 event to be\n  *                                   recognized.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of d in reg INT1_DURATION_A\n  *\n  */\nint32_t lsm303agr_xl_int1_gen_duration_set(lsm303agr_ctx_t *ctx, uint8_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_INT1_DURATION_A, &reg.byte, 1);\n  reg.int1_duration_a.d = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_INT1_DURATION_A, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_int1_gen_duration: [get]  The minimum duration (LSb = 1/ODR)\n  *                                   of the Interrupt 1 event to be\n  *                                   recognized.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of d in reg INT1_DURATION_A\n  *\n  */\nint32_t lsm303agr_xl_int1_gen_duration_get(lsm303agr_ctx_t *ctx, uint8_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_INT1_DURATION_A, &reg.byte, 1);\n  *val = reg.int1_duration_a.d;\n\n  return mm_error;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup   interrupts_generator_2_for_xl\n  * @brief   This section group all the functions that manage the second\n  *          interrupts generator for accelerometer\n  * @{\n  */\n\n/**\n  * @brief  xl_int2_gen_conf: [set]  Interrupt generator 2 configuration\n  *                                  register\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_int2_cfg_a_t: registers INT2_CFG_A\n  *\n  */\nint32_t lsm303agr_xl_int2_gen_conf_set(lsm303agr_ctx_t *ctx,\n                                   lsm303agr_int2_cfg_a_t *val)\n{\n  return lsm303agr_write_reg(ctx, LSM303AGR_INT2_CFG_A, (uint8_t*) val, 1);\n}\n\n/**\n  * @brief  xl_int2_gen_conf: [get]  Interrupt generator 2 configuration\n  *                                  register\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_int2_cfg_a_t: registers INT2_CFG_A\n  *\n  */\nint32_t lsm303agr_xl_int2_gen_conf_get(lsm303agr_ctx_t *ctx,\n                                   lsm303agr_int2_cfg_a_t *val)\n{\n  return lsm303agr_read_reg(ctx, LSM303AGR_INT2_CFG_A, (uint8_t*) val, 1);\n}\n/**\n  * @brief  xl_int2_gen_source: [get]  Interrupt generator 2 source register\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_int2_src_a_t: registers INT2_SRC_A\n  *\n  */\nint32_t lsm303agr_xl_int2_gen_source_get(lsm303agr_ctx_t *ctx,\n                                     lsm303agr_int2_src_a_t *val)\n{\n  return lsm303agr_read_reg(ctx, LSM303AGR_INT2_SRC_A, (uint8_t*) val, 1);\n}\n/**\n  * @brief  xl_int2_gen_threshold: [set]  User-defined threshold value for xl\n  *                                    interrupt event on generator 2.\n  *                             LSb = 16mg@2g / 32mg@4g / 62mg@8g / 186mg@16g\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of ths in reg INT2_THS_A\n  *\n  */\nint32_t lsm303agr_xl_int2_gen_threshold_set(lsm303agr_ctx_t *ctx,\n                                            uint8_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_INT2_THS_A, &reg.byte, 1);\n  reg.int2_ths_a.ths = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_INT2_THS_A, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_int2_gen_threshold: [get]  User-defined threshold value for\n  *                                    xl interrupt event on generator 2.\n  *                             LSb = 16mg@2g / 32mg@4g / 62mg@8g / 186mg@16g\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of ths in reg INT2_THS_A\n  *\n  */\nint32_t lsm303agr_xl_int2_gen_threshold_get(lsm303agr_ctx_t *ctx,\n                                            uint8_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_INT2_THS_A, &reg.byte, 1);\n  *val = reg.int2_ths_a.ths;\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_int2_gen_duration: [set]  The minimum duration (LSb = 1/ODR)\n  *                                   of the Interrupt 1 event to be\n  *                                   recognized.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of d in reg INT2_DURATION_A\n  *\n  */\nint32_t lsm303agr_xl_int2_gen_duration_set(lsm303agr_ctx_t *ctx, uint8_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_INT2_DURATION_A, \n                                &reg.byte, 1);\n  reg.int2_duration_a.d = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_INT2_DURATION_A,\n                                 &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_int2_gen_duration: [get]  The minimum duration (LSb = 1/ODR)\n  *                                   of the Interrupt 1 event to be\n  *                                   recognized.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of d in reg INT2_DURATION_A\n  *\n  */\nint32_t lsm303agr_xl_int2_gen_duration_get(lsm303agr_ctx_t *ctx,\n                                           uint8_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_INT2_DURATION_A,\n                                &reg.byte, 1);\n  *val = reg.int2_duration_a.d;\n\n  return mm_error;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  interrupt_pins_xl\n  * @brief   This section group all the functions that manage interrupt\n  *          pins of accelerometer \n  * @{\n  */\n\n/**\n  * @brief  xl_high_pass_int_conf: [set]  High-pass filter on interrupts/tap\n  *                                    generator\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_hp_a_t: change the values of hp in reg CTRL_REG2_A\n  *\n  */\nint32_t lsm303agr_xl_high_pass_int_conf_set(lsm303agr_ctx_t *ctx,\n                                        lsm303agr_hp_a_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG2_A, &reg.byte, 1);\n  reg.ctrl_reg2_a.hp = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG2_A, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_high_pass_int_conf: [get]  High-pass filter on interrupts/tap\n  *                                    generator\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_hp_a_t: Get the values of hp in reg CTRL_REG2_A\n  *\n  */\nint32_t lsm303agr_xl_high_pass_int_conf_get(lsm303agr_ctx_t *ctx,\n                                        lsm303agr_hp_a_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG2_A, &reg.byte, 1);\n  *val = (lsm303agr_hp_a_t) reg.ctrl_reg2_a.hp;\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_pin_int1_config: [set]  Int1 pin routing configuration register.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_ctrl_reg3_a_t: registers CTRL_REG3_A\n  *\n  */\nint32_t lsm303agr_xl_pin_int1_config_set(lsm303agr_ctx_t *ctx,\n                                     lsm303agr_ctrl_reg3_a_t *val)\n{\n  return lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG3_A, (uint8_t*) val, 1);\n}\n\n/**\n  * @brief  xl_pin_int1_config: [get]  Int1 pin routing configuration register.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_ctrl_reg3_a_t: registers CTRL_REG3_A\n  *\n  */\nint32_t lsm303agr_xl_pin_int1_config_get(lsm303agr_ctx_t *ctx,\n                                     lsm303agr_ctrl_reg3_a_t *val)\n{\n  return lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG3_A, (uint8_t*) val, 1);\n}\n/**\n  * @brief  xl_int2_pin_detect_4d: [set]  4D enable: 4D detection is enabled\n  *                                    on INT2 pin when 6D bit on\n  *                                    INT2_CFG_A (34h) is set to 1.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of d4d_int2 in reg CTRL_REG5_A\n  *\n  */\nint32_t lsm303agr_xl_int2_pin_detect_4d_set(lsm303agr_ctx_t *ctx,\n                                            uint8_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG5_A, &reg.byte, 1);\n  reg.ctrl_reg5_a.d4d_int2 = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG5_A, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_int2_pin_detect_4d: [get]  4D enable: 4D detection is enabled\n  *                                    on INT2 pin when 6D bit on\n  *                                    INT2_CFG_A (34h) is set to 1.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of d4d_int2 in reg CTRL_REG5_A\n  *\n  */\nint32_t lsm303agr_xl_int2_pin_detect_4d_get(lsm303agr_ctx_t *ctx,\n                                            uint8_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG5_A, &reg.byte, 1);\n  *val = reg.ctrl_reg5_a.d4d_int2;\n\n  return mm_error;\n}\n\n/**\n  * @brief   xl_int2pin_notification_mode: [set]  Latch interrupt request\n  *                                             on INT2_SRC_A (35h) register,\n  *                                             with INT2_SRC_A (35h) register\n  *                                             cleared by reading INT2_SRC_A\n  *                                             (35h) itself.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_lir_int2_a_t: change the values of lir_int2 in\n  *                               reg CTRL_REG5_A\n  *\n  */\nint32_t lsm303agr_xl_int2pin_notification_mode_set(lsm303agr_ctx_t *ctx,\n                                                 lsm303agr_lir_int2_a_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG5_A, &reg.byte, 1);\n  reg.ctrl_reg5_a.lir_int2 = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG5_A, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief   xl_int2pin_notification_mode: [get] Latch interrupt request on\n  *                                            INT2_SRC_A (35h) register, with\n  *                                            INT2_SRC_A (35h) register \n  *                                            cleared by reading \n  *                                            INT2_SRC_A (35h)itself.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_lir_int2_a_t: Get the values of lir_int2 in \n  *                                 reg CTRL_REG5_A\n  *\n  */\nint32_t lsm303agr_xl_int2pin_notification_mode_get(lsm303agr_ctx_t *ctx,\n                                                lsm303agr_lir_int2_a_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG5_A, &reg.byte, 1);\n  *val = (lsm303agr_lir_int2_a_t) reg.ctrl_reg5_a.lir_int2;\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_int1_pin_detect_4d: [set]  4D enable: 4D detection is enabled\n  *                                    on INT1 pin when 6D bit on INT1_CFG_A\n  *                                    (30h) is set to 1.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of d4d_int1 in reg CTRL_REG5_A\n  *\n  */\nint32_t lsm303agr_xl_int1_pin_detect_4d_set(lsm303agr_ctx_t *ctx, uint8_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG5_A, &reg.byte, 1);\n  reg.ctrl_reg5_a.d4d_int1 = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG5_A, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_int1_pin_detect_4d: [get]  4D enable: 4D detection is enabled\n  *                                    on INT1 pin when 6D bit on INT1_CFG_A\n  *                                    (30h) is set to 1.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of d4d_int1 in reg CTRL_REG5_A\n  *\n  */\nint32_t lsm303agr_xl_int1_pin_detect_4d_get(lsm303agr_ctx_t *ctx, uint8_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG5_A, &reg.byte, 1);\n  *val = reg.ctrl_reg5_a.d4d_int1;\n\n  return mm_error;\n}\n\n/**\n  * @brief   xl_int1pin_notification_mode: [set]  Latch interrupt request on\n  *                                             INT1_SRC_A (31h), with \n  *                                             INT1_SRC_A(31h) register \n  *                                             cleared by reading \n  *                                             INT1_SRC_A (31h) itself.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_lir_int1_a_t: change the values of lir_int1 in\n  *                               reg CTRL_REG5_A\n  *\n  */\nint32_t lsm303agr_xl_int1pin_notification_mode_set(lsm303agr_ctx_t *ctx,\n                                                 lsm303agr_lir_int1_a_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG5_A, &reg.byte, 1);\n  reg.ctrl_reg5_a.lir_int1 = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG5_A, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief   xl_int1pin_notification_mode: [get]  Latch interrupt request on\n  *                                             INT1_SRC_A (31h), with\n  *                                             INT1_SRC_A (31h) register \n  *                                             cleared by reading INT1_SRC_A\n  *                                             (31h) itself.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_lir_int1_a_t: Get the values of lir_int1 in\n  *                                 reg CTRL_REG5_A\n  *\n  */\nint32_t lsm303agr_xl_int1pin_notification_mode_get(lsm303agr_ctx_t *ctx,\n                                                lsm303agr_lir_int1_a_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG5_A, &reg.byte, 1);\n  *val = (lsm303agr_lir_int1_a_t) reg.ctrl_reg5_a.lir_int1;\n\n  return mm_error;\n}\n\n/**\n  * @brief  _xl_pin_int2_config: [set]  Int2 pin routing configuration register.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_ctrl_reg6_a_t: registers CTRL_REG6_A\n  *\n  */\nint32_t lsm303agr_xl_pin_int2_config_set(lsm303agr_ctx_t *ctx,\n                                     lsm303agr_ctrl_reg6_a_t *val)\n{\n  return lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG6_A, (uint8_t*) val, 1);\n}\n\n/**\n  * @brief  _xl_pin_int2_config: [get]  Int2 pin routing configuration register.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_ctrl_reg6_a_t: registers CTRL_REG6_A\n  *\n  */\nint32_t lsm303agr_xl_pin_int2_config_get(lsm303agr_ctx_t *ctx,\n                                     lsm303agr_ctrl_reg6_a_t *val)\n{\n  return lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG6_A, (uint8_t*) val, 1);\n}\n\n/**\n  * @}\n  */\n  \n  /**\n  * @addtogroup  mag interrupts\n  * @brief   This section group all the functions that manage the \n  *          magnetometer interrupts\n  * @{\n  */\n\n/**\n  * @brief  offset_int_conf: [set]  The interrupt block recognition checks\n  *                                 data after/before the hard-iron correction\n  *                                 to discover the interrupt.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_int_on_dataoff_m_t: change the values of int_on_dataoff\n  *                                       in reg CFG_REG_B_M\n  *\n  */\nint32_t lsm303agr_mag_offset_int_conf_set(lsm303agr_ctx_t *ctx,\n                                          lsm303agr_int_on_dataoff_m_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_B_M, &reg.byte, 1);\n  reg.cfg_reg_b_m.int_on_dataoff = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_CFG_REG_B_M, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  offset_int_conf: [get]  The interrupt block recognition checks\n  *                                 data after/before the hard-iron correction\n  *                                 to discover the interrupt.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_int_on_dataoff_m_t: Get the values of int_on_dataoff in\n  *                                       reg CFG_REG_B_M\n  *\n  */\nint32_t lsm303agr_mag_offset_int_conf_get(lsm303agr_ctx_t *ctx,\n                                          lsm303agr_int_on_dataoff_m_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_B_M, &reg.byte, 1);\n  *val = (lsm303agr_int_on_dataoff_m_t) reg.cfg_reg_b_m.int_on_dataoff;\n\n  return mm_error;\n}\n\n/**\n  * @brief  mag_drdy_on_pin: [set]  Data-ready signal on INT_DRDY pin.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of drdy_on_pin in reg CFG_REG_C_M\n  *\n  */\nint32_t lsm303agr_mag_drdy_on_pin_set(lsm303agr_ctx_t *ctx, uint8_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_C_M, &reg.byte, 1);\n  reg.cfg_reg_c_m.int_mag = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_CFG_REG_C_M, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  mag_drdy_on_pin: [get]  Data-ready signal on INT_DRDY pin.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of drdy_on_pin in reg CFG_REG_C_M\n  *\n  */\nint32_t lsm303agr_mag_drdy_on_pin_get(lsm303agr_ctx_t *ctx, uint8_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_C_M, &reg.byte, 1);\n  *val = reg.cfg_reg_c_m.int_mag;\n\n  return mm_error;\n}\n\n/**\n  * @brief  mag_int_on_pin: [set]  Interrupt signal on INT_DRDY pin.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of int_on_pin in reg CFG_REG_C_M\n  *\n  */\nint32_t lsm303agr_mag_int_on_pin_set(lsm303agr_ctx_t *ctx, uint8_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_C_M, &reg.byte, 1);\n  reg.cfg_reg_c_m.int_mag_pin = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_CFG_REG_C_M, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  mag_int_on_pin: [get]  Interrupt signal on INT_DRDY pin.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of int_on_pin in reg CFG_REG_C_M\n  *\n  */\nint32_t lsm303agr_mag_int_on_pin_get(lsm303agr_ctx_t *ctx, uint8_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_C_M, &reg.byte, 1);\n  *val = reg.cfg_reg_c_m.int_mag_pin;\n\n  return mm_error;\n}\n\n/**\n  * @brief  mag_int_gen_conf: [set] Interrupt generator configuration\n  *                                 register\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_int_crtl_reg_m_t: registers INT_CRTL_REG_M\n  *\n  */\nint32_t lsm303agr_mag_int_gen_conf_set(lsm303agr_ctx_t *ctx,\n                                 lsm303agr_int_crtl_reg_m_t *val)\n{\n  return lsm303agr_write_reg(ctx, LSM303AGR_INT_CRTL_REG_M, (uint8_t*) val, 1);\n}\n\n/**\n  * @brief  mag_int_gen_conf: [get]  Interrupt generator configuration\n  *                                  register\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_int_crtl_reg_m_t: registers INT_CRTL_REG_M\n  *\n  */\nint32_t lsm303agr_mag_int_gen_conf_get(lsm303agr_ctx_t *ctx,\n                                 lsm303agr_int_crtl_reg_m_t *val)\n{\n  return lsm303agr_read_reg(ctx, LSM303AGR_INT_CRTL_REG_M,\n                            (uint8_t*) val, 1);\n}\n\n/**\n  * @brief  mag_int_gen_source: [get]  Interrupt generator source register\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_int_source_reg_m_t: registers INT_SOURCE_REG_M\n  *\n  */\nint32_t lsm303agr_mag_int_gen_source_get(lsm303agr_ctx_t *ctx,\n                                   lsm303agr_int_source_reg_m_t *val)\n{\n  return lsm303agr_read_reg(ctx, LSM303AGR_INT_SOURCE_REG_M,\n                            (uint8_t*) val, 1);\n}\n\n/**\n  * @brief  mag_int_gen_treshold: [set]  User-defined threshold value for xl\n  *                                  interrupt event on generator.\n  *                                  Data format is the same of output\n  *                                  data raw: twos complement with\n  *                                  1LSb = 1.5mG.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that contains data to write\n  *\n  */\nint32_t lsm303agr_mag_int_gen_treshold_set(lsm303agr_ctx_t *ctx,\n                                           uint8_t *buff)\n{\n  return lsm303agr_write_reg(ctx, LSM303AGR_INT_THS_L_REG_M, buff, 2);\n}\n\n/**\n  * @brief  mag_int_gen_treshold: [get]  User-defined threshold value for\n  *                                  xl interrupt event on generator.\n  *                                  Data format is the same of output\n  *                                  data raw: twos complement with\n  *                                  1LSb = 1.5mG.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lsm303agr_mag_int_gen_treshold_get(lsm303agr_ctx_t *ctx,\n                                           uint8_t *buff)\n{\n  return lsm303agr_read_reg(ctx, LSM303AGR_INT_THS_L_REG_M, buff, 2);\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  accelerometer_fifo\n  * @brief   This section group all the functions concerning the xl \n  *          fifo usage\n  * @{\n  */\n\n/**\n  * @brief  xl_fifo: [set] FIFOenable.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of fifo_en in reg CTRL_REG5_A\n  *\n  */\nint32_t lsm303agr_xl_fifo_set(lsm303agr_ctx_t *ctx, uint8_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG5_A, &reg.byte, 1);\n  reg.ctrl_reg5_a.fifo_en = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG5_A, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_fifo: [get] FIFOenable.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of fifo_en in reg CTRL_REG5_A\n  *\n  */\nint32_t lsm303agr_xl_fifo_get(lsm303agr_ctx_t *ctx, uint8_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG5_A, &reg.byte, 1);\n  *val = reg.ctrl_reg5_a.fifo_en;\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_fifo_watermark: [set]  FIFO watermark level selection.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of fth in reg FIFO_CTRL_REG_A\n  *\n  */\nint32_t lsm303agr_xl_fifo_watermark_set(lsm303agr_ctx_t *ctx, uint8_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_FIFO_CTRL_REG_A,\n                                &reg.byte, 1);\n  reg.fifo_ctrl_reg_a.fth = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_FIFO_CTRL_REG_A,\n                                 &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_fifo_watermark: [get]  FIFO watermark level selection.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of fth in reg FIFO_CTRL_REG_A\n  *\n  */\nint32_t lsm303agr_xl_fifo_watermark_get(lsm303agr_ctx_t *ctx, uint8_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_FIFO_CTRL_REG_A,\n                                &reg.byte, 1);\n  *val = reg.fifo_ctrl_reg_a.fth;\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_fifo_trigger_event: [set]  Trigger FIFO selection.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_tr_a_t: change the values of tr in reg FIFO_CTRL_REG_A\n  *\n  */\nint32_t lsm303agr_xl_fifo_trigger_event_set(lsm303agr_ctx_t *ctx,\n                                        lsm303agr_tr_a_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_FIFO_CTRL_REG_A,\n                                &reg.byte, 1);\n  reg.fifo_ctrl_reg_a.tr = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_FIFO_CTRL_REG_A,\n                                 &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_fifo_trigger_event: [get]  Trigger FIFO selection.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_tr_a_t: Get the values of tr in reg FIFO_CTRL_REG_A\n  *\n  */\nint32_t lsm303agr_xl_fifo_trigger_event_get(lsm303agr_ctx_t *ctx,\n                                        lsm303agr_tr_a_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_FIFO_CTRL_REG_A,\n                                &reg.byte, 1);\n  *val = (lsm303agr_tr_a_t) reg.fifo_ctrl_reg_a.tr;\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_fifo_mode: [set]  FIFO mode selection.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_fm_a_t: change the values of fm in reg FIFO_CTRL_REG_A\n  *\n  */\nint32_t lsm303agr_xl_fifo_mode_set(lsm303agr_ctx_t *ctx,\n                                   lsm303agr_fm_a_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_FIFO_CTRL_REG_A,\n                                &reg.byte, 1);\n  reg.fifo_ctrl_reg_a.fm = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_FIFO_CTRL_REG_A,\n                                 &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_fifo_mode: [get]  FIFO mode selection.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_fm_t: Get the values of fm in reg FIFO_CTRL_REG_A\n  *\n  */\nint32_t lsm303agr_xl_fifo_mode_get(lsm303agr_ctx_t *ctx,\n                                   lsm303agr_fm_a_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_FIFO_CTRL_REG_A,\n                                &reg.byte, 1);\n  *val = (lsm303agr_fm_a_t) reg.fifo_ctrl_reg_a.fm;\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_fifo_status: [get]  FIFO status register.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_fifo_src_reg_a_t: registers FIFO_SRC_REG_A\n  *\n  */\nint32_t lsm303agr_xl_fifo_status_get(lsm303agr_ctx_t *ctx,\n                                 lsm303agr_fifo_src_reg_a_t *val)\n{\n  return lsm303agr_read_reg(ctx, LSM303AGR_FIFO_SRC_REG_A,\n                            (uint8_t*) val, 1);\n}\n/**\n  * @brief  xl_fifo_data_level: [get]  FIFO stored data level.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of fss in reg FIFO_SRC_REG_A\n  *\n  */\nint32_t lsm303agr_xl_fifo_data_level_get(lsm303agr_ctx_t *ctx, uint8_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_FIFO_SRC_REG_A,\n                                &reg.byte, 1);\n  *val = reg.fifo_src_reg_a.fss;\n\n  return mm_error;\n}\n/**\n  * @brief  xl_fifo_empty_flag: [get]  Empty FIFO status flag.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of empty in reg FIFO_SRC_REG_A\n  *\n  */\nint32_t lsm303agr_xl_fifo_empty_flag_get(lsm303agr_ctx_t *ctx, uint8_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_FIFO_SRC_REG_A,\n                                &reg.byte, 1);\n  *val = reg.fifo_src_reg_a.empty;\n\n  return mm_error;\n}\n/**\n  * @brief  xl_fifo_ovr_flag: [get]  FIFO overrun status flag.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of ovrn_fifo in reg FIFO_SRC_REG_A\n  *\n  */\nint32_t lsm303agr_xl_fifo_ovr_flag_get(lsm303agr_ctx_t *ctx, uint8_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_FIFO_SRC_REG_A,\n                                &reg.byte, 1);\n  *val = reg.fifo_src_reg_a.ovrn_fifo;\n\n  return mm_error;\n}\n/**\n  * @brief  xl_fifo_fth_flag: [get]  FIFO watermark status.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of wtm in reg FIFO_SRC_REG_A\n  *\n  */\nint32_t lsm303agr_xl_fifo_fth_flag_get(lsm303agr_ctx_t *ctx, uint8_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_FIFO_SRC_REG_A, &reg.byte, 1);\n  *val = reg.fifo_src_reg_a.wtm;\n\n  return mm_error;\n}\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  tap_generator\n  * @brief   This section group all the functions that manage the tap and\n  *          double tap event generation\n  * @{\n  */\n\n/**\n  * @brief  tap_conf: [set]  Tap/Double Tap generator configuration register\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_click_cfg_a_t: registers CLICK_CFG_A\n  *\n  */\nint32_t lsm303agr_tap_conf_set(lsm303agr_ctx_t *ctx,\n                               lsm303agr_click_cfg_a_t *val)\n{\n  return lsm303agr_write_reg(ctx, LSM303AGR_CLICK_CFG_A, (uint8_t*) val, 1);\n}\n\n/**\n  * @brief  tap_conf: [get]  Tap/Double Tap generator configuration register\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_click_cfg_a_t: registers CLICK_CFG_A\n  *\n  */\nint32_t lsm303agr_tap_conf_get(lsm303agr_ctx_t *ctx,\n                               lsm303agr_click_cfg_a_t *val)\n{\n  return lsm303agr_read_reg(ctx, LSM303AGR_CLICK_CFG_A, (uint8_t*) val, 1);\n}\n/**\n  * @brief  tap_source: [get]  Tap/Double Tap generator source register\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_click_cfg_t: registers CLICK_SRC_A\n  *\n  */\nint32_t lsm303agr_tap_source_get(lsm303agr_ctx_t *ctx,\n                                 lsm303agr_click_src_a_t *val)\n{\n  return lsm303agr_read_reg(ctx, LSM303AGR_CLICK_SRC_A, (uint8_t*) val, 1);\n}\n/**\n  * @brief  tap_threshold: [set]  User-defined threshold value for Tap/Double\n  *                               Tap event. (1 LSB = full scale/128)\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of ths in reg CLICK_THS_A\n  *\n  */\nint32_t lsm303agr_tap_threshold_set(lsm303agr_ctx_t *ctx, uint8_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CLICK_THS_A, &reg.byte, 1);\n  reg.click_ths_a.ths = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_CLICK_THS_A, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  tap_threshold: [get]  User-defined threshold value for Tap/Double\n  *                               Tap event. (1 LSB = full scale/128)\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of ths in reg CLICK_THS_A\n  *\n  */\nint32_t lsm303agr_tap_threshold_get(lsm303agr_ctx_t *ctx, uint8_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CLICK_THS_A, &reg.byte, 1);\n  *val = reg.click_ths_a.ths;\n\n  return mm_error;\n}\n\n/**\n  * @brief  shock_dur: [set]  The maximum time (1 LSB = 1/ODR) interval\n  *                           that can elapse between the start of the\n  *                           click-detection procedure and when the\n  *                           acceleration falls back below the threshold.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of tli in reg TIME_LIMIT_A\n  *\n  */\nint32_t lsm303agr_shock_dur_set(lsm303agr_ctx_t *ctx, uint8_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_TIME_LIMIT_A, &reg.byte, 1);\n  reg.time_limit_a.tli = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_TIME_LIMIT_A, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  shock_dur: [get]  The maximum time (1 LSB = 1/ODR) interval\n  *                           that can elapse between the start of the\n  *                           click-detection procedure and when the\n  *                           acceleration falls back below the threshold.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of tli in reg TIME_LIMIT_A\n  *\n  */\nint32_t lsm303agr_shock_dur_get(lsm303agr_ctx_t *ctx, uint8_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_TIME_LIMIT_A, &reg.byte, 1);\n  *val = reg.time_limit_a.tli;\n\n  return mm_error;\n}\n\n/**\n  * @brief  quiet_dur: [set]  The time (1 LSB = 1/ODR) interval that\n  *                           starts after the first click detection\n  *                           where the click-detection procedure is\n  *                           disabled, in cases where the device is\n  *                           configured for double-click detection.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of tla in reg TIME_LATENCY_A\n  *\n  */\nint32_t lsm303agr_quiet_dur_set(lsm303agr_ctx_t *ctx, uint8_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_TIME_LATENCY_A,\n                                &reg.byte, 1);\n  reg.time_latency_a.tla = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_TIME_LATENCY_A,\n                                 &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  quiet_dur: [get]  The time (1 LSB = 1/ODR) interval that\n  *                           starts after the first click detection\n  *                           where the click-detection procedure is\n  *                           disabled, in cases where the device is\n  *                           configured for double-click detection.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of tla in reg TIME_LATENCY_A\n  *\n  */\nint32_t lsm303agr_quiet_dur_get(lsm303agr_ctx_t *ctx, uint8_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_TIME_LATENCY_A,\n                                &reg.byte, 1);\n  *val = reg.time_latency_a.tla;\n\n  return mm_error;\n}\n\n/**\n  * @brief  double_tap_timeout: [set]  The maximum interval of time\n  *                                    (1 LSB = 1/ODR) that can elapse\n  *                                    after the end of the latency interval\n  *                                    in which the click-detection procedure\n  *                                    can start, in cases where the device is\n  *                                    configured for double-click detection.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of tw in reg TIME_WINDOW_A\n  *\n  */\nint32_t lsm303agr_double_tap_timeout_set(lsm303agr_ctx_t *ctx, uint8_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_TIME_WINDOW_A, &reg.byte, 1);\n  reg.time_window_a.tw = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_TIME_WINDOW_A, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  double_tap_timeout: [get]  The maximum interval of time\n  *                                    (1 LSB = 1/ODR) that can elapse\n  *                                    after the end of the latency interval\n  *                                    in which the click-detection procedure\n  *                                    can start, in cases where the device\n  *                                    is configured for double-click\n  *                                    detection.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of tw in reg TIME_WINDOW_A\n  *\n  */\nint32_t lsm303agr_double_tap_timeout_get(lsm303agr_ctx_t *ctx, uint8_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_TIME_WINDOW_A, &reg.byte, 1);\n  *val = reg.time_window_a.tw;\n\n  return mm_error;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup   activity_inactivity_xl\n  * @brief   This section group all the functions concerning activity\n  *          inactivity functionality foe accelerometer\n  * @{\n  */\n\n/**\n  * @brief  act_threshold: [set]  Sleep-to-wake, return-to-sleep activation\n  *                               threshold in low-power mode.\n  *                        1 LSb = 16mg@2g / 32mg@4g / 62mg@8g / 186mg@16g\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of acth in reg ACT_THS_A\n  *\n  */\nint32_t lsm303agr_act_threshold_set(lsm303agr_ctx_t *ctx, uint8_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_ACT_THS_A, &reg.byte, 1);\n  reg.act_ths_a.acth = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_ACT_THS_A, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  act_threshold: [get]  Sleep-to-wake, return-to-sleep activation\n  *                               threshold in low-power mode.\n  *                        1 LSb = 16mg@2g / 32mg@4g / 62mg@8g / 186mg@16g\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of acth in reg ACT_THS_A\n  *\n  */\nint32_t lsm303agr_act_threshold_get(lsm303agr_ctx_t *ctx, uint8_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_ACT_THS_A, &reg.byte, 1);\n  *val = reg.act_ths_a.acth;\n\n  return mm_error;\n}\n\n/**\n  * @brief  act_timeout: [set]  Sleep-to-wake, return-to-sleep\n  *                             duration = (8*1[LSb]+1)/ODR.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of actd in reg ACT_DUR_A\n  *\n  */\nint32_t lsm303agr_act_timeout_set(lsm303agr_ctx_t *ctx, uint8_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_ACT_DUR_A, &reg.byte, 1);\n  reg.act_dur_a.actd = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_ACT_DUR_A, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  act_timeout: [get]  Sleep-to-wake, return-to-sleep\n  *                             duration = (8*1[LSb]+1)/ODR.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of actd in reg ACT_DUR_A\n  *\n  */\nint32_t lsm303agr_act_timeout_get(lsm303agr_ctx_t *ctx, uint8_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_ACT_DUR_A, &reg.byte, 1);\n  *val = reg.act_dur_a.actd;\n\n  return mm_error;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  serial_interface\n  * @brief   This section group all the functions concerning serial\n  *          interface management\n  * @{\n  */\n\n/**\n  * @brief  xl_spi_mode: [set]  SPI Serial Interface Mode selection.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_sim_a_t: change the values of sim in reg CTRL_REG4_A\n  *\n  */\nint32_t lsm303agr_xl_spi_mode_set(lsm303agr_ctx_t *ctx,\n                                  lsm303agr_sim_a_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG4_A, &reg.byte, 1);\n  reg.ctrl_reg4_a.spi_enable = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG4_A, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_spi_mode: [get]  SPI Serial Interface Mode selection.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_sim_a_t: Get the values of sim in reg CTRL_REG4_A\n  *\n  */\nint32_t lsm303agr_xl_spi_mode_get(lsm303agr_ctx_t *ctx,\n                                  lsm303agr_sim_a_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG4_A, &reg.byte, 1);\n  *val = (lsm303agr_sim_a_t) reg.ctrl_reg4_a.spi_enable;\n\n  return mm_error;\n}\n/**\n  * @brief  i2c_interface: [set]  Enable/Disable I2C interface.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_i2c_dis_m_t: change the values of i2c_dis in\n  *                                reg CFG_REG_C_M\n  *\n  */\nint32_t lsm303agr_mag_i2c_interface_set(lsm303agr_ctx_t *ctx,\n                                        lsm303agr_i2c_dis_m_t val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_C_M, &reg.byte, 1);\n  reg.cfg_reg_c_m.i2c_dis = val;\n  mm_error = lsm303agr_write_reg(ctx, LSM303AGR_CFG_REG_C_M, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  i2c_interface: [get]  Enable/Disable I2C interface.\n  *\n  * @param  lsm303agr_ctx_t *ctx: read / write interface definitions\n  * @param  lsm303agr_i2c_dis_m_t: Get the values of i2c_dis in\n  *                                reg CFG_REG_C_M\n  *\n  */\nint32_t lsm303agr_mag_i2c_interface_get(lsm303agr_ctx_t *ctx,\n                                        lsm303agr_i2c_dis_m_t *val)\n{\n  lsm303agr_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_C_M, &reg.byte, 1);\n  *val = (lsm303agr_i2c_dis_m_t) reg.cfg_reg_c_m.i2c_dis;\n\n  return mm_error;\n}\n\n/**\n  * @}\n  */\n\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/"
              }
            }
          },
          "md5": "00ab1e152e791a00a0ce17f09c91dbcb"
        },
        "lps22hb": {
          "libName": "lps22hb",
          "manufacturer": "STMicroelectronics",
          "description": "The LPS22HB is an ultra-compact piezoresistive absolute pressure sensor which functions as a digital output barometer. The device comprises a sensing element and an IC interface which communicates through I2C or SPI from the sensing element to the application.",
          "type": "Pressure",
          "icon": "",
          "image": "",
          "version": "",
          "eelVersion": "3",
          "shoppingCartLinks": {
            "digikey": {
              "links": {
                "info": "https://www.digikey.com/product-detail/en/stmicroelectronics/STEVAL-MET001V1/497-16372-ND/5873438"
              },
              "cartData": {
                "part": "497-16372-ND",
                "partid": "5873438",
                "source": "dkstudio",
                "qty": "1"
              }
            }
          },
          "requires": [
            "embedded",
            "fpmath",
            "i2c"
          ],
          "elements": [
            {
              "name": "LPS22HBPressure",
              "type": "EmbeddedLPS22HB",
              "icon": "EmbeddedPressure.svg",
              "defaultAbility": "readPressure",
              "defaultTrigger": "pressureRead",
              "helpPageHref": "https://developer.atmosphereiot.com/documents/elements/stmicroelectronicslps22hbelement.html",
              "hidden": false,
              "abilities": [
                {
                  "name": "setup",
                  "hidden": true,
                  "code": "\tATMO_LPS22HB_Config_t config;\n\tconfig.i2cInstance = ATMO_PROPERTY(undefined, i2cInstance);\n\tconfig.spiInstance = ATMO_PROPERTY(undefined, spiInstance);\n\tconfig.gpioInstance = ATMO_PROPERTY(undefined, gpioInstance);\n\tconfig.csPin = ATMO_PROPERTY(undefined, csPin);\n\tconfig.i2cAddress = ATMO_PROPERTY(undefined, i2cAddress);\n\tconfig.spi3Wire = ATMO_PROPERTY(undefined, spi3Wire);\n\tconfig.driverType.type = ATMO_PROPERTY(undefined, communicationMode);\n\treturn ATMO_LPS22HB_Init(&config) == ATMO_LPS22HB_Status_Success ? ATMO_Status_Success : ATMO_Status_Fail;\n\n"
                },
                {
                  "name": "readPressure",
                  "triggers": [
                    "pressureRead"
                  ],
                  "code": "\tfloat pressure = 0.0;\n\tif( ATMO_LPS22HB_GetPressure(&pressure) != ATMO_LPS22HB_Status_Success )\n\t{\n\t\treturn ATMO_Status_Fail;\n\t}\n\n\tATMO_CreateValueFloat(out, pressure);\n\t\n\treturn ATMO_Status_Success;\n"
                },
                {
                  "name": "readTemperature",
                  "triggers": [
                    "temperatureRead"
                  ],
                  "code": "\t\n\tfloat temperature = 0.0;\n\tif( ATMO_LPS22HB_GetTempData(&temperature) != ATMO_LPS22HB_Status_Success )\n\t{\n\t\treturn ATMO_Status_Fail;\n\t}\n\n\tATMO_CreateValueFloat(out, temperature);\n\t\n\treturn ATMO_Status_Success;\n"
                }
              ],
              "properties": [
                {
                  "name": "communicationMode",
                  "input": "select",
                  "inputOptions": [
                    "ATMO_DRIVERTYPE_SPI",
                    "ATMO_DRIVERTYPE_I2C"
                  ],
                  "value": "ATMO_DRIVERTYPE_SPI"
                },
                {
                  "name": "i2cInstance",
                  "input": "number",
                  "value": "0"
                },
                {
                  "name": "spiInstance",
                  "input": "number",
                  "value": "0"
                },
                {
                  "name": "gpioInstance",
                  "input": "number",
                  "value": "0"
                },
                {
                  "name": "csPin",
                  "input": "number",
                  "value": "0"
                },
                {
                  "name": "spi3Wire",
                  "input": "checkbox",
                  "value": true
                },
                {
                  "name": "i2cAddress",
                  "input": "select",
                  "inputOptions": [
                    "0x5D",
                    "0x5C"
                  ],
                  "value": "0x5D"
                }
              ],
              "triggers": [],
              "variables": [],
              "language": {
                "en-US": {
                  "EmbeddedLPS22HB": "LPS22HB",
                  "i2cInstance": "I2C Driver Instance",
                  "i2cAddress": "I2C Address",
                  "setup": "Setup",
                  "readTemperature": "Read Temperature",
                  "temperatureRead": "Temperature Read",
                  "readPressure": "Read Pressure",
                  "pressureRead": "Pressure Read",
                  "communicationMode": "Communication Mode",
                  "ATMO_DRIVERTYPE_SPI": "SPI",
                  "ATMO_DRIVERTYPE_I2C": "I2C",
                  "spiInstance": "SPI Driver Instance",
                  "gpioInstance": "GPIO Driver Instance",
                  "spi3Wire": "3 Wire SPI Mode",
                  "csPin": "Chip Select Pin"
                }
              }
            }
          ],
          "files": {
            "common": {
              "headers": {
                "lps22hb.h": "/**\r\n ******************************************************************************\r\n * @file    lps22hb.h\r\n * @author\r\n * @version\r\n * @date\r\n * @brief   Atmosphere API - lps22hb header file\r\n ******************************************************************************\r\n * @attention\r\n *\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *   1. Redistributions of source code must retain the above copyright notice,\r\n *      this list of conditions and the following disclaimer.\r\n *   2. Redistributions in binary form must reproduce the above copyright notice,\r\n *      this list of conditions and the following disclaimer in the documentation\r\n *      and/or other materials provided with the distribution.\r\n *   3. Neither the name of Atmosphere IoT Corp. nor the names of its contributors\r\n *      may be used to endorse or promote products derived from this software\r\n *      without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n ******************************************************************************\r\n */\r\n#ifndef _ATMO_LPS22HB_H_\r\n#define _ATMO_LPS22HB_H_\r\n\r\n#include \"../app_src/atmosphere_platform.h\"\r\n\r\ntypedef struct {\r\n    ATMO_DriverInstanceHandle_t i2cInstance;\r\n    ATMO_DriverInstanceHandle_t spiInstance;\r\n    ATMO_DriverInstanceHandle_t gpioInstance;\r\n    uint8_t i2cAddress;\r\n    bool spi3Wire;\r\n    ATMO_GPIO_Device_Pin_t csPin; // Only used for SPI\r\n    ATMO_CORE_DeviceHandle_t driverType;\r\n}ATMO_LPS22HB_Config_t;\r\n\r\ntypedef enum {\r\n    ATMO_LPS22HB_Status_Success = 0 ,\r\n    ATMO_LPS22HB_Status_Fail\r\n} ATMO_LPS22HB_Status_t;\r\n\r\nATMO_LPS22HB_Status_t ATMO_LPS22HB_Init(ATMO_LPS22HB_Config_t *config);\r\n\r\n/**\r\n * @brief Get pressure data in hPa\r\n * \r\n * @param pressureHpa \r\n * @return ATMO_LPS22HB_Status_t \r\n */\r\nATMO_LPS22HB_Status_t ATMO_LPS22HB_GetPressure(float *pressureHpa);\r\n\r\n/**\r\n * @brief Get temperature data in degrees C\r\n * \r\n * @param tempC \r\n * @return ATMO_LPS22HB_Status_t \r\n */\r\nATMO_LPS22HB_Status_t ATMO_LPS22HB_GetTempData(float *tempC);\r\n\r\n#endif\r\n",
                "lps22hb_reg.h": "/*\n ******************************************************************************\n * @file    lps22hb_reg.h\n * @author  MEMS Software Solution Team\n * @date    15-September-2017\n * @brief   This file contains all the functions prototypes for the\n *          lps22hb_reg.c driver.\n ******************************************************************************\n * @attention\n *\n * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *   1. Redistributions of source code must retain the above copyright notice,\n *      this list of conditions and the following disclaimer.\n *   2. Redistributions in binary form must reproduce the above copyright notice,\n *      this list of conditions and the following disclaimer in the documentation\n *      and/or other materials provided with the distribution.\n *   3. Neither the name of STMicroelectronics nor the names of its contributors\n *      may be used to endorse or promote products derived from this software\n *      without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n/* Define to prevent recursive inclusion -------------------------------------*/\n#ifndef __LPS22HB_DRIVER__H\n#define __LPS22HB_DRIVER__H\n\n#ifdef __cplusplus\n  extern \"C\" {\n#endif\n\n/* Includes ------------------------------------------------------------------*/\n#include <stdint.h>\n\n/** @addtogroup lps22hb\n * @{\n */\n\n#ifndef __MEMS_SHARED__TYPES\n#define __MEMS_SHARED__TYPES\n\n/** @defgroup ST_MEMS_common_types\n  * @{\n  */\n\ntypedef union{\n\tint16_t i16bit[3];\n\tuint8_t u8bit[6];\n} axis3bit16_t;\n\ntypedef union{\n\tint16_t i16bit;\n\tuint8_t u8bit[2];\n} axis1bit16_t;\n\ntypedef union{\n\tint32_t i32bit[3];\n\tuint8_t u8bit[12];\n} axis3bit32_t;\n\ntypedef union{\n\tint32_t i32bit;\n\tuint8_t u8bit[4];\n} axis1bit32_t;\n\ntypedef struct {\n   uint8_t bit0       : 1;\n   uint8_t bit1       : 1;\n   uint8_t bit2       : 1;\n   uint8_t bit3       : 1;\n   uint8_t bit4       : 1;\n   uint8_t bit5       : 1;\n   uint8_t bit6       : 1;\n   uint8_t bit7       : 1;\n} bitwise_t;\n\n#define PROPERTY_DISABLE                (0)\n#define PROPERTY_ENABLE                 (1)\n\n#endif /*__MEMS_SHARED__TYPES*/\n\n/**\n  * @}\n  */\n\n/** @defgroup lps22hb_interface\n  * @{\n  */\n\ntypedef int32_t (*lps22hb_write_ptr)(void *, uint8_t, uint8_t*, uint16_t);\ntypedef int32_t (*lps22hb_read_ptr) (void *, uint8_t, uint8_t*, uint16_t);\n\ntypedef struct {\n  /** Component mandatory fields **/\n  lps22hb_write_ptr  write_reg;\n  lps22hb_read_ptr   read_reg;\n  /** Customizable optional pointer **/\n  void *handle;\n} lps22hb_ctx_t;\n\n/**\n  * @}\n  */\n\n\n/** @defgroup lps22hb_Infos\n  * @{\n  */\n  /** I2C Device Address 8 bit format: if SA0=0 -> 0xB9 if SA0=1 -> 0xBB **/\n#define LPS22HB_I2C_ADD_H   0xBB\n#define LPS22HB_I2C_ADD_L   0xB9\n\n/** Device Identification (Who am I) **/\n#define LPS22HB_ID            0xB1\n\n/**\n  * @}\n  */\n\n/**\n  * @defgroup lps22hb_Sensitivity\n  * @{\n  */\n\n#define LPS22HB_FROM_LSB_TO_hPa(lsb)     (float)( lsb / 4096.0f )\n#define LPS22HB_FROM_LSB_TO_degC(lsb)    (float)( lsb / 100.0f )\n\n/**\n  * @}\n  */\n\n#define LPS22HB_INTERRUPT_CFG  0x0B\ntypedef struct {\n  uint8_t pe               : 2; /* ple + phe -> pe */\n  uint8_t lir              : 1;\n  uint8_t diff_en          : 1;\n  uint8_t reset_az         : 1;\n  uint8_t autozero         : 1;\n  uint8_t reset_arp        : 1;\n  uint8_t autorifp         : 1;\n} lps22hb_interrupt_cfg_t;\n\n#define LPS22HB_THS_P_L        0x0C\n#define LPS22HB_THS_P_H        0x0D\n#define LPS22HB_WHO_AM_I       0x0F\n#define LPS22HB_CTRL_REG1      0x10\ntypedef struct {\n  uint8_t sim              : 1;\n  uint8_t bdu              : 1;\n  uint8_t lpfp             : 2; /* en_lpfp + lpfp_cfg -> lpfp */\n  uint8_t odr              : 3;\n  uint8_t not_used_01      : 1;\n} lps22hb_ctrl_reg1_t;\n\n#define LPS22HB_CTRL_REG2      0x11\ntypedef struct {\n  uint8_t one_shot         : 1;\n  uint8_t not_used_01      : 1;\n  uint8_t swreset          : 1;\n  uint8_t i2c_dis          : 1;\n  uint8_t if_add_inc       : 1;\n  uint8_t stop_on_fth      : 1;\n  uint8_t fifo_en          : 1;\n  uint8_t boot             : 1;\n} lps22hb_ctrl_reg2_t;\n\n#define LPS22HB_CTRL_REG3      0x12\ntypedef struct {\n  uint8_t int_s            : 2;\n  uint8_t drdy             : 1;\n  uint8_t f_ovr            : 1;\n  uint8_t f_fth            : 1;\n  uint8_t f_fss5           : 1;\n  uint8_t pp_od            : 1;\n  uint8_t int_h_l          : 1;\n} lps22hb_ctrl_reg3_t;\n\n\n#define LPS22HB_FIFO_CTRL      0x14\ntypedef struct {\n  uint8_t wtm              : 5;\n  uint8_t f_mode           : 3;\n} lps22hb_fifo_ctrl_t;\n\n#define LPS22HB_REF_P_XL       0x15\n#define LPS22HB_REF_P_L        0x16\n#define LPS22HB_REF_P_H        0x17\n#define LPS22HB_RPDS_L         0x18\n#define LPS22HB_RPDS_H         0x19\n\n#define LPS22HB_RES_CONF       0x1A\ntypedef struct {\n  uint8_t lc_en            : 1;\n  uint8_t not_used_01      : 7;\n} lps22hb_res_conf_t;\n\n#define LPS22HB_INT_SOURCE     0x25\ntypedef struct {\n  uint8_t ph               : 1;\n  uint8_t pl               : 1;\n  uint8_t ia               : 1;\n  uint8_t not_used_01      : 4;\n  uint8_t boot_status      : 1;\n} lps22hb_int_source_t;\n\n#define LPS22HB_FIFO_STATUS    0x26\ntypedef struct {\n  uint8_t fss              : 6;\n  uint8_t ovr              : 1;\n  uint8_t fth_fifo         : 1;\n} lps22hb_fifo_status_t;\n\n#define LPS22HB_STATUS         0x27\ntypedef struct {\n  uint8_t p_da             : 1;\n  uint8_t t_da             : 1;\n  uint8_t not_used_02      : 2;\n  uint8_t p_or             : 1;\n  uint8_t t_or             : 1;\n  uint8_t not_used_01      : 2;\n} lps22hb_status_t;\n\n#define LPS22HB_PRESS_OUT_XL   0x28\n#define LPS22HB_PRESS_OUT_L    0x29\n#define LPS22HB_PRESS_OUT_H    0x2A\n#define LPS22HB_TEMP_OUT_L     0x2B\n#define LPS22HB_TEMP_OUT_H     0x2C\n#define LPS22HB_LPFP_RES       0x33\n\ntypedef union{\n  lps22hb_interrupt_cfg_t      interrupt_cfg;\n  lps22hb_ctrl_reg1_t          ctrl_reg1;\n  lps22hb_ctrl_reg2_t          ctrl_reg2;\n  lps22hb_ctrl_reg3_t          ctrl_reg3;\n  lps22hb_fifo_ctrl_t          fifo_ctrl;\n  lps22hb_res_conf_t           res_conf;\n  lps22hb_int_source_t         int_source;\n  lps22hb_fifo_status_t        fifo_status;\n  lps22hb_status_t             status;\n  bitwise_t                    bitwise;\n  uint8_t                      byte;\n} lps22hb_reg_t;\n\nint32_t lps22hb_read_reg(lps22hb_ctx_t *ctx, uint8_t reg, uint8_t* data,\n                         uint16_t len);\nint32_t lps22hb_write_reg(lps22hb_ctx_t *ctx, uint8_t reg, uint8_t* data,\n                          uint16_t len);\n\nint32_t lps22hb_autozero_rst_set(lps22hb_ctx_t *ctx, uint8_t val);\nint32_t lps22hb_autozero_rst_get(lps22hb_ctx_t *ctx, uint8_t *val);\n\nint32_t lps22hb_autozero_set(lps22hb_ctx_t *ctx, uint8_t val);\nint32_t lps22hb_autozero_get(lps22hb_ctx_t *ctx, uint8_t *val);\n\nint32_t lps22hb_pressure_snap_rst_set(lps22hb_ctx_t *ctx, uint8_t val);\nint32_t lps22hb_pressure_snap_rst_get(lps22hb_ctx_t *ctx, uint8_t *val);\n\nint32_t lps22hb_pressure_snap_set(lps22hb_ctx_t *ctx, uint8_t val);\nint32_t lps22hb_pressure_snap_get(lps22hb_ctx_t *ctx, uint8_t *val);\n\nint32_t lps22hb_block_data_update_set(lps22hb_ctx_t *ctx, uint8_t val);\nint32_t lps22hb_block_data_update_get(lps22hb_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LPS22HB_LPF_ODR_DIV_2  = 0,\n  LPS22HB_LPF_ODR_DIV_9  = 2,\n  LPS22HB_LPF_ODR_DIV_20 = 3,\n} lps22hb_lpfp_t;\nint32_t lps22hb_low_pass_filter_mode_set(lps22hb_ctx_t *ctx, lps22hb_lpfp_t val);\nint32_t lps22hb_low_pass_filter_mode_get(lps22hb_ctx_t *ctx, lps22hb_lpfp_t *val);\n\ntypedef enum {\n  LPS22HB_POWER_DOWN  = 0,\n  LPS22HB_ODR_1_Hz    = 1,\n  LPS22HB_ODR_10_Hz   = 2,\n  LPS22HB_ODR_25_Hz   = 3,\n  LPS22HB_ODR_50_Hz   = 4,\n  LPS22HB_ODR_75_Hz   = 5,\n} lps22hb_odr_t;\nint32_t lps22hb_data_rate_set(lps22hb_ctx_t *ctx, lps22hb_odr_t val);\nint32_t lps22hb_data_rate_get(lps22hb_ctx_t *ctx, lps22hb_odr_t *val);\n\nint32_t lps22hb_one_shoot_trigger_set(lps22hb_ctx_t *ctx, uint8_t val);\nint32_t lps22hb_one_shoot_trigger_get(lps22hb_ctx_t *ctx, uint8_t *val);\n\nint32_t lps22hb_pressure_ref_set(lps22hb_ctx_t *ctx, uint8_t *buff);\nint32_t lps22hb_pressure_ref_get(lps22hb_ctx_t *ctx, uint8_t *buff);\n\nint32_t lps22hb_pressure_offset_set(lps22hb_ctx_t *ctx, uint8_t *buff);\nint32_t lps22hb_pressure_offset_get(lps22hb_ctx_t *ctx, uint8_t *buff);\n\nint32_t lps22hb_press_data_ready_get(lps22hb_ctx_t *ctx, uint8_t *val);\n\nint32_t lps22hb_temp_data_ready_get(lps22hb_ctx_t *ctx, uint8_t *val);\n\nint32_t lps22hb_press_data_ovr_get(lps22hb_ctx_t *ctx, uint8_t *val);\n\nint32_t lps22hb_temp_data_ovr_get(lps22hb_ctx_t *ctx, uint8_t *val);\n\nint32_t lps22hb_pressure_raw_get(lps22hb_ctx_t *ctx, uint8_t *buff);\n\nint32_t lps22hb_temperature_raw_get(lps22hb_ctx_t *ctx, uint8_t *buff);\n\nint32_t lps22hb_low_pass_rst_get(lps22hb_ctx_t *ctx, uint8_t *buff);\n\nint32_t lps22hb_device_id_get(lps22hb_ctx_t *ctx, uint8_t *buff);\n\nint32_t lps22hb_reset_set(lps22hb_ctx_t *ctx, uint8_t val);\nint32_t lps22hb_reset_get(lps22hb_ctx_t *ctx, uint8_t *val);\n\nint32_t lps22hb_boot_set(lps22hb_ctx_t *ctx, uint8_t val);\nint32_t lps22hb_boot_get(lps22hb_ctx_t *ctx, uint8_t *val);\n\nint32_t lps22hb_low_power_set(lps22hb_ctx_t *ctx, uint8_t val);\nint32_t lps22hb_low_power_get(lps22hb_ctx_t *ctx, uint8_t *val);\n\nint32_t lps22hb_boot_status_get(lps22hb_ctx_t *ctx, uint8_t *val);\n\ntypedef struct{\n  lps22hb_fifo_status_t  fifo_status;\n  lps22hb_status_t       status;\n} lps22hb_dev_stat_t;\nint32_t lps22hb_dev_status_get(lps22hb_ctx_t *ctx, lps22hb_dev_stat_t *val);\n\ntypedef enum {\n  LPS22HB_NO_THRESHOLD = 0,\n  LPS22HB_POSITIVE     = 1,\n  LPS22HB_NEGATIVE     = 2,\n  LPS22HB_BOTH         = 3,\n} lps22hb_pe_t;\nint32_t lps22hb_sign_of_int_threshold_set(lps22hb_ctx_t *ctx, lps22hb_pe_t val);\nint32_t lps22hb_sign_of_int_threshold_get(lps22hb_ctx_t *ctx, lps22hb_pe_t *val);\n\ntypedef enum {\n  LPS22HB_INT_PULSED  = 0,\n  LPS22HB_INT_LATCHED = 1,\n} lps22hb_lir_t;\nint32_t lps22hb_int_notification_mode_set(lps22hb_ctx_t *ctx, lps22hb_lir_t val);\nint32_t lps22hb_int_notification_mode_get(lps22hb_ctx_t *ctx, lps22hb_lir_t *val);\n\nint32_t lps22hb_int_generation_set(lps22hb_ctx_t *ctx, uint8_t val);\nint32_t lps22hb_int_generation_get(lps22hb_ctx_t *ctx, uint8_t *val);\n\nint32_t lps22hb_int_threshold_set(lps22hb_ctx_t *ctx, uint8_t *buff);\nint32_t lps22hb_int_threshold_get(lps22hb_ctx_t *ctx, uint8_t *buff);\n\ntypedef enum {\n  LPS22HB_DRDY_OR_FIFO_FLAGS = 0,\n  LPS22HB_HIGH_PRES_INT      = 1,\n  LPS22HB_LOW_PRES_INT       = 2,\n  LPS22HB_EVERY_PRES_INT     = 3,\n} lps22hb_int_s_t;\nint32_t lps22hb_int_pin_mode_set(lps22hb_ctx_t *ctx, lps22hb_int_s_t val);\nint32_t lps22hb_int_pin_mode_get(lps22hb_ctx_t *ctx, lps22hb_int_s_t *val);\n\nint32_t lps22hb_drdy_on_int_set(lps22hb_ctx_t *ctx, uint8_t val);\nint32_t lps22hb_drdy_on_int_get(lps22hb_ctx_t *ctx, uint8_t *val);\n\nint32_t lps22hb_fifo_ovr_on_int_set(lps22hb_ctx_t *ctx, uint8_t val);\nint32_t lps22hb_fifo_ovr_on_int_get(lps22hb_ctx_t *ctx, uint8_t *val);\n\nint32_t lps22hb_fifo_threshold_on_int_set(lps22hb_ctx_t *ctx, uint8_t val);\nint32_t lps22hb_fifo_threshold_on_int_get(lps22hb_ctx_t *ctx, uint8_t *val);\n\nint32_t lps22hb_fifo_full_on_int_set(lps22hb_ctx_t *ctx, uint8_t val);\nint32_t lps22hb_fifo_full_on_int_get(lps22hb_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LPS22HB_PUSH_PULL  = 0,\n  LPS22HB_OPEN_DRAIN = 1,\n} lps22hb_pp_od_t;\nint32_t lps22hb_pin_mode_set(lps22hb_ctx_t *ctx, lps22hb_pp_od_t val);\nint32_t lps22hb_pin_mode_get(lps22hb_ctx_t *ctx, lps22hb_pp_od_t *val);\n\ntypedef enum {\n  LPS22HB_ACTIVE_HIGH = 0,\n  LPS22HB_ACTIVE_LOW = 1,\n} lps22hb_int_h_l_t;\nint32_t lps22hb_int_polarity_set(lps22hb_ctx_t *ctx, lps22hb_int_h_l_t val);\nint32_t lps22hb_int_polarity_get(lps22hb_ctx_t *ctx, lps22hb_int_h_l_t *val);\n\nint32_t lps22hb_int_source_get(lps22hb_ctx_t *ctx, lps22hb_int_source_t *val);\n\nint32_t lps22hb_int_on_press_high_get(lps22hb_ctx_t *ctx, uint8_t *val);\n\nint32_t lps22hb_int_on_press_low_get(lps22hb_ctx_t *ctx, uint8_t *val);\n\nint32_t lps22hb_interrupt_event_get(lps22hb_ctx_t *ctx, uint8_t *val);\n\nint32_t lps22hb_stop_on_fifo_threshold_set(lps22hb_ctx_t *ctx, uint8_t val);\nint32_t lps22hb_stop_on_fifo_threshold_get(lps22hb_ctx_t *ctx, uint8_t *val);\n\nint32_t lps22hb_fifo_set(lps22hb_ctx_t *ctx, uint8_t val);\nint32_t lps22hb_fifo_get(lps22hb_ctx_t *ctx, uint8_t *val);\n\nint32_t lps22hb_fifo_watermark_set(lps22hb_ctx_t *ctx, uint8_t val);\nint32_t lps22hb_fifo_watermark_get(lps22hb_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LPS22HB_BYPASS_MODE           = 0,\n  LPS22HB_FIFO_MODE             = 1,\n  LPS22HB_STREAM_MODE           = 2,\n  LPS22HB_Stream_to_FIFO_mode   = 3,\n  LPS22HB_BYPASS_TO_STREAM_MODE = 4,\n  LPS22HB_DYNAMIC_STREAM_MODE   = 6,\n  LPS22HB_BYPASS_TO_FIFO_MODE   = 7,\n} lps22hb_f_mode_t;\nint32_t lps22hb_fifo_mode_set(lps22hb_ctx_t *ctx, lps22hb_f_mode_t val);\nint32_t lps22hb_fifo_mode_get(lps22hb_ctx_t *ctx, lps22hb_f_mode_t *val);\n\nint32_t lps22hb_fifo_data_level_get(lps22hb_ctx_t *ctx, uint8_t *val);\n\nint32_t lps22hb_fifo_ovr_flag_get(lps22hb_ctx_t *ctx, uint8_t *val);\n\nint32_t lps22hb_fifo_fth_flag_get(lps22hb_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LPS22HB_SPI_4_WIRE = 0,\n  LPS22HB_SPI_3_WIRE = 1,\n} lps22hb_sim_t;\nint32_t lps22hb_spi_mode_set(lps22hb_ctx_t *ctx, lps22hb_sim_t val);\nint32_t lps22hb_spi_mode_get(lps22hb_ctx_t *ctx, lps22hb_sim_t *val);\n\ntypedef enum {\n  LPS22HB_I2C_ENABLE = 0,\n  LPS22HB_I2C_DISABLE = 1,\n} lps22hb_i2c_dis_t;\nint32_t lps22hb_i2c_interface_set(lps22hb_ctx_t *ctx, lps22hb_i2c_dis_t val);\nint32_t lps22hb_i2c_interface_get(lps22hb_ctx_t *ctx, lps22hb_i2c_dis_t *val);\n\nint32_t lps22hb_auto_add_inc_set(lps22hb_ctx_t *ctx, uint8_t val);\nint32_t lps22hb_auto_add_inc_get(lps22hb_ctx_t *ctx, uint8_t *val);\n\n/**\n  * @}\n  */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /*__LPS22HB_DRIVER__H */\n\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\n"
              },
              "objects": {
                "lps22hb.c": "#include \"lps22hb.h\"\r\n#include \"lps22hb_reg.h\"\r\n\r\nstatic ATMO_LPS22HB_Config_t _LPS22HB_PrivConfig;\r\nstatic lps22hb_ctx_t _LPS22HB_Ctx;\r\n\r\nstatic int32_t _ATMO_LPS22HB_PlatformWrite(void *handle, uint8_t Reg, uint8_t *Bufp,\r\n                              uint16_t len)\r\n{\r\n\tif(_LPS22HB_PrivConfig.driverType.type == ATMO_DRIVERTYPE_I2C )\r\n\t{\r\n\t\tuint8_t i2cAddress = *((uint8_t*)handle);\r\n\t\tATMO_I2C_Status_t status = ATMO_I2C_MasterWrite(_LPS22HB_PrivConfig.i2cInstance, i2cAddress,\r\n\t\t&Reg, 1, Bufp, len, 1000);\r\n\t\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tATMO_GPIO_Device_Pin_t csPin = *((ATMO_GPIO_Device_Pin_t *)handle);\r\n\t\tATMO_GPIO_SetPinState(_LPS22HB_PrivConfig.gpioInstance, csPin, ATMO_GPIO_PinState_Low);\r\n\t\tATMO_SPI_Status_t status = ATMO_SPI_MasterWrite(_LPS22HB_PrivConfig.spiInstance, ATMO_SPI_CS_NONE, &Reg, 1, Bufp, len, 1000);\r\n\t\tATMO_GPIO_SetPinState(_LPS22HB_PrivConfig.gpioInstance, csPin, ATMO_GPIO_PinState_High);\r\n\t\treturn (status == ATMO_SPI_Status_Success) ? 0 : 1;\r\n\t}\r\n  \r\n\r\n}\r\n\r\nstatic int32_t _ATMO_LPS22HB_PlatformRead(void *handle, uint8_t Reg, uint8_t *Bufp,\r\n                             uint16_t len)\r\n{\r\n\tif(_LPS22HB_PrivConfig.driverType.type == ATMO_DRIVERTYPE_I2C )\r\n\t{\r\n\t\tuint8_t i2cAddress = *((uint8_t*)handle);\r\n\t\tATMO_I2C_Status_t status = ATMO_I2C_Status_Success;\r\n\t\tuint8_t currentReg = Reg;\r\n\r\n\t\t// Need to do discrete reads or block update doesn't work\r\n\t\tfor(unsigned int i = 0; (i < len) && (status == ATMO_I2C_Status_Success); i++)\r\n\t\t{\r\n\t\t\tstatus = ATMO_I2C_MasterRead(_LPS22HB_PrivConfig.i2cInstance, i2cAddress,\r\n\t\t\t\t&currentReg, 1, &Bufp[i], 1, 1000);\r\n\t\t\tcurrentReg++;\r\n\t\t}\r\n\r\n\t\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tATMO_GPIO_Device_Pin_t csPin = *((ATMO_GPIO_Device_Pin_t *)handle);\r\n\r\n\t\tReg |= 0x80;\r\n\r\n\t\tATMO_GPIO_SetPinState(_LPS22HB_PrivConfig.gpioInstance, csPin, ATMO_GPIO_PinState_Low);\r\n\t\tATMO_SPI_Status_t status = ATMO_SPI_MasterRead(_LPS22HB_PrivConfig.spiInstance, ATMO_SPI_CS_NONE, &Reg, 1, Bufp, len, 1000);\r\n\t\tATMO_GPIO_SetPinState(_LPS22HB_PrivConfig.gpioInstance, csPin, ATMO_GPIO_PinState_High);\r\n\r\n\t\treturn (status == ATMO_SPI_Status_Success) ? 0 : 1;\r\n\t}\r\n}\r\n\r\nATMO_LPS22HB_Status_t ATMO_LPS22HB_Init(ATMO_LPS22HB_Config_t *config)\r\n{\r\n    if(config == NULL)\r\n    {\r\n        return ATMO_LPS22HB_Status_Fail;\r\n    }\r\n\r\n    memcpy(&_LPS22HB_PrivConfig, config, sizeof(_LPS22HB_PrivConfig));\r\n\r\n    _LPS22HB_Ctx.write_reg = _ATMO_LPS22HB_PlatformWrite;\r\n    _LPS22HB_Ctx.read_reg = _ATMO_LPS22HB_PlatformRead;\r\n\r\n    if(config->driverType.type == ATMO_DRIVERTYPE_SPI)\r\n    {\r\n\t\t// Initialize SPI\r\n\t\tATMO_SPI_Peripheral_t spiConf;\r\n\t\tspiConf.operatingMode = ATMO_SPI_OperatingMode_Master;\r\n\t\tspiConf.deviceConfig.baudRate = 2500000;\r\n\t\tspiConf.deviceConfig.clockContinuous = false;\r\n\t\tspiConf.deviceConfig.clockMode = ATMO_SPI_ClockMode_3;\r\n\t\tspiConf.deviceConfig.msbFirst = true;\r\n\t\tspiConf.deviceConfig.ssActiveLow = true;\r\n\t\tATMO_SPI_SetConfiguration(config->spiInstance, &spiConf);\r\n\r\n    \t_LPS22HB_Ctx.handle = (void*)&_LPS22HB_PrivConfig.csPin;\r\n\r\n    \tATMO_GPIO_Config_t gpioConfig;\r\n    \tgpioConfig.initialState = ATMO_GPIO_PinState_High;\r\n    \tgpioConfig.pinMode = ATMO_GPIO_PinMode_Output_PushPull;\r\n    \tATMO_GPIO_SetPinConfiguration(config->gpioInstance, config->csPin, &gpioConfig);\r\n\r\n    \tuint8_t spiModeByte = 0x01;\r\n    \tif(!config->spi3Wire)\r\n    \t{\r\n    \t\tspiModeByte = 0x00;\r\n    \t}\r\n\r\n    \tlps22hb_write_reg(&_LPS22HB_Ctx, LPS22HB_CTRL_REG1, &spiModeByte, 1);\r\n\r\n    \t// Reset and mem boot\r\n    \tuint8_t resetByte = 0x84;\r\n    \tlps22hb_write_reg(&_LPS22HB_Ctx, LPS22HB_CTRL_REG2, &resetByte, 1);\r\n\r\n    \tATMO_PLATFORM_DelayMilliseconds(1000);\r\n\r\n\r\n    \tlps22hb_write_reg(&_LPS22HB_Ctx, LPS22HB_CTRL_REG1, &spiModeByte, 1);\r\n    }\r\n    else\r\n    {\r\n\t\tATMO_I2C_Peripheral_t i2cConfig;\r\n\t\ti2cConfig.operatingMode = ATMO_I2C_OperatingMode_Master;\r\n\t\ti2cConfig.baudRate = ATMO_I2C_BaudRate_Standard_Mode;\r\n\t\tATMO_I2C_SetConfiguration(config->i2cInstance, &i2cConfig);\r\n    \t_LPS22HB_Ctx.handle = (void*)&_LPS22HB_PrivConfig.i2cAddress;\r\n\r\n\t\t// Reset and mem boot\r\n    \tuint8_t resetByte = 0x84;\r\n    \tlps22hb_write_reg(&_LPS22HB_Ctx, LPS22HB_CTRL_REG2, &resetByte, 1);\r\n\r\n\t\tATMO_PLATFORM_DelayMilliseconds(1000);\r\n    }\r\n\r\n    uint8_t whoamI = 0;\r\n    lps22hb_device_id_get(&_LPS22HB_Ctx, &whoamI);\r\n\r\n    if ( whoamI != LPS22HB_ID )\r\n    {\r\n        ATMO_PLATFORM_DebugPrint(\"Invalid lps22hb Accel WhoAmI (Rcv %02X Expect %02X\\r\\n\", whoamI, LPS22HB_ID);\r\n        return ATMO_LPS22HB_Status_Fail;\r\n    }\r\n\r\n    if(config->driverType.type == ATMO_DRIVERTYPE_SPI)\r\n    {\r\n    \tlps22hb_auto_add_inc_set(&_LPS22HB_Ctx, 1);\r\n    }\r\n\r\n    /*\r\n    *  Enable Block Data Update\r\n    */\r\n    lps22hb_block_data_update_set(&_LPS22HB_Ctx, 1);\r\n    /*\r\n    * Set Output Data Rate\r\n    */\r\n    lps22hb_data_rate_set(&_LPS22HB_Ctx, LPS22HB_ODR_10_Hz);\r\n\r\n    return ATMO_LPS22HB_Status_Success;\r\n}\r\n\r\n/**\r\n * @brief Get pressure data in hPa\r\n * \r\n * @param pressureHpa \r\n * @return ATMO_LPS22HB_Status_t \r\n */\r\nATMO_LPS22HB_Status_t ATMO_LPS22HB_GetPressure(float *pressureHpa)\r\n{\r\n    uint8_t pressureData[3] = {0};\r\n    lps22hb_pressure_raw_get(&_LPS22HB_Ctx, pressureData);\r\n\r\n    int32_t pressure = (pressureData[2] << 16) | (pressureData[1] << 8) | pressureData[0];\r\n    *pressureHpa = LPS22HB_FROM_LSB_TO_hPa(pressure);\r\n    return ATMO_LPS22HB_Status_Success;\r\n}\r\n\r\n/**\r\n * @brief Get temperature data in degrees C\r\n * \r\n * @param data \r\n * @return ATMO_LPS22HB_Status_t \r\n */\r\nATMO_LPS22HB_Status_t ATMO_LPS22HB_GetTempData(float *tempC)\r\n{\r\n    uint8_t rawData[2] = {0};\r\n    lps22hb_temperature_raw_get(&_LPS22HB_Ctx, rawData);\r\n\r\n    int16_t tempDataInt = (rawData[1] << 8) | rawData[0];\r\n    *tempC = LPS22HB_FROM_LSB_TO_degC( tempDataInt );\r\n    return ATMO_LPS22HB_Status_Success;\r\n}\r\n",
                "lps22hb_reg.c": "/*\n ******************************************************************************\n * @file    lps22hb_reg.c\n * @author  MEMS Software Solution Team\n * @date    15-September-2017\n * @brief   LPS22HB driver file\n ******************************************************************************\n * @attention\n *\n * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *   1. Redistributions of source code must retain the above copyright notice,\n *      this list of conditions and the following disclaimer.\n *   2. Redistributions in binary form must reproduce the above copyright notice,\n *      this list of conditions and the following disclaimer in the documentation\n *      and/or other materials provided with the distribution.\n *   3. Neither the name of STMicroelectronics nor the names of its contributors\n *      may be used to endorse or promote products derived from this software\n *      without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n#include \"lps22hb_reg.h\"\n\n/**\n  * @addtogroup  lps22hb\n  * @brief  This file provides a set of functions needed to drive the\n  *         lps22hb enanced inertial module.\n  * @{\n  */\n\n/** \n  * @addtogroup  interfaces_functions\n  * @brief  This section provide a set of functions used to read and write\n  *         a generic register of the device.\n  * @{\n  */\n\n/**\n  * @brief  Read generic device register\n  * \n  * @param  lps22hb_ctx_t* ctx: read / write interface definitions\n  * @param  uint8_t reg: register to read\n  * @param  uint8_t* data: pointer to buffer that store the data read\n  * @param  uint16_t len: number of consecutive register to read\n  *\n  */\nint32_t lps22hb_read_reg(lps22hb_ctx_t* ctx, uint8_t reg, uint8_t* data,\n                         uint16_t len)\n{\n  return ctx->read_reg(ctx->handle, reg, data, len);\n}\n\n/**\n  * @brief  Write generic device register\n  * \n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t reg: register to write\n  * @param  uint8_t* data: pointer to data to write in register reg\n  * @param  uint16_t len: number of consecutive register to write\n  *\n*/\nint32_t lps22hb_write_reg(lps22hb_ctx_t* ctx, uint8_t reg, uint8_t* data,\n                          uint16_t len)\n{\n  return ctx->write_reg(ctx->handle, reg, data, len);\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  data_generation_c\n  * @brief   This section group all the functions concerning data generation\n  * @{\n  */\n\n/**\n  * @brief  autozero_rst: [set]  Reset Autozero function.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of reset_az in reg INTERRUPT_CFG\n  *\n  */\nint32_t lps22hb_autozero_rst_set(lps22hb_ctx_t *ctx, uint8_t val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_INTERRUPT_CFG, &(reg.byte), 1);\n  reg.interrupt_cfg.reset_az = val;\n  mm_error = lps22hb_write_reg(ctx, LPS22HB_INTERRUPT_CFG, &(reg.byte), 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  autozero_rst: [get]  Reset Autozero function.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of reset_az in reg INTERRUPT_CFG\n  *\n  */\nint32_t lps22hb_autozero_rst_get(lps22hb_ctx_t *ctx, uint8_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_INTERRUPT_CFG, &(reg.byte), 1);\n  *val = reg.interrupt_cfg.reset_az;\n\n  return mm_error;\n}\n\n/**\n  * @brief  autozero: [set]  Enable Autozero function.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of autozero in reg INTERRUPT_CFG\n  *\n  */\nint32_t lps22hb_autozero_set(lps22hb_ctx_t *ctx, uint8_t val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_INTERRUPT_CFG, &(reg.byte), 1);\n  reg.interrupt_cfg.autozero = val;\n  mm_error = lps22hb_write_reg(ctx, LPS22HB_INTERRUPT_CFG, &(reg.byte), 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  autozero: [get]  Enable Autozero function.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of autozero in reg INTERRUPT_CFG\n  *\n  */\nint32_t lps22hb_autozero_get(lps22hb_ctx_t *ctx, uint8_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_INTERRUPT_CFG, &(reg.byte), 1);\n  *val = reg.interrupt_cfg.autozero;\n\n  return mm_error;\n}\n\n/**\n  * @brief  pressure_snap_rst: [set]  Reset AutoRifP function.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of reset_arp in reg INTERRUPT_CFG\n  *\n  */\nint32_t lps22hb_pressure_snap_rst_set(lps22hb_ctx_t *ctx, uint8_t val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_INTERRUPT_CFG, &(reg.byte), 1);\n  reg.interrupt_cfg.reset_arp = val;\n  mm_error = lps22hb_write_reg(ctx, LPS22HB_INTERRUPT_CFG, &(reg.byte), 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  pressure_snap_rst: [get]  Reset AutoRifP function.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of reset_arp in reg INTERRUPT_CFG\n  *\n  */\nint32_t lps22hb_pressure_snap_rst_get(lps22hb_ctx_t *ctx, uint8_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_INTERRUPT_CFG, &(reg.byte), 1);\n  *val = reg.interrupt_cfg.reset_arp;\n\n  return mm_error;\n}\n\n/**\n  * @brief  pressure_snap: [set]  Enable AutoRifP function.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of autorifp in reg INTERRUPT_CFG\n  *\n  */\nint32_t lps22hb_pressure_snap_set(lps22hb_ctx_t *ctx, uint8_t val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_INTERRUPT_CFG, &(reg.byte), 1);\n  reg.interrupt_cfg.autorifp = val;\n  mm_error = lps22hb_write_reg(ctx, LPS22HB_INTERRUPT_CFG, &(reg.byte), 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  pressure_snap: [get]  Enable AutoRifP function.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of autorifp in reg INTERRUPT_CFG\n  *\n  */\nint32_t lps22hb_pressure_snap_get(lps22hb_ctx_t *ctx, uint8_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_INTERRUPT_CFG, &(reg.byte), 1);\n  *val = reg.interrupt_cfg.autorifp;\n\n  return mm_error;\n}\n\n/**\n  * @brief  block_data_update: [set] Blockdataupdate.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of bdu in reg CTRL_REG1\n  *\n  */\nint32_t lps22hb_block_data_update_set(lps22hb_ctx_t *ctx, uint8_t val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG1, &(reg.byte), 1);\n  reg.ctrl_reg1.bdu = val;\n  mm_error = lps22hb_write_reg(ctx, LPS22HB_CTRL_REG1, &(reg.byte), 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  block_data_update: [get] Blockdataupdate.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of bdu in reg CTRL_REG1\n  *\n  */\nint32_t lps22hb_block_data_update_get(lps22hb_ctx_t *ctx, uint8_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG1, &(reg.byte), 1);\n  *val = reg.ctrl_reg1.bdu;\n\n  return mm_error;\n}\n\n/**\n  * @brief   low_pass_filter_mode: [set]  Low-pass bandwidth selection.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  lps22hb_lpfp_t: change the values of lpfp in reg CTRL_REG1\n  *\n  */\nint32_t lps22hb_low_pass_filter_mode_set(lps22hb_ctx_t *ctx,\n                                          lps22hb_lpfp_t val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG1, &(reg.byte), 1);\n  reg.ctrl_reg1.lpfp = val;\n  mm_error = lps22hb_write_reg(ctx, LPS22HB_CTRL_REG1, &(reg.byte), 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief   low_pass_filter_mode: [get]  Low-pass bandwidth selection.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  lps22hb_lpfp_t: Get the values of lpfp in reg CTRL_REG1\n  *\n  */\nint32_t lps22hb_low_pass_filter_mode_get(lps22hb_ctx_t *ctx,\n                                          lps22hb_lpfp_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG1, &(reg.byte), 1);\n  *val = (lps22hb_lpfp_t) reg.ctrl_reg1.lpfp;\n\n  return mm_error;\n}\n\n/**\n  * @brief  data_rate: [set]  Output data rate selection.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  lps22hb_odr_t: change the values of odr in reg CTRL_REG1\n  *\n  */\nint32_t lps22hb_data_rate_set(lps22hb_ctx_t *ctx, lps22hb_odr_t val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG1, &(reg.byte), 1);\n  reg.ctrl_reg1.odr = val;\n  mm_error = lps22hb_write_reg(ctx, LPS22HB_CTRL_REG1, &(reg.byte), 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  data_rate: [get]  Output data rate selection.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  lps22hb_odr_t: Get the values of odr in reg CTRL_REG1\n  *\n  */\nint32_t lps22hb_data_rate_get(lps22hb_ctx_t *ctx, lps22hb_odr_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG1, &(reg.byte), 1);\n  *val = (lps22hb_odr_t) reg.ctrl_reg1.odr;\n\n  return mm_error;\n}\n\n/**\n  * @brief  one_shoot_trigger: [set]  One-shot mode. Device perform\n  *                                   a single measure. \n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of one_shot in reg CTRL_REG2\n  *\n  */\nint32_t lps22hb_one_shoot_trigger_set(lps22hb_ctx_t *ctx, uint8_t val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG2, &(reg.byte), 1);\n  reg.ctrl_reg2.one_shot = val;\n  mm_error = lps22hb_write_reg(ctx, LPS22HB_CTRL_REG2, &(reg.byte), 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  one_shoot_trigger: [get]  One-shot mode. Device perform\n  *                                   a single measure. \n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of one_shot in reg CTRL_REG2\n  *\n  */\nint32_t lps22hb_one_shoot_trigger_get(lps22hb_ctx_t *ctx, uint8_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG2, &(reg.byte), 1);\n  *val = reg.ctrl_reg2.one_shot;\n\n  return mm_error;\n}\n\n/**\n  * @brief  pressure_ref: [set]  The Reference pressure value is a 24-bit\n  *                              data expressed as 2s complement. The value\n  *                              is used when AUTOZERO or AUTORIFP function\n  *                              is enabled.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that contains data to write\n  *\n  */\nint32_t lps22hb_pressure_ref_set(lps22hb_ctx_t *ctx, uint8_t *buff)\n{\n  return lps22hb_write_reg(ctx, LPS22HB_REF_P_XL, buff, 3);\n}\n\n/**\n  * @brief  pressure_ref: [get]  The Reference pressure value is a\n  *                              24-bit data expressed as 2s complement.\n  *                              The value is used when AUTOZERO or AUTORIFP\n  *                              function is enabled.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lps22hb_pressure_ref_get(lps22hb_ctx_t *ctx, uint8_t *buff)\n{\n  return lps22hb_read_reg(ctx, LPS22HB_REF_P_XL, buff, 3);\n}\n\n/**\n  * @brief  pressure_offset: [set]  The pressure offset value is 16-bit\n  *                                 data that can be used to implement\n  *                                 one-point calibration (OPC) after\n  *                                 soldering.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that contains data to write\n  *\n  */\nint32_t lps22hb_pressure_offset_set(lps22hb_ctx_t *ctx, uint8_t *buff)\n{\n  return lps22hb_write_reg(ctx, LPS22HB_RPDS_L, buff, 2);\n}\n\n/**\n  * @brief  pressure_offset: [get]  The pressure offset value is 16-bit\n  *                                 data that can be used to implement\n  *                                 one-point calibration (OPC) after\n  *                                 soldering.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lps22hb_pressure_offset_get(lps22hb_ctx_t *ctx, uint8_t *buff)\n{\n  return lps22hb_read_reg(ctx, LPS22HB_RPDS_L, buff, 2);\n}\n\n/**\n  * @brief  press_data_ready: [get]  Pressure data available.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of p_da in reg STATUS\n  *\n  */\nint32_t lps22hb_press_data_ready_get(lps22hb_ctx_t *ctx, uint8_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_STATUS, &(reg.byte), 1);\n  *val = reg.status.p_da;\n\n  return mm_error;\n}\n\n/**\n  * @brief  temp_data_ready: [get]  Temperature data available.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of t_da in reg STATUS\n  *\n  */\nint32_t lps22hb_temp_data_ready_get(lps22hb_ctx_t *ctx, uint8_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_STATUS, &(reg.byte), 1);\n  *val = reg.status.t_da;\n\n  return mm_error;\n}\n\n/**\n  * @brief  press_data_ovr: [get]  Pressure data overrun.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of p_or in reg STATUS\n  *\n  */\nint32_t lps22hb_press_data_ovr_get(lps22hb_ctx_t *ctx, uint8_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_STATUS, &(reg.byte), 1);\n  *val = reg.status.p_or;\n\n  return mm_error;\n}\n\n/**\n  * @brief  temp_data_ovr: [get]  Temperature data overrun.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of t_or in reg STATUS\n  *\n  */\nint32_t lps22hb_temp_data_ovr_get(lps22hb_ctx_t *ctx, uint8_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_STATUS, &(reg.byte), 1);\n  *val = reg.status.t_or;\n\n  return mm_error;\n}\n\n/**\n  * @brief  pressure_raw: [get]  Pressure output value\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lps22hb_pressure_raw_get(lps22hb_ctx_t *ctx, uint8_t *buff)\n{\n  return lps22hb_read_reg(ctx, LPS22HB_PRESS_OUT_XL, buff, 3);\n}\n\n/**\n  * @brief  temperature_raw: [get]  Temperature output value\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lps22hb_temperature_raw_get(lps22hb_ctx_t *ctx, uint8_t *buff)\n{\n  return lps22hb_read_reg(ctx, LPS22HB_TEMP_OUT_L, (uint8_t*) buff, 2);\n}\n\n/**\n  * @brief  low_pass_rst: [get]  Low-pass filter reset register. If the\n  *                              LPFP is active, in order to avoid the\n  *                              transitory phase, the filter can be reset\n  *                              by reading this register before generating\n  *                              pressure measurements.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lps22hb_low_pass_rst_get(lps22hb_ctx_t *ctx, uint8_t *buff)\n{\n  return lps22hb_read_reg(ctx, LPS22HB_LPFP_RES, (uint8_t*) buff, 1);\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  common\n  * @brief   This section group common usefull functions\n  * @{\n  */\n\n/**\n  * @brief  device_id: [get] DeviceWhoamI\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lps22hb_device_id_get(lps22hb_ctx_t *ctx, uint8_t *buff)\n{\n  return lps22hb_read_reg(ctx, LPS22HB_WHO_AM_I, (uint8_t*) buff, 1);\n}\n\n/**\n  * @brief  reset: [set]  Software reset. Restore the default values\n  *                       in user registers\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of swreset in reg CTRL_REG2\n  *\n  */\nint32_t lps22hb_reset_set(lps22hb_ctx_t *ctx, uint8_t val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG2, &(reg.byte), 1);\n  reg.ctrl_reg2.swreset = val;\n  mm_error = lps22hb_write_reg(ctx, LPS22HB_CTRL_REG2, &(reg.byte), 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  reset: [get]  Software reset. Restore the default values\n  *                       in user registers\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of swreset in reg CTRL_REG2\n  *\n  */\nint32_t lps22hb_reset_get(lps22hb_ctx_t *ctx, uint8_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG2, &(reg.byte), 1);\n  *val = reg.ctrl_reg2.swreset;\n\n  return mm_error;\n}\n\n/**\n  * @brief  boot: [set]  Reboot memory content. Reload the calibration\n  *                      parameters\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of boot in reg CTRL_REG2\n  *\n  */\nint32_t lps22hb_boot_set(lps22hb_ctx_t *ctx, uint8_t val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG2, &(reg.byte), 1);\n  reg.ctrl_reg2.boot = val;\n  mm_error = lps22hb_write_reg(ctx, LPS22HB_CTRL_REG2, &(reg.byte), 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  boot: [get]  Reboot memory content. Reload the calibration\n  *                      parameters\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of boot in reg CTRL_REG2\n  *\n  */\nint32_t lps22hb_boot_get(lps22hb_ctx_t *ctx, uint8_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG2, &(reg.byte), 1);\n  *val = reg.ctrl_reg2.boot;\n\n  return mm_error;\n}\n\n/**\n  * @brief  low_power: [set] Lowcurrentmode.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of lc_en in reg RES_CONF\n  *\n  */\nint32_t lps22hb_low_power_set(lps22hb_ctx_t *ctx, uint8_t val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_RES_CONF, &(reg.byte), 1);\n  reg.res_conf.lc_en = val;\n  mm_error = lps22hb_write_reg(ctx, LPS22HB_RES_CONF, &(reg.byte), 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  low_power: [get] Lowcurrentmode.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of lc_en in reg RES_CONF\n  *\n  */\nint32_t lps22hb_low_power_get(lps22hb_ctx_t *ctx, uint8_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_RES_CONF, &(reg.byte), 1);\n  *val = reg.res_conf.lc_en;\n\n  return mm_error;\n}\n\n/**\n  * @brief  boot_status: [get]  If 1 indicates that the Boot (Reboot)\n  *                             phase is running.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of boot_status in reg INT_SOURCE\n  *\n  */\nint32_t lps22hb_boot_status_get(lps22hb_ctx_t *ctx, uint8_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_INT_SOURCE, &(reg.byte), 1);\n  *val = reg.int_source.boot_status;\n\n  return mm_error;\n}\n\n/**\n  * @brief  dev_status: [get]  All the status bit, FIFO and data generation\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  lps22hb_dev_stat: union of registers from FIFO_STATUS to STATUS\n  *\n  */\nint32_t lps22hb_dev_status_get(lps22hb_ctx_t *ctx, lps22hb_dev_stat_t *val)\n{\n  return lps22hb_read_reg(ctx, LPS22HB_FIFO_STATUS, (uint8_t*) val, 2);\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  interrupts\n  * @brief   This section group all the functions that manage interrupts\n  * @{\n  */\n\n/**\n  * @brief   sign_of_int_threshold: [set]  Enable interrupt generation on\n  *                                        pressure low/high event.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  lps22hb_pe_t: change the values of pe in reg INTERRUPT_CFG\n  *\n  */\nint32_t lps22hb_sign_of_int_threshold_set(lps22hb_ctx_t *ctx,\n                                           lps22hb_pe_t val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_INTERRUPT_CFG, &(reg.byte), 1);\n  reg.interrupt_cfg.pe = val;\n  mm_error = lps22hb_write_reg(ctx, LPS22HB_INTERRUPT_CFG, &(reg.byte), 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief   sign_of_int_threshold: [get]  Enable interrupt generation on\n  *                                        pressure low/high event.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  lps22hb_pe_t: Get the values of pe in reg INTERRUPT_CFG\n  *\n  */\nint32_t lps22hb_sign_of_int_threshold_get(lps22hb_ctx_t *ctx,\n                                           lps22hb_pe_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_INTERRUPT_CFG, &(reg.byte), 1);\n  *val = (lps22hb_pe_t) reg.interrupt_cfg.pe;\n\n  return mm_error;\n}\n\n/**\n  * @brief   int_notification_mode: [set]  Interrupt request to the\n  *                                        INT_SOURCE (25h) register\n  *                                        mode (pulsed / latched) \n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  lps22hb_lir_t: change the values of lir in reg INTERRUPT_CFG\n  *\n  */\nint32_t lps22hb_int_notification_mode_set(lps22hb_ctx_t *ctx,\n                                           lps22hb_lir_t val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_INTERRUPT_CFG, &(reg.byte), 1);\n  reg.interrupt_cfg.lir = val;\n  mm_error = lps22hb_write_reg(ctx, LPS22HB_INTERRUPT_CFG, &(reg.byte), 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief   int_notification_mode: [get]  Interrupt request to the\n  *                                        INT_SOURCE (25h) register\n  *                                        mode (pulsed / latched) \n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  lps22hb_lir_t: Get the values of lir in reg INTERRUPT_CFG\n  *\n  */\nint32_t lps22hb_int_notification_mode_get(lps22hb_ctx_t *ctx,\n                                          lps22hb_lir_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_INTERRUPT_CFG, &(reg.byte), 1);\n  *val = (lps22hb_lir_t) reg.interrupt_cfg.lir;\n\n  return mm_error;\n}\n\n/**\n  * @brief  int_generation: [set]  Enable interrupt generation.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of diff_en in reg INTERRUPT_CFG\n  *\n  */\nint32_t lps22hb_int_generation_set(lps22hb_ctx_t *ctx, uint8_t val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_INTERRUPT_CFG, &(reg.byte), 1);\n  reg.interrupt_cfg.diff_en = val;\n  mm_error = lps22hb_write_reg(ctx, LPS22HB_INTERRUPT_CFG, &(reg.byte), 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  int_generation: [get]  Enable interrupt generation.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of diff_en in reg INTERRUPT_CFG\n  *\n  */\nint32_t lps22hb_int_generation_get(lps22hb_ctx_t *ctx, uint8_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_INTERRUPT_CFG, &(reg.byte), 1);\n  *val = reg.interrupt_cfg.diff_en;\n\n  return mm_error;\n}\n\n/**\n  * @brief  int_threshold: [set]  User-defined threshold value for\n  *                              pressure interrupt event\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that contains data to write\n  *\n  */\nint32_t lps22hb_int_threshold_set(lps22hb_ctx_t *ctx, uint8_t *buff)\n{\n  return lps22hb_write_reg(ctx, LPS22HB_THS_P_L, (uint8_t*) buff, 2);\n}\n\n/**\n  * @brief  int_threshold: [get]  User-defined threshold value for\n  *                              pressure interrupt event\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lps22hb_int_threshold_get(lps22hb_ctx_t *ctx, uint8_t *buff)\n{\n  return lps22hb_read_reg(ctx, LPS22HB_THS_P_L, (uint8_t*) buff, 2);\n}\n\n/**\n  * @brief  int_pin_mode: [set]  Data signal on INT_DRDY pin control bits.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  lps22hb_int_s_t: change the values of int_s in reg CTRL_REG3\n  *\n  */\nint32_t lps22hb_int_pin_mode_set(lps22hb_ctx_t *ctx, lps22hb_int_s_t val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG3, &(reg.byte), 1);\n  reg.ctrl_reg3.int_s = val;\n  mm_error = lps22hb_write_reg(ctx, LPS22HB_CTRL_REG3, &(reg.byte), 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  int_pin_mode: [get]  Data signal on INT_DRDY pin control bits.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  lps22hb_int_s_t: Get the values of int_s in reg CTRL_REG3\n  *\n  */\nint32_t lps22hb_int_pin_mode_get(lps22hb_ctx_t *ctx, lps22hb_int_s_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG3, &(reg.byte), 1);\n  *val = (lps22hb_int_s_t) reg.ctrl_reg3.int_s;\n\n  return mm_error;\n}\n\n/**\n  * @brief  drdy_on_int: [set]  Data-ready signal on INT_DRDY pin.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of drdy in reg CTRL_REG3\n  *\n  */\nint32_t lps22hb_drdy_on_int_set(lps22hb_ctx_t *ctx, uint8_t val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG3, &(reg.byte), 1);\n  reg.ctrl_reg3.drdy = val;\n  mm_error = lps22hb_write_reg(ctx, LPS22HB_CTRL_REG3, &(reg.byte), 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  drdy_on_int: [get]  Data-ready signal on INT_DRDY pin.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of drdy in reg CTRL_REG3\n  *\n  */\nint32_t lps22hb_drdy_on_int_get(lps22hb_ctx_t *ctx, uint8_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG3, &(reg.byte), 1);\n  *val = reg.ctrl_reg3.drdy;\n\n  return mm_error;\n}\n\n/**\n  * @brief  fifo_ovr_on_int: [set]  FIFO overrun interrupt on INT_DRDY pin.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of f_ovr in reg CTRL_REG3\n  *\n  */\nint32_t lps22hb_fifo_ovr_on_int_set(lps22hb_ctx_t *ctx, uint8_t val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG3, &(reg.byte), 1);\n  reg.ctrl_reg3.f_ovr = val;\n  mm_error = lps22hb_write_reg(ctx, LPS22HB_CTRL_REG3, &(reg.byte), 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  fifo_ovr_on_int: [get]  FIFO overrun interrupt on INT_DRDY pin.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of f_ovr in reg CTRL_REG3\n  *\n  */\nint32_t lps22hb_fifo_ovr_on_int_get(lps22hb_ctx_t *ctx, uint8_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG3, &(reg.byte), 1);\n  *val = reg.ctrl_reg3.f_ovr;\n\n  return mm_error;\n}\n\n/**\n  * @brief   fifo_threshold_on_int: [set]  FIFO watermark status\n  *                                        on INT_DRDY pin.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of f_fth in reg CTRL_REG3\n  *\n  */\nint32_t lps22hb_fifo_threshold_on_int_set(lps22hb_ctx_t *ctx, uint8_t val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG3, &(reg.byte), 1);\n  reg.ctrl_reg3.f_fth = val;\n  mm_error = lps22hb_write_reg(ctx, LPS22HB_CTRL_REG3, &(reg.byte), 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief   fifo_threshold_on_int: [get]  FIFO watermark status\n  *                                        on INT_DRDY pin.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of f_fth in reg CTRL_REG3\n  *\n  */\nint32_t lps22hb_fifo_threshold_on_int_get(lps22hb_ctx_t *ctx, uint8_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG3, &(reg.byte), 1);\n  *val = reg.ctrl_reg3.f_fth;\n\n  return mm_error;\n}\n\n/**\n  * @brief  fifo_full_on_int: [set]  FIFO full flag on INT_DRDY pin.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of f_fss5 in reg CTRL_REG3\n  *\n  */\nint32_t lps22hb_fifo_full_on_int_set(lps22hb_ctx_t *ctx, uint8_t val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG3, &(reg.byte), 1);\n  reg.ctrl_reg3.f_fss5 = val;\n  mm_error = lps22hb_write_reg(ctx, LPS22HB_CTRL_REG3, &(reg.byte), 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  fifo_full_on_int: [get]  FIFO full flag on INT_DRDY pin.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of f_fss5 in reg CTRL_REG3\n  *\n  */\nint32_t lps22hb_fifo_full_on_int_get(lps22hb_ctx_t *ctx, uint8_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG3, &(reg.byte), 1);\n  *val = reg.ctrl_reg3.f_fss5;\n\n  return mm_error;\n}\n\n/**\n  * @brief  pin_mode: [set]  Push-pull/open drain selection on interrupt pads.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  lps22hb_pp_od_t: change the values of pp_od in reg CTRL_REG3\n  *\n  */\nint32_t lps22hb_pin_mode_set(lps22hb_ctx_t *ctx, lps22hb_pp_od_t val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG3, &(reg.byte), 1);\n  reg.ctrl_reg3.pp_od = val;\n  mm_error = lps22hb_write_reg(ctx, LPS22HB_CTRL_REG3, &(reg.byte), 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  pin_mode: [get]  Push-pull/open drain selection on interrupt pads.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  lps22hb_pp_od_t: Get the values of pp_od in reg CTRL_REG3\n  *\n  */\nint32_t lps22hb_pin_mode_get(lps22hb_ctx_t *ctx, lps22hb_pp_od_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG3, &(reg.byte), 1);\n  *val = (lps22hb_pp_od_t) reg.ctrl_reg3.pp_od;\n\n  return mm_error;\n}\n\n/**\n  * @brief  int_polarity: [set]  Interrupt active-high/low.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  lps22hb_int_h_l_t: change the values of int_h_l in reg CTRL_REG3\n  *\n  */\nint32_t lps22hb_int_polarity_set(lps22hb_ctx_t *ctx, lps22hb_int_h_l_t val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG3, &(reg.byte), 1);\n  reg.ctrl_reg3.int_h_l = val;\n  mm_error = lps22hb_write_reg(ctx, LPS22HB_CTRL_REG3, &(reg.byte), 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  int_polarity: [get]  Interrupt active-high/low.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  lps22hb_int_h_l_t: Get the values of int_h_l in reg CTRL_REG3\n  *\n  */\nint32_t lps22hb_int_polarity_get(lps22hb_ctx_t *ctx, lps22hb_int_h_l_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG3, &(reg.byte), 1);\n  *val = (lps22hb_int_h_l_t) reg.ctrl_reg3.int_h_l;\n\n  return mm_error;\n}\n\n/**\n  * @brief  int_source: [get]  Interrupt source register\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  lps22hb_int_source_t: register INT_SOURCE\n  *\n  */\nint32_t lps22hb_int_source_get(lps22hb_ctx_t *ctx, lps22hb_int_source_t *val)\n{\n  return lps22hb_read_reg(ctx, LPS22HB_INT_SOURCE, (uint8_t*) val, 1);\n}\n\n/**\n  * @brief  int_on_press_high: [get]  Differential pressure high\n  *                                   interrupt flag.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of ph in reg INT_SOURCE\n  *\n  */\nint32_t lps22hb_int_on_press_high_get(lps22hb_ctx_t *ctx, uint8_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_INT_SOURCE, &(reg.byte), 1);\n  *val = reg.int_source.ph;\n\n  return mm_error;\n}\n\n/**\n  * @brief  int_on_press_low: [get]  Differential pressure low interrupt flag.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of pl in reg INT_SOURCE\n  *\n  */\nint32_t lps22hb_int_on_press_low_get(lps22hb_ctx_t *ctx, uint8_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_INT_SOURCE, &(reg.byte), 1);\n  *val = reg.int_source.pl;\n\n  return mm_error;\n}\n\n/**\n  * @brief  interrupt_event: [get]  Interrupt active flag.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of ia in reg INT_SOURCE\n  *\n  */\nint32_t lps22hb_interrupt_event_get(lps22hb_ctx_t *ctx, uint8_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_INT_SOURCE, &(reg.byte), 1);\n  *val = reg.int_source.ia;\n\n  return mm_error;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  fifo\n  * @brief   This section group all the functions concerning the fifo usage\n  * @{\n  */\n\n/**\n  * @brief   stop_on_fifo_threshold: [set]  Stop on FIFO watermark.\n  *                                         Enable FIFO watermark level use.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of stop_on_fth in reg CTRL_REG2\n  *\n  */\nint32_t lps22hb_stop_on_fifo_threshold_set(lps22hb_ctx_t *ctx, uint8_t val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG2, &(reg.byte), 1);\n  reg.ctrl_reg2.stop_on_fth = val;\n  mm_error = lps22hb_write_reg(ctx, LPS22HB_CTRL_REG2, &(reg.byte), 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief   stop_on_fifo_threshold: [get]  Stop on FIFO watermark.\n  *                                         Enable FIFO watermark level use.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of stop_on_fth in reg CTRL_REG2\n  *\n  */\nint32_t lps22hb_stop_on_fifo_threshold_get(lps22hb_ctx_t *ctx, uint8_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG2, &(reg.byte), 1);\n  *val = reg.ctrl_reg2.stop_on_fth;\n\n  return mm_error;\n}\n\n/**\n  * @brief  fifo: [set] FIFOenable.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of fifo_en in reg CTRL_REG2\n  *\n  */\nint32_t lps22hb_fifo_set(lps22hb_ctx_t *ctx, uint8_t val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG2, &(reg.byte), 1);\n  reg.ctrl_reg2.fifo_en = val;\n  mm_error = lps22hb_write_reg(ctx, LPS22HB_CTRL_REG2, &(reg.byte), 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  fifo: [get] FIFOenable.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of fifo_en in reg CTRL_REG2\n  *\n  */\nint32_t lps22hb_fifo_get(lps22hb_ctx_t *ctx, uint8_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG2, &(reg.byte), 1);\n  *val = reg.ctrl_reg2.fifo_en;\n\n  return mm_error;\n}\n\n/**\n  * @brief  fifo_watermark: [set]  FIFO watermark level selection.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of wtm in reg FIFO_CTRL\n  *\n  */\nint32_t lps22hb_fifo_watermark_set(lps22hb_ctx_t *ctx, uint8_t val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_FIFO_CTRL, &(reg.byte), 1);\n  reg.fifo_ctrl.wtm = val;\n  mm_error = lps22hb_write_reg(ctx, LPS22HB_FIFO_CTRL, &(reg.byte), 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  fifo_watermark: [get]  FIFO watermark level selection.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of wtm in reg FIFO_CTRL\n  *\n  */\nint32_t lps22hb_fifo_watermark_get(lps22hb_ctx_t *ctx, uint8_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_FIFO_CTRL, &(reg.byte), 1);\n  *val = reg.fifo_ctrl.wtm;\n\n  return mm_error;\n}\n\n/**\n  * @brief  fifo_mode: [set]  FIFO mode selection.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  lps22hb_f_mode_t: change the values of f_mode in reg FIFO_CTRL\n  *\n  */\nint32_t lps22hb_fifo_mode_set(lps22hb_ctx_t *ctx, lps22hb_f_mode_t val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_FIFO_CTRL, &(reg.byte), 1);\n  reg.fifo_ctrl.f_mode = val;\n  mm_error = lps22hb_write_reg(ctx, LPS22HB_FIFO_CTRL, &(reg.byte), 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  fifo_mode: [get]  FIFO mode selection.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  lps22hb_f_mode_t: Get the values of f_mode in reg FIFO_CTRL\n  *\n  */\nint32_t lps22hb_fifo_mode_get(lps22hb_ctx_t *ctx, lps22hb_f_mode_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_FIFO_CTRL, &(reg.byte), 1);\n  *val = (lps22hb_f_mode_t) reg.fifo_ctrl.f_mode;\n\n  return mm_error;\n}\n\n/**\n  * @brief  fifo_data_level: [get]  FIFO stored data level.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of fss in reg FIFO_STATUS\n  *\n  */\nint32_t lps22hb_fifo_data_level_get(lps22hb_ctx_t *ctx, uint8_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_FIFO_STATUS, &(reg.byte), 1);\n  *val = reg.fifo_status.fss;\n\n  return mm_error;\n}\n\n/**\n  * @brief  fifo_ovr_flag: [get]  FIFO overrun status.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of ovr in reg FIFO_STATUS\n  *\n  */\nint32_t lps22hb_fifo_ovr_flag_get(lps22hb_ctx_t *ctx, uint8_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_FIFO_STATUS, &(reg.byte), 1);\n  *val = reg.fifo_status.ovr;\n\n  return mm_error;\n}\n\n/**\n  * @brief  fifo_fth_flag: [get]  FIFO watermark status.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of fth_fifo in reg FIFO_STATUS\n  *\n  */\nint32_t lps22hb_fifo_fth_flag_get(lps22hb_ctx_t *ctx, uint8_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_FIFO_STATUS, &(reg.byte), 1);\n  *val = reg.fifo_status.fth_fifo;\n\n  return mm_error;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  serial_interface\n  * @brief   This section group all the functions concerning serial\n  *          interface management\n  * @{\n  */\n\n/**\n  * @brief  spi_mode: [set]  SPI Serial Interface Mode selection.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  lps22hb_sim_t: change the values of sim in reg CTRL_REG1\n  *\n  */\nint32_t lps22hb_spi_mode_set(lps22hb_ctx_t *ctx, lps22hb_sim_t val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG1, &(reg.byte), 1);\n  reg.ctrl_reg1.sim = val;\n  mm_error = lps22hb_write_reg(ctx, LPS22HB_CTRL_REG1, &(reg.byte), 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  spi_mode: [get]  SPI Serial Interface Mode selection.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  lps22hb_sim_t: Get the values of sim in reg CTRL_REG1\n  *\n  */\nint32_t lps22hb_spi_mode_get(lps22hb_ctx_t *ctx, lps22hb_sim_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG1, &(reg.byte), 1);\n  *val = (lps22hb_sim_t) reg.ctrl_reg1.sim;\n\n  return mm_error;\n}\n\n/**\n  * @brief  i2c_interface: [set]  Disable I2C interface.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  lps22hb_i2c_dis_t: change the values of i2c_dis in reg CTRL_REG2\n  *\n  */\nint32_t lps22hb_i2c_interface_set(lps22hb_ctx_t *ctx, lps22hb_i2c_dis_t val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG2, &(reg.byte), 1);\n  reg.ctrl_reg2.i2c_dis = val;\n  mm_error = lps22hb_write_reg(ctx, LPS22HB_CTRL_REG2, &(reg.byte), 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  i2c_interface: [get]  Disable I2C interface.\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  lps22hb_i2c_dis_t: Get the values of i2c_dis in reg CTRL_REG2\n  *\n  */\nint32_t lps22hb_i2c_interface_get(lps22hb_ctx_t *ctx, lps22hb_i2c_dis_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG2, &(reg.byte), 1);\n  *val = (lps22hb_i2c_dis_t) reg.ctrl_reg2.i2c_dis;\n\n  return mm_error;\n}\n\n/**\n  * @brief  auto_add_inc: [set]  Register address automatically incremented\n  *                              during a multiple byte access with a serial\n  *                              interface (I2C or SPI).\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of if_add_inc in reg CTRL_REG2\n  *\n  */\nint32_t lps22hb_auto_add_inc_set(lps22hb_ctx_t *ctx, uint8_t val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG2, &(reg.byte), 1);\n  reg.ctrl_reg2.if_add_inc = val;\n  mm_error = lps22hb_write_reg(ctx, LPS22HB_CTRL_REG2, &(reg.byte), 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  auto_add_inc: [get]  Register address automatically\n  *                              incremented during a multiple byte access\n  *                              with a serial interface (I2C or SPI).\n  *\n  * @param  lps22hb_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of if_add_inc in reg CTRL_REG2\n  *\n  */\nint32_t lps22hb_auto_add_inc_get(lps22hb_ctx_t *ctx, uint8_t *val)\n{\n  lps22hb_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG2, &(reg.byte), 1);\n  *val = reg.ctrl_reg2.if_add_inc;\n\n  return mm_error;\n}\n\n/**\n  * @}\n  */\n\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/"
              }
            }
          },
          "md5": "b1327f96f54f66104b3adfe3a7f6f2a1"
        },
        "lsm6dsm": {
          "libName": "lsm6dsm",
          "manufacturer": "STMicroelectronics",
          "description": "3D Inertial Module",
          "type": "Accelerometer Gyroscope",
          "icon": "",
          "image": "",
          "version": "",
          "eelVersion": "3",
          "shoppingCartLinks": {
            "digikey": {
              "links": {
                "info": "https://www.digikey.com/product-detail/en/stmicroelectronics/LSM6DSMTR/497-16696-2-ND/6192777"
              },
              "cartData": {
                "part": "497-16696-2-ND",
                "partid": "6192777",
                "source": "dkstudio",
                "qty": "1"
              }
            }
          },
          "requires": [
            "embedded",
            "i2c",
            "gpio",
            "fpmath",
            "spi"
          ],
          "elements": [
            {
              "name": "EmbeddedLSM6DSM",
              "type": "EmbeddedLSM6DSM",
              "icon": "EmbeddedGyroscope.svg",
              "defaultAbility": "xAcceleration",
              "defaultTrigger": "xAccelerationRead",
              "hidden": false,
              "helpPageHref": "https://developer.atmosphereiot.com/documents/elements/stmicroelectronicslsm6dsmelement.html",
              "abilities": [
                {
                  "name": "setup",
                  "hidden": true,
                  "code": "    ATMO_LSM6DSM_Config_t config;\r\n    config.i2cInstance = ATMO_PROPERTY(undefined, i2cInstance);\r\n    config.i2cAddress = ATMO_PROPERTY(undefined, i2cAddress);\r\n    config.accelOdr = ATMO_PROPERTY(undefined, accelOdr);\r\n    config.gyroOdr = ATMO_PROPERTY(undefined, gyroOdr);\r\n    config.accelFullScale = ATMO_PROPERTY(undefined, accelFullScale);\r\n    config.gyroFullScale = ATMO_PROPERTY(undefined, gyroFullScale);\r\n    config.driverType.type = ATMO_PROPERTY(undefined, communicationMode);\r\n    config.csPin = ATMO_PROPERTY(undefined, csPin);\r\n    config.spi3Wire = ATMO_PROPERTY(undefined, spi3Wire);\r\n    config.spiInstance = ATMO_PROPERTY(undefined, spiInstance);\r\n    config.gpioInstance = ATMO_PROPERTY(undefined, gpioInstance);\r\n    return ATMO_LSM6DSM_Init(&config) == ATMO_LSM6DSM_Status_Success ? ATMO_Status_Success : ATMO_Status_Fail;"
                },
                {
                  "name": "xAcceleration",
                  "triggers": [
                    "xAccelerationRead"
                  ],
                  "code": "    ATMO_LSM6DSM_AccelData_t accelData;\r\n    if(ATMO_LSM6DSM_GetAccelData(&accelData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, accelData.x);\r\n    return ATMO_Status_Success;"
                },
                {
                  "name": "yAcceleration",
                  "triggers": [
                    "yAccelerationRead"
                  ],
                  "code": "    ATMO_LSM6DSM_AccelData_t accelData;\r\n    if(ATMO_LSM6DSM_GetAccelData(&accelData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, accelData.y);\r\n    return ATMO_Status_Success;"
                },
                {
                  "name": "zAcceleration",
                  "triggers": [
                    "zAccelerationRead"
                  ],
                  "code": "    ATMO_LSM6DSM_AccelData_t accelData;\r\n    if(ATMO_LSM6DSM_GetAccelData(&accelData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, accelData.z);\r\n    return ATMO_Status_Success;"
                },
                {
                  "name": "acceleration",
                  "triggers": [
                    "accelerationRead"
                  ],
                  "code": "    ATMO_LSM6DSM_AccelData_t accelData;\r\n    ATMO_3dFloatVector_t vec;\r\n    if(ATMO_LSM6DSM_GetAccelData(&accelData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    vec.x = accelData.x;\r\n    vec.y = accelData.y;\r\n    vec.z = accelData.z;\r\n\r\n    ATMO_CreateValue3dVectorFloat(out, &vec);\r\n    return ATMO_Status_Success;"
                },
                {
                  "name": "rotSpeed",
                  "triggers": [
                    "rotSpeedRead"
                  ],
                  "code": "    ATMO_LSM6DSM_GyroData_t gyroData;\r\n    ATMO_3dFloatVector_t vec;\r\n    if(ATMO_LSM6DSM_GetGyroData(&gyroData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    vec.x = gyroData.x;\r\n    vec.y = gyroData.y;\r\n    vec.z = gyroData.z;\r\n\r\n    ATMO_CreateValue3dVectorFloat(out, &vec);\r\n    return ATMO_Status_Success;"
                },
                {
                  "name": "xRotSpeed",
                  "triggers": [
                    "xRotSpeedRead"
                  ],
                  "code": "    ATMO_LSM6DSM_GyroData_t gyroData;\r\n    if(ATMO_LSM6DSM_GetGyroData(&gyroData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, gyroData.x);\r\n    return ATMO_Status_Success;"
                },
                {
                  "name": "yRotSpeed",
                  "triggers": [
                    "yRotSpeedRead"
                  ],
                  "code": "    ATMO_LSM6DSM_GyroData_t gyroData;\r\n    if(ATMO_LSM6DSM_GetGyroData(&gyroData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, gyroData.y);\r\n    return ATMO_Status_Success;"
                },
                {
                  "name": "zRotSpeed",
                  "triggers": [
                    "zRotSpeedRead"
                  ],
                  "code": "    ATMO_LSM6DSM_GyroData_t gyroData;\r\n    if(ATMO_LSM6DSM_GetGyroData(&gyroData) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, gyroData.z);\r\n    return ATMO_Status_Success;"
                },
                {
                  "name": "temperature",
                  "triggers": [
                    "temperatureRead"
                  ],
                  "code": "    float temperature = 0;\r\n    if(ATMO_LSM6DSM_GetTempData(&temperature) != ATMO_LSM6DSM_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, temperature);\r\n    return ATMO_Status_Success;"
                }
              ],
              "properties": [
                {
                  "name": "communicationMode",
                  "input": "select",
                  "inputOptions": [
                    "ATMO_DRIVERTYPE_SPI",
                    "ATMO_DRIVERTYPE_I2C"
                  ],
                  "value": "ATMO_DRIVERTYPE_SPI"
                },
                {
                  "name": "i2cInstance",
                  "input": "number",
                  "value": "0"
                },
                {
                  "name": "spiInstance",
                  "input": "number",
                  "value": "0"
                },
                {
                  "name": "gpioInstance",
                  "input": "number",
                  "value": "0"
                },
                {
                  "name": "csPin",
                  "input": "number",
                  "value": "0"
                },
                {
                  "name": "spi3Wire",
                  "input": "checkbox",
                  "value": true
                },
                {
                  "name": "i2cAddress",
                  "input": "select",
                  "inputOptions": [
                    "0x6B",
                    "0x6A"
                  ],
                  "value": "0x6B"
                },
                {
                  "name": "accelOdr",
                  "input": "select",
                  "inputOptions": [
                    "LSM6DSM_XL_ODR_OFF",
                    "LSM6DSM_XL_ODR_12Hz5",
                    "LSM6DSM_XL_ODR_26Hz",
                    "LSM6DSM_XL_ODR_52Hz",
                    "LSM6DSM_XL_ODR_104Hz",
                    "LSM6DSM_XL_ODR_208Hz",
                    "LSM6DSM_XL_ODR_416Hz",
                    "LSM6DSM_XL_ODR_833Hz",
                    "LSM6DSM_XL_ODR_1Hz6",
                    "LSM6DSM_XL_ODR_1k66Hz",
                    "LSM6DSM_XL_ODR_3k33Hz",
                    "LSM6DSM_XL_ODR_6k66Hz"
                  ],
                  "value": "LSM6DSM_XL_ODR_12Hz5"
                },
                {
                  "name": "gyroOdr",
                  "input": "select",
                  "inputOptions": [
                    "LSM6DSM_GY_ODR_OFF",
                    "LSM6DSM_GY_ODR_12Hz5",
                    "LSM6DSM_GY_ODR_26Hz",
                    "LSM6DSM_GY_ODR_52Hz",
                    "LSM6DSM_GY_ODR_104Hz",
                    "LSM6DSM_GY_ODR_208Hz",
                    "LSM6DSM_GY_ODR_416Hz",
                    "LSM6DSM_GY_ODR_833Hz",
                    "LSM6DSM_GY_ODR_1k66Hz",
                    "LSM6DSM_GY_ODR_3k33Hz",
                    "LSM6DSM_GY_ODR_6k66Hz"
                  ],
                  "value": "LSM6DSM_GY_ODR_12Hz5"
                },
                {
                  "name": "accelFullScale",
                  "input": "select",
                  "inputOptions": [
                    "LSM6DSM_2g",
                    "LSM6DSM_4g",
                    "LSM6DSM_8g",
                    "LSM6DSM_16g"
                  ],
                  "value": "LSM6DSM_2g"
                },
                {
                  "name": "gyroFullScale",
                  "input": "select",
                  "inputOptions": [
                    "LSM6DSM_125dps",
                    "LSM6DSM_250dps",
                    "LSM6DSM_500dps",
                    "LSM6DSM_1000dps",
                    "LSM6DSM_2000dps"
                  ],
                  "value": "LSM6DSM_2000dps"
                }
              ],
              "triggers": [],
              "variables": [],
              "language": {
                "en-US": {
                  "EmbeddedLSM6DSM": "LSM6DSM Accelerometer",
                  "xAcceleration": "Read X Acceleration (mg)",
                  "yAcceleration": "Read Y Acceleration (mg)",
                  "zAcceleration": "Read Z Acceleration (mg)",
                  "xRotSpeed": "Read X Rotation Speed (mdps)",
                  "yRotSpeed": "Read Y Rotation Speed (mdps)",
                  "zRotSpeed": "Read Z Rotation Speed (mdps)",
                  "xAccelerationRead": "X Acceleration Read",
                  "yAccelerationRead": "Y Acceleration Read",
                  "zAccelerationRead": "Z Acceleration Read",
                  "xRotSpeedRead": "X Rotation Speed Read",
                  "yRotSpeedRead": "Y Rotation Speed Read",
                  "zRotSpeedRead": "Z Rotation Speed Read",
                  "acceleration": "Read Acceleration",
                  "accelerationRead": "Acceleration Read",
                  "rotSpeed": "Read Rotation Speed",
                  "rotSpeedRead": "Rotation Speed Read",
                  "gyroOdr": "Gyroscope Output Data Rate",
                  "accelOdr": "Accelerometer Output Data Rate",
                  "i2cAddress": "I2C Address",
                  "csPin": "Chip Select Pin",
                  "accelFullScale": "Accelerometer Full-Scale",
                  "gyroFullScale": "Gyroscope Full-Scale",
                  "communicationMode": "Communication Mode",
                  "ATMO_DRIVERTYPE_SPI": "SPI",
                  "ATMO_DRIVERTYPE_I2C": "I2C",
                  "spiInstance": "SPI Driver Instance",
                  "gpioInstance": "GPIO Driver Instance",
                  "spi3Wire": "3 Wire SPI Mode",
                  "temperature": "Read Temperature",
                  "temperatureRead": "Temperature Read",
                  "LSM6DSM_XL_ODR_12Hz5": "12.5 Hz",
                  "LSM6DSM_XL_ODR_26Hz": "26 Hz",
                  "LSM6DSM_XL_ODR_52Hz": "52 Hz",
                  "LSM6DSM_XL_ODR_104Hz": "104 Hz",
                  "LSM6DSM_XL_ODR_208Hz": "208 Hz",
                  "LSM6DSM_XL_ODR_416Hz": "416 Hz",
                  "LSM6DSM_XL_ODR_833Hz": "833 Hz",
                  "LSM6DSM_XL_ODR_1k66Hz": "1.66 kHz",
                  "LSM6DSM_XL_ODR_3k33Hz": "3.33 kHz",
                  "LSM6DSM_XL_ODR_6k66Hz": "6.66 kHz",
                  "LSM6DSM_XL_ODR_1Hz6": "1.6 Hz",
                  "LSM6DSM_GY_ODR_12Hz5": "12.5 Hz",
                  "LSM6DSM_GY_ODR_26Hz": "26 Hz",
                  "LSM6DSM_GY_ODR_52Hz": "52 Hz",
                  "LSM6DSM_GY_ODR_104Hz": "104 Hz",
                  "LSM6DSM_GY_ODR_208Hz": "208 Hz",
                  "LSM6DSM_GY_ODR_416Hz": "416 Hz",
                  "LSM6DSM_GY_ODR_833Hz": "833 Hz",
                  "LSM6DSM_GY_ODR_1k66Hz": "1.66 kHz",
                  "LSM6DSM_GY_ODR_3k33Hz": "3.33 kHz",
                  "LSM6DSM_GY_ODR_6k66Hz": "6.66 kHz",
                  "LSM6DSM_2g": "2 g",
                  "LSM6DSM_16g": "16 g",
                  "LSM6DSM_4g": "4 g",
                  "LSM6DSM_8g": "8 g",
                  "LSM6DSM_250dps": "250 dps",
                  "LSM6DSM_125dps": "125 dps",
                  "LSM6DSM_500dps": "500 dps",
                  "LSM6DSM_1000dps": "1000 dps",
                  "LSM6DSM_2000dps": "2000 dps"
                }
              }
            }
          ],
          "files": {
            "common": {
              "headers": {
                "lsm6dsm.h": "/**\r\n ******************************************************************************\r\n * @file    lsm6dsm.h\r\n * @author\r\n * @version\r\n * @date\r\n * @brief   Atmosphere API - lsm6dsm header file\r\n ******************************************************************************\r\n * @attention\r\n *\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *   1. Redistributions of source code must retain the above copyright notice,\r\n *      this list of conditions and the following disclaimer.\r\n *   2. Redistributions in binary form must reproduce the above copyright notice,\r\n *      this list of conditions and the following disclaimer in the documentation\r\n *      and/or other materials provided with the distribution.\r\n *   3. Neither the name of Atmosphere IoT Corp. nor the names of its contributors\r\n *      may be used to endorse or promote products derived from this software\r\n *      without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n ******************************************************************************\r\n */\r\n#ifndef _ATMO_LSM6DSM_H_\r\n#define _ATMO_LSM6DSM_H_\r\n\r\n#include \"../app_src/atmosphere_platform.h\"\r\n\r\ntypedef struct {\r\n    ATMO_DriverInstanceHandle_t i2cInstance;\r\n    ATMO_DriverInstanceHandle_t spiInstance;\r\n    ATMO_DriverInstanceHandle_t gpioInstance;\r\n    uint8_t i2cAddress;\r\n    uint8_t accelOdr;\r\n    uint8_t gyroOdr;\r\n    uint8_t accelFullScale;\r\n    uint8_t gyroFullScale;\r\n    bool spi3Wire;\r\n    ATMO_GPIO_Device_Pin_t csPin; // Only used for SPI\r\n    ATMO_CORE_DeviceHandle_t driverType;\r\n}ATMO_LSM6DSM_Config_t;\r\n\r\ntypedef enum {\r\n    ATMO_LSM6DSM_Status_Success = 0 ,\r\n    ATMO_LSM6DSM_Status_Fail\r\n} ATMO_LSM6DSM_Status_t;\r\n\r\ntypedef struct {\r\n    float x;\r\n    float y;\r\n    float z;\r\n} ATMO_LSM6DSM_AccelData_t;\r\n\r\ntypedef ATMO_LSM6DSM_AccelData_t ATMO_LSM6DSM_GyroData_t;\r\n\r\nATMO_LSM6DSM_Status_t ATMO_LSM6DSM_Init(ATMO_LSM6DSM_Config_t *config);\r\n\r\n/**\r\n * @brief Get acceleration data. Each axis is in mg\r\n * \r\n * @param data \r\n * @return ATMO_LSM6DSM_Status_t \r\n */\r\nATMO_LSM6DSM_Status_t ATMO_LSM6DSM_GetAccelData(ATMO_LSM6DSM_AccelData_t *data);\r\n\r\n/**\r\n * @brief Get gyroscope data. Each axis is in mdps\r\n * \r\n * @param data \r\n * @return ATMO_LSM6DSM_Status_t \r\n */\r\nATMO_LSM6DSM_Status_t ATMO_LSM6DSM_GetGyroData(ATMO_LSM6DSM_GyroData_t *data);\r\n\r\n/**\r\n * @brief Get temperature data in degrees C\r\n * \r\n * @param tempC \r\n * @return ATMO_LSM6DSM_Status_t \r\n */\r\nATMO_LSM6DSM_Status_t ATMO_LSM6DSM_GetTempData(float *tempC);\r\n\r\n#endif\r\n",
                "lsm6dsm_reg.h": "/*\n ******************************************************************************\n * @file    lsm6dsm_reg.h\n * @author  Sensors Software Solution Team\n * @brief   This file contains all the functions prototypes for the\n *          lsm6dsm_reg.c driver.\n ******************************************************************************\n * @attention\n *\n * <h2><center>&copy; COPYRIGHT(c) 2018 STMicroelectronics</center></h2>\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *   1. Redistributions of source code must retain the above copyright notice,\n *      this list of conditions and the following disclaimer.\n *   2. Redistributions in binary form must reproduce the above copyright notice,\n *      this list of conditions and the following disclaimer in the documentation\n *      and/or other materials provided with the distribution.\n *   3. Neither the name of STMicroelectronics nor the names of its contributors\n *      may be used to endorse or promote products derived from this software\n *      without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n/* Define to prevent recursive inclusion -------------------------------------*/\n#ifndef __LSM6DSM_DRIVER__H\n#define __LSM6DSM_DRIVER__H\n\n#ifdef __cplusplus\n  extern \"C\" {\n#endif\n\n/* Includes ------------------------------------------------------------------*/\n#include <stdint.h>\n\n/** @addtogroup lsm6dsm\n * @{\n */\n\n#ifndef __MEMS_SHARED__TYPES\n#define __MEMS_SHARED__TYPES\n\n/** @defgroup ST_MEMS_common_types\n  * @{\n  */\n\ntypedef union{\n\tint16_t i16bit[3];\n\tuint8_t u8bit[6];\n} axis3bit16_t;\n\ntypedef union{\n\tint16_t i16bit;\n\tuint8_t u8bit[2];\n} axis1bit16_t;\n\ntypedef union{\n\tint32_t i32bit[3];\n\tuint8_t u8bit[12];\n} axis3bit32_t;\n\ntypedef union{\n\tint32_t i32bit;\n\tuint8_t u8bit[4];\n} axis1bit32_t;\n\ntypedef struct {\n   uint8_t bit0       : 1;\n   uint8_t bit1       : 1;\n   uint8_t bit2       : 1;\n   uint8_t bit3       : 1;\n   uint8_t bit4       : 1;\n   uint8_t bit5       : 1;\n   uint8_t bit6       : 1;\n   uint8_t bit7       : 1;\n} bitwise_t;\n\n#define PROPERTY_DISABLE                (0)\n#define PROPERTY_ENABLE                 (1)\n\n#endif /*__MEMS_SHARED__TYPES*/\n\n/**\n  * @}\n  */\n\n/** @defgroup lsm6dsm_interface\n  * @{\n  */\n\ntypedef int32_t (*lsm6dsm_write_ptr)(void *, uint8_t, uint8_t*, uint16_t);\ntypedef int32_t (*lsm6dsm_read_ptr) (void *, uint8_t, uint8_t*, uint16_t);\n\ntypedef struct {\n  /** Component mandatory fields **/\n  lsm6dsm_write_ptr  write_reg;\n  lsm6dsm_read_ptr   read_reg;\n  /** Customizable optional pointer **/\n  void *handle;\n} lsm6dsm_ctx_t;\n\n/**\n  * @}\n  */\n\n/** @defgroup lsm6dsm_Infos\n  * @{\n  */\n\n/** I2C Device Address 8 bit format  if SA0=0 -> D5 if SA0=1 -> D7 **/\n#define LSM6DSM_I2C_ADD_L     0xD5\n#define LSM6DSM_I2C_ADD_H     0xD7\n\n/** Device Identification (Who am I) **/\n#define LSM6DSM_ID            0x6A\n\n/**\n  * @}\n  */\n\n/**\n  * @defgroup lsm6dsm_Sensitivity\n  * @{\n  */\n\n#define LSM6DSM_FROM_FS_2g_TO_mg(lsb)    (float)(lsb *  61.0f) / 1000.0f\n#define LSM6DSM_FROM_FS_4g_TO_mg(lsb)    (float)(lsb * 122.0f) / 1000.0f\n#define LSM6DSM_FROM_FS_8g_TO_mg(lsb)    (float)(lsb * 244.0f) / 1000.0f\n#define LSM6DSM_FROM_FS_16g_TO_mg(lsb)   (float)(lsb * 488.0f) / 1000.0f\n\n#define LSM6DSM_FROM_FS_125dps_TO_mdps(lsb)  (float)(lsb *  4375.0f ) / 1000.0f\n#define LSM6DSM_FROM_FS_250dps_TO_mdps(lsb)  (float)(lsb *  8750.0f ) / 1000.0f\n#define LSM6DSM_FROM_FS_500dps_TO_mdps(lsb)  (float)(lsb * 17500.0f ) / 1000.0f\n#define LSM6DSM_FROM_FS_1000dps_TO_mdps(lsb) (float)(lsb * 35.0f)\n#define LSM6DSM_FROM_FS_2000dps_TO_mdps(lsb) (float)(lsb * 70.0f)\n\n#define LSM6DSM_FROM_LSB_TO_degC(lsb)   ((float)((int16_t)lsb>>8)*1.0f + 25.0f)\n\n/**\n  * @}\n  */\n\n#define LSM6DSM_FUNC_CFG_ACCESS              0x01\ntypedef struct {\n  uint8_t not_used_01              : 5;\n  uint8_t func_cfg_en              : 3;  /* func_cfg_en + func_cfg_en_b */\n} lsm6dsm_func_cfg_access_t;\n\n#define LSM6DSM_SENSOR_SYNC_TIME_FRAME       0x04\ntypedef struct {\n  uint8_t tph                      : 4;\n  uint8_t not_used_01              : 4;\n} lsm6dsm_sensor_sync_time_frame_t;\n\n#define LSM6DSM_SENSOR_SYNC_RES_RATIO        0x05\ntypedef struct {\n  uint8_t rr                       : 2;\n  uint8_t not_used_01              : 6;\n} lsm6dsm_sensor_sync_res_ratio_t;\n\n#define LSM6DSM_FIFO_CTRL1                   0x06\ntypedef struct {\n  uint8_t fth                      : 8;  /* + FIFO_CTRL2(fth) */\n} lsm6dsm_fifo_ctrl1_t;\n\n#define LSM6DSM_FIFO_CTRL2                   0x07\ntypedef struct {\n  uint8_t fth                      : 3;  /* + FIFO_CTRL1(fth) */\n  uint8_t fifo_temp_en             : 1;\n  uint8_t not_used_01              : 2;\n  uint8_t  timer_pedo_fifo_drdy    : 1;\n  uint8_t timer_pedo_fifo_en       : 1;\n} lsm6dsm_fifo_ctrl2_t;\n\n#define LSM6DSM_FIFO_CTRL3                   0x08\ntypedef struct {\n  uint8_t dec_fifo_xl              : 3;\n  uint8_t dec_fifo_gyro            : 3;\n  uint8_t not_used_01              : 2;\n} lsm6dsm_fifo_ctrl3_t;\n\n#define LSM6DSM_FIFO_CTRL4                   0x09\ntypedef struct {\n  uint8_t dec_ds3_fifo             : 3;\n  uint8_t dec_ds4_fifo             : 3;\n  uint8_t only_high_data           : 1;\n  uint8_t stop_on_fth              : 1;\n} lsm6dsm_fifo_ctrl4_t;\n\n#define LSM6DSM_FIFO_CTRL5                   0x0A\ntypedef struct {\n  uint8_t fifo_mode                : 3;\n  uint8_t odr_fifo                 : 4;\n  uint8_t not_used_01              : 1;\n} lsm6dsm_fifo_ctrl5_t;\n\n#define LSM6DSM_DRDY_PULSE_CFG               0x0B\ntypedef struct {\n  uint8_t int2_wrist_tilt          : 1;\n  uint8_t not_used_01              : 6;\n  uint8_t drdy_pulsed              : 1;\n} lsm6dsm_drdy_pulse_cfg_t;\n\n#define LSM6DSM_INT1_CTRL                    0x0D\ntypedef struct {\n  uint8_t int1_drdy_xl             : 1;\n  uint8_t int1_drdy_g              : 1;\n  uint8_t int1_boot                : 1;\n  uint8_t int1_fth                 : 1;\n  uint8_t int1_fifo_ovr            : 1;\n  uint8_t int1_full_flag           : 1;\n  uint8_t int1_sign_mot            : 1;\n  uint8_t int1_step_detector       : 1;\n} lsm6dsm_int1_ctrl_t;\n\n#define LSM6DSM_INT2_CTRL                    0x0E\ntypedef struct {\n  uint8_t int2_drdy_xl             : 1;\n  uint8_t int2_drdy_g              : 1;\n  uint8_t int2_drdy_temp           : 1;\n  uint8_t int2_fth                 : 1;\n  uint8_t int2_fifo_ovr            : 1;\n  uint8_t int2_full_flag           : 1;\n  uint8_t int2_step_count_ov       : 1;\n  uint8_t int2_step_delta          : 1;\n} lsm6dsm_int2_ctrl_t;\n\n#define LSM6DSM_WHO_AM_I                     0x0F\n#define LSM6DSM_CTRL1_XL                     0x10\ntypedef struct {\n  uint8_t bw0_xl                   : 1;\n  uint8_t lpf1_bw_sel              : 1;\n  uint8_t fs_xl                    : 2;\n  uint8_t odr_xl                   : 4;\n} lsm6dsm_ctrl1_xl_t;\n\n#define LSM6DSM_CTRL2_G                      0x11\ntypedef struct {\n  uint8_t not_used_01              : 1;\n  uint8_t fs_g                     : 3;  /* fs_g + fs_125 */\n  uint8_t odr_g                    : 4;\n} lsm6dsm_ctrl2_g_t;\n\n#define LSM6DSM_CTRL3_C                      0x12\ntypedef struct {\n  uint8_t sw_reset                 : 1;\n  uint8_t ble                      : 1;\n  uint8_t if_inc                   : 1;\n  uint8_t sim                      : 1;\n  uint8_t pp_od                    : 1;\n  uint8_t h_lactive                : 1;\n  uint8_t bdu                      : 1;\n  uint8_t boot                     : 1;\n} lsm6dsm_ctrl3_c_t;\n\n#define LSM6DSM_CTRL4_C                      0x13\ntypedef struct {\n  uint8_t not_used_01              : 1;\n  uint8_t lpf1_sel_g               : 1;\n  uint8_t i2c_disable              : 1;\n  uint8_t drdy_mask                : 1;\n  uint8_t den_drdy_int1            : 1;\n  uint8_t int2_on_int1             : 1;\n  uint8_t sleep                    : 1;\n  uint8_t den_xl_en                : 1;\n} lsm6dsm_ctrl4_c_t;\n\n#define LSM6DSM_CTRL5_C                      0x14\ntypedef struct {\n  uint8_t st_xl                    : 2;\n  uint8_t st_g                     : 2;\n  uint8_t den_lh                   : 1;\n  uint8_t rounding                 : 3;\n} lsm6dsm_ctrl5_c_t;\n\n#define LSM6DSM_CTRL6_C                      0x15\ntypedef struct {\n  uint8_t ftype                    : 2;\n  uint8_t not_used_01              : 1;\n  uint8_t usr_off_w                : 1;\n  uint8_t xl_hm_mode               : 1;\n  uint8_t den_mode                 : 3;  /* trig_en + lvl_en + lvl2_en */\n} lsm6dsm_ctrl6_c_t;\n\n#define LSM6DSM_CTRL7_G                      0x16\ntypedef struct {\n  uint8_t not_used_01              : 2;\n  uint8_t rounding_status          : 1;\n  uint8_t not_used_02              : 1;\n  uint8_t hpm_g                    : 2;\n  uint8_t hp_en_g                  : 1;\n  uint8_t g_hm_mode                : 1;\n} lsm6dsm_ctrl7_g_t;\n\n#define LSM6DSM_CTRL8_XL                     0x17\ntypedef struct {\n  uint8_t low_pass_on_6d           : 1;\n  uint8_t not_used_01              : 1;\n  uint8_t hp_slope_xl_en           : 1;\n  uint8_t input_composite          : 1;\n  uint8_t hp_ref_mode              : 1;\n  uint8_t hpcf_xl                  : 2;\n  uint8_t lpf2_xl_en               : 1;\n} lsm6dsm_ctrl8_xl_t;\n\n#define LSM6DSM_CTRL9_XL                     0x18\ntypedef struct {\n  uint8_t not_used_01              : 2;\n  uint8_t soft_en                  : 1;\n  uint8_t not_used_02              : 1;\n  uint8_t den_xl_g                 : 1;\n  uint8_t den_z                    : 1;\n  uint8_t den_y                    : 1;\n  uint8_t den_x                    : 1;\n} lsm6dsm_ctrl9_xl_t;\n\n#define LSM6DSM_CTRL10_C                     0x19\ntypedef struct {\n  uint8_t sign_motion_en           : 1;\n  uint8_t pedo_rst_step            : 1;\n  uint8_t func_en                  : 1;\n  uint8_t tilt_en                  : 1;\n  uint8_t pedo_en                  : 1;\n  uint8_t timer_en                 : 1;\n  uint8_t not_used_01              : 1;\n  uint8_t wrist_tilt_en            : 1;\n} lsm6dsm_ctrl10_c_t;\n\n#define LSM6DSM_MASTER_CONFIG                0x1A\ntypedef struct {\n  uint8_t master_on                : 1;\n  uint8_t iron_en                  : 1;\n  uint8_t pass_through_mode        : 1;\n  uint8_t pull_up_en               : 1;\n  uint8_t start_config             : 1;\n  uint8_t not_used_01              : 1;\n  uint8_t  data_valid_sel_fifo     : 1;\n  uint8_t drdy_on_int1             : 1;\n} lsm6dsm_master_config_t;\n\n#define LSM6DSM_WAKE_UP_SRC                  0x1B\ntypedef struct {\n  uint8_t z_wu                     : 1;\n  uint8_t y_wu                     : 1;\n  uint8_t x_wu                     : 1;\n  uint8_t wu_ia                    : 1;\n  uint8_t sleep_state_ia           : 1;\n  uint8_t ff_ia                    : 1;\n  uint8_t not_used_01              : 2;\n} lsm6dsm_wake_up_src_t;\n\n#define LSM6DSM_TAP_SRC                      0x1C\ntypedef struct {\n  uint8_t z_tap                    : 1;\n  uint8_t y_tap                    : 1;\n  uint8_t x_tap                    : 1;\n  uint8_t tap_sign                 : 1;\n  uint8_t double_tap               : 1;\n  uint8_t single_tap               : 1;\n  uint8_t tap_ia                   : 1;\n  uint8_t not_used_01              : 1;\n} lsm6dsm_tap_src_t;\n\n#define LSM6DSM_D6D_SRC                      0x1D\ntypedef struct {\n  uint8_t xl                       : 1;\n  uint8_t xh                       : 1;\n  uint8_t yl                       : 1;\n  uint8_t yh                       : 1;\n  uint8_t zl                       : 1;\n  uint8_t zh                       : 1;\n  uint8_t d6d_ia                   : 1;\n  uint8_t den_drdy                 : 1;\n} lsm6dsm_d6d_src_t;\n\n#define LSM6DSM_STATUS_REG                   0x1E\ntypedef struct {\n  uint8_t xlda                     : 1;\n  uint8_t gda                      : 1;\n  uint8_t tda                      : 1;\n  uint8_t not_used_01              : 5;\n} lsm6dsm_status_reg_t;\n\n#define LSM6DSM_STATUS_SPIAUX                0x1E\ntypedef struct {\n  uint8_t xlda                     : 1;\n  uint8_t gda                      : 1;\n  uint8_t gyro_settling            : 1;\n  uint8_t not_used_01              : 5;\n} lsm6dsm_status_spiaux_t;\n\n#define LSM6DSM_OUT_TEMP_L                   0x20\n#define LSM6DSM_OUT_TEMP_H                   0x21\n#define LSM6DSM_OUTX_L_G                     0x22\n#define LSM6DSM_OUTX_H_G                     0x23\n#define LSM6DSM_OUTY_L_G                     0x24\n#define LSM6DSM_OUTY_H_G                     0x25\n#define LSM6DSM_OUTZ_L_G                     0x26\n#define LSM6DSM_OUTZ_H_G                     0x27\n#define LSM6DSM_OUTX_L_XL                    0x28\n#define LSM6DSM_OUTX_H_XL                    0x29\n#define LSM6DSM_OUTY_L_XL                    0x2A\n#define LSM6DSM_OUTY_H_XL                    0x2B\n#define LSM6DSM_OUTZ_L_XL                    0x2C\n#define LSM6DSM_OUTZ_H_XL                    0x2D\n#define LSM6DSM_SENSORHUB1_REG               0x2E\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsm_sensorhub1_reg_t;\n\n#define LSM6DSM_SENSORHUB2_REG               0x2F\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsm_sensorhub2_reg_t;\n\n#define LSM6DSM_SENSORHUB3_REG               0x30\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsm_sensorhub3_reg_t;\n\n#define LSM6DSM_SENSORHUB4_REG               0x31\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsm_sensorhub4_reg_t;\n\n#define LSM6DSM_SENSORHUB5_REG               0x32\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsm_sensorhub5_reg_t;\n\n#define LSM6DSM_SENSORHUB6_REG               0x33\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsm_sensorhub6_reg_t;\n\n#define LSM6DSM_SENSORHUB7_REG               0x34\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsm_sensorhub7_reg_t;\n\n#define LSM6DSM_SENSORHUB8_REG               0x35\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsm_sensorhub8_reg_t;\n\n#define LSM6DSM_SENSORHUB9_REG               0x36\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsm_sensorhub9_reg_t;\n\n#define LSM6DSM_SENSORHUB10_REG              0x37\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsm_sensorhub10_reg_t;\n\n#define LSM6DSM_SENSORHUB11_REG              0x38\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsm_sensorhub11_reg_t;\n\n#define LSM6DSM_SENSORHUB12_REG              0x39\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsm_sensorhub12_reg_t;\n\n#define LSM6DSM_FIFO_STATUS1                 0x3A\ntypedef struct {\n  uint8_t diff_fifo                : 8;  /* + FIFO_STATUS2(diff_fifo) */\n} lsm6dsm_fifo_status1_t;\n\n#define LSM6DSM_FIFO_STATUS2                 0x3B\ntypedef struct {\n  uint8_t diff_fifo                : 3;  /* + FIFO_STATUS1(diff_fifo) */\n  uint8_t not_used_01              : 1;\n  uint8_t fifo_empty               : 1;\n  uint8_t fifo_full_smart          : 1;\n  uint8_t over_run                 : 1;\n  uint8_t waterm                   : 1;\n} lsm6dsm_fifo_status2_t;\n\n#define LSM6DSM_FIFO_STATUS3                 0x3C\ntypedef struct {\n  uint8_t fifo_pattern             : 8;  /* + FIFO_STATUS4(fifo_pattern) */\n} lsm6dsm_fifo_status3_t;\n\n#define LSM6DSM_FIFO_STATUS4                 0x3D\ntypedef struct {\n  uint8_t fifo_pattern             : 2;  /* + FIFO_STATUS3(fifo_pattern) */\n  uint8_t not_used_01              : 6;\n} lsm6dsm_fifo_status4_t;\n\n#define LSM6DSM_FIFO_DATA_OUT_L              0x3E\n#define LSM6DSM_FIFO_DATA_OUT_H              0x3F\n#define LSM6DSM_TIMESTAMP0_REG               0x40\n#define LSM6DSM_TIMESTAMP1_REG               0x41\n#define LSM6DSM_TIMESTAMP2_REG               0x42\n#define LSM6DSM_STEP_TIMESTAMP_L             0x49\n#define LSM6DSM_STEP_TIMESTAMP_H             0x4A\n#define LSM6DSM_STEP_COUNTER_L               0x4B\n#define LSM6DSM_STEP_COUNTER_H               0x4C\n\n#define LSM6DSM_SENSORHUB13_REG              0x4D\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsm_sensorhub13_reg_t;\n\n#define LSM6DSM_SENSORHUB14_REG              0x4E\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsm_sensorhub14_reg_t;\n\n#define LSM6DSM_SENSORHUB15_REG              0x4F\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsm_sensorhub15_reg_t;\n\n#define LSM6DSM_SENSORHUB16_REG              0x50\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsm_sensorhub16_reg_t;\n\n#define LSM6DSM_SENSORHUB17_REG              0x51\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsm_sensorhub17_reg_t;\n\n#define LSM6DSM_SENSORHUB18_REG              0x52\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsm_sensorhub18_reg_t;\n\n#define LSM6DSM_FUNC_SRC1                    0x53\ntypedef struct {\n  uint8_t sensorhub_end_op         : 1;\n  uint8_t si_end_op                : 1;\n  uint8_t hi_fail                  : 1;\n  uint8_t step_overflow            : 1;\n  uint8_t step_detected            : 1;\n  uint8_t tilt_ia                  : 1;\n  uint8_t sign_motion_ia           : 1;\n  uint8_t  step_count_delta_ia     : 1;\n} lsm6dsm_func_src1_t;\n\n#define LSM6DSM_FUNC_SRC2                    0x54\ntypedef struct {\n  uint8_t wrist_tilt_ia            : 1;\n  uint8_t not_used_01              : 2;\n  uint8_t slave0_nack              : 1;\n  uint8_t slave1_nack              : 1;\n  uint8_t slave2_nack              : 1;\n  uint8_t slave3_nack              : 1;\n  uint8_t not_used_02              : 1;\n} lsm6dsm_func_src2_t;\n\n#define LSM6DSM_WRIST_TILT_IA                0x55\ntypedef struct {\n  uint8_t not_used_01              : 2;\n  uint8_t wrist_tilt_ia_zneg       : 1;\n  uint8_t wrist_tilt_ia_zpos       : 1;\n  uint8_t wrist_tilt_ia_yneg       : 1;\n  uint8_t wrist_tilt_ia_ypos       : 1;\n  uint8_t wrist_tilt_ia_xneg       : 1;\n  uint8_t wrist_tilt_ia_xpos       : 1;\n} lsm6dsm_wrist_tilt_ia_t;\n\n#define LSM6DSM_TAP_CFG                      0x58\ntypedef struct {\n  uint8_t lir                      : 1;\n  uint8_t tap_z_en                 : 1;\n  uint8_t tap_y_en                 : 1;\n  uint8_t tap_x_en                 : 1;\n  uint8_t slope_fds                : 1;\n  uint8_t inact_en                 : 2;\n  uint8_t interrupts_enable        : 1;\n} lsm6dsm_tap_cfg_t;\n\n#define LSM6DSM_TAP_THS_6D                   0x59\ntypedef struct {\n  uint8_t tap_ths                  : 5;\n  uint8_t sixd_ths                 : 2;\n  uint8_t d4d_en                   : 1;\n} lsm6dsm_tap_ths_6d_t;\n\n#define LSM6DSM_INT_DUR2                     0x5A\ntypedef struct {\n  uint8_t shock                    : 2;\n  uint8_t quiet                    : 2;\n  uint8_t dur                      : 4;\n} lsm6dsm_int_dur2_t;\n\n#define LSM6DSM_WAKE_UP_THS                  0x5B\ntypedef struct {\n  uint8_t wk_ths                   : 6;\n  uint8_t not_used_01              : 1;\n  uint8_t single_double_tap        : 1;\n} lsm6dsm_wake_up_ths_t;\n\n#define LSM6DSM_WAKE_UP_DUR                  0x5C\ntypedef struct {\n  uint8_t sleep_dur                : 4;\n  uint8_t timer_hr                 : 1;\n  uint8_t wake_dur                 : 2;\n  uint8_t ff_dur                   : 1;\n} lsm6dsm_wake_up_dur_t;\n\n#define LSM6DSM_FREE_FALL                    0x5D\ntypedef struct {\n  uint8_t ff_ths                   : 3;\n  uint8_t ff_dur                   : 5;\n} lsm6dsm_free_fall_t;\n\n#define LSM6DSM_MD1_CFG                      0x5E\ntypedef struct {\n  uint8_t int1_timer               : 1;\n  uint8_t int1_tilt                : 1;\n  uint8_t int1_6d                  : 1;\n  uint8_t int1_double_tap          : 1;\n  uint8_t int1_ff                  : 1;\n  uint8_t int1_wu                  : 1;\n  uint8_t int1_single_tap          : 1;\n  uint8_t int1_inact_state         : 1;\n} lsm6dsm_md1_cfg_t;\n\n#define LSM6DSM_MD2_CFG                      0x5F\ntypedef struct {\n  uint8_t int2_iron                : 1;\n  uint8_t int2_tilt                : 1;\n  uint8_t int2_6d                  : 1;\n  uint8_t int2_double_tap          : 1;\n  uint8_t int2_ff                  : 1;\n  uint8_t int2_wu                  : 1;\n  uint8_t int2_single_tap          : 1;\n  uint8_t int2_inact_state         : 1;\n} lsm6dsm_md2_cfg_t;\n\n#define LSM6DSM_MASTER_CMD_CODE              0x60\ntypedef struct {\n  uint8_t master_cmd_code          : 8;\n} lsm6dsm_master_cmd_code_t;\n\n#define LSM6DSM_SENS_SYNC_SPI_ERROR_CODE     0x61\ntypedef struct {\n  uint8_t error_code               : 8;\n} lsm6dsm_sens_sync_spi_error_code_t;\n\n#define LSM6DSM_OUT_MAG_RAW_X_L              0x66\n#define LSM6DSM_OUT_MAG_RAW_X_H              0x67\n#define LSM6DSM_OUT_MAG_RAW_Y_L              0x68\n#define LSM6DSM_OUT_MAG_RAW_Y_H              0x69\n#define LSM6DSM_OUT_MAG_RAW_Z_L              0x6A\n#define LSM6DSM_OUT_MAG_RAW_Z_H              0x6B\n#define LSM6DSM_INT_OIS  0x6F\ntypedef struct {\n  uint8_t not_used_01              : 6;\n  uint8_t lvl2_ois                 : 1;\n  uint8_t int2_drdy_ois            : 1;\n} lsm6dsm_int_ois_t;\n\n#define LSM6DSM_CTRL1_OIS                    0x70\ntypedef struct {\n  uint8_t ois_en_spi2              : 1;\n  uint8_t fs_g_ois                 : 3;  /* fs_g_ois + fs_125_ois */\n  uint8_t mode4_en                 : 1;\n  uint8_t sim_ois                  : 1;\n  uint8_t lvl1_ois                 : 1;\n  uint8_t ble_ois                  : 1;\n} lsm6dsm_ctrl1_ois_t;\n\n#define LSM6DSM_CTRL2_OIS                    0x71\ntypedef struct {\n  uint8_t hp_en_ois                : 1;\n  uint8_t ftype_ois                : 2;\n  uint8_t not_used_01              : 1;\n  uint8_t hpm_ois                  : 2;\n  uint8_t not_used_02              : 2;\n} lsm6dsm_ctrl2_ois_t;\n\n#define LSM6DSM_CTRL3_OIS                    0x72\ntypedef struct {\n  uint8_t st_ois_clampdis          : 1;\n  uint8_t st_ois                   : 2;\n  uint8_t filter_xl_conf_ois       : 2;\n  uint8_t fs_xl_ois                : 2;\n  uint8_t den_lh_ois               : 1;\n} lsm6dsm_ctrl3_ois_t;\n\n#define LSM6DSM_X_OFS_USR                    0x73\n#define LSM6DSM_Y_OFS_USR                    0x74\n#define LSM6DSM_Z_OFS_USR                    0x75\n#define LSM6DSM_SLV0_ADD                     0x02\ntypedef struct {\n  uint8_t rw_0                     : 1;\n  uint8_t slave0_add               : 7;\n} lsm6dsm_slv0_add_t;\n\n#define LSM6DSM_SLV0_SUBADD                  0x03\ntypedef struct {\n  uint8_t slave0_reg               : 8;\n} lsm6dsm_slv0_subadd_t;\n\n#define LSM6DSM_SLAVE0_CONFIG                0x04\ntypedef struct {\n  uint8_t slave0_numop             : 3;\n  uint8_t src_mode                 : 1;\n  uint8_t aux_sens_on              : 2;\n  uint8_t slave0_rate              : 2;\n} lsm6dsm_slave0_config_t;\n\n#define LSM6DSM_SLV1_ADD                     0x05\ntypedef struct {\n  uint8_t r_1                      : 1;\n  uint8_t slave1_add               : 7;\n} lsm6dsm_slv1_add_t;\n\n#define LSM6DSM_SLV1_SUBADD                  0x06\ntypedef struct {\n  uint8_t slave1_reg               : 8;\n} lsm6dsm_slv1_subadd_t;\n\n#define LSM6DSM_SLAVE1_CONFIG                0x07\ntypedef struct {\n  uint8_t slave1_numop             : 3;\n  uint8_t not_used_01              : 2;\n  uint8_t write_once               : 1;\n  uint8_t slave1_rate              : 2;\n} lsm6dsm_slave1_config_t;\n\n#define LSM6DSM_SLV2_ADD                     0x08\ntypedef struct {\n  uint8_t r_2                      : 1;\n  uint8_t slave2_add               : 7;\n} lsm6dsm_slv2_add_t;\n\n#define LSM6DSM_SLV2_SUBADD                  0x09\ntypedef struct {\n  uint8_t slave2_reg               : 8;\n} lsm6dsm_slv2_subadd_t;\n\n#define LSM6DSM_SLAVE2_CONFIG                0x0A\ntypedef struct {\n  uint8_t slave2_numop             : 3;\n  uint8_t not_used_01              : 3;\n  uint8_t slave2_rate              : 2;\n} lsm6dsm_slave2_config_t;\n\n#define LSM6DSM_SLV3_ADD                     0x0B\ntypedef struct {\n  uint8_t r_3                      : 1;\n  uint8_t slave3_add               : 7;\n} lsm6dsm_slv3_add_t;\n\n#define LSM6DSM_SLV3_SUBADD                  0x0C\ntypedef struct {\n  uint8_t slave3_reg               : 8;\n} lsm6dsm_slv3_subadd_t;\n\n#define LSM6DSM_SLAVE3_CONFIG                0x0D\ntypedef struct {\n  uint8_t slave3_numop             : 3;\n  uint8_t not_used_01              : 3;\n  uint8_t slave3_rate              : 2;\n} lsm6dsm_slave3_config_t;\n\n#define LSM6DSM_DATAWRITE_SRC_MODE_SUB_SLV0  0x0E\ntypedef struct {\n  uint8_t slave_dataw              : 8;\n} lsm6dsm_datawrite_src_mode_sub_slv0_t;\n\n#define LSM6DSM_CONFIG_PEDO_THS_MIN          0x0F\ntypedef struct {\n  uint8_t ths_min                  : 5;\n  uint8_t not_used_01              : 2;\n  uint8_t pedo_fs                  : 1;\n} lsm6dsm_config_pedo_ths_min_t;\n\n#define LSM6DSM_SM_THS                       0x13\n#define LSM6DSM_PEDO_DEB_REG                 0x14\ntypedef struct {\n  uint8_t deb_step      : 3;\n  uint8_t deb_time      : 5;\n} lsm6dsm_pedo_deb_reg_t;\n\n#define LSM6DSM_STEP_COUNT_DELTA             0x15\n#define LSM6DSM_MAG_SI_XX                    0x24\n#define LSM6DSM_MAG_SI_XY                    0x25\n#define LSM6DSM_MAG_SI_XZ                    0x26\n#define LSM6DSM_MAG_SI_YX                    0x27\n#define LSM6DSM_MAG_SI_YY                    0x28\n#define LSM6DSM_MAG_SI_YZ                    0x29\n#define LSM6DSM_MAG_SI_ZX                    0x2A\n#define LSM6DSM_MAG_SI_ZY                    0x2B\n#define LSM6DSM_MAG_SI_ZZ                    0x2C\n#define LSM6DSM_MAG_OFFX_L                   0x2D\n#define LSM6DSM_MAG_OFFX_H                   0x2E\n#define LSM6DSM_MAG_OFFY_L                   0x2F\n#define LSM6DSM_MAG_OFFY_H                   0x30\n#define LSM6DSM_MAG_OFFZ_L                   0x31\n#define LSM6DSM_MAG_OFFZ_H                   0x32\n#define LSM6DSM_A_WRIST_TILT_LAT             0x50\n#define LSM6DSM_A_WRIST_TILT_THS             0x54\n#define LSM6DSM_A_WRIST_TILT_MASK            0x59\ntypedef struct {\n  uint8_t not_used_01              : 2;\n  uint8_t  wrist_tilt_mask_zneg    : 1;\n  uint8_t  wrist_tilt_mask_zpos    : 1;\n  uint8_t  wrist_tilt_mask_yneg    : 1;\n  uint8_t  wrist_tilt_mask_ypos    : 1;\n  uint8_t  wrist_tilt_mask_xneg    : 1;\n  uint8_t  wrist_tilt_mask_xpos    : 1;\n} lsm6dsm_a_wrist_tilt_mask_t;\n\ntypedef union{\n  lsm6dsm_func_cfg_access_t                  func_cfg_access;\n  lsm6dsm_sensor_sync_time_frame_t           sensor_sync_time_frame;\n  lsm6dsm_sensor_sync_res_ratio_t            sensor_sync_res_ratio;\n  lsm6dsm_fifo_ctrl1_t                       fifo_ctrl1;\n  lsm6dsm_fifo_ctrl2_t                       fifo_ctrl2;\n  lsm6dsm_fifo_ctrl3_t                       fifo_ctrl3;\n  lsm6dsm_fifo_ctrl4_t                       fifo_ctrl4;\n  lsm6dsm_fifo_ctrl5_t                       fifo_ctrl5;\n  lsm6dsm_drdy_pulse_cfg_t                   drdy_pulse_cfg;\n  lsm6dsm_int1_ctrl_t                        int1_ctrl;\n  lsm6dsm_int2_ctrl_t                        int2_ctrl;\n  lsm6dsm_ctrl1_xl_t                         ctrl1_xl;\n  lsm6dsm_ctrl2_g_t                          ctrl2_g;\n  lsm6dsm_ctrl3_c_t                          ctrl3_c;\n  lsm6dsm_ctrl4_c_t                          ctrl4_c;\n  lsm6dsm_ctrl5_c_t                          ctrl5_c;\n  lsm6dsm_ctrl6_c_t                          ctrl6_c;\n  lsm6dsm_ctrl7_g_t                          ctrl7_g;\n  lsm6dsm_ctrl8_xl_t                         ctrl8_xl;\n  lsm6dsm_ctrl9_xl_t                         ctrl9_xl;\n  lsm6dsm_ctrl10_c_t                         ctrl10_c;\n  lsm6dsm_master_config_t                    master_config;\n  lsm6dsm_wake_up_src_t                      wake_up_src;\n  lsm6dsm_tap_src_t                          tap_src;\n  lsm6dsm_d6d_src_t                          d6d_src;\n  lsm6dsm_status_reg_t                       status_reg;\n  lsm6dsm_status_spiaux_t                    status_spiaux;\n  lsm6dsm_sensorhub1_reg_t                   sensorhub1_reg;\n  lsm6dsm_sensorhub2_reg_t                   sensorhub2_reg;\n  lsm6dsm_sensorhub3_reg_t                   sensorhub3_reg;\n  lsm6dsm_sensorhub4_reg_t                   sensorhub4_reg;\n  lsm6dsm_sensorhub5_reg_t                   sensorhub5_reg;\n  lsm6dsm_sensorhub6_reg_t                   sensorhub6_reg;\n  lsm6dsm_sensorhub7_reg_t                   sensorhub7_reg;\n  lsm6dsm_sensorhub8_reg_t                   sensorhub8_reg;\n  lsm6dsm_sensorhub9_reg_t                   sensorhub9_reg;\n  lsm6dsm_sensorhub10_reg_t                  sensorhub10_reg;\n  lsm6dsm_sensorhub11_reg_t                  sensorhub11_reg;\n  lsm6dsm_sensorhub12_reg_t                  sensorhub12_reg;\n  lsm6dsm_fifo_status1_t                     fifo_status1;\n  lsm6dsm_fifo_status2_t                     fifo_status2;\n  lsm6dsm_fifo_status3_t                     fifo_status3;\n  lsm6dsm_fifo_status4_t                     fifo_status4;\n  lsm6dsm_sensorhub13_reg_t                  sensorhub13_reg;\n  lsm6dsm_sensorhub14_reg_t                  sensorhub14_reg;\n  lsm6dsm_sensorhub15_reg_t                  sensorhub15_reg;\n  lsm6dsm_sensorhub16_reg_t                  sensorhub16_reg;\n  lsm6dsm_sensorhub17_reg_t                  sensorhub17_reg;\n  lsm6dsm_sensorhub18_reg_t                  sensorhub18_reg;\n  lsm6dsm_func_src1_t                        func_src1;\n  lsm6dsm_func_src2_t                        func_src2;\n  lsm6dsm_wrist_tilt_ia_t                    wrist_tilt_ia;\n  lsm6dsm_tap_cfg_t                          tap_cfg;\n  lsm6dsm_tap_ths_6d_t                       tap_ths_6d;\n  lsm6dsm_int_dur2_t                         int_dur2;\n  lsm6dsm_wake_up_ths_t                      wake_up_ths;\n  lsm6dsm_wake_up_dur_t                      wake_up_dur;\n  lsm6dsm_free_fall_t                        free_fall;\n  lsm6dsm_md1_cfg_t                          md1_cfg;\n  lsm6dsm_md2_cfg_t                          md2_cfg;\n  lsm6dsm_master_cmd_code_t                  master_cmd_code;\n  lsm6dsm_sens_sync_spi_error_code_t         sens_sync_spi_error_code;\n  lsm6dsm_int_ois_t                          int_ois;\n  lsm6dsm_ctrl1_ois_t                        ctrl1_ois;\n  lsm6dsm_ctrl2_ois_t                        ctrl2_ois;\n  lsm6dsm_ctrl3_ois_t                        ctrl3_ois;\n  lsm6dsm_slv0_add_t                         slv0_add;\n  lsm6dsm_slv0_subadd_t                      slv0_subadd;\n  lsm6dsm_slave0_config_t                    slave0_config;\n  lsm6dsm_slv1_add_t                         slv1_add;\n  lsm6dsm_slv1_subadd_t                      slv1_subadd;\n  lsm6dsm_slave1_config_t                    slave1_config;\n  lsm6dsm_slv2_add_t                         slv2_add;\n  lsm6dsm_slv2_subadd_t                      slv2_subadd;\n  lsm6dsm_slave2_config_t                    slave2_config;\n  lsm6dsm_slv3_add_t                         slv3_add;\n  lsm6dsm_slv3_subadd_t                      slv3_subadd;\n  lsm6dsm_slave3_config_t                    slave3_config;\n  lsm6dsm_datawrite_src_mode_sub_slv0_t      datawrite_src_mode_sub_slv0;\n  lsm6dsm_config_pedo_ths_min_t              config_pedo_ths_min;\n  lsm6dsm_pedo_deb_reg_t                     pedo_deb_reg;\n  lsm6dsm_a_wrist_tilt_mask_t                a_wrist_tilt_mask;\n  bitwise_t                                  bitwise;\n  uint8_t                                    byte;\n} lsm6dsm_reg_t;\nint32_t lsm6dsm_read_reg(lsm6dsm_ctx_t *ctx, uint8_t reg, uint8_t* data,\n                         uint16_t len);\nint32_t lsm6dsm_write_reg(lsm6dsm_ctx_t *ctx, uint8_t reg, uint8_t* data,\n                          uint16_t len);\n\ntypedef enum {\n  LSM6DSM_2g    = 0,\n  LSM6DSM_16g   = 1,\n  LSM6DSM_4g    = 2,\n  LSM6DSM_8g    = 3,\n} lsm6dsm_fs_xl_t;\nint32_t lsm6dsm_xl_full_scale_set(lsm6dsm_ctx_t *ctx, lsm6dsm_fs_xl_t val);\nint32_t lsm6dsm_xl_full_scale_get(lsm6dsm_ctx_t *ctx, lsm6dsm_fs_xl_t *val);\n\ntypedef enum {\n  LSM6DSM_XL_ODR_OFF      =  0,\n  LSM6DSM_XL_ODR_12Hz5    =  1,\n  LSM6DSM_XL_ODR_26Hz     =  2,\n  LSM6DSM_XL_ODR_52Hz     =  3,\n  LSM6DSM_XL_ODR_104Hz    =  4,\n  LSM6DSM_XL_ODR_208Hz    =  5,\n  LSM6DSM_XL_ODR_416Hz    =  6,\n  LSM6DSM_XL_ODR_833Hz    =  7,\n  LSM6DSM_XL_ODR_1k66Hz   =  8,\n  LSM6DSM_XL_ODR_3k33Hz   =  9,\n  LSM6DSM_XL_ODR_6k66Hz   = 10,\n  LSM6DSM_XL_ODR_1Hz6     = 11,\n} lsm6dsm_odr_xl_t;\nint32_t lsm6dsm_xl_data_rate_set(lsm6dsm_ctx_t *ctx, lsm6dsm_odr_xl_t val);\nint32_t lsm6dsm_xl_data_rate_get(lsm6dsm_ctx_t *ctx, lsm6dsm_odr_xl_t *val);\n\ntypedef enum {\n  LSM6DSM_250dps   = 0,\n  LSM6DSM_125dps   = 1,\n  LSM6DSM_500dps   = 2,\n  LSM6DSM_1000dps  = 4,\n  LSM6DSM_2000dps  = 6,\n} lsm6dsm_fs_g_t;\nint32_t lsm6dsm_gy_full_scale_set(lsm6dsm_ctx_t *ctx, lsm6dsm_fs_g_t val);\nint32_t lsm6dsm_gy_full_scale_get(lsm6dsm_ctx_t *ctx, lsm6dsm_fs_g_t *val);\n\ntypedef enum {\n  LSM6DSM_GY_ODR_OFF    =  0,\n  LSM6DSM_GY_ODR_12Hz5  =  1,\n  LSM6DSM_GY_ODR_26Hz   =  2,\n  LSM6DSM_GY_ODR_52Hz   =  3,\n  LSM6DSM_GY_ODR_104Hz  =  4,\n  LSM6DSM_GY_ODR_208Hz  =  5,\n  LSM6DSM_GY_ODR_416Hz  =  6,\n  LSM6DSM_GY_ODR_833Hz  =  7,\n  LSM6DSM_GY_ODR_1k66Hz =  8,\n  LSM6DSM_GY_ODR_3k33Hz =  9,\n  LSM6DSM_GY_ODR_6k66Hz = 10,\n} lsm6dsm_odr_g_t;\nint32_t lsm6dsm_gy_data_rate_set(lsm6dsm_ctx_t *ctx, lsm6dsm_odr_g_t val);\nint32_t lsm6dsm_gy_data_rate_get(lsm6dsm_ctx_t *ctx, lsm6dsm_odr_g_t *val);\n\nint32_t lsm6dsm_block_data_update_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_block_data_update_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSM_LSb_1mg  = 0,\n  LSM6DSM_LSb_16mg = 1,\n} lsm6dsm_usr_off_w_t;\nint32_t lsm6dsm_xl_offset_weight_set(lsm6dsm_ctx_t *ctx,\n                                     lsm6dsm_usr_off_w_t val);\nint32_t lsm6dsm_xl_offset_weight_get(lsm6dsm_ctx_t *ctx,\n                                     lsm6dsm_usr_off_w_t *val);\n\ntypedef enum {\n  LSM6DSM_XL_HIGH_PERFORMANCE  = 0,\n  LSM6DSM_XL_NORMAL            = 1,\n} lsm6dsm_xl_hm_mode_t;\nint32_t lsm6dsm_xl_power_mode_set(lsm6dsm_ctx_t *ctx,\n                                  lsm6dsm_xl_hm_mode_t val);\nint32_t lsm6dsm_xl_power_mode_get(lsm6dsm_ctx_t *ctx,\n                                  lsm6dsm_xl_hm_mode_t *val);\n\ntypedef enum {\n  LSM6DSM_STAT_RND_DISABLE  = 0,\n  LSM6DSM_STAT_RND_ENABLE   = 1,\n} lsm6dsm_rounding_status_t;\nint32_t lsm6dsm_rounding_on_status_set(lsm6dsm_ctx_t *ctx,\n                                       lsm6dsm_rounding_status_t val);\nint32_t lsm6dsm_rounding_on_status_get(lsm6dsm_ctx_t *ctx,\n                                       lsm6dsm_rounding_status_t *val);\n\ntypedef enum {\n  LSM6DSM_GY_HIGH_PERFORMANCE  = 0,\n  LSM6DSM_GY_NORMAL            = 1,\n} lsm6dsm_g_hm_mode_t;\nint32_t lsm6dsm_gy_power_mode_set(lsm6dsm_ctx_t *ctx,\n                                  lsm6dsm_g_hm_mode_t val);\nint32_t lsm6dsm_gy_power_mode_get(lsm6dsm_ctx_t *ctx,\n                                  lsm6dsm_g_hm_mode_t *val);\n\ntypedef union {\n  struct {\n  lsm6dsm_wake_up_src_t        wake_up_src;\n  lsm6dsm_tap_src_t            tap_src;\n  lsm6dsm_d6d_src_t            d6d_src;\n  lsm6dsm_status_reg_t         status_reg;\n  lsm6dsm_func_src1_t          func_src1;\n  lsm6dsm_func_src2_t          func_src2;\n  lsm6dsm_wrist_tilt_ia_t      wrist_tilt_ia;\n  lsm6dsm_a_wrist_tilt_mask_t  a_wrist_tilt_mask;\n  } reg;\n  uint8_t byte[8];\n} lsm6dsm_all_sources_t;\nint32_t lsm6dsm_all_sources_get(lsm6dsm_ctx_t *ctx,\n                                lsm6dsm_all_sources_t *val);\n\nint32_t lsm6dsm_status_reg_get(lsm6dsm_ctx_t *ctx, lsm6dsm_status_reg_t *val);\n\nint32_t lsm6dsm_xl_flag_data_ready_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsm_gy_flag_data_ready_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsm_temp_flag_data_ready_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsm_xl_usr_offset_set(lsm6dsm_ctx_t *ctx, uint8_t *buff);\nint32_t lsm6dsm_xl_usr_offset_get(lsm6dsm_ctx_t *ctx, uint8_t *buff);\nint32_t lsm6dsm_timestamp_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_timestamp_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSM_LSB_6ms4 = 0,\n  LSM6DSM_LSB_25us = 1,\n} lsm6dsm_timer_hr_t;\nint32_t lsm6dsm_timestamp_res_set(lsm6dsm_ctx_t *ctx, lsm6dsm_timer_hr_t val);\nint32_t lsm6dsm_timestamp_res_get(lsm6dsm_ctx_t *ctx, lsm6dsm_timer_hr_t *val);\n\ntypedef enum {\n  LSM6DSM_ROUND_DISABLE            = 0,\n  LSM6DSM_ROUND_XL                 = 1,\n  LSM6DSM_ROUND_GY                 = 2,\n  LSM6DSM_ROUND_GY_XL              = 3,\n  LSM6DSM_ROUND_SH1_TO_SH6         = 4,\n  LSM6DSM_ROUND_XL_SH1_TO_SH6      = 5,\n  LSM6DSM_ROUND_GY_XL_SH1_TO_SH12  = 6,\n  LSM6DSM_ROUND_GY_XL_SH1_TO_SH6   = 7,\n} lsm6dsm_rounding_t;\nint32_t lsm6dsm_rounding_mode_set(lsm6dsm_ctx_t *ctx, lsm6dsm_rounding_t val);\nint32_t lsm6dsm_rounding_mode_get(lsm6dsm_ctx_t *ctx, lsm6dsm_rounding_t *val);\n\nint32_t lsm6dsm_temperature_raw_get(lsm6dsm_ctx_t *ctx, uint8_t *buff);\nint32_t lsm6dsm_angular_rate_raw_get(lsm6dsm_ctx_t *ctx, uint8_t *buff);\nint32_t lsm6dsm_acceleration_raw_get(lsm6dsm_ctx_t *ctx, uint8_t *buff);\nint32_t lsm6dsm_mag_calibrated_raw_get(lsm6dsm_ctx_t *ctx, uint8_t *buff);\nint32_t lsm6dsm_fifo_raw_data_get(lsm6dsm_ctx_t *ctx, uint8_t *buffer, uint8_t len);\n\ntypedef enum {\n  LSM6DSM_USER_BANK   = 0,\n  LSM6DSM_BANK_A      = 4,\n  LSM6DSM_BANK_B      = 5,\n} lsm6dsm_func_cfg_en_t;\nint32_t lsm6dsm_mem_bank_set(lsm6dsm_ctx_t *ctx, lsm6dsm_func_cfg_en_t val);\nint32_t lsm6dsm_mem_bank_get(lsm6dsm_ctx_t *ctx, lsm6dsm_func_cfg_en_t *val);\n\ntypedef enum {\n  LSM6DSM_DRDY_LATCHED    = 0,\n  LSM6DSM_DRDY_PULSED     = 1,\n} lsm6dsm_drdy_pulsed_t;\nint32_t lsm6dsm_data_ready_mode_set(lsm6dsm_ctx_t *ctx,\n                                    lsm6dsm_drdy_pulsed_t val);\nint32_t lsm6dsm_data_ready_mode_get(lsm6dsm_ctx_t *ctx,\n                                    lsm6dsm_drdy_pulsed_t *val);\n\nint32_t lsm6dsm_device_id_get(lsm6dsm_ctx_t *ctx, uint8_t *buff);\nint32_t lsm6dsm_reset_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_reset_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSM_LSB_AT_LOW_ADD  = 0,\n  LSM6DSM_MSB_AT_LOW_ADD  = 1,\n} lsm6dsm_ble_t;\nint32_t lsm6dsm_data_format_set(lsm6dsm_ctx_t *ctx, lsm6dsm_ble_t val);\nint32_t lsm6dsm_data_format_get(lsm6dsm_ctx_t *ctx, lsm6dsm_ble_t *val);\n\nint32_t lsm6dsm_auto_increment_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_auto_increment_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsm_boot_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_boot_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSM_XL_ST_DISABLE    = 0,\n  LSM6DSM_XL_ST_POSITIVE   = 1,\n  LSM6DSM_XL_ST_NEGATIVE   = 2,\n} lsm6dsm_st_xl_t;\nint32_t lsm6dsm_xl_self_test_set(lsm6dsm_ctx_t *ctx, lsm6dsm_st_xl_t val);\nint32_t lsm6dsm_xl_self_test_get(lsm6dsm_ctx_t *ctx, lsm6dsm_st_xl_t *val);\n\ntypedef enum {\n  LSM6DSM_GY_ST_DISABLE    = 0,\n  LSM6DSM_GY_ST_POSITIVE   = 1,\n  LSM6DSM_GY_ST_NEGATIVE   = 3,\n} lsm6dsm_st_g_t;\nint32_t lsm6dsm_gy_self_test_set(lsm6dsm_ctx_t *ctx, lsm6dsm_st_g_t val);\nint32_t lsm6dsm_gy_self_test_get(lsm6dsm_ctx_t *ctx, lsm6dsm_st_g_t *val);\n\nint32_t lsm6dsm_filter_settling_mask_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_filter_settling_mask_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSM_USE_SLOPE = 0,\n  LSM6DSM_USE_HPF   = 1,\n} lsm6dsm_slope_fds_t;\nint32_t lsm6dsm_xl_hp_path_internal_set(lsm6dsm_ctx_t *ctx,\n                                        lsm6dsm_slope_fds_t val);\nint32_t lsm6dsm_xl_hp_path_internal_get(lsm6dsm_ctx_t *ctx,\n                                        lsm6dsm_slope_fds_t *val);\n\ntypedef enum {\n  LSM6DSM_XL_ANA_BW_1k5Hz = 0,\n  LSM6DSM_XL_ANA_BW_400Hz = 1,\n} lsm6dsm_bw0_xl_t;\nint32_t lsm6dsm_xl_filter_analog_set(lsm6dsm_ctx_t *ctx,\n                                     lsm6dsm_bw0_xl_t val);\nint32_t lsm6dsm_xl_filter_analog_get(lsm6dsm_ctx_t *ctx,\n                                     lsm6dsm_bw0_xl_t *val);\n\ntypedef enum {\n  LSM6DSM_XL_LP1_ODR_DIV_2 = 0,\n  LSM6DSM_XL_LP1_ODR_DIV_4 = 1,\n  LSM6DSM_XL_LP1_NA        = 2,  /* ERROR CODE */\n} lsm6dsm_lpf1_bw_sel_t;\nint32_t lsm6dsm_xl_lp1_bandwidth_set(lsm6dsm_ctx_t *ctx,\n                                     lsm6dsm_lpf1_bw_sel_t val);\nint32_t lsm6dsm_xl_lp1_bandwidth_get(lsm6dsm_ctx_t *ctx,\n                                     lsm6dsm_lpf1_bw_sel_t *val);\n\ntypedef enum {\n  LSM6DSM_XL_LOW_LAT_LP_ODR_DIV_50     = 0x00,\n  LSM6DSM_XL_LOW_LAT_LP_ODR_DIV_100    = 0x01,\n  LSM6DSM_XL_LOW_LAT_LP_ODR_DIV_9      = 0x02,\n  LSM6DSM_XL_LOW_LAT_LP_ODR_DIV_400    = 0x03,\n  LSM6DSM_XL_LOW_NOISE_LP_ODR_DIV_50   = 0x10,\n  LSM6DSM_XL_LOW_NOISE_LP_ODR_DIV_100  = 0x11,\n  LSM6DSM_XL_LOW_NOISE_LP_ODR_DIV_9    = 0x12,\n  LSM6DSM_XL_LOW_NOISE_LP_ODR_DIV_400  = 0x13,\n  LSM6DSM_XL_LP_NA                     = 0x20, /* ERROR CODE */\n} lsm6dsm_input_composite_t;\nint32_t lsm6dsm_xl_lp2_bandwidth_set(lsm6dsm_ctx_t *ctx,\n                                     lsm6dsm_input_composite_t val);\nint32_t lsm6dsm_xl_lp2_bandwidth_get(lsm6dsm_ctx_t *ctx,\n                                     lsm6dsm_input_composite_t *val);\n\nint32_t lsm6dsm_xl_reference_mode_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_xl_reference_mode_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSM_XL_HP_ODR_DIV_4      = 0x00, /* Slope filter */\n  LSM6DSM_XL_HP_ODR_DIV_100    = 0x01,\n  LSM6DSM_XL_HP_ODR_DIV_9      = 0x02,\n  LSM6DSM_XL_HP_ODR_DIV_400    = 0x03,\n  LSM6DSM_XL_HP_NA             = 0x10, /* ERROR CODE */\n} lsm6dsm_hpcf_xl_t;\nint32_t lsm6dsm_xl_hp_bandwidth_set(lsm6dsm_ctx_t *ctx,\n                                    lsm6dsm_hpcf_xl_t val);\nint32_t lsm6dsm_xl_hp_bandwidth_get(lsm6dsm_ctx_t *ctx,\n                                    lsm6dsm_hpcf_xl_t *val);\n\ntypedef enum {\n  LSM6DSM_XL_UI_LP1_ODR_DIV_2 = 0,\n  LSM6DSM_XL_UI_LP1_ODR_DIV_4 = 1,\n  LSM6DSM_XL_UI_LP1_NA        = 2,  /* ERROR CODE */\n} lsm6dsm_ui_lpf1_bw_sel_t;\nint32_t lsm6dsm_xl_ui_lp1_bandwidth_set(lsm6dsm_ctx_t *ctx,\n                                        lsm6dsm_ui_lpf1_bw_sel_t val);\nint32_t lsm6dsm_xl_ui_lp1_bandwidth_get(lsm6dsm_ctx_t *ctx,\n                                        lsm6dsm_ui_lpf1_bw_sel_t *val);\n\nint32_t lsm6dsm_xl_ui_slope_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_xl_ui_slope_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSM_AUX_LP_LIGHT          = 2,\n  LSM6DSM_AUX_LP_NORMAL         = 3,\n  LSM6DSM_AUX_LP_STRONG         = 0,\n  LSM6DSM_AUX_LP_AGGRESSIVE     = 1,\n} lsm6dsm_filter_xl_conf_ois_t;\nint32_t lsm6dsm_xl_aux_lp_bandwidth_set(lsm6dsm_ctx_t *ctx,\n                                        lsm6dsm_filter_xl_conf_ois_t val);\nint32_t lsm6dsm_xl_aux_lp_bandwidth_get(lsm6dsm_ctx_t *ctx,\n                                        lsm6dsm_filter_xl_conf_ois_t *val);\n\ntypedef enum {\n  LSM6DSM_LP2_ONLY                    = 0x00,\n\n  LSM6DSM_HP_16mHz_LP2                = 0x80,\n  LSM6DSM_HP_65mHz_LP2                = 0x90,\n  LSM6DSM_HP_260mHz_LP2               = 0xA0,\n  LSM6DSM_HP_1Hz04_LP2                = 0xB0,\n\n  LSM6DSM_HP_DISABLE_LP1_LIGHT        = 0x0A,\n  LSM6DSM_HP_DISABLE_LP1_NORMAL       = 0x09,\n  LSM6DSM_HP_DISABLE_LP_STRONG        = 0x08,\n  LSM6DSM_HP_DISABLE_LP1_AGGRESSIVE   = 0x0B,\n\n  LSM6DSM_HP_16mHz_LP1_LIGHT          = 0x8A,\n  LSM6DSM_HP_65mHz_LP1_NORMAL         = 0x99,\n  LSM6DSM_HP_260mHz_LP1_STRONG        = 0xA8,\n  LSM6DSM_HP_1Hz04_LP1_AGGRESSIVE     = 0xBB,\n} lsm6dsm_lpf1_sel_g_t;\nint32_t lsm6dsm_gy_band_pass_set(lsm6dsm_ctx_t *ctx,\n                                    lsm6dsm_lpf1_sel_g_t val);\nint32_t lsm6dsm_gy_band_pass_get(lsm6dsm_ctx_t *ctx,\n                                    lsm6dsm_lpf1_sel_g_t *val);\n\nint32_t lsm6dsm_gy_ui_high_pass_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_gy_ui_high_pass_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSM_HP_DISABLE_LP_173Hz        = 0x02,\n  LSM6DSM_HP_DISABLE_LP_237Hz        = 0x01,\n  LSM6DSM_HP_DISABLE_LP_351Hz        = 0x00,\n  LSM6DSM_HP_DISABLE_LP_937Hz        = 0x03,\n\n  LSM6DSM_HP_16mHz_LP_173Hz          = 0x82,\n  LSM6DSM_HP_65mHz_LP_237Hz          = 0x91,\n  LSM6DSM_HP_260mHz_LP_351Hz         = 0xA0,\n  LSM6DSM_HP_1Hz04_LP_937Hz          = 0xB3,\n} lsm6dsm_hp_en_ois_t;\nint32_t lsm6dsm_gy_aux_bandwidth_set(lsm6dsm_ctx_t *ctx,\n                                     lsm6dsm_hp_en_ois_t val);\nint32_t lsm6dsm_gy_aux_bandwidth_get(lsm6dsm_ctx_t *ctx,\n                                     lsm6dsm_hp_en_ois_t *val);\n\nint32_t lsm6dsm_aux_status_reg_get(lsm6dsm_ctx_t *ctx,\n                                   lsm6dsm_status_spiaux_t *val);\n\nint32_t lsm6dsm_aux_xl_flag_data_ready_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsm_aux_gy_flag_data_ready_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsm_aux_gy_flag_settling_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSM_AUX_DEN_DISABLE         = 0,\n  LSM6DSM_AUX_DEN_LEVEL_LATCH     = 3,\n  LSM6DSM_AUX_DEN_LEVEL_TRIG      = 2,\n} lsm6dsm_lvl_ois_t;\nint32_t lsm6dsm_aux_den_mode_set(lsm6dsm_ctx_t *ctx,\n                                 lsm6dsm_lvl_ois_t val);\nint32_t lsm6dsm_aux_den_mode_get(lsm6dsm_ctx_t *ctx,\n                                 lsm6dsm_lvl_ois_t *val);\n\nint32_t lsm6dsm_aux_drdy_on_int2_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_aux_drdy_on_int2_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSM_AUX_DISABLE   = 0,\n  LSM6DSM_MODE_3_GY     = 1,\n  LSM6DSM_MODE_4_GY_XL  = 3,\n} lsm6dsm_ois_en_spi2_t;\nint32_t lsm6dsm_aux_mode_set(lsm6dsm_ctx_t *ctx, lsm6dsm_ois_en_spi2_t val);\nint32_t lsm6dsm_aux_mode_get(lsm6dsm_ctx_t *ctx, lsm6dsm_ois_en_spi2_t *val);\n\ntypedef enum {\n  LSM6DSM_250dps_AUX   = 0,\n  LSM6DSM_125dps_AUX   = 1,\n  LSM6DSM_500dps_AUX   = 2,\n  LSM6DSM_1000dps_AUX  = 4,\n  LSM6DSM_2000dps_AUX  = 6,\n} lsm6dsm_fs_g_ois_t;\nint32_t lsm6dsm_aux_gy_full_scale_set(lsm6dsm_ctx_t *ctx,\n                                      lsm6dsm_fs_g_ois_t val);\nint32_t lsm6dsm_aux_gy_full_scale_get(lsm6dsm_ctx_t *ctx,\n                                      lsm6dsm_fs_g_ois_t *val);\n\ntypedef enum {\n  LSM6DSM_AUX_SPI_4_WIRE = 0,\n  LSM6DSM_AUX_SPI_3_WIRE = 1,\n} lsm6dsm_sim_ois_t;\nint32_t lsm6dsm_aux_spi_mode_set(lsm6dsm_ctx_t *ctx, lsm6dsm_sim_ois_t val);\nint32_t lsm6dsm_aux_spi_mode_get(lsm6dsm_ctx_t *ctx, lsm6dsm_sim_ois_t *val);\n\ntypedef enum {\n  LSM6DSM_AUX_LSB_AT_LOW_ADD = 0,\n  LSM6DSM_AUX_MSB_AT_LOW_ADD = 1,\n} lsm6dsm_ble_ois_t;\nint32_t lsm6dsm_aux_data_format_set(lsm6dsm_ctx_t *ctx,\n                                    lsm6dsm_ble_ois_t val);\nint32_t lsm6dsm_aux_data_format_get(lsm6dsm_ctx_t *ctx,\n                                    lsm6dsm_ble_ois_t *val);\n\ntypedef enum {\n  LSM6DSM_ENABLE_CLAMP    = 0,\n  LSM6DSM_DISABLE_CLAMP   = 1,\n} lsm6dsm_st_ois_clampdis_t;\nint32_t lsm6dsm_aux_gy_clamp_set(lsm6dsm_ctx_t *ctx,\n                                 lsm6dsm_st_ois_clampdis_t val);\nint32_t lsm6dsm_aux_gy_clamp_get(lsm6dsm_ctx_t *ctx,\n                                 lsm6dsm_st_ois_clampdis_t *val);\n\ntypedef enum {\n  LSM6DSM_AUX_GY_DISABLE  = 0,\n  LSM6DSM_AUX_GY_POS      = 1,\n  LSM6DSM_AUX_GY_NEG      = 3,\n} lsm6dsm_st_ois_t;\nint32_t lsm6dsm_aux_gy_self_test_set(lsm6dsm_ctx_t *ctx,\n                                     lsm6dsm_st_ois_t val);\nint32_t lsm6dsm_aux_gy_self_test_get(lsm6dsm_ctx_t *ctx,\n                                     lsm6dsm_st_ois_t *val);\n\ntypedef enum {\n  LSM6DSM_AUX_2g   = 0,\n  LSM6DSM_AUX_16g  = 1,\n  LSM6DSM_AUX_4g   = 2,\n  LSM6DSM_AUX_8g   = 3,\n} lsm6dsm_fs_xl_ois_t;\nint32_t lsm6dsm_aux_xl_full_scale_set(lsm6dsm_ctx_t *ctx,\n                                      lsm6dsm_fs_xl_ois_t val);\nint32_t lsm6dsm_aux_xl_full_scale_get(lsm6dsm_ctx_t *ctx,\n                                      lsm6dsm_fs_xl_ois_t *val);\n\ntypedef enum {\n  LSM6DSM_AUX_DEN_ACTIVE_LOW   = 0,\n  LSM6DSM_AUX_DEN_ACTIVE_HIGH  = 1,\n} lsm6dsm_den_lh_ois_t;\nint32_t lsm6dsm_aux_den_polarity_set(lsm6dsm_ctx_t *ctx,\n                                     lsm6dsm_den_lh_ois_t val);\nint32_t lsm6dsm_aux_den_polarity_get(lsm6dsm_ctx_t *ctx,\n                                     lsm6dsm_den_lh_ois_t *val);\n\ntypedef enum {\n  LSM6DSM_SPI_4_WIRE  = 0,\n  LSM6DSM_SPI_3_WIRE  = 1,\n} lsm6dsm_sim_t;\nint32_t lsm6dsm_spi_mode_set(lsm6dsm_ctx_t *ctx, lsm6dsm_sim_t val);\nint32_t lsm6dsm_spi_mode_get(lsm6dsm_ctx_t *ctx, lsm6dsm_sim_t *val);\n\ntypedef enum {\n  LSM6DSM_I2C_ENABLE   = 0,\n  LSM6DSM_I2C_DISABLE  = 1,\n} lsm6dsm_i2c_disable_t;\nint32_t lsm6dsm_i2c_interface_set(lsm6dsm_ctx_t *ctx,\n                                  lsm6dsm_i2c_disable_t val);\nint32_t lsm6dsm_i2c_interface_get(lsm6dsm_ctx_t *ctx,\n                                  lsm6dsm_i2c_disable_t *val);\n\ntypedef struct {\n  uint8_t int1_drdy_xl             : 1;\n  uint8_t int1_drdy_g              : 1;\n  uint8_t int1_boot                : 1;\n  uint8_t int1_fth                 : 1;\n  uint8_t int1_fifo_ovr            : 1;\n  uint8_t int1_full_flag           : 1;\n  uint8_t int1_sign_mot            : 1;\n  uint8_t int1_step_detector       : 1;\n  uint8_t int1_timer               : 1;\n  uint8_t int1_tilt                : 1;\n  uint8_t int1_6d                  : 1;\n  uint8_t int1_double_tap          : 1;\n  uint8_t int1_ff                  : 1;\n  uint8_t int1_wu                  : 1;\n  uint8_t int1_single_tap          : 1;\n  uint8_t int1_inact_state         : 1;\n  uint8_t den_drdy_int1            : 1;\n  uint8_t drdy_on_int1             : 1;\n} lsm6dsm_int1_route_t;\nint32_t lsm6dsm_pin_int1_route_set(lsm6dsm_ctx_t *ctx,\n                                   lsm6dsm_int1_route_t val);\nint32_t lsm6dsm_pin_int1_route_get(lsm6dsm_ctx_t *ctx,\n                                   lsm6dsm_int1_route_t *val);\n\ntypedef struct{\n  uint8_t int2_drdy_xl             : 1;\n  uint8_t int2_drdy_g              : 1;\n  uint8_t int2_drdy_temp           : 1;\n  uint8_t int2_fth                 : 1;\n  uint8_t int2_fifo_ovr            : 1;\n  uint8_t int2_full_flag           : 1;\n  uint8_t int2_step_count_ov       : 1;\n  uint8_t int2_step_delta          : 1;\n  uint8_t int2_iron                : 1;\n  uint8_t int2_tilt                : 1;\n  uint8_t int2_6d                  : 1;\n  uint8_t int2_double_tap          : 1;\n  uint8_t int2_ff                  : 1;\n  uint8_t int2_wu                  : 1;\n  uint8_t int2_single_tap          : 1;\n  uint8_t int2_inact_state         : 1;\n  uint8_t int2_wrist_tilt          : 1;\n} lsm6dsm_int2_route_t;\nint32_t lsm6dsm_pin_int2_route_set(lsm6dsm_ctx_t *ctx,\n                                   lsm6dsm_int2_route_t val);\nint32_t lsm6dsm_pin_int2_route_get(lsm6dsm_ctx_t *ctx,\n                                   lsm6dsm_int2_route_t *val);\n\ntypedef enum {\n  LSM6DSM_PUSH_PULL   = 0,\n  LSM6DSM_OPEN_DRAIN  = 1,\n} lsm6dsm_pp_od_t;\nint32_t lsm6dsm_pin_mode_set(lsm6dsm_ctx_t *ctx, lsm6dsm_pp_od_t val);\nint32_t lsm6dsm_pin_mode_get(lsm6dsm_ctx_t *ctx, lsm6dsm_pp_od_t *val);\n\ntypedef enum {\n  LSM6DSM_ACTIVE_HIGH   = 0,\n  LSM6DSM_ACTIVE_LOW    = 1,\n} lsm6dsm_h_lactive_t;\nint32_t lsm6dsm_pin_polarity_set(lsm6dsm_ctx_t *ctx, lsm6dsm_h_lactive_t val);\nint32_t lsm6dsm_pin_polarity_get(lsm6dsm_ctx_t *ctx, lsm6dsm_h_lactive_t *val);\n\nint32_t lsm6dsm_all_on_int1_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_all_on_int1_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSM_INT_PULSED   = 0,\n  LSM6DSM_INT_LATCHED  = 1,\n} lsm6dsm_lir_t;\nint32_t lsm6dsm_int_notification_set(lsm6dsm_ctx_t *ctx, lsm6dsm_lir_t val);\nint32_t lsm6dsm_int_notification_get(lsm6dsm_ctx_t *ctx, lsm6dsm_lir_t *val);\n\nint32_t lsm6dsm_wkup_threshold_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_wkup_threshold_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsm_wkup_dur_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_wkup_dur_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsm_gy_sleep_mode_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_gy_sleep_mode_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSM_PROPERTY_DISABLE          = 0,\n  LSM6DSM_XL_12Hz5_GY_NOT_AFFECTED  = 1,\n  LSM6DSM_XL_12Hz5_GY_SLEEP         = 2,\n  LSM6DSM_XL_12Hz5_GY_PD            = 3,\n} lsm6dsm_inact_en_t;\nint32_t lsm6dsm_act_mode_set(lsm6dsm_ctx_t *ctx, lsm6dsm_inact_en_t val);\nint32_t lsm6dsm_act_mode_get(lsm6dsm_ctx_t *ctx, lsm6dsm_inact_en_t *val);\n\nint32_t lsm6dsm_act_sleep_dur_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_act_sleep_dur_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsm_tap_src_get(lsm6dsm_ctx_t *ctx, lsm6dsm_tap_src_t *val);\n\nint32_t lsm6dsm_tap_detection_on_z_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_tap_detection_on_z_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsm_tap_detection_on_y_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_tap_detection_on_y_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsm_tap_detection_on_x_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_tap_detection_on_x_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsm_tap_threshold_x_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_tap_threshold_x_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsm_tap_shock_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_tap_shock_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsm_tap_quiet_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_tap_quiet_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsm_tap_dur_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_tap_dur_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSM_ONLY_SINGLE          = 0,\n  LSM6DSM_BOTH_SINGLE_DOUBLE   = 1,\n} lsm6dsm_single_double_tap_t;\nint32_t lsm6dsm_tap_mode_set(lsm6dsm_ctx_t *ctx,\n                             lsm6dsm_single_double_tap_t val);\nint32_t lsm6dsm_tap_mode_get(lsm6dsm_ctx_t *ctx,\n                             lsm6dsm_single_double_tap_t *val);\n\ntypedef enum {\n  LSM6DSM_ODR_DIV_2_FEED      = 0,\n  LSM6DSM_LPF2_FEED           = 1,\n} lsm6dsm_low_pass_on_6d_t;\nint32_t lsm6dsm_6d_feed_data_set(lsm6dsm_ctx_t *ctx,\n                                 lsm6dsm_low_pass_on_6d_t val);\nint32_t lsm6dsm_6d_feed_data_get(lsm6dsm_ctx_t *ctx,\n                                 lsm6dsm_low_pass_on_6d_t *val);\n\ntypedef enum {\n  LSM6DSM_DEG_80      = 0,\n  LSM6DSM_DEG_70      = 1,\n  LSM6DSM_DEG_60      = 2,\n  LSM6DSM_DEG_50      = 3,\n} lsm6dsm_sixd_ths_t;\nint32_t lsm6dsm_6d_threshold_set(lsm6dsm_ctx_t *ctx, lsm6dsm_sixd_ths_t val);\nint32_t lsm6dsm_6d_threshold_get(lsm6dsm_ctx_t *ctx, lsm6dsm_sixd_ths_t *val);\n\nint32_t lsm6dsm_4d_mode_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_4d_mode_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsm_ff_dur_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_ff_dur_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSM_FF_TSH_156mg = 0,\n  LSM6DSM_FF_TSH_219mg = 1,\n  LSM6DSM_FF_TSH_250mg = 2,\n  LSM6DSM_FF_TSH_312mg = 3,\n  LSM6DSM_FF_TSH_344mg = 4,\n  LSM6DSM_FF_TSH_406mg = 5,\n  LSM6DSM_FF_TSH_469mg = 6,\n  LSM6DSM_FF_TSH_500mg = 7,\n} lsm6dsm_ff_ths_t;\nint32_t lsm6dsm_ff_threshold_set(lsm6dsm_ctx_t *ctx, lsm6dsm_ff_ths_t val);\nint32_t lsm6dsm_ff_threshold_get(lsm6dsm_ctx_t *ctx, lsm6dsm_ff_ths_t *val);\n\nint32_t lsm6dsm_fifo_watermark_set(lsm6dsm_ctx_t *ctx, uint16_t val);\nint32_t lsm6dsm_fifo_watermark_get(lsm6dsm_ctx_t *ctx, uint16_t *val);\n\nint32_t lsm6dsm_fifo_data_level_get(lsm6dsm_ctx_t *ctx, uint16_t *val);\n\nint32_t lsm6dsm_fifo_wtm_flag_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsm_fifo_pattern_get(lsm6dsm_ctx_t *ctx, uint16_t *val);\n\nint32_t lsm6dsm_fifo_temp_batch_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_fifo_temp_batch_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSM_TRG_XL_GY_DRDY     = 0,\n  LSM6DSM_TRG_STEP_DETECT    = 1,\n  LSM6DSM_TRG_SH_DRDY        = 2,\n} lsm6dsm_trigger_fifo_t;\nint32_t lsm6dsm_fifo_write_trigger_set(lsm6dsm_ctx_t *ctx,\n                                       lsm6dsm_trigger_fifo_t val);\nint32_t lsm6dsm_fifo_write_trigger_get(lsm6dsm_ctx_t *ctx,\n                                       lsm6dsm_trigger_fifo_t *val);\n\nint32_t lsm6dsm_fifo_pedo_and_timestamp_batch_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_fifo_pedo_and_timestamp_batch_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSM_FIFO_XL_DISABLE  = 0,\n  LSM6DSM_FIFO_XL_NO_DEC   = 1,\n  LSM6DSM_FIFO_XL_DEC_2    = 2,\n  LSM6DSM_FIFO_XL_DEC_3    = 3,\n  LSM6DSM_FIFO_XL_DEC_4    = 4,\n  LSM6DSM_FIFO_XL_DEC_8    = 5,\n  LSM6DSM_FIFO_XL_DEC_16   = 6,\n  LSM6DSM_FIFO_XL_DEC_32   = 7,\n} lsm6dsm_dec_fifo_xl_t;\nint32_t lsm6dsm_fifo_xl_batch_set(lsm6dsm_ctx_t *ctx,\n                                  lsm6dsm_dec_fifo_xl_t val);\nint32_t lsm6dsm_fifo_xl_batch_get(lsm6dsm_ctx_t *ctx,\n                                  lsm6dsm_dec_fifo_xl_t *val);\n\ntypedef enum {\n  LSM6DSM_FIFO_GY_DISABLE = 0,\n  LSM6DSM_FIFO_GY_NO_DEC = 1,\n  LSM6DSM_FIFO_GY_DEC_2 = 2,\n  LSM6DSM_FIFO_GY_DEC_3 = 3,\n  LSM6DSM_FIFO_GY_DEC_4 = 4,\n  LSM6DSM_FIFO_GY_DEC_8 = 5,\n  LSM6DSM_FIFO_GY_DEC_16 = 6,\n  LSM6DSM_FIFO_GY_DEC_32 = 7,\n} lsm6dsm_dec_fifo_gyro_t;\nint32_t lsm6dsm_fifo_gy_batch_set(lsm6dsm_ctx_t *ctx,\n                                  lsm6dsm_dec_fifo_gyro_t val);\nint32_t lsm6dsm_fifo_gy_batch_get(lsm6dsm_ctx_t *ctx,\n                                  lsm6dsm_dec_fifo_gyro_t *val);\n\ntypedef enum {\n  LSM6DSM_FIFO_DS3_DISABLE   = 0,\n  LSM6DSM_FIFO_DS3_NO_DEC    = 1,\n  LSM6DSM_FIFO_DS3_DEC_2     = 2,\n  LSM6DSM_FIFO_DS3_DEC_3     = 3,\n  LSM6DSM_FIFO_DS3_DEC_4     = 4,\n  LSM6DSM_FIFO_DS3_DEC_8     = 5,\n  LSM6DSM_FIFO_DS3_DEC_16    = 6,\n  LSM6DSM_FIFO_DS3_DEC_32    = 7,\n} lsm6dsm_dec_ds3_fifo_t;\nint32_t lsm6dsm_fifo_dataset_3_batch_set(lsm6dsm_ctx_t *ctx,\n                                         lsm6dsm_dec_ds3_fifo_t val);\nint32_t lsm6dsm_fifo_dataset_3_batch_get(lsm6dsm_ctx_t *ctx,\n                                         lsm6dsm_dec_ds3_fifo_t *val);\n\ntypedef enum {\n  LSM6DSM_FIFO_DS4_DISABLE  = 0,\n  LSM6DSM_FIFO_DS4_NO_DEC   = 1,\n  LSM6DSM_FIFO_DS4_DEC_2    = 2,\n  LSM6DSM_FIFO_DS4_DEC_3    = 3,\n  LSM6DSM_FIFO_DS4_DEC_4    = 4,\n  LSM6DSM_FIFO_DS4_DEC_8    = 5,\n  LSM6DSM_FIFO_DS4_DEC_16   = 6,\n  LSM6DSM_FIFO_DS4_DEC_32   = 7,\n} lsm6dsm_dec_ds4_fifo_t;\nint32_t lsm6dsm_fifo_dataset_4_batch_set(lsm6dsm_ctx_t *ctx,\n                                         lsm6dsm_dec_ds4_fifo_t val);\nint32_t lsm6dsm_fifo_dataset_4_batch_get(lsm6dsm_ctx_t *ctx,\n                                         lsm6dsm_dec_ds4_fifo_t *val);\n\nint32_t lsm6dsm_fifo_xl_gy_8bit_format_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_fifo_xl_gy_8bit_format_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsm_fifo_stop_on_wtm_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_fifo_stop_on_wtm_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSM_BYPASS_MODE           = 0,\n  LSM6DSM_FIFO_MODE             = 1,\n  LSM6DSM_STREAM_TO_FIFO_MODE   = 3,\n  LSM6DSM_BYPASS_TO_STREAM_MODE = 4,\n  LSM6DSM_STREAM_MODE           = 6,\n} lsm6dsm_fifo_mode_t;\nint32_t lsm6dsm_fifo_mode_set(lsm6dsm_ctx_t *ctx, lsm6dsm_fifo_mode_t val);\nint32_t lsm6dsm_fifo_mode_get(lsm6dsm_ctx_t *ctx, lsm6dsm_fifo_mode_t *val);\n\ntypedef enum {\n  LSM6DSM_FIFO_DISABLE   =  0,\n  LSM6DSM_FIFO_12Hz5     =  1,\n  LSM6DSM_FIFO_26Hz      =  2,\n  LSM6DSM_FIFO_52Hz      =  3,\n  LSM6DSM_FIFO_104Hz     =  4,\n  LSM6DSM_FIFO_208Hz     =  5,\n  LSM6DSM_FIFO_416Hz     =  6,\n  LSM6DSM_FIFO_833Hz     =  7,\n  LSM6DSM_FIFO_1k66Hz    =  8,\n  LSM6DSM_FIFO_3k33Hz    =  9,\n  LSM6DSM_FIFO_6k66Hz    = 10,\n} lsm6dsm_odr_fifo_t;\nint32_t lsm6dsm_fifo_data_rate_set(lsm6dsm_ctx_t *ctx,\n                                   lsm6dsm_odr_fifo_t val);\nint32_t lsm6dsm_fifo_data_rate_get(lsm6dsm_ctx_t *ctx,\n                                   lsm6dsm_odr_fifo_t *val);\n\ntypedef enum {\n  LSM6DSM_DEN_ACT_LOW    = 0,\n  LSM6DSM_DEN_ACT_HIGH   = 1,\n} lsm6dsm_den_lh_t;\nint32_t lsm6dsm_den_polarity_set(lsm6dsm_ctx_t *ctx, lsm6dsm_den_lh_t val);\nint32_t lsm6dsm_den_polarity_get(lsm6dsm_ctx_t *ctx, lsm6dsm_den_lh_t *val);\n\ntypedef enum {\n  LSM6DSM_DEN_DISABLE    = 0,\n  LSM6DSM_LEVEL_FIFO     = 6,\n  LSM6DSM_LEVEL_LETCHED  = 3,\n  LSM6DSM_LEVEL_TRIGGER  = 2,\n  LSM6DSM_EDGE_TRIGGER   = 4,\n} lsm6dsm_den_mode_t;\nint32_t lsm6dsm_den_mode_set(lsm6dsm_ctx_t *ctx, lsm6dsm_den_mode_t val);\nint32_t lsm6dsm_den_mode_get(lsm6dsm_ctx_t *ctx, lsm6dsm_den_mode_t *val);\n\ntypedef enum {\n  LSM6DSM_STAMP_IN_GY_DATA     = 0,\n  LSM6DSM_STAMP_IN_XL_DATA     = 1,\n  LSM6DSM_STAMP_IN_GY_XL_DATA  = 2,\n} lsm6dsm_den_xl_en_t;\nint32_t lsm6dsm_den_enable_set(lsm6dsm_ctx_t *ctx, lsm6dsm_den_xl_en_t val);\nint32_t lsm6dsm_den_enable_get(lsm6dsm_ctx_t *ctx, lsm6dsm_den_xl_en_t *val);\n\nint32_t lsm6dsm_den_mark_axis_z_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_den_mark_axis_z_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsm_den_mark_axis_y_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_den_mark_axis_y_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsm_den_mark_axis_x_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_den_mark_axis_x_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsm_pedo_step_reset_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_pedo_step_reset_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsm_pedo_sens_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_pedo_sens_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsm_pedo_threshold_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_pedo_threshold_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSM_PEDO_AT_2g = 0,\n  LSM6DSM_PEDO_AT_4g = 1,\n} lsm6dsm_pedo_fs_t;\nint32_t lsm6dsm_pedo_full_scale_set(lsm6dsm_ctx_t *ctx,\n                                    lsm6dsm_pedo_fs_t val);\nint32_t lsm6dsm_pedo_full_scale_get(lsm6dsm_ctx_t *ctx,\n                                    lsm6dsm_pedo_fs_t *val);\n\nint32_t lsm6dsm_pedo_debounce_steps_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_pedo_debounce_steps_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsm_pedo_timeout_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_pedo_timeout_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsm_pedo_steps_period_set(lsm6dsm_ctx_t *ctx, uint8_t *buff);\nint32_t lsm6dsm_pedo_steps_period_get(lsm6dsm_ctx_t *ctx, uint8_t *buff);\nint32_t lsm6dsm_motion_sens_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_motion_sens_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsm_motion_threshold_set(lsm6dsm_ctx_t *ctx, uint8_t *buff);\nint32_t lsm6dsm_motion_threshold_get(lsm6dsm_ctx_t *ctx, uint8_t *buff);\n\nint32_t lsm6dsm_tilt_sens_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_tilt_sens_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsm_wrist_tilt_sens_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_wrist_tilt_sens_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsm_tilt_latency_set(lsm6dsm_ctx_t *ctx, uint8_t *buff);\nint32_t lsm6dsm_tilt_latency_get(lsm6dsm_ctx_t *ctx, uint8_t *buff);\nint32_t lsm6dsm_tilt_threshold_set(lsm6dsm_ctx_t *ctx, uint8_t *buff);\nint32_t lsm6dsm_tilt_threshold_get(lsm6dsm_ctx_t *ctx, uint8_t *buff);\n\nint32_t lsm6dsm_tilt_src_set(lsm6dsm_ctx_t *ctx,\n                             lsm6dsm_a_wrist_tilt_mask_t *val);\nint32_t lsm6dsm_tilt_src_get(lsm6dsm_ctx_t *ctx,\n                             lsm6dsm_a_wrist_tilt_mask_t *val);\n\nint32_t lsm6dsm_mag_soft_iron_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_mag_soft_iron_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsm_mag_hard_iron_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_mag_hard_iron_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsm_mag_soft_iron_mat_set(lsm6dsm_ctx_t *ctx, uint8_t *buff);\nint32_t lsm6dsm_mag_soft_iron_mat_get(lsm6dsm_ctx_t *ctx, uint8_t *buff);\n\nint32_t lsm6dsm_mag_offset_set(lsm6dsm_ctx_t *ctx, uint8_t *buff);\nint32_t lsm6dsm_mag_offset_get(lsm6dsm_ctx_t *ctx, uint8_t *buff);\n\nint32_t lsm6dsm_func_en_set(lsm6dsm_ctx_t *ctx, uint8_t val);\n\nint32_t lsm6dsm_sh_sync_sens_frame_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_sh_sync_sens_frame_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSM_RES_RATIO_2_11  = 0,\n  LSM6DSM_RES_RATIO_2_12  = 1,\n  LSM6DSM_RES_RATIO_2_13  = 2,\n  LSM6DSM_RES_RATIO_2_14  = 3,\n} lsm6dsm_rr_t;\nint32_t lsm6dsm_sh_sync_sens_ratio_set(lsm6dsm_ctx_t *ctx, lsm6dsm_rr_t val);\nint32_t lsm6dsm_sh_sync_sens_ratio_get(lsm6dsm_ctx_t *ctx, lsm6dsm_rr_t *val);\n\nint32_t lsm6dsm_sh_master_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_sh_master_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsm_sh_pass_through_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_sh_pass_through_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSM_EXT_PULL_UP       = 0,\n  LSM6DSM_INTERNAL_PULL_UP  = 1,\n} lsm6dsm_pull_up_en_t;\nint32_t lsm6dsm_sh_pin_mode_set(lsm6dsm_ctx_t *ctx, lsm6dsm_pull_up_en_t val);\nint32_t lsm6dsm_sh_pin_mode_get(lsm6dsm_ctx_t *ctx, lsm6dsm_pull_up_en_t *val);\n\ntypedef enum {\n  LSM6DSM_XL_GY_DRDY        = 0,\n  LSM6DSM_EXT_ON_INT2_PIN   = 1,\n} lsm6dsm_start_config_t;\nint32_t lsm6dsm_sh_syncro_mode_set(lsm6dsm_ctx_t *ctx,\n                                   lsm6dsm_start_config_t val);\nint32_t lsm6dsm_sh_syncro_mode_get(lsm6dsm_ctx_t *ctx,\n                                   lsm6dsm_start_config_t *val);\n\nint32_t lsm6dsm_sh_drdy_on_int1_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_sh_drdy_on_int1_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\ntypedef union {\n  struct {\n    lsm6dsm_sensorhub1_reg_t   sh_byte_1;\n    lsm6dsm_sensorhub2_reg_t   sh_byte_2;\n    lsm6dsm_sensorhub3_reg_t   sh_byte_3;\n    lsm6dsm_sensorhub4_reg_t   sh_byte_4;\n    lsm6dsm_sensorhub5_reg_t   sh_byte_5;\n    lsm6dsm_sensorhub6_reg_t   sh_byte_6;\n    lsm6dsm_sensorhub7_reg_t   sh_byte_7;\n    lsm6dsm_sensorhub8_reg_t   sh_byte_8;\n    lsm6dsm_sensorhub9_reg_t   sh_byte_9;\n    lsm6dsm_sensorhub10_reg_t  sh_byte_10;\n    lsm6dsm_sensorhub11_reg_t  sh_byte_11;\n    lsm6dsm_sensorhub12_reg_t  sh_byte_12;\n    lsm6dsm_sensorhub13_reg_t  sh_byte_13;\n    lsm6dsm_sensorhub14_reg_t  sh_byte_14;\n    lsm6dsm_sensorhub15_reg_t  sh_byte_15;\n    lsm6dsm_sensorhub16_reg_t  sh_byte_16;\n    lsm6dsm_sensorhub17_reg_t  sh_byte_17;\n    lsm6dsm_sensorhub18_reg_t  sh_byte_18;\n  } reg;\n  uint8_t byte[18];\n} lsm6dsm_emb_sh_read_t;\nint32_t lsm6dsm_sh_read_data_raw_get(lsm6dsm_ctx_t *ctx,\n                                     lsm6dsm_emb_sh_read_t *val);\n\nint32_t lsm6dsm_sh_cmd_sens_sync_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_sh_cmd_sens_sync_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsm_sh_spi_sync_error_set(lsm6dsm_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsm_sh_spi_sync_error_get(lsm6dsm_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSM_NORMAL_MODE_READ  = 0,\n  LSM6DSM_SRC_MODE_READ     = 1,\n} lsm6dsm_src_mode_t;\nint32_t lsm6dsm_sh_cfg_slave_0_rd_mode_set(lsm6dsm_ctx_t *ctx,\n                                           lsm6dsm_src_mode_t val);\nint32_t lsm6dsm_sh_cfg_slave_0_rd_mode_get(lsm6dsm_ctx_t *ctx,\n                                           lsm6dsm_src_mode_t *val);\n\ntypedef enum {\n  LSM6DSM_SLV_0        = 0,\n  LSM6DSM_SLV_0_1      = 1,\n  LSM6DSM_SLV_0_1_2    = 2,\n  LSM6DSM_SLV_0_1_2_3  = 3,\n} lsm6dsm_aux_sens_on_t;\nint32_t lsm6dsm_sh_num_of_dev_connected_set(lsm6dsm_ctx_t *ctx,\n                                            lsm6dsm_aux_sens_on_t val);\nint32_t lsm6dsm_sh_num_of_dev_connected_get(lsm6dsm_ctx_t *ctx,\n                                            lsm6dsm_aux_sens_on_t *val);\n\ntypedef struct{\n  uint8_t   slv0_add;\n  uint8_t   slv0_subadd;\n  uint8_t   slv0_data;\n} lsm6dsm_sh_cfg_write_t;\nint32_t lsm6dsm_sh_cfg_write(lsm6dsm_ctx_t *ctx, lsm6dsm_sh_cfg_write_t *val);\n\ntypedef struct{\n  uint8_t   slv_add;\n  uint8_t   slv_subadd;\n  uint8_t   slv_len;\n} lsm6dsm_sh_cfg_read_t;\nint32_t lsm6dsm_sh_slv0_cfg_read(lsm6dsm_ctx_t *ctx,\n                                 lsm6dsm_sh_cfg_read_t *val);\nint32_t lsm6dsm_sh_slv1_cfg_read(lsm6dsm_ctx_t *ctx,\n                                 lsm6dsm_sh_cfg_read_t *val);\nint32_t lsm6dsm_sh_slv2_cfg_read(lsm6dsm_ctx_t *ctx,\n                                 lsm6dsm_sh_cfg_read_t *val);\nint32_t lsm6dsm_sh_slv3_cfg_read(lsm6dsm_ctx_t *ctx,\n                                 lsm6dsm_sh_cfg_read_t *val);\n\ntypedef enum {\n  LSM6DSM_SL0_NO_DEC   = 0,\n  LSM6DSM_SL0_DEC_2    = 1,\n  LSM6DSM_SL0_DEC_4    = 2,\n  LSM6DSM_SL0_DEC_8    = 3,\n} lsm6dsm_slave0_rate_t;\nint32_t lsm6dsm_sh_slave_0_dec_set(lsm6dsm_ctx_t *ctx,\n                                   lsm6dsm_slave0_rate_t val);\nint32_t lsm6dsm_sh_slave_0_dec_get(lsm6dsm_ctx_t *ctx,\n                                   lsm6dsm_slave0_rate_t *val);\n\ntypedef enum {\n  LSM6DSM_EACH_SH_CYCLE     = 0,\n  LSM6DSM_ONLY_FIRST_CYCLE  = 1,\n} lsm6dsm_write_once_t;\nint32_t lsm6dsm_sh_write_mode_set(lsm6dsm_ctx_t *ctx,\n                                  lsm6dsm_write_once_t val);\nint32_t lsm6dsm_sh_write_mode_get(lsm6dsm_ctx_t *ctx,\n                                  lsm6dsm_write_once_t *val);\n\ntypedef enum {\n  LSM6DSM_SL1_NO_DEC   = 0,\n  LSM6DSM_SL1_DEC_2    = 1,\n  LSM6DSM_SL1_DEC_4    = 2,\n  LSM6DSM_SL1_DEC_8    = 3,\n} lsm6dsm_slave1_rate_t;\nint32_t lsm6dsm_sh_slave_1_dec_set(lsm6dsm_ctx_t *ctx,\n                                   lsm6dsm_slave1_rate_t val);\nint32_t lsm6dsm_sh_slave_1_dec_get(lsm6dsm_ctx_t *ctx,\n                                   lsm6dsm_slave1_rate_t *val);\n\ntypedef enum {\n  LSM6DSM_SL2_NO_DEC  = 0,\n  LSM6DSM_SL2_DEC_2   = 1,\n  LSM6DSM_SL2_DEC_4   = 2,\n  LSM6DSM_SL2_DEC_8   = 3,\n} lsm6dsm_slave2_rate_t;\nint32_t lsm6dsm_sh_slave_2_dec_set(lsm6dsm_ctx_t *ctx,\n                                   lsm6dsm_slave2_rate_t val);\nint32_t lsm6dsm_sh_slave_2_dec_get(lsm6dsm_ctx_t *ctx,\n                                   lsm6dsm_slave2_rate_t *val);\n\ntypedef enum {\n  LSM6DSM_SL3_NO_DEC  = 0,\n  LSM6DSM_SL3_DEC_2   = 1,\n  LSM6DSM_SL3_DEC_4   = 2,\n  LSM6DSM_SL3_DEC_8   = 3,\n} lsm6dsm_slave3_rate_t;\nint32_t lsm6dsm_sh_slave_3_dec_set(lsm6dsm_ctx_t *ctx,\n                                   lsm6dsm_slave3_rate_t val);\nint32_t lsm6dsm_sh_slave_3_dec_get(lsm6dsm_ctx_t *ctx,\n                                   lsm6dsm_slave3_rate_t *val);\n\n/**\n  * @}\n  */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /*__LSM6DSM_DRIVER__H */\n\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\n"
              },
              "objects": {
                "lsm6dsm.c": "#include \"lsm6dsm.h\"\r\n#include \"lsm6dsm_reg.h\"\r\n\r\nstatic ATMO_LSM6DSM_Config_t _LSM6DSM_PrivConfig;\r\nstatic lsm6dsm_ctx_t _LSM6DSM_Ctx;\r\n\r\nstatic int32_t _ATMO_LSM6DSM_PlatformWrite(void *handle, uint8_t Reg, uint8_t *Bufp,\r\n                              uint16_t len)\r\n{\r\n\tif(_LSM6DSM_PrivConfig.driverType.type == ATMO_DRIVERTYPE_I2C )\r\n\t{\r\n\t\tuint8_t i2cAddress = *((uint8_t*)handle);\r\n\t\tATMO_I2C_Status_t status = ATMO_I2C_MasterWrite(_LSM6DSM_PrivConfig.i2cInstance, i2cAddress,\r\n\t\t&Reg, 1, Bufp, len, 1000);\r\n\t\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tATMO_GPIO_Device_Pin_t csPin = *((ATMO_GPIO_Device_Pin_t *)handle);\r\n\t\tATMO_GPIO_SetPinState(_LSM6DSM_PrivConfig.gpioInstance, csPin, ATMO_GPIO_PinState_Low);\r\n\t\tATMO_SPI_Status_t status = ATMO_SPI_MasterWrite(_LSM6DSM_PrivConfig.spiInstance, ATMO_SPI_CS_NONE, &Reg, 1, Bufp, len, 1000);\r\n\t\tATMO_GPIO_SetPinState(_LSM6DSM_PrivConfig.gpioInstance, csPin, ATMO_GPIO_PinState_High);\r\n\t\treturn (status == ATMO_SPI_Status_Success) ? 0 : 1;\r\n\t}\r\n  \r\n\r\n}\r\n\r\nstatic int32_t _ATMO_LSM6DSM_PlatformRead(void *handle, uint8_t Reg, uint8_t *Bufp,\r\n                             uint16_t len)\r\n{\r\n\tif(_LSM6DSM_PrivConfig.driverType.type == ATMO_DRIVERTYPE_I2C )\r\n\t{\r\n\t\tuint8_t i2cAddress = *((uint8_t*)handle);\r\n\t\tATMO_I2C_Status_t status = ATMO_I2C_Status_Success;\r\n\t\tuint8_t currentReg = Reg;\r\n\r\n\t\t// Need to do discrete reads or block update doesn't work\r\n\t\tfor(unsigned int i = 0; (i < len) && (status == ATMO_I2C_Status_Success); i++)\r\n\t\t{\r\n\t\t\tstatus = ATMO_I2C_MasterRead(_LSM6DSM_PrivConfig.i2cInstance, i2cAddress,\r\n\t\t\t\t&currentReg, 1, &Bufp[i], 1, 1000);\r\n\t\t\tcurrentReg++;\r\n\t\t}\r\n\r\n\t\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tATMO_GPIO_Device_Pin_t csPin = *((ATMO_GPIO_Device_Pin_t *)handle);\r\n\r\n\t\tATMO_SPI_Status_t status = ATMO_SPI_Status_Success;\r\n\r\n\t\tfor(unsigned int i = 0; (i < len) && (status == ATMO_SPI_Status_Success); i++)\r\n\t\t{\r\n\t\t\tATMO_GPIO_SetPinState(_LSM6DSM_PrivConfig.gpioInstance, csPin, ATMO_GPIO_PinState_Low);\r\n\t\t\tuint8_t readReg = (Reg + i) | 0x80;\r\n\t\t\tstatus = ATMO_SPI_MasterRead(_LSM6DSM_PrivConfig.spiInstance, ATMO_SPI_CS_NONE, &readReg, 1, &Bufp[i], 1, 1000);\r\n\t\t\tATMO_GPIO_SetPinState(_LSM6DSM_PrivConfig.gpioInstance, csPin, ATMO_GPIO_PinState_High);\r\n\t\t}\r\n\r\n\r\n\t\treturn (status == ATMO_SPI_Status_Success) ? 0 : 1;\r\n\t}\r\n}\r\n\r\nATMO_LSM6DSM_Status_t ATMO_LSM6DSM_Init(ATMO_LSM6DSM_Config_t *config)\r\n{\r\n    if(config == NULL)\r\n    {\r\n        return ATMO_LSM6DSM_Status_Fail;\r\n    }\r\n\r\n    memcpy(&_LSM6DSM_PrivConfig, config, sizeof(_LSM6DSM_PrivConfig));\r\n\r\n    _LSM6DSM_Ctx.write_reg = _ATMO_LSM6DSM_PlatformWrite;\r\n    _LSM6DSM_Ctx.read_reg = _ATMO_LSM6DSM_PlatformRead;\r\n\r\n    if(config->driverType.type == ATMO_DRIVERTYPE_SPI)\r\n    {\r\n\t\t// Initialize SPI\r\n\t\tATMO_SPI_Peripheral_t spiConf;\r\n\t\tspiConf.operatingMode = ATMO_SPI_OperatingMode_Master;\r\n\t\tspiConf.deviceConfig.baudRate = 2500000;\r\n\t\tspiConf.deviceConfig.clockContinuous = false;\r\n\t\tspiConf.deviceConfig.clockMode = ATMO_SPI_ClockMode_3;\r\n\t\tspiConf.deviceConfig.msbFirst = true;\r\n\t\tspiConf.deviceConfig.ssActiveLow = true;\r\n\t\tATMO_SPI_SetConfiguration(config->spiInstance, &spiConf);\r\n        \r\n    \t_LSM6DSM_Ctx.handle = (void*)&_LSM6DSM_PrivConfig.csPin;\r\n\r\n    \tATMO_GPIO_Config_t gpioConfig;\r\n    \tgpioConfig.initialState = ATMO_GPIO_PinState_High;\r\n    \tgpioConfig.pinMode = ATMO_GPIO_PinMode_Output_PushPull;\r\n    \tATMO_GPIO_SetPinConfiguration(config->gpioInstance, config->csPin, &gpioConfig);\r\n\r\n    \tuint8_t spiByte = 0x0C;\r\n    \tif(!config->spi3Wire)\r\n    \t{\r\n    \t\tspiByte = 0x04;\r\n    \t}\r\n\r\n    \tlsm6dsm_write_reg(&_LSM6DSM_Ctx, LSM6DSM_CTRL3_C, &spiByte, 1);\r\n    }\r\n    else\r\n    {\r\n    \tATMO_I2C_Peripheral_t i2cConfig;\r\n\t\ti2cConfig.operatingMode = ATMO_I2C_OperatingMode_Master;\r\n\t\ti2cConfig.baudRate = ATMO_I2C_BaudRate_Standard_Mode;\r\n\t\tATMO_I2C_SetConfiguration(config->i2cInstance, &i2cConfig);\r\n\r\n    \t_LSM6DSM_Ctx.handle = (void*)&_LSM6DSM_PrivConfig.i2cAddress;\r\n    }\r\n\r\n    uint8_t whoamI = 0;\r\n    lsm6dsm_device_id_get(&_LSM6DSM_Ctx, &whoamI);\r\n    if ( whoamI != LSM6DSM_ID )\r\n    {\r\n        ATMO_PLATFORM_DebugPrint(\"Invalid LSM6DSM Accel WhoAmI (Rcv %02X Expect %02X\\r\\n\", whoamI, LSM6DSM_ID);\r\n        return ATMO_LSM6DSM_Status_Fail;\r\n    }\r\n\r\n\r\n    // Reset device settings\r\n    uint8_t rst = 0;\r\n    lsm6dsm_reset_set(&_LSM6DSM_Ctx, 1);\r\n    do {\r\n    \tATMO_PLATFORM_DelayMilliseconds(10);\r\n\r\n    \t// After the reset, try to set to SPI mode if needed\r\n    \tif(config->driverType.type == ATMO_DRIVERTYPE_SPI)\r\n    \t{\r\n        \tuint8_t spiByte = 0x0C;\r\n        \tif(!config->spi3Wire)\r\n        \t{\r\n        \t\tspiByte = 0x04;\r\n        \t}\r\n\r\n        \tlsm6dsm_write_reg(&_LSM6DSM_Ctx, LSM6DSM_CTRL3_C, &spiByte, 1);\r\n    \t}\r\n        lsm6dsm_reset_get(&_LSM6DSM_Ctx, &rst);\r\n    } while (rst);\r\n\r\n    // Enable block update\r\n    lsm6dsm_block_data_update_set(&_LSM6DSM_Ctx, 1);\r\n\r\n    // Set ODR\r\n    lsm6dsm_xl_data_rate_set(&_LSM6DSM_Ctx, config->accelOdr);\r\n    lsm6dsm_gy_data_rate_set(&_LSM6DSM_Ctx, config->gyroOdr);\r\n\r\n    // Set Full Scale\r\n    lsm6dsm_xl_full_scale_set(&_LSM6DSM_Ctx, config->accelFullScale);\r\n    lsm6dsm_gy_full_scale_set(&_LSM6DSM_Ctx, config->gyroFullScale);\r\n\r\n    /*\r\n    * Configure filtering chain(No aux interface).\r\n    */  \r\n    /*\r\n    * Accelerometer - analog filter.\r\n    */  \r\n    lsm6dsm_xl_filter_analog_set(&_LSM6DSM_Ctx, LSM6DSM_XL_ANA_BW_400Hz);\r\n\r\n    /*\r\n    * Accelerometer - LPF1 path ( LPF2 not used ).\r\n    */\r\n    //lsm6dsm_xl_lp1_bandwidth_set(&dev_ctx, LSM6DSM_XL_LP1_ODR_DIV_4);\r\n\r\n    /*\r\n    * Accelerometer - LPF1 + LPF2 path.\r\n    */\r\n    lsm6dsm_xl_lp2_bandwidth_set(&_LSM6DSM_Ctx, LSM6DSM_XL_LOW_NOISE_LP_ODR_DIV_100);\r\n\r\n    /*\r\n    * Accelerometer - High Pass / Slope path.\r\n    */\r\n    //lsm6dsm_xl_reference_mode_set(&dev_ctx, PROPERTY_DISABLE);\r\n    //lsm6dsm_xl_hp_bandwidth_set(&dev_ctx, LSM6DSM_XL_HP_ODR_DIV_100);\r\n\r\n    /*\r\n    * Gyroscope - filtering chain.\r\n    */\r\n    lsm6dsm_gy_band_pass_set(&_LSM6DSM_Ctx, LSM6DSM_HP_260mHz_LP1_STRONG);\r\n    \r\n \r\n    return ATMO_LSM6DSM_Status_Success;\r\n}\r\n\r\n/**\r\n * @brief Get acceleration data. Each axis is in mg\r\n * \r\n * @param data \r\n * @return ATMO_LSM6DSM_Status_t \r\n */\r\nATMO_LSM6DSM_Status_t ATMO_LSM6DSM_GetAccelData(ATMO_LSM6DSM_AccelData_t *data)\r\n{\r\n    uint8_t rawData[6] = {0};\r\n    lsm6dsm_acceleration_raw_get(&_LSM6DSM_Ctx, rawData);\r\n\r\n    int16_t rawDataInt[3] = {0};\r\n    rawDataInt[0] = (rawData[1] << 8) | rawData[0];\r\n    rawDataInt[1] = (rawData[3] << 8) | rawData[2];\r\n    rawDataInt[2] = (rawData[5] << 8) | rawData[4];\r\n\r\n    switch(_LSM6DSM_PrivConfig.accelFullScale)\r\n    {\r\n        case LSM6DSM_2g:\r\n        {\r\n            data->x = LSM6DSM_FROM_FS_2g_TO_mg( rawDataInt[0] );\r\n            data->y = LSM6DSM_FROM_FS_2g_TO_mg( rawDataInt[1] );\r\n            data->z = LSM6DSM_FROM_FS_2g_TO_mg( rawDataInt[2] );\r\n            break;\r\n        }\r\n        case LSM6DSM_4g:\r\n        {\r\n            data->x = LSM6DSM_FROM_FS_4g_TO_mg( rawDataInt[0] );\r\n            data->y = LSM6DSM_FROM_FS_4g_TO_mg( rawDataInt[1] );\r\n            data->z = LSM6DSM_FROM_FS_4g_TO_mg( rawDataInt[2] );\r\n            break;\r\n        }\r\n        case LSM6DSM_8g:\r\n        {\r\n            data->x = LSM6DSM_FROM_FS_8g_TO_mg( rawDataInt[0] );\r\n            data->y = LSM6DSM_FROM_FS_8g_TO_mg( rawDataInt[1] );\r\n            data->z = LSM6DSM_FROM_FS_8g_TO_mg( rawDataInt[2] );\r\n            break;\r\n        }\r\n        case LSM6DSM_16g:\r\n        {\r\n            data->x = LSM6DSM_FROM_FS_16g_TO_mg( rawDataInt[0] );\r\n            data->y = LSM6DSM_FROM_FS_16g_TO_mg( rawDataInt[1] );\r\n            data->z = LSM6DSM_FROM_FS_16g_TO_mg( rawDataInt[2] );\r\n            break;\r\n        }\r\n        default:\r\n        {\r\n            memset(data, 0, sizeof(ATMO_LSM6DSM_AccelData_t));\r\n            return ATMO_LSM6DSM_Status_Fail;\r\n            break;\r\n        }\r\n\r\n    }\r\n\r\n    return ATMO_LSM6DSM_Status_Success;\r\n}\r\n\r\n/**\r\n * @brief Get gyroscope data. Each axis is in mdps\r\n * \r\n * @param data \r\n * @return ATMO_LSM6DSM_Status_t \r\n */\r\nATMO_LSM6DSM_Status_t ATMO_LSM6DSM_GetGyroData(ATMO_LSM6DSM_GyroData_t *data)\r\n{\r\n    uint8_t rawData[6] = {0};\r\n    lsm6dsm_angular_rate_raw_get(&_LSM6DSM_Ctx, rawData);\r\n\r\n    int16_t rawDataInt[3] = {0};\r\n    rawDataInt[0] = (rawData[1] << 8) | rawData[0];\r\n    rawDataInt[1] = (rawData[3] << 8) | rawData[2];\r\n    rawDataInt[2] = (rawData[5] << 8) | rawData[4];\r\n\r\n    switch(_LSM6DSM_PrivConfig.gyroFullScale)\r\n    {\r\n        case LSM6DSM_125dps:\r\n        {\r\n            data->x = LSM6DSM_FROM_FS_125dps_TO_mdps(rawDataInt[0]);\r\n            data->y = LSM6DSM_FROM_FS_125dps_TO_mdps(rawDataInt[1]);\r\n            data->z = LSM6DSM_FROM_FS_125dps_TO_mdps(rawDataInt[2]);\r\n            break;\r\n        }\r\n        case LSM6DSM_250dps:\r\n        {\r\n            data->x = LSM6DSM_FROM_FS_250dps_TO_mdps(rawDataInt[0]);\r\n            data->y = LSM6DSM_FROM_FS_250dps_TO_mdps(rawDataInt[1]);\r\n            data->z = LSM6DSM_FROM_FS_250dps_TO_mdps(rawDataInt[2]);\r\n            break;\r\n        }\r\n        case LSM6DSM_500dps:\r\n        {\r\n            data->x = LSM6DSM_FROM_FS_500dps_TO_mdps(rawDataInt[0]);\r\n            data->y = LSM6DSM_FROM_FS_500dps_TO_mdps(rawDataInt[1]);\r\n            data->z = LSM6DSM_FROM_FS_500dps_TO_mdps(rawDataInt[2]);\r\n            break;\r\n        }\r\n        case LSM6DSM_1000dps:\r\n        {\r\n            data->x = LSM6DSM_FROM_FS_500dps_TO_mdps(rawDataInt[0]);\r\n            data->y = LSM6DSM_FROM_FS_500dps_TO_mdps(rawDataInt[1]);\r\n            data->z = LSM6DSM_FROM_FS_500dps_TO_mdps(rawDataInt[2]);\r\n            break;\r\n        }\r\n        case LSM6DSM_2000dps:\r\n        {\r\n            data->x = LSM6DSM_FROM_FS_500dps_TO_mdps(rawDataInt[0]);\r\n            data->y = LSM6DSM_FROM_FS_500dps_TO_mdps(rawDataInt[1]);\r\n            data->z = LSM6DSM_FROM_FS_500dps_TO_mdps(rawDataInt[2]);\r\n            break;\r\n        }\r\n        default:\r\n        {\r\n            data->x = 0;\r\n            data->y = 0;\r\n            data->z = 0;\r\n        }\r\n    }\r\n\r\n\r\n    return ATMO_LSM6DSM_Status_Success;\r\n}\r\n\r\n/**\r\n * @brief Get temperature data in degrees C\r\n * \r\n * @param data \r\n * @return ATMO_LSM6DSM_Status_t \r\n */\r\nATMO_LSM6DSM_Status_t ATMO_LSM6DSM_GetTempData(float *tempC)\r\n{\r\n    uint8_t rawData[2] = {0};\r\n    lsm6dsm_temperature_raw_get(&_LSM6DSM_Ctx, rawData);\r\n\r\n    int16_t tempDataInt = (rawData[1] << 8) | rawData[0];\r\n    *tempC = LSM6DSM_FROM_LSB_TO_degC( tempDataInt );\r\n    return ATMO_LSM6DSM_Status_Success;\r\n}\r\n",
                "lsm6dsm_reg.c": "/*\n ******************************************************************************\n * @file    lsm6dsm_reg.c\n * @author  Sensors Software Solution Team\n * @brief   LSM6DSM driver file\n ******************************************************************************\n * @attention\n *\n * <h2><center>&copy; COPYRIGHT(c) 2018 STMicroelectronics</center></h2>\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *   1. Redistributions of source code must retain the above copyright notice,\n *      this list of conditions and the following disclaimer.\n *   2. Redistributions in binary form must reproduce the above copyright notice,\n *      this list of conditions and the following disclaimer in the documentation\n *      and/or other materials provided with the distribution.\n *   3. Neither the name of STMicroelectronics nor the names of its contributors\n *      may be used to endorse or promote products derived from this software\n *      without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n#include \"lsm6dsm_reg.h\"\n\n/**\n  * @addtogroup  lsm6dsm\n  * @brief  This file provides a set of functions needed to drive the\n  *         lsm6dsm enanced inertial module.\n  * @{\n  */\n\n/**\n  * @addtogroup  interfaces_functions\n  * @brief  This section provide a set of functions used to read and write\n  *         a generic register of the device.\n  * @{\n  */\n\n/**\n  * @brief  Read generic device register\n  *\n  * @param  lsm6dsm_ctx_t* ctx: read / write interface definitions\n  * @param  uint8_t reg: register to read\n  * @param  uint8_t* data: pointer to buffer that store the data read\n  * @param  uint16_t len: number of consecutive register to read\n  *\n  */\nint32_t lsm6dsm_read_reg(lsm6dsm_ctx_t* ctx, uint8_t reg, uint8_t* data,\n                         uint16_t len)\n{\n  return ctx->read_reg(ctx->handle, reg, data, len);\n}\n\n/**\n  * @brief  Write generic device register\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t reg: register to write\n  * @param  uint8_t* data: pointer to data to write in register reg\n  * @param  uint16_t len: number of consecutive register to write\n  *\n*/\nint32_t lsm6dsm_write_reg(lsm6dsm_ctx_t* ctx, uint8_t reg, uint8_t* data,\n                          uint16_t len)\n{\n  return ctx->write_reg(ctx->handle, reg, data, len);\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  data_generation_c\n  * @brief   This section groups all the functions concerning data generation\n  * @{\n  */\n\n/**\n  * @brief  xl_full_scale: [set]  Accelerometer full-scale selection.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_fs_xl_t: change the values of fs_xl in reg CTRL1_XL\n  *\n  */\nint32_t lsm6dsm_xl_full_scale_set(lsm6dsm_ctx_t *ctx, lsm6dsm_fs_xl_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL1_XL, &reg.byte, 1);\n  reg.ctrl1_xl.fs_xl = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL1_XL, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_full_scale: [get]  Accelerometer full-scale selection.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_fs_xl_t: Get the values of fs_xl in reg CTRL1_XL\n  *\n  */\nint32_t lsm6dsm_xl_full_scale_get(lsm6dsm_ctx_t *ctx, lsm6dsm_fs_xl_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL1_XL, &reg.byte, 1);\n  *val = (lsm6dsm_fs_xl_t) reg.ctrl1_xl.fs_xl;\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_data_rate: [set]  Accelerometer UI data rate selection.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_odr_xl_t: change the values of odr_xl in reg CTRL1_XL\n  *\n  */\nint32_t lsm6dsm_xl_data_rate_set(lsm6dsm_ctx_t *ctx, lsm6dsm_odr_xl_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL1_XL, &reg.byte, 1);\n  reg.ctrl1_xl.odr_xl = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL1_XL, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_data_rate: [get]  Accelerometer UI data rate selection.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_odr_xl_t: Get the values of odr_xl in reg CTRL1_XL\n  *\n  */\nint32_t lsm6dsm_xl_data_rate_get(lsm6dsm_ctx_t *ctx, lsm6dsm_odr_xl_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL1_XL, &reg.byte, 1);\n  *val = (lsm6dsm_odr_xl_t) reg.ctrl1_xl.odr_xl;\n\n  return mm_error;\n}\n\n/**\n  * @brief  gy_full_scale: [set]  Gyroscope UI chain full-scale selection.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_fs_g_t: change the values of fs_g in reg CTRL2_G\n  *\n  */\nint32_t lsm6dsm_gy_full_scale_set(lsm6dsm_ctx_t *ctx, lsm6dsm_fs_g_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL2_G, &reg.byte, 1);\n  reg.ctrl2_g.fs_g = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL2_G, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  gy_full_scale: [get]  Gyroscope UI chain full-scale selection.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_fs_g_t: Get the values of fs_g in reg CTRL2_G\n  *\n  */\nint32_t lsm6dsm_gy_full_scale_get(lsm6dsm_ctx_t *ctx, lsm6dsm_fs_g_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL2_G, &reg.byte, 1);\n  *val = (lsm6dsm_fs_g_t) reg.ctrl2_g.fs_g;\n\n  return mm_error;\n}\n\n/**\n  * @brief  gy_data_rate: [set]  Gyroscope UI data rate selection.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_odr_g_t: change the values of odr_g in reg CTRL2_G\n  *\n  */\nint32_t lsm6dsm_gy_data_rate_set(lsm6dsm_ctx_t *ctx, lsm6dsm_odr_g_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL2_G, &reg.byte, 1);\n  reg.ctrl2_g.odr_g = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL2_G, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  gy_data_rate: [get]  Gyroscope UI data rate selection.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_odr_g_t: Get the values of odr_g in reg CTRL2_G\n  *\n  */\nint32_t lsm6dsm_gy_data_rate_get(lsm6dsm_ctx_t *ctx, lsm6dsm_odr_g_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL2_G, &reg.byte, 1);\n  *val = (lsm6dsm_odr_g_t) reg.ctrl2_g.odr_g;\n\n  return mm_error;\n}\n\n/**\n  * @brief  block_data_update: [set] Blockdataupdate.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of bdu in reg CTRL3_C\n  *\n  */\nint32_t lsm6dsm_block_data_update_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL3_C, &reg.byte, 1);\n  reg.ctrl3_c.bdu = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL3_C, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  block_data_update: [get] Blockdataupdate.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of bdu in reg CTRL3_C\n  *\n  */\nint32_t lsm6dsm_block_data_update_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL3_C, &reg.byte, 1);\n  *val = reg.ctrl3_c.bdu;\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_offset_weight: [set] Weight of XL user offset bits of\n  *                                 registers X_OFS_USR(73h), Y_OFS_USR(74h),\n  *                                 Z_OFS_USR (75h)\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_usr_off_w_t: change the values of usr_off_w in reg CTRL6_C\n  *\n  */\nint32_t lsm6dsm_xl_offset_weight_set(lsm6dsm_ctx_t *ctx,\n                                     lsm6dsm_usr_off_w_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL6_C, &reg.byte, 1);\n  reg.ctrl6_c.usr_off_w = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL6_C, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_offset_weight: [get] Weight of XL user offset bits of\n  *                                 registers X_OFS_USR(73h), Y_OFS_USR(74h),\n  *                                 Z_OFS_USR(75h)\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_usr_off_w_t: Get the values of usr_off_w in reg CTRL6_C\n  *\n  */\nint32_t lsm6dsm_xl_offset_weight_get(lsm6dsm_ctx_t *ctx,\n                                     lsm6dsm_usr_off_w_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL6_C, &reg.byte, 1);\n  *val = (lsm6dsm_usr_off_w_t) reg.ctrl6_c.usr_off_w;\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_power_mode: [set] High-performance operating mode\n  *                              for accelerometer\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_xl_hm_mode_t: change the values of xl_hm_mode\n  *                               in reg CTRL6_C\n  *\n  */\nint32_t lsm6dsm_xl_power_mode_set(lsm6dsm_ctx_t *ctx, lsm6dsm_xl_hm_mode_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL6_C, &reg.byte, 1);\n  reg.ctrl6_c.xl_hm_mode = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL6_C, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_power_mode: [get] High-performance operating mode\n  *                              for accelerometer\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_xl_hm_mode_t: Get the values of xl_hm_mode in reg CTRL6_C\n  *\n  */\nint32_t lsm6dsm_xl_power_mode_get(lsm6dsm_ctx_t *ctx,\n                                  lsm6dsm_xl_hm_mode_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL6_C, &reg.byte, 1);\n  *val = (lsm6dsm_xl_hm_mode_t) reg.ctrl6_c.xl_hm_mode;\n\n  return mm_error;\n}\n\n/**\n  * @brief  rounding_on_status: [set] Source register rounding function\n  *                                   on WAKE_UP_SRC (1Bh), TAP_SRC (1Ch),\n  *                                   D6D_SRC (1Dh), STATUS_REG (1Eh) and\n  *                                   FUNC_SRC1 (53h) registers in the\n  *                                   primary interface\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_rounding_status_t: change the values of rounding_status\n  *                                    in reg CTRL7_G\n  *\n  */\nint32_t lsm6dsm_rounding_on_status_set(lsm6dsm_ctx_t *ctx,\n                                       lsm6dsm_rounding_status_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL7_G, &reg.byte, 1);\n  reg.ctrl7_g.rounding_status = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL7_G, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  rounding_on_status: [get] Source register rounding function\n  *                                   on WAKE_UP_SRC (1Bh), TAP_SRC (1Ch),\n  *                                   D6D_SRC (1Dh), STATUS_REG (1Eh) and\n  *                                   FUNC_SRC1 (53h) registers in the\n  *                                   primary interface\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_rounding_status_t: Get the values of rounding_status\n  *                                    in reg CTRL7_G\n  *\n  */\nint32_t lsm6dsm_rounding_on_status_get(lsm6dsm_ctx_t *ctx,\n                                       lsm6dsm_rounding_status_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL7_G, &reg.byte, 1);\n  *val = (lsm6dsm_rounding_status_t) reg.ctrl7_g.rounding_status;\n\n  return mm_error;\n}\n\n/**\n  * @brief  gy_power_mode: [set] High-performance operating mode\n  *                              disable for gyroscope.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_g_hm_mode_t: change the values of g_hm_mode in reg CTRL7_G\n  *\n  */\nint32_t lsm6dsm_gy_power_mode_set(lsm6dsm_ctx_t *ctx, lsm6dsm_g_hm_mode_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL7_G, &reg.byte, 1);\n  reg.ctrl7_g.g_hm_mode = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL7_G, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  gy_power_mode: [get] High-performance operating mode\n  *                              disable for gyroscope.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_g_hm_mode_t: Get the values of g_hm_mode in reg CTRL7_G\n  *\n  */\nint32_t lsm6dsm_gy_power_mode_get(lsm6dsm_ctx_t *ctx, lsm6dsm_g_hm_mode_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL7_G, &reg.byte, 1);\n  *val = (lsm6dsm_g_hm_mode_t) reg.ctrl7_g.g_hm_mode;\n\n  return mm_error;\n}\n\n/**\n  * @brief  all_sources: [get] Read all the interrupt/status flag of\n  *                            the device.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_all_sources: WAKE_UP_SRC, TAP_SRC, D6D_SRC, STATUS_REG,\n  *                              FUNC_SRC1, FUNC_SRC2, WRIST_TILT_IA,\n  *                              A_WRIST_TILT_Mask\n  *\n  */\nint32_t lsm6dsm_all_sources_get(lsm6dsm_ctx_t *ctx, lsm6dsm_all_sources_t *val)\n{\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_WAKE_UP_SRC, &(val->byte[0]), 4);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_FUNC_SRC1, &(val->byte[4]), 3);\n  \n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_B);  \n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_A_WRIST_TILT_MASK,\n                              &(val->byte[7]), 1);\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @brief  status_reg: [get] The STATUS_REG register is read by the\n  *                           primary interface\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  status_reg_t: registers STATUS_REG\n  *\n  */\nint32_t lsm6dsm_status_reg_get(lsm6dsm_ctx_t *ctx, lsm6dsm_status_reg_t *val)\n{\n  return lsm6dsm_read_reg(ctx, LSM6DSM_STATUS_REG, (uint8_t*) val, 1);\n}\n\n/**\n  * @brief  xl_flag_data_ready: [get]  Accelerometer new data available.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of xlda in reg STATUS_REG\n  *\n  */\nint32_t lsm6dsm_xl_flag_data_ready_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_STATUS_REG, &reg.byte, 1);\n  *val = reg.status_reg.xlda;\n\n  return mm_error;\n}\n\n/**\n  * @brief  gy_flag_data_ready: [get]  Gyroscope new data available.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of gda in reg STATUS_REG\n  *\n  */\nint32_t lsm6dsm_gy_flag_data_ready_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_STATUS_REG, &reg.byte, 1);\n  *val = reg.status_reg.gda;\n\n  return mm_error;\n}\n\n/**\n  * @brief   temp_flag_data_ready: [get]  Temperature new data available.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of tda in reg STATUS_REG\n  *\n  */\nint32_t lsm6dsm_temp_flag_data_ready_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_STATUS_REG, &reg.byte, 1);\n  *val = reg.status_reg.tda;\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_usr_offset: [set] Accelerometer axis user offset correction\n  *                              expressed in twos complement, weight\n  *                              depends on USR_OFF_W in CTRL6_C.\n  *                              The value must be in the range [-127 127].\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that contains data to write\n  *\n  */\nint32_t lsm6dsm_xl_usr_offset_set(lsm6dsm_ctx_t *ctx, uint8_t *buff)\n{\n  return lsm6dsm_write_reg(ctx, LSM6DSM_X_OFS_USR, buff, 3);\n}\n\n/**\n  * @brief  xl_usr_offset: [get] Accelerometer axis user offset correction\n  *                              expressed in twos complement, weight\n  *                              depends on USR_OFF_W in CTRL6_C.\n  *                              The value must be in the range [-127 127].\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lsm6dsm_xl_usr_offset_get(lsm6dsm_ctx_t *ctx, uint8_t *buff)\n{\n  return lsm6dsm_read_reg(ctx, LSM6DSM_X_OFS_USR, buff, 3);\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  Timestamp\n  * @brief   This section groups all the functions that manage the\n  *          timestamp generation.\n  * @{\n  */\n\n/**\n  * @brief  timestamp: [set] Enable timestamp count. The count is saved in\n  *                          TIMESTAMP0_REG (40h), TIMESTAMP1_REG (41h)\n  *                          and TIMESTAMP2_REG (42h).\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of timer_en in reg CTRL10_C\n  *\n  */\nint32_t lsm6dsm_timestamp_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL10_C, &reg.byte, 1);\n  reg.ctrl10_c.timer_en = val;\n  if (val) {\n    reg.ctrl10_c.func_en = val;\n  }\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL10_C, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  timestamp: [get] Enable timestamp count. The count is saved\n  *                          in TIMESTAMP0_REG (40h), TIMESTAMP1_REG (41h)\n  *                          and TIMESTAMP2_REG (42h).\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of timer_en in reg CTRL10_C\n  *\n  */\nint32_t lsm6dsm_timestamp_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL10_C, &reg.byte, 1);\n  *val = reg.ctrl10_c.timer_en;\n\n  return mm_error;\n}\n\n/**\n  * @brief  timestamp_res: [set] Timestamp register resolution setting.\n  *                              Configuration of this bit affects\n  *                              TIMESTAMP0_REG(40h), TIMESTAMP1_REG(41h),\n  *                              TIMESTAMP2_REG(42h), STEP_TIMESTAMP_L(49h),\n  *                              STEP_TIMESTAMP_H(4Ah) and\n  *                              STEP_COUNT_DELTA(15h) registers.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_timer_hr_t: change the values of timer_hr in\n  *                             reg WAKE_UP_DUR\n  *\n  */\nint32_t lsm6dsm_timestamp_res_set(lsm6dsm_ctx_t *ctx, lsm6dsm_timer_hr_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_WAKE_UP_DUR, &reg.byte, 1);\n  reg.wake_up_dur.timer_hr = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_WAKE_UP_DUR, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  timestamp_res: [get] Timestamp register resolution setting.\n  *                              Configuration of this bit affects\n  *                              TIMESTAMP0_REG(40h), TIMESTAMP1_REG(41h),\n  *                              TIMESTAMP2_REG(42h), STEP_TIMESTAMP_L(49h),\n  *                              STEP_TIMESTAMP_H(4Ah) and\n  *                              STEP_COUNT_DELTA(15h) registers.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_timer_hr_t: Get the values of timer_hr in reg WAKE_UP_DUR\n  *\n  */\nint32_t lsm6dsm_timestamp_res_get(lsm6dsm_ctx_t *ctx, lsm6dsm_timer_hr_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_WAKE_UP_DUR, &reg.byte, 1);\n  *val = (lsm6dsm_timer_hr_t) reg.wake_up_dur.timer_hr;\n\n  return mm_error;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  Dataoutput\n  * @brief   This section groups all the data output functions.\n  * @{\n  */\n\n/**\n  * @brief  rounding_mode: [set] Circular burst-mode (rounding) read from\n  *                              output registers through the primary interface.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_rounding_t: change the values of rounding in reg CTRL5_C\n  *\n  */\nint32_t lsm6dsm_rounding_mode_set(lsm6dsm_ctx_t *ctx, lsm6dsm_rounding_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL5_C, &reg.byte, 1);\n  reg.ctrl5_c.rounding = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL5_C, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  rounding_mode: [get] Circular burst-mode (rounding) read from\n  *                              output registers through the primary\n  *                              interface.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_rounding_t: Get the values of rounding in reg CTRL5_C\n  *\n  */\nint32_t lsm6dsm_rounding_mode_get(lsm6dsm_ctx_t *ctx, lsm6dsm_rounding_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL5_C, &reg.byte, 1);\n  *val = (lsm6dsm_rounding_t) reg.ctrl5_c.rounding;\n\n  return mm_error;\n}\n\n/**\n  * @brief  temperature_raw: [get] Temperature data output register (r).\n  *                                L and H registers together express a 16-bit\n  *                                word in twos complement.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lsm6dsm_temperature_raw_get(lsm6dsm_ctx_t *ctx, uint8_t *buff)\n{\n  return lsm6dsm_read_reg(ctx, LSM6DSM_OUT_TEMP_L, buff, 2);\n}\n\n/**\n  * @brief  angular_rate_raw: [get] Angular rate sensor. The value is\n  *                                 expressed as a 16-bit word in\n  *                                 twos complement.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lsm6dsm_angular_rate_raw_get(lsm6dsm_ctx_t *ctx, uint8_t *buff)\n{\n  return lsm6dsm_read_reg(ctx, LSM6DSM_OUTX_L_G, buff, 6);\n}\n\n/**\n  * @brief  acceleration_raw: [get] Linear acceleration output register.\n  *                                 The value is expressed as a 16-bit word\n  *                                 in twos complement.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lsm6dsm_acceleration_raw_get(lsm6dsm_ctx_t *ctx, uint8_t *buff)\n{\n  return lsm6dsm_read_reg(ctx, LSM6DSM_OUTX_L_XL, buff, 6);\n}\n\n/**\n  * @brief  mag_calibrated_raw: [get]  External magnetometer raw data\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lsm6dsm_mag_calibrated_raw_get(lsm6dsm_ctx_t *ctx, uint8_t *buff)\n{\n  return lsm6dsm_read_reg(ctx, LSM6DSM_OUT_MAG_RAW_X_L, buff, 6);\n}\n\n/**\n  * @brief   fifo_raw_data: [get]  read data in FIFO.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t *: data buffer to store FIFO data.\n  * @param  uint8_t : number of data to read from FIFO.\n  *\n  */\nint32_t lsm6dsm_fifo_raw_data_get(lsm6dsm_ctx_t *ctx, uint8_t *buffer, uint8_t len)\n{\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_FIFO_DATA_OUT_L, buffer, len);\n\n  return mm_error;\n}\n\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  common\n  * @brief   This section groups common usefull functions.\n  * @{\n  */\n\n/**\n  * @brief  mem_bank: [set] Enable access to the embedded\n  *                         functions/sensor hub configuration registers\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_func_cfg_en_t: change the values of func_cfg_en in\n  *                                reg FUNC_CFG_ACCESS\n  *\n  */\nint32_t lsm6dsm_mem_bank_set(lsm6dsm_ctx_t *ctx, lsm6dsm_func_cfg_en_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_FUNC_CFG_ACCESS, &reg.byte, 1);\n  reg.func_cfg_access.func_cfg_en = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_FUNC_CFG_ACCESS, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  mem_bank: [get] Enable access to the embedded functions/sensor\n  *                         hub configuration registers\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_func_cfg_en_t: Get the values of func_cfg_en in\n  *                                reg FUNC_CFG_ACCESS\n  *\n  */\nint32_t lsm6dsm_mem_bank_get(lsm6dsm_ctx_t *ctx, lsm6dsm_func_cfg_en_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_FUNC_CFG_ACCESS, &reg.byte, 1);\n  *val = (lsm6dsm_func_cfg_en_t) reg.func_cfg_access.func_cfg_en;\n\n  return mm_error;\n}\n\n/**\n  * @brief  data_ready_mode: [set]  data-ready pulsed / letched mode\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_drdy_pulsed_t: change the values of drdy_pulsed in\n  *                                reg DRDY_PULSE_CFG\n  *\n  */\nint32_t lsm6dsm_data_ready_mode_set(lsm6dsm_ctx_t *ctx,\n                                    lsm6dsm_drdy_pulsed_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_DRDY_PULSE_CFG, &reg.byte, 1);\n  reg.drdy_pulse_cfg.drdy_pulsed = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_DRDY_PULSE_CFG, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  data_ready_mode: [get]  data-ready pulsed / letched mode\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_drdy_pulsed_t: Get the values of drdy_pulsed\n  *                                in reg DRDY_PULSE_CFG\n  *\n  */\nint32_t lsm6dsm_data_ready_mode_get(lsm6dsm_ctx_t *ctx,\n                                    lsm6dsm_drdy_pulsed_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_DRDY_PULSE_CFG, &reg.byte, 1);\n  *val = (lsm6dsm_drdy_pulsed_t) reg.drdy_pulse_cfg.drdy_pulsed;\n\n  return mm_error;\n}\n\n/**\n  * @brief  device_id: [get] DeviceWhoamI.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lsm6dsm_device_id_get(lsm6dsm_ctx_t *ctx, uint8_t *buff)\n{\n  return lsm6dsm_read_reg(ctx, LSM6DSM_WHO_AM_I, buff, 1);\n}\n\n/**\n  * @brief  reset: [set] Software reset. Restore the default\n  *                      values in user registers\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of sw_reset in reg CTRL3_C\n  *\n  */\nint32_t lsm6dsm_reset_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL3_C, &reg.byte, 1);\n  reg.ctrl3_c.sw_reset = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL3_C, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  reset: [get] Software reset. Restore the default\n  *                      values in user registers\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of sw_reset in reg CTRL3_C\n  *\n  */\nint32_t lsm6dsm_reset_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL3_C, &reg.byte, 1);\n  *val = reg.ctrl3_c.sw_reset;\n\n  return mm_error;\n}\n\n/**\n  * @brief  data_format: [set]  Big/Little Endian Data selection.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_ble_t: change the values of ble in reg CTRL3_C\n  *\n  */\nint32_t lsm6dsm_data_format_set(lsm6dsm_ctx_t *ctx, lsm6dsm_ble_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL3_C, &reg.byte, 1);\n  reg.ctrl3_c.ble = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL3_C, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  data_format: [get]  Big/Little Endian Data selection.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_ble_t: Get the values of ble in reg CTRL3_C\n  *\n  */\nint32_t lsm6dsm_data_format_get(lsm6dsm_ctx_t *ctx, lsm6dsm_ble_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL3_C, &reg.byte, 1);\n  *val = (lsm6dsm_ble_t) reg.ctrl3_c.ble;\n\n  return mm_error;\n}\n\n/**\n  * @brief  auto_increment: [set] Register address automatically incremented\n  *                               during a multiple byte access with a\n  *                               serial interface.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of if_inc in reg CTRL3_C\n  *\n  */\nint32_t lsm6dsm_auto_increment_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL3_C, &reg.byte, 1);\n  reg.ctrl3_c.if_inc = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL3_C, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  auto_increment: [get] Register address automatically incremented\n  *                               during a multiple byte access with a\n  *                               serial interface.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of if_inc in reg CTRL3_C\n  *\n  */\nint32_t lsm6dsm_auto_increment_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL3_C, &reg.byte, 1);\n  *val = reg.ctrl3_c.if_inc;\n\n  return mm_error;\n}\n\n/**\n  * @brief  boot: [set] Reboot memory content. Reload the calibration\n  *                     parameters.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of boot in reg CTRL3_C\n  *\n  */\nint32_t lsm6dsm_boot_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL3_C, &reg.byte, 1);\n  reg.ctrl3_c.boot = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL3_C, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  boot: [get] Reboot memory content. Reload the calibration\n  *                     parameters.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of boot in reg CTRL3_C\n  *\n  */\nint32_t lsm6dsm_boot_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL3_C, &reg.byte, 1);\n  *val = reg.ctrl3_c.boot;\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_self_test: [set]  Linear acceleration sensor self-test enable.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_st_xl_t: change the values of st_xl in reg CTRL5_C\n  *\n  */\nint32_t lsm6dsm_xl_self_test_set(lsm6dsm_ctx_t *ctx, lsm6dsm_st_xl_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL5_C, &reg.byte, 1);\n  reg.ctrl5_c.st_xl = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL5_C, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_self_test: [get]  Linear acceleration sensor self-test enable.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_st_xl_t: Get the values of st_xl in reg CTRL5_C\n  *\n  */\nint32_t lsm6dsm_xl_self_test_get(lsm6dsm_ctx_t *ctx, lsm6dsm_st_xl_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL5_C, &reg.byte, 1);\n  *val = (lsm6dsm_st_xl_t) reg.ctrl5_c.st_xl;\n\n  return mm_error;\n}\n\n/**\n  * @brief  gy_self_test: [set]  Angular rate sensor self-test enable.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_st_g_t: change the values of st_g in reg CTRL5_C\n  *\n  */\nint32_t lsm6dsm_gy_self_test_set(lsm6dsm_ctx_t *ctx, lsm6dsm_st_g_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL5_C, &reg.byte, 1);\n  reg.ctrl5_c.st_g = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL5_C, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  gy_self_test: [get]  Angular rate sensor self-test enable.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_st_g_t: Get the values of st_g in reg CTRL5_C\n  *\n  */\nint32_t lsm6dsm_gy_self_test_get(lsm6dsm_ctx_t *ctx, lsm6dsm_st_g_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL5_C, &reg.byte, 1);\n  *val = (lsm6dsm_st_g_t) reg.ctrl5_c.st_g;\n\n  return mm_error;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  filters\n  * @brief   This section group all the functions concerning the filters\n  *          configuration that impact both accelerometer and gyro.\n  * @{\n  */\n\n/**\n  * @brief   filter_settling_mask: [set] Mask DRDY on pin (both XL & Gyro)\n  *                                      until filter settling ends\n  *                                      (XL and Gyro independently masked).\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of drdy_mask in reg CTRL4_C\n  *\n  */\nint32_t lsm6dsm_filter_settling_mask_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL4_C, &reg.byte, 1);\n  reg.ctrl4_c.drdy_mask = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL4_C, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief   filter_settling_mask: [get] Mask DRDY on pin (both XL & Gyro)\n  *                                      until filter settling ends\n  *                                      (XL and Gyro independently masked).\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of drdy_mask in reg CTRL4_C\n  *\n  */\nint32_t lsm6dsm_filter_settling_mask_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL4_C, &reg.byte, 1);\n  *val = reg.ctrl4_c.drdy_mask;\n\n  return mm_error;\n}\n\n/**\n  * @brief   xl_hp_path_internal: [set] HPF or SLOPE filter selection on\n  *                                     wake-up and Activity/Inactivity\n  *                                     functions.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_slope_fds_t: change the values of slope_fds in reg TAP_CFG\n  *\n  */\nint32_t lsm6dsm_xl_hp_path_internal_set(lsm6dsm_ctx_t *ctx,\n                                        lsm6dsm_slope_fds_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_TAP_CFG, &reg.byte, 1);\n  reg.tap_cfg.slope_fds = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_TAP_CFG, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief   xl_hp_path_internal: [get] HPF or SLOPE filter selection on\n  *                                     wake-up and Activity/Inactivity\n  *                                     functions.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_slope_fds_t: Get the values of slope_fds in reg TAP_CFG\n  *\n  */\nint32_t lsm6dsm_xl_hp_path_internal_get(lsm6dsm_ctx_t *ctx,\n                                        lsm6dsm_slope_fds_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_TAP_CFG, &reg.byte, 1);\n  *val = (lsm6dsm_slope_fds_t) reg.tap_cfg.slope_fds;\n\n  return mm_error;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup   accelerometer_filters\n  * @brief   This section group all the functions concerning the filters\n  *          configuration that impact accelerometer in every mode.\n  * @{\n  */\n\n/**\n  * @brief  xl_filter_analog: [set] Accelerometer analog chain bandwidth\n  *                                 selection (only for accelerometer\n  *                                 ODR  1.67 kHz).\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_bw0_xl_t: change the values of bw0_xl in reg CTRL1_XL\n  *\n  */\nint32_t lsm6dsm_xl_filter_analog_set(lsm6dsm_ctx_t *ctx, lsm6dsm_bw0_xl_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL1_XL, &reg.byte, 1);\n  reg.ctrl1_xl.bw0_xl = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL1_XL, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_filter_analog: [get] Accelerometer analog chain bandwidth\n  *                                 selection (only for accelerometer\n  *                                 ODR  1.67 kHz).\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_bw0_xl_t: Get the values of bw0_xl in reg CTRL1_XL\n  *\n  */\nint32_t lsm6dsm_xl_filter_analog_get(lsm6dsm_ctx_t *ctx,\n                                     lsm6dsm_bw0_xl_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL1_XL, &reg.byte, 1);\n  *val = (lsm6dsm_bw0_xl_t) reg.ctrl1_xl.bw0_xl;\n\n  return mm_error;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup   accelerometer_filters_mode:1,2,3\n  * @brief   This section group all the functions concerning the filters\n  *          configuration that impact accelerometer mode 1, 2, 3\n  *          (accelerometer on aux interface disable).\n  * @{\n  */\n\n/**\n  * @brief  xl_lp1_bandwidth: [set] Accelerometer digital LPF (LPF1)\n  *                                 bandwidth selection LPF2 is not used.\n  *                                 Only for mode 1, 2, 3.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_lpf1_bw_sel_t: change the values of lpf1_bw_sel in\n  *                                reg CTRL1_XL\n  *\n  */\nint32_t lsm6dsm_xl_lp1_bandwidth_set(lsm6dsm_ctx_t *ctx,\n                                     lsm6dsm_lpf1_bw_sel_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL1_XL, &reg.byte, 1);\n  reg.ctrl1_xl.lpf1_bw_sel = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL1_XL, &reg.byte, 1);\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL8_XL, &reg.byte, 1);\n  reg.ctrl8_xl.lpf2_xl_en = 0;\n  reg.ctrl8_xl.hp_slope_xl_en = 0;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL8_XL, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_lp1_bandwidth: [get] Accelerometer digital LPF (LPF1)\n  *                                 bandwidth selection LPF2 is not used.\n  *                                 Only for mode 1, 2, 3.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_lpf1_bw_sel_t: Get the values of lpf1_bw_sel in\n  *                                reg CTRL1_XL\n  *\n  */\nint32_t lsm6dsm_xl_lp1_bandwidth_get(lsm6dsm_ctx_t *ctx,\n                                     lsm6dsm_lpf1_bw_sel_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL8_XL, &reg.byte, 1);\n  if (reg.ctrl8_xl.lpf2_xl_en || reg.ctrl8_xl.hp_slope_xl_en){\n    *val = LSM6DSM_XL_LP1_NA;\n  }\n  else{\n    mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL1_XL, &reg.byte, 1);\n    *val = (lsm6dsm_lpf1_bw_sel_t) reg.ctrl1_xl.lpf1_bw_sel;\n  }\n  return mm_error;\n}\n\n/**\n  * @brief  xl_lp2_bandwidth: [set] LPF2onoutputs\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_input_composite_t: change the values of\n  *                                    input_composite in reg CTRL8_XL\n  *\n  */\nint32_t lsm6dsm_xl_lp2_bandwidth_set(lsm6dsm_ctx_t *ctx,\n                                     lsm6dsm_input_composite_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL8_XL, &reg.byte, 1);\n  reg.ctrl8_xl.input_composite = ( val & 0x10 ) >> 4;\n  reg.ctrl8_xl.hpcf_xl = val & 0x03;\n  reg.ctrl8_xl.lpf2_xl_en = 1;\n  reg.ctrl8_xl.hp_slope_xl_en = 0;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL8_XL, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_lp2_bandwidth: [get] LPF2onoutputs\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_input_composite_t: Get the values of\n  *                                    input_composite in reg CTRL8_XL\n  *\n  */\nint32_t lsm6dsm_xl_lp2_bandwidth_get(lsm6dsm_ctx_t *ctx,\n                                     lsm6dsm_input_composite_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL8_XL, &reg.byte, 1);\n  if ( (!reg.ctrl8_xl.lpf2_xl_en) || reg.ctrl8_xl.hp_slope_xl_en){\n    *val = LSM6DSM_XL_LP_NA;\n  }\n  else{\n    *val = (lsm6dsm_input_composite_t) ((reg.ctrl8_xl.input_composite << 4) +\n                                        reg.ctrl8_xl.hpcf_xl);\n  }\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_reference_mode: [set]  Enable HP filter reference mode.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of hp_ref_mode in reg CTRL8_XL\n  *\n  */\nint32_t lsm6dsm_xl_reference_mode_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL8_XL, &reg.byte, 1);\n  reg.ctrl8_xl.hp_ref_mode = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL8_XL, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_reference_mode: [get]  Enable HP filter reference mode.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of hp_ref_mode in reg CTRL8_XL\n  *\n  */\nint32_t lsm6dsm_xl_reference_mode_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL8_XL, &reg.byte, 1);\n  *val = reg.ctrl8_xl.hp_ref_mode;\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_hp_bandwidth: [set]  High pass/Slope on outputs.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_hpcf_xl_t: change the values of hpcf_xl in reg CTRL8_XL\n  *\n  */\nint32_t lsm6dsm_xl_hp_bandwidth_set(lsm6dsm_ctx_t *ctx, lsm6dsm_hpcf_xl_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL8_XL, &reg.byte, 1);\n  reg.ctrl8_xl.input_composite = 0;\n  reg.ctrl8_xl.hpcf_xl = val & 0x03;\n  reg.ctrl8_xl.hp_slope_xl_en = 1;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL8_XL, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_hp_bandwidth: [get]  High pass/Slope on outputs.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_hpcf_xl_t: Get the values of hpcf_xl in reg CTRL8_XL\n  *\n  */\nint32_t lsm6dsm_xl_hp_bandwidth_get(lsm6dsm_ctx_t *ctx, lsm6dsm_hpcf_xl_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL8_XL, &reg.byte, 1);\n  if (!reg.ctrl8_xl.hp_slope_xl_en){\n    *val = LSM6DSM_XL_HP_NA;\n  }\n  else{\n    *val = (lsm6dsm_hpcf_xl_t) reg.ctrl8_xl.hpcf_xl;\n  }\n\n  return mm_error;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup   accelerometer_filters_mode:4\n  * @brief   This section group all the functions concerning the filters\n  *          configuration that impact accelerometer when mode 4\n  *          (accelerometer on aux interface enable).\n  * @{\n  */\n\n/**\n  * @brief   xl_ui_lp1_bandwidth: [set] Accelerometer digital LPF (LPF1)\n  *                                     bandwidth selection. Only for mode 4.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_lpf1_bw_sel_t: change the values of lpf1_bw_sel in\n  *                                reg CTRL1_XL\n  *\n  */\nint32_t lsm6dsm_xl_ui_lp1_bandwidth_set(lsm6dsm_ctx_t *ctx,\n                                        lsm6dsm_ui_lpf1_bw_sel_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL1_XL, &reg.byte, 1);\n  reg.ctrl1_xl.lpf1_bw_sel = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL1_XL, &reg.byte, 1);\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL8_XL, &reg.byte, 1);\n  reg.ctrl8_xl.hp_slope_xl_en = 0;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL8_XL, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief   xl_ui_lp1_bandwidth: [get] Accelerometer digital LPF (LPF1)\n  *                                     bandwidth selection. Only for mode 4.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_lpf1_bw_sel_t: Get the values of lpf1_bw_sel in\n  *                                reg CTRL1_XL\n  *\n  */\nint32_t lsm6dsm_xl_ui_lp1_bandwidth_get(lsm6dsm_ctx_t *ctx,\n                                        lsm6dsm_ui_lpf1_bw_sel_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL8_XL, &reg.byte, 1);\n  if (reg.ctrl8_xl.hp_slope_xl_en){\n    *val = LSM6DSM_XL_UI_LP1_NA;\n  }\n  else{\n    mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL1_XL, &reg.byte, 1);\n    *val = (lsm6dsm_ui_lpf1_bw_sel_t) reg.ctrl1_xl.lpf1_bw_sel;\n  }\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_ui_slope: [set]  Slope filter on outputs\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of hp_slope_xl_en in reg CTRL8_XL\n  *\n  */\nint32_t lsm6dsm_xl_ui_slope_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL8_XL, &reg.byte, 1);\n  reg.ctrl8_xl.hp_slope_xl_en = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL8_XL, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  xl_ui_slope: [get]  Slope filter on outputs\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t *val: Get the values of hp_slope_xl_en in reg CTRL8_XL\n  *\n  */\nint32_t lsm6dsm_xl_ui_slope_get(lsm6dsm_ctx_t *ctx,  uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL8_XL, &reg.byte, 1);\n  *val = reg.ctrl8_xl.hp_slope_xl_en;\n\n  return mm_error;\n}\n\n/**\n  * @brief   xl_aux_lp_bandwidth: [set]\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  filter_xl_conf_ois_t: change the values of filter_xl_conf_ois\n  *                               in reg CTRL3_OIS\n  * Cut off feq [ODR_UI = 0 / ODR UI  1600 Hz]\n  * LIGHT      636   Hz  2.96\n  * NORMAL     295   Hz  5.12\n  * STRONG     140   Hz  9.39\n  * AGGRESSIVE  68.2 Hz 17.6\n  *\n  * Cut off feq [ODR UI  800 Hz ]\n  * LIGHT      329   Hz  5.08\n  * NORMAL     222   Hz  7.23\n  * STRONG     128   Hz 11.5\n  * AGGRESSIVE  66.5 Hz 19.7\n  *\n  */\nint32_t lsm6dsm_xl_aux_lp_bandwidth_set(lsm6dsm_ctx_t *ctx,\n                                        lsm6dsm_filter_xl_conf_ois_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL3_OIS, &reg.byte, 1);\n  reg.ctrl3_ois.filter_xl_conf_ois = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL3_OIS, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief   xl_aux_lp_bandwidth: [get]\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_filter_xl_conf_ois_t: Get the values of filter_xl_conf_ois\n  *                                       in reg CTRL3_OIS\n  *\n  * Cut off feq [ODR_UI = 0 / ODR UI  1600 Hz]\n  * LIGHT      636   Hz  2.96\n  * NORMAL     295   Hz  5.12\n  * STRONG     140   Hz  9.39\n  * AGGRESSIVE  68.2 Hz 17.6\n  *\n  * Cut off feq [ODR UI  800 Hz ]\n  * LIGHT      329   Hz  5.08\n  * NORMAL     222   Hz  7.23\n  * STRONG     128   Hz 11.5\n  * AGGRESSIVE  66.5 Hz 19.7\n  *\n  *\n  */\nint32_t lsm6dsm_xl_aux_lp_bandwidth_get(lsm6dsm_ctx_t *ctx,\n                                        lsm6dsm_filter_xl_conf_ois_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL3_OIS, &reg.byte, 1);\n  *val = (lsm6dsm_filter_xl_conf_ois_t) reg.ctrl3_ois.filter_xl_conf_ois;\n\n  return mm_error;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup   gyroscope_filters_mode:1,2\n  * @brief   This section group all the functions concerning the filters\n  *          configuration that impact gyroscope mode 1, 2\n  *          (gyroscope on aux interface disable).\n  * @{\n  */\n\n/**\n  * @brief  gy_band_pass: [set] Gyroscope low pass path bandwidth.\n  *                             Only Mode: 1, 2.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_lpf1_sel_g_t: gyroscope filtering chain configurationin\n  *                               Mode: 1, 2.\n  *\n  */\nint32_t lsm6dsm_gy_band_pass_set(lsm6dsm_ctx_t *ctx, lsm6dsm_lpf1_sel_g_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL7_G, &reg.byte, 1);\n  reg.ctrl7_g.hpm_g  = ( val & 0x30 ) >> 4;\n  reg.ctrl7_g.hp_en_g = ( val & 0x80 ) >> 7;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL7_G, &reg.byte, 1);\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL6_C, &reg.byte, 1);\n  reg.ctrl6_c.ftype = val & 0x03;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL6_C, &reg.byte, 1);\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL4_C, &reg.byte, 1);\n  reg.ctrl4_c.lpf1_sel_g = ( val & 0x08 ) >> 3;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL4_C, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  gy_band_pass: [get] Gyroscope low pass path bandwidth.\n  *                             Only Mode: 1, 2.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_lpf1_sel_g_t: gyroscope filtering chain\n  *                               configurationin Mode: 1, 2.\n  *\n  */\nint32_t lsm6dsm_gy_band_pass_get(lsm6dsm_ctx_t *ctx, lsm6dsm_lpf1_sel_g_t *val)\n{\n  lsm6dsm_reg_t reg[3];\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL6_C, &reg[0].byte, 1);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL4_C, &reg[1].byte, 1);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL7_G, &reg[2].byte, 1);\n\n  *val = (lsm6dsm_lpf1_sel_g_t) ( ( reg[2].ctrl7_g.hp_en_g << 7 )   +\n                                  ( reg[2].ctrl7_g.hpm_g << 4 )     +\n                                  ( reg[1].ctrl4_c.lpf1_sel_g << 3) +\n                                    reg[0].ctrl6_c.ftype );\n\n  if (!reg[2].ctrl7_g.hp_en_g){\n    *val &= 0x0F;\n  }\n  if(!reg[1].ctrl4_c.lpf1_sel_g){\n    *val &= 0xF0;\n  }\n\n  return mm_error;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup   gyroscope_filters_mode:3,4\n  * @brief   This section group all the functions concerning the filters\n  *          configuration that impact gyroscope when mode 3, 4\n  *          (gyroscope on aux interface enable).\n  * @{\n  */\n\n/**\n  * @brief  gy_ui_high_pass: [set] HPF is available on gyroscope's OIS\n  *                                chain only if HP_EN_G in CTRL7_G (16h)\n  *                                is set to '0'\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  hp_en_g_t: gyroscope ui filtering chain configuration in\n  *                    Mode: 3, 4.\n  *\n  */\nint32_t lsm6dsm_gy_ui_high_pass_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL7_G, &reg.byte, 1);\n  reg.ctrl7_g.hp_en_g = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL7_G, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  gy_ui_high_pass: [get] HPF is available on gyroscope's OIS\n  *                                chain only if HP_EN_G in CTRL7_G (16h)\n  *                                is set to '0'\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  hp_en_g_t: gyroscope ui filtering chain configuration in\n  *                    Mode: 3, 4.\n  *\n  */\nint32_t lsm6dsm_gy_ui_high_pass_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL7_G, &reg.byte, 1);\n\n  *val = reg.ctrl7_g.hp_en_g;\n\n  return mm_error;\n}\n\n\n/**\n  * @brief  gy_aux_bandwidth: [set] HPF is available on gyroscope's OIS chain\n  *                                 only if HP_EN_G in CTRL7_G (16h) is set\n  *                                 to '0'\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  hp_en_ois_t: gyroscope aux (ois) filtering chain configuration in\n  *                      Mode: 3, 4.\n  *\n  */\nint32_t lsm6dsm_gy_aux_bandwidth_set(lsm6dsm_ctx_t *ctx,\n                                     lsm6dsm_hp_en_ois_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL7_G, &reg.byte, 1);\n  reg.ctrl7_g.hp_en_g = 0;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL7_G, &reg.byte, 1);\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL2_OIS, &reg.byte, 1);\n  reg.ctrl2_ois.ftype_ois = val & 0x03;\n  reg.ctrl2_ois.hp_en_ois = ( val & 0x80 ) >> 7;\n  reg.ctrl2_ois.hpm_ois = ( val & 0x30 ) >> 4;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL2_OIS, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  gy_aux_bandwidth: [get] HPF is available on gyroscope's OIS\n  *                                 chain only if HP_EN_G in CTRL7_G(16h)\n  *                                 is set to '0'\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  hp_en_ois_t: gyroscope aux (ois) filtering chain configuration in\n  *                      Mode: 3, 4.\n  *\n  */\nint32_t lsm6dsm_gy_aux_bandwidth_get(lsm6dsm_ctx_t *ctx,\n                                     lsm6dsm_hp_en_ois_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL2_OIS, &reg.byte, 1);\n\n\n  *val = (lsm6dsm_hp_en_ois_t) ( ( reg.ctrl2_ois.hp_en_ois << 7 ) +\n                                 ( reg.ctrl2_ois.hpm_ois << 4)    +\n                                   reg.ctrl2_ois.ftype_ois);\n\n  if (!reg.ctrl2_ois.hp_en_ois){\n    *val &= 0x0F;\n  }\n\n  return mm_error;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup   Auxiliary_interface\n  * @brief   This section groups all the functions concerning\n  *          auxiliary interface.\n  * @{\n  */\n\n/**\n  * @brief  aux_status_reg: [get] The STATUS_SPIAux register is read\n  *                               by the auxiliary SPI.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  status_spiaux_t: registers STATUS_SPIAUX.\n  *\n  */\nint32_t lsm6dsm_aux_status_reg_get(lsm6dsm_ctx_t *ctx,\n                                   lsm6dsm_status_spiaux_t *val)\n{\n  return lsm6dsm_read_reg(ctx, LSM6DSM_STATUS_SPIAUX, (uint8_t*) val, 1);\n}\n\n/**\n  * @brief   aux_xl_flag_data_ready: [get]  AUX accelerometer data available\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of xlda in reg STATUS_SPIAUX\n  *\n  */\nint32_t lsm6dsm_aux_xl_flag_data_ready_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_STATUS_SPIAUX, &reg.byte, 1);\n  *val = reg.status_spiaux.xlda;\n\n  return mm_error;\n}\n\n/**\n  * @brief   aux_gy_flag_data_ready: [get]  AUX gyroscope data available.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of gda in reg STATUS_SPIAUX\n  *\n  */\nint32_t lsm6dsm_aux_gy_flag_data_ready_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_STATUS_SPIAUX, &reg.byte, 1);\n  *val = reg.status_spiaux.gda;\n\n  return mm_error;\n}\n\n/**\n  * @brief   aux_gy_flag_settling: [get] High when the gyroscope output is\n  *                                      in the settling phase.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of gyro_settling in reg STATUS_SPIAUX\n  *\n  */\nint32_t lsm6dsm_aux_gy_flag_settling_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_STATUS_SPIAUX, &reg.byte, 1);\n  *val = reg.status_spiaux.gyro_settling;\n\n  return mm_error;\n}\n\n/**\n  * @brief  aux_den_mode: [set]  Configure DEN mode on the OIS chain.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_lvl2_ois_t: change the values of lvl2_ois in reg INT_OIS\n  *\n  */\nint32_t lsm6dsm_aux_den_mode_set(lsm6dsm_ctx_t *ctx, lsm6dsm_lvl_ois_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_INT_OIS, &reg.byte, 1);\n  reg.int_ois.lvl2_ois = val & 0x01;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_INT_OIS, &reg.byte, 1);\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL1_OIS, &reg.byte, 1);\n  reg.ctrl1_ois.lvl1_ois = (val & 0x02) >> 1;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL1_OIS, &reg.byte, 1);\n\n\n  return mm_error;\n}\n\n/**\n  * @brief  aux_den_mode: [get]  Configure DEN mode on the OIS chain.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_lvl2_ois_t: Get the values of lvl2_ois in reg INT_OIS\n  *\n  */\nint32_t lsm6dsm_aux_den_mode_get(lsm6dsm_ctx_t *ctx, lsm6dsm_lvl_ois_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_INT_OIS, &reg.byte, 1);\n  *val = (lsm6dsm_lvl_ois_t) reg.int_ois.lvl2_ois;\n\n  return mm_error;\n}\n\n/**\n  * @brief  aux_drdy_on_int2: [set] Enables/Disable OIS chain DRDY on\n  *                                 INT2 pin. This setting has priority over\n  *                                 all other INT2 settings.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of int2_drdy_ois in reg INT_OIS\n  *\n  */\nint32_t lsm6dsm_aux_drdy_on_int2_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_INT_OIS, &reg.byte, 1);\n  reg.int_ois.int2_drdy_ois = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_INT_OIS, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  aux_drdy_on_int2: [get] Enables/Disable OIS chain DRDY on\n  *                                 INT2 pin. This setting has priority\n  *                                 over all other INT2 settings.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of int2_drdy_ois in reg INT_OIS\n  *\n  */\nint32_t lsm6dsm_aux_drdy_on_int2_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_INT_OIS, &reg.byte, 1);\n  *val = reg.int_ois.int2_drdy_ois;\n\n  return mm_error;\n}\n\n/**\n  * @brief  aux_mode: [set] Enables OIS chain data processing for gyro\n  *                         in Mode 3 and Mode 4 (mode4_en = 1) and\n  *                         accelerometer data in and Mode 4 (mode4_en = 1).\n  *                         When the OIS chain is enabled, the OIS outputs are\n  *                         available through the SPI2 in registers\n  *                         OUTX_L_G(22h) through OUTZ_H_G(27h) and\n  *                         STATUS_REG(1Eh) / STATUS_SPIAux, and LPF1 is\n  *                         dedicated to this chain.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_ois_en_spi2_t: change the values of ois_en_spi2 in\n  *                                reg CTRL1_OIS\n  *\n  */\nint32_t lsm6dsm_aux_mode_set(lsm6dsm_ctx_t *ctx, lsm6dsm_ois_en_spi2_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL1_OIS, &reg.byte, 1);\n  reg.ctrl1_ois.ois_en_spi2 = val & 0x01;\n  reg.ctrl1_ois.mode4_en = (val & 0x02) >> 1;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL1_OIS, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  aux_mode: [get] Enables OIS chain data processing for gyro\n  *                         in Mode 3 and Mode 4 (mode4_en = 1) and\n  *                         accelerometer data in and Mode 4 (mode4_en = 1).\n  *                         When the OIS chain is enabled, the OIS outputs\n  *                         are available through the SPI2 in registers\n  *                         OUTX_L_G(22h) through OUTZ_H_G(27h) and\n  *                         STATUS_REG(1Eh) / STATUS_SPIAux, and LPF1 is\n  *                         dedicated to this chain.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_ois_en_spi2_t: Get the values of ois_en_spi2 in\n  *                                reg CTRL1_OIS\n  *\n  */\nint32_t lsm6dsm_aux_mode_get(lsm6dsm_ctx_t *ctx, lsm6dsm_ois_en_spi2_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL1_OIS, &reg.byte, 1);\n  *val = (lsm6dsm_ois_en_spi2_t) ( (reg.ctrl1_ois.mode4_en << 1) +\n                                   reg.ctrl1_ois.ois_en_spi2 );\n\n  return mm_error;\n}\n\n/**\n  * @brief  aux_gy_full_scale: [set]  Selects gyroscope OIS chain full-scale.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_fs_g_ois_t: change the values of fs_g_ois in reg CTRL1_OIS\n  *\n  */\nint32_t lsm6dsm_aux_gy_full_scale_set(lsm6dsm_ctx_t *ctx,\n                                      lsm6dsm_fs_g_ois_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL1_OIS, &reg.byte, 1);\n  reg.ctrl1_ois.fs_g_ois = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL1_OIS, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  aux_gy_full_scale: [get]  Selects gyroscope OIS chain full-scale.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_fs_g_ois_t: Get the values of fs_g_ois in reg CTRL1_OIS\n  *\n  */\nint32_t lsm6dsm_aux_gy_full_scale_get(lsm6dsm_ctx_t *ctx,\n                                      lsm6dsm_fs_g_ois_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL1_OIS, &reg.byte, 1);\n  *val = (lsm6dsm_fs_g_ois_t) reg.ctrl1_ois.fs_g_ois;\n\n  return mm_error;\n}\n\n/**\n  * @brief  aux_spi_mode: [set]  SPI2 3- or 4-wire interface.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_sim_ois_t: change the values of sim_ois in reg CTRL1_OIS\n  *\n  */\nint32_t lsm6dsm_aux_spi_mode_set(lsm6dsm_ctx_t *ctx, lsm6dsm_sim_ois_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL1_OIS, &reg.byte, 1);\n  reg.ctrl1_ois.sim_ois = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL1_OIS, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  aux_spi_mode: [get]  SPI2 3- or 4-wire interface.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_sim_ois_t: Get the values of sim_ois in reg CTRL1_OIS\n  *\n  */\nint32_t lsm6dsm_aux_spi_mode_get(lsm6dsm_ctx_t *ctx, lsm6dsm_sim_ois_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL1_OIS, &reg.byte, 1);\n  *val = (lsm6dsm_sim_ois_t) reg.ctrl1_ois.sim_ois;\n\n  return mm_error;\n}\n\n/**\n  * @brief  aux_data_format: [set] Big/Little Endian Data selection\n  *                                on aux interface.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_ble_ois_t: change the values of ble_ois in reg CTRL1_OIS\n  *\n  */\nint32_t lsm6dsm_aux_data_format_set(lsm6dsm_ctx_t *ctx, lsm6dsm_ble_ois_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL1_OIS, &reg.byte, 1);\n  reg.ctrl1_ois.ble_ois = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL1_OIS, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  aux_data_format: [get] Big/Little Endian Data selection on\n  *                                aux interface.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_ble_ois_t: Get the values of ble_ois in reg CTRL1_OIS\n  *\n  */\nint32_t lsm6dsm_aux_data_format_get(lsm6dsm_ctx_t *ctx, lsm6dsm_ble_ois_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL1_OIS, &reg.byte, 1);\n  *val = (lsm6dsm_ble_ois_t) reg.ctrl1_ois.ble_ois;\n\n  return mm_error;\n}\n\n/**\n  * @brief  aux_gy_clamp: [set] Enable / Disables OIS chain clamp.\n  *                             Enable: All OIS chain outputs = 8000h\n  *                             during self-test; Disable: OIS chain\n  *                             self-test outputs dependent from the aux\n  *                             gyro full scale selected.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_st_ois_clampdis_t: change the values of st_ois_clampdis\n  *                                    in reg CTRL3_OIS\n  *\n  */\nint32_t lsm6dsm_aux_gy_clamp_set(lsm6dsm_ctx_t *ctx,\n                                 lsm6dsm_st_ois_clampdis_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL3_OIS, &reg.byte, 1);\n  reg.ctrl3_ois.st_ois_clampdis = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL3_OIS, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  aux_gy_clamp: [get] Enable / Disables OIS chain clamp.\n  *                             Enable: All OIS chain outputs = 8000h\n  *                             during self-test; Disable: OIS chain self-test\n  *                             outputs dependent from the aux gyro full\n  *                             scale selected.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_st_ois_clampdis_t: Get the values of st_ois_clampdis in\n  *                                    reg CTRL3_OIS\n  *\n  */\nint32_t lsm6dsm_aux_gy_clamp_get(lsm6dsm_ctx_t *ctx,\n                                 lsm6dsm_st_ois_clampdis_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL3_OIS, &reg.byte, 1);\n  *val = (lsm6dsm_st_ois_clampdis_t) reg.ctrl3_ois.st_ois_clampdis;\n\n  return mm_error;\n}\n\n/**\n  * @brief  aux_gy_self_test: [set]  Selects gyroscope OIS chain self-test.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_st_ois_t: change the values of st_ois in reg CTRL3_OIS\n  *\n  */\nint32_t lsm6dsm_aux_gy_self_test_set(lsm6dsm_ctx_t *ctx, lsm6dsm_st_ois_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL3_OIS, &reg.byte, 1);\n  reg.ctrl3_ois.st_ois = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL3_OIS, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  aux_gy_self_test: [get]  Selects gyroscope OIS chain self-test.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_st_ois_t: Get the values of st_ois in reg CTRL3_OIS\n  *\n  */\nint32_t lsm6dsm_aux_gy_self_test_get(lsm6dsm_ctx_t *ctx, lsm6dsm_st_ois_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL3_OIS, &reg.byte, 1);\n  *val = (lsm6dsm_st_ois_t) reg.ctrl3_ois.st_ois;\n\n  return mm_error;\n}\n\n/**\n  * @brief  aux_xl_full_scale: [set] Selects accelerometer OIS channel\n  *                                  full-scale.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_fs_xl_ois_t: change the values of fs_xl_ois in\n  *                              reg CTRL3_OIS\n  *\n  */\nint32_t lsm6dsm_aux_xl_full_scale_set(lsm6dsm_ctx_t *ctx,\n                                      lsm6dsm_fs_xl_ois_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL3_OIS, &reg.byte, 1);\n  reg.ctrl3_ois.fs_xl_ois = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL3_OIS, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  aux_xl_full_scale: [get] Selects accelerometer OIS channel\n  *                                  full-scale.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_fs_xl_ois_t: Get the values of fs_xl_ois in reg CTRL3_OIS\n  *\n  */\nint32_t lsm6dsm_aux_xl_full_scale_get(lsm6dsm_ctx_t *ctx,\n                                      lsm6dsm_fs_xl_ois_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL3_OIS, &reg.byte, 1);\n  *val = (lsm6dsm_fs_xl_ois_t) reg.ctrl3_ois.fs_xl_ois;\n\n  return mm_error;\n}\n\n/**\n  * @brief  aux_den_polarity: [set] Indicates polarity of DEN signal\n  *                                 on OIS chain.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_den_lh_ois_t: change the values of den_lh_ois in\n  *                               reg CTRL3_OIS\n  *\n  */\nint32_t lsm6dsm_aux_den_polarity_set(lsm6dsm_ctx_t *ctx,\n                                     lsm6dsm_den_lh_ois_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL3_OIS, &reg.byte, 1);\n  reg.ctrl3_ois.den_lh_ois = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL3_OIS, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  aux_den_polarity: [get] Indicates polarity of DEN signal on\n  *                                 OIS chain.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_den_lh_ois_t: Get the values of den_lh_ois in\n  *                               reg CTRL3_OIS\n  *\n  */\nint32_t lsm6dsm_aux_den_polarity_get(lsm6dsm_ctx_t *ctx,\n                                     lsm6dsm_den_lh_ois_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL3_OIS, &reg.byte, 1);\n  *val = (lsm6dsm_den_lh_ois_t) reg.ctrl3_ois.den_lh_ois;\n\n  return mm_error;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup   main_serial_interface\n  * @brief   This section groups all the functions concerning main serial\n  *          interface management (not auxiliary)\n  * @{\n  */\n\n/**\n  * @brief  spi_mode: [set]  SPI Serial Interface Mode selection.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_sim_t: change the values of sim in reg CTRL3_C\n  *\n  */\nint32_t lsm6dsm_spi_mode_set(lsm6dsm_ctx_t *ctx, lsm6dsm_sim_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL3_C, &reg.byte, 1);\n  reg.ctrl3_c.sim = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL3_C, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  spi_mode: [get]  SPI Serial Interface Mode selection.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_sim_t: Get the values of sim in reg CTRL3_C\n  *\n  */\nint32_t lsm6dsm_spi_mode_get(lsm6dsm_ctx_t *ctx, lsm6dsm_sim_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL3_C, &reg.byte, 1);\n  *val = (lsm6dsm_sim_t) reg.ctrl3_c.sim;\n\n  return mm_error;\n}\n\n/**\n  * @brief  i2c_interface: [set]  Disable / Enable I2C interface.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_i2c_disable_t: change the values of i2c_disable in\n  *                                reg CTRL4_C\n  *\n  */\nint32_t lsm6dsm_i2c_interface_set(lsm6dsm_ctx_t *ctx,\n                                  lsm6dsm_i2c_disable_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL4_C, &reg.byte, 1);\n  reg.ctrl4_c.i2c_disable = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL4_C, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  i2c_interface: [get]  Disable / Enable I2C interface.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_i2c_disable_t: Get the values of i2c_disable in reg CTRL4_C\n  *\n  */\nint32_t lsm6dsm_i2c_interface_get(lsm6dsm_ctx_t *ctx,\n                                  lsm6dsm_i2c_disable_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL4_C, &reg.byte, 1);\n  *val = (lsm6dsm_i2c_disable_t) reg.ctrl4_c.i2c_disable;\n\n  return mm_error;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  interrupt_pins\n  * @brief   This section groups all the functions that manage interrup pins\n  * @{\n  */\n\n/**\n  * @brief  pin_int1_route: [set] Select the signal that need to route on\n  *                               int1 pad\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_int1_ctrl: configure INT1_CTRL, MD1_CFG,\n  *                            CTRL4_C(den_drdy_int1),\n  *                            MASTER_CONFIG(drdy_on_int1)\n  *\n  */\nint32_t lsm6dsm_pin_int1_route_set(lsm6dsm_ctx_t *ctx,\n                                   lsm6dsm_int1_route_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_INT1_CTRL, &reg.byte, 1);\n  reg.int1_ctrl.int1_drdy_xl        = val.int1_drdy_xl;\n  reg.int1_ctrl.int1_drdy_g         = val.int1_drdy_g;\n  reg.int1_ctrl.int1_boot           = val.int1_boot;\n  reg.int1_ctrl.int1_fth            = val.int1_fth;\n  reg.int1_ctrl.int1_fifo_ovr       = val.int1_fifo_ovr;\n  reg.int1_ctrl.int1_full_flag      = val.int1_full_flag;\n  reg.int1_ctrl.int1_sign_mot       = val.int1_sign_mot;\n  reg.int1_ctrl.int1_step_detector  = val.int1_step_detector;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_INT1_CTRL, &reg.byte, 1);\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_MD1_CFG, &reg.byte, 1);\n  reg.md1_cfg.int1_timer           = val.int1_timer;\n  reg.md1_cfg.int1_tilt            = val.int1_tilt;\n  reg.md1_cfg.int1_6d              = val.int1_6d;\n  reg.md1_cfg.int1_double_tap      = val.int1_double_tap;\n  reg.md1_cfg.int1_ff              = val.int1_ff;\n  reg.md1_cfg.int1_wu              = val.int1_wu;\n  reg.md1_cfg.int1_single_tap      = val.int1_single_tap;\n  reg.md1_cfg.int1_inact_state     = val.int1_inact_state;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_MD1_CFG, &reg.byte, 1);\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL4_C, &reg.byte, 1);\n  reg.ctrl4_c.den_drdy_int1        = val.den_drdy_int1;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL4_C, &reg.byte, 1);\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_MASTER_CONFIG, &reg.byte, 1);\n  reg.master_config.drdy_on_int1   = val.den_drdy_int1;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_MASTER_CONFIG, &reg.byte, 1);\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_TAP_CFG, &reg.byte, 1);\n  if (val.int1_6d || val.int1_ff || val.int1_wu || val.int1_single_tap ||\n      val.int1_double_tap || val.int1_inact_state){\n    reg.tap_cfg.interrupts_enable = PROPERTY_ENABLE;\n  }\n  else{\n    reg.tap_cfg.interrupts_enable = PROPERTY_DISABLE;\n  }\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_TAP_CFG, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  pin_int1_route: [get] Select the signal that need to route on\n  *                               int1 pad\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_int1_route_t: read INT1_CTRL, MD1_CFG,\n  *                               CTRL4_C(den_drdy_int1),\n  *                               MASTER_CONFIG(drdy_on_int1)\n  *\n  */\nint32_t lsm6dsm_pin_int1_route_get(lsm6dsm_ctx_t *ctx,\n                                   lsm6dsm_int1_route_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_INT1_CTRL, &reg.byte, 1);\n  val->int1_drdy_xl       = reg.int1_ctrl.int1_drdy_xl;\n  val->int1_drdy_g        = reg.int1_ctrl.int1_drdy_g;\n  val->int1_boot          = reg.int1_ctrl.int1_boot;\n  val->int1_fth           = reg.int1_ctrl.int1_fth;\n  val->int1_fifo_ovr      = reg.int1_ctrl.int1_fifo_ovr;\n  val->int1_full_flag     = reg.int1_ctrl.int1_full_flag;\n  val->int1_sign_mot      = reg.int1_ctrl.int1_sign_mot;\n  val->int1_step_detector = reg.int1_ctrl.int1_step_detector ;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_MD1_CFG, &reg.byte, 1);\n  val->int1_timer       = reg.md1_cfg.int1_timer;\n  val->int1_tilt        = reg.md1_cfg.int1_tilt;\n  val->int1_6d          = reg.md1_cfg.int1_6d;\n  val->int1_double_tap  = reg.md1_cfg.int1_double_tap;\n  val->int1_ff          = reg.md1_cfg.int1_ff;\n  val->int1_wu          = reg.md1_cfg.int1_wu;\n  val->int1_single_tap  = reg.md1_cfg.int1_single_tap;\n  val->int1_inact_state = reg.md1_cfg.int1_inact_state;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL4_C, &reg.byte, 1);\n  val->den_drdy_int1 = reg.ctrl4_c.den_drdy_int1;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_MASTER_CONFIG, &reg.byte, 1);\n  val->den_drdy_int1 = reg.master_config.drdy_on_int1;\n\n  return mm_error;\n}\n\n/**\n  * @brief  pin_int2_route: [set] Select the signal that need to route on\n  *                               int2 pad\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_int2_route_t: INT2_CTRL, DRDY_PULSE_CFG(int2_wrist_tilt),\n  *                               MD2_CFG\n  *\n  */\nint32_t lsm6dsm_pin_int2_route_set(lsm6dsm_ctx_t *ctx,\n                                   lsm6dsm_int2_route_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_INT2_CTRL, &reg.byte, 1);\n  reg.int2_ctrl.int2_drdy_xl        = val.int2_drdy_xl;\n  reg.int2_ctrl.int2_drdy_g         = val.int2_drdy_g;\n  reg.int2_ctrl.int2_drdy_temp      = val.int2_drdy_temp;\n  reg.int2_ctrl.int2_fth            = val.int2_fth;\n  reg.int2_ctrl.int2_fifo_ovr       = val.int2_fifo_ovr;\n  reg.int2_ctrl.int2_full_flag      = val.int2_full_flag;\n  reg.int2_ctrl.int2_step_count_ov  = val.int2_step_count_ov;\n  reg.int2_ctrl.int2_step_delta     = val.int2_step_delta;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_INT2_CTRL, &reg.byte, 1);\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_MD2_CFG, &reg.byte, 1);\n  reg.md2_cfg.int2_iron              = val.int2_iron;\n  reg.md2_cfg.int2_tilt              = val.int2_tilt;\n  reg.md2_cfg.int2_6d                = val.int2_6d;\n  reg.md2_cfg.int2_double_tap        = val.int2_double_tap;\n  reg.md2_cfg.int2_ff                = val.int2_ff;\n  reg.md2_cfg.int2_wu                = val.int2_wu;\n  reg.md2_cfg.int2_single_tap        = val.int2_single_tap;\n  reg.md2_cfg.int2_inact_state       = val.int2_inact_state;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_MD2_CFG, &reg.byte, 1);\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_DRDY_PULSE_CFG, &reg.byte, 1);\n  reg.drdy_pulse_cfg.int2_wrist_tilt        = val.int2_wrist_tilt;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_DRDY_PULSE_CFG, &reg.byte, 1);\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_TAP_CFG, &reg.byte, 1);\n  if (val.int2_6d || val.int2_ff || val.int2_wu || val.int2_single_tap ||\n      val.int2_double_tap || val.int2_inact_state){\n    reg.tap_cfg.interrupts_enable = PROPERTY_ENABLE;\n  }\n  else{\n    reg.tap_cfg.interrupts_enable = PROPERTY_DISABLE;\n  }\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_TAP_CFG, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  pin_int2_route: [get] Select the signal that need to route on\n  *                               int2 pad\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_int2_route_t: INT2_CTRL, DRDY_PULSE_CFG(int2_wrist_tilt),\n  *                               MD2_CFG\n  *\n  */\nint32_t lsm6dsm_pin_int2_route_get(lsm6dsm_ctx_t *ctx,\n                                   lsm6dsm_int2_route_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_INT2_CTRL, &reg.byte, 1);\n  val->int2_drdy_xl         = reg.int2_ctrl.int2_drdy_xl;\n  val->int2_drdy_g          = reg.int2_ctrl.int2_drdy_g;\n  val->int2_drdy_temp       = reg.int2_ctrl.int2_drdy_temp;\n  val->int2_fth             = reg.int2_ctrl.int2_fth;\n  val->int2_fifo_ovr        = reg.int2_ctrl.int2_fifo_ovr;\n  val->int2_full_flag       = reg.int2_ctrl.int2_full_flag;\n  val->int2_step_count_ov   = reg.int2_ctrl.int2_step_count_ov;\n  val->int2_step_delta      = reg.int2_ctrl.int2_step_delta;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_MD2_CFG, &reg.byte, 1);\n  val->int2_iron           = reg.md2_cfg.int2_iron;\n  val->int2_tilt           = reg.md2_cfg.int2_tilt;\n  val->int2_6d             = reg.md2_cfg.int2_6d;\n  val->int2_double_tap     = reg.md2_cfg.int2_double_tap;\n  val->int2_ff             = reg.md2_cfg.int2_ff;\n  val->int2_wu             = reg.md2_cfg.int2_wu;\n  val->int2_single_tap     = reg.md2_cfg.int2_single_tap;\n  val->int2_inact_state    = reg.md2_cfg.int2_inact_state;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_DRDY_PULSE_CFG, &reg.byte, 1);\n  val->int2_wrist_tilt = reg.drdy_pulse_cfg.int2_wrist_tilt;\n\n  return mm_error;\n}\n\n/**\n  * @brief  pin_mode: [set]  Push-pull/open drain selection on interrupt pads.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_pp_od_t: change the values of pp_od in reg CTRL3_C\n  *\n  */\nint32_t lsm6dsm_pin_mode_set(lsm6dsm_ctx_t *ctx, lsm6dsm_pp_od_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL3_C, &reg.byte, 1);\n  reg.ctrl3_c.pp_od = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL3_C, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  pin_mode: [get]  Push-pull/open drain selection on interrupt pads.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_pp_od_t: Get the values of pp_od in reg CTRL3_C\n  *\n  */\nint32_t lsm6dsm_pin_mode_get(lsm6dsm_ctx_t *ctx, lsm6dsm_pp_od_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL3_C, &reg.byte, 1);\n  *val = (lsm6dsm_pp_od_t) reg.ctrl3_c.pp_od;\n\n  return mm_error;\n}\n\n/**\n  * @brief  pin_polarity: [set]  Interrupt active-high/low.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_h_lactive_t: change the values of h_lactive in reg CTRL3_C\n  *\n  */\nint32_t lsm6dsm_pin_polarity_set(lsm6dsm_ctx_t *ctx, lsm6dsm_h_lactive_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL3_C, &reg.byte, 1);\n  reg.ctrl3_c.h_lactive = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL3_C, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  pin_polarity: [get]  Interrupt active-high/low.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_h_lactive_t: Get the values of h_lactive in reg CTRL3_C\n  *\n  */\nint32_t lsm6dsm_pin_polarity_get(lsm6dsm_ctx_t *ctx, lsm6dsm_h_lactive_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL3_C, &reg.byte, 1);\n  *val = (lsm6dsm_h_lactive_t) reg.ctrl3_c.h_lactive;\n\n  return mm_error;\n}\n\n/**\n  * @brief  all_on_int1: [set] All interrupt signals become available on\n  *                            INT1 pin.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of int2_on_int1 in reg CTRL4_C\n  *\n  */\nint32_t lsm6dsm_all_on_int1_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL4_C, &reg.byte, 1);\n  reg.ctrl4_c.int2_on_int1 = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL4_C, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  all_on_int1: [get] All interrupt signals become available on\n  *                            INT1 pin.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of int2_on_int1 in reg CTRL4_C\n  *\n  */\nint32_t lsm6dsm_all_on_int1_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL4_C, &reg.byte, 1);\n  *val = reg.ctrl4_c.int2_on_int1;\n\n  return mm_error;\n}\n\n/**\n  * @brief  int_notification: [set]  Latched/pulsed interrupt.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_lir_t: change the values of lir in reg TAP_CFG\n  *\n  */\nint32_t lsm6dsm_int_notification_set(lsm6dsm_ctx_t *ctx, lsm6dsm_lir_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_TAP_CFG, &reg.byte, 1);\n  reg.tap_cfg.lir = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_TAP_CFG, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  int_notification: [get]  Latched/pulsed interrupt.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_lir_t: Get the values of lir in reg TAP_CFG\n  *\n  */\nint32_t lsm6dsm_int_notification_get(lsm6dsm_ctx_t *ctx, lsm6dsm_lir_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_TAP_CFG, &reg.byte, 1);\n  *val = (lsm6dsm_lir_t) reg.tap_cfg.lir;\n\n  return mm_error;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  Wake_Up_event\n  * @brief   This section groups all the functions that manage the Wake Up\n  *          event generation.\n  * @{\n  */\n\n/**\n  * @brief  wkup_threshold: [set]  Threshold for wakeup.1 LSB = FS_XL / 64.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of wk_ths in reg WAKE_UP_THS\n  *\n  */\nint32_t lsm6dsm_wkup_threshold_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_WAKE_UP_THS, &reg.byte, 1);\n  reg.wake_up_ths.wk_ths = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_WAKE_UP_THS, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  wkup_threshold: [get]  Threshold for wakeup.1 LSB = FS_XL / 64.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of wk_ths in reg WAKE_UP_THS\n  *\n  */\nint32_t lsm6dsm_wkup_threshold_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_WAKE_UP_THS, &reg.byte, 1);\n  *val = reg.wake_up_ths.wk_ths;\n\n  return mm_error;\n}\n\n/**\n  * @brief  wkup_dur: [set]  Wake up duration event.1LSb = 1 / ODR\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of wake_dur in reg WAKE_UP_DUR\n  *\n  */\nint32_t lsm6dsm_wkup_dur_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_WAKE_UP_DUR, &reg.byte, 1);\n  reg.wake_up_dur.wake_dur = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_WAKE_UP_DUR, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  wkup_dur: [get]  Wake up duration event.1LSb = 1 / ODR\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of wake_dur in reg WAKE_UP_DUR\n  *\n  */\nint32_t lsm6dsm_wkup_dur_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_WAKE_UP_DUR, &reg.byte, 1);\n  *val = reg.wake_up_dur.wake_dur;\n\n  return mm_error;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup   Activity/Inactivity_detection\n  * @brief   This section groups all the functions concerning\n  *          activity/inactivity detection.\n  * @{\n  */\n\n/**\n  * @brief  gy_sleep_mode: [set]  Enables gyroscope Sleep mode.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of sleep in reg CTRL4_C\n  *\n  */\nint32_t lsm6dsm_gy_sleep_mode_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL4_C, &reg.byte, 1);\n  reg.ctrl4_c.sleep = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL4_C, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  gy_sleep_mode: [get]  Enables gyroscope Sleep mode.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of sleep in reg CTRL4_C\n  *\n  */\nint32_t lsm6dsm_gy_sleep_mode_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL4_C, &reg.byte, 1);\n  *val = reg.ctrl4_c.sleep;\n\n  return mm_error;\n}\n\n/**\n  * @brief  act_mode: [set]  Enable inactivity function.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_inact_en_t: change the values of inact_en in reg TAP_CFG\n  *\n  */\nint32_t lsm6dsm_act_mode_set(lsm6dsm_ctx_t *ctx, lsm6dsm_inact_en_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_TAP_CFG, &reg.byte, 1);\n  reg.tap_cfg.inact_en = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_TAP_CFG, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  act_mode: [get]  Enable inactivity function.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_inact_en_t: Get the values of inact_en in reg TAP_CFG\n  *\n  */\nint32_t lsm6dsm_act_mode_get(lsm6dsm_ctx_t *ctx, lsm6dsm_inact_en_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_TAP_CFG, &reg.byte, 1);\n  *val = (lsm6dsm_inact_en_t) reg.tap_cfg.inact_en;\n\n  return mm_error;\n}\n\n/**\n  * @brief  act_sleep_dur: [set] Duration to go in sleep mode.\n  *                              1 LSb = 512 / ODR\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of sleep_dur in reg WAKE_UP_DUR\n  *\n  */\nint32_t lsm6dsm_act_sleep_dur_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_WAKE_UP_DUR, &reg.byte, 1);\n  reg.wake_up_dur.sleep_dur = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_WAKE_UP_DUR, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  act_sleep_dur: [get] Duration to go in sleep mode.\n  *                              1 LSb = 512 / ODR\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of sleep_dur in reg WAKE_UP_DUR\n  *\n  */\nint32_t lsm6dsm_act_sleep_dur_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_WAKE_UP_DUR, &reg.byte, 1);\n  *val = reg.wake_up_dur.sleep_dur;\n\n  return mm_error;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  tap_generator\n  * @brief   This section groups all the functions that manage the tap and\n  *          double tap event generation.\n  * @{\n  */\n\n/**\n  * @brief  tap_src: [get]  Read the tap / double tap source register.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_: union of registers from TAP_SRC to\n  *\n  */\nint32_t lsm6dsm_tap_src_get(lsm6dsm_ctx_t *ctx, lsm6dsm_tap_src_t *val)\n{\n  return lsm6dsm_read_reg(ctx, LSM6DSM_TAP_SRC, (uint8_t*) val, 1);\n}\n\n/**\n  * @brief  tap_detection_on_z: [set]  Enable Z direction in tap recognition.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of tap_z_en in reg TAP_CFG\n  *\n  */\nint32_t lsm6dsm_tap_detection_on_z_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_TAP_CFG, &reg.byte, 1);\n  reg.tap_cfg.tap_z_en = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_TAP_CFG, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  tap_detection_on_z: [get]  Enable Z direction in tap recognition.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of tap_z_en in reg TAP_CFG\n  *\n  */\nint32_t lsm6dsm_tap_detection_on_z_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_TAP_CFG, &reg.byte, 1);\n  *val = reg.tap_cfg.tap_z_en;\n\n  return mm_error;\n}\n\n/**\n  * @brief  tap_detection_on_y: [set]  Enable Y direction in tap recognition.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of tap_y_en in reg TAP_CFG\n  *\n  */\nint32_t lsm6dsm_tap_detection_on_y_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_TAP_CFG, &reg.byte, 1);\n  reg.tap_cfg.tap_y_en = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_TAP_CFG, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  tap_detection_on_y: [get]  Enable Y direction in tap recognition.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of tap_y_en in reg TAP_CFG\n  *\n  */\nint32_t lsm6dsm_tap_detection_on_y_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_TAP_CFG, &reg.byte, 1);\n  *val = reg.tap_cfg.tap_y_en;\n\n  return mm_error;\n}\n\n/**\n  * @brief  tap_detection_on_x: [set]  Enable X direction in tap recognition.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of tap_x_en in reg TAP_CFG\n  *\n  */\nint32_t lsm6dsm_tap_detection_on_x_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_TAP_CFG, &reg.byte, 1);\n  reg.tap_cfg.tap_x_en = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_TAP_CFG, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  tap_detection_on_x: [get]  Enable X direction in tap recognition.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of tap_x_en in reg TAP_CFG\n  *\n  */\nint32_t lsm6dsm_tap_detection_on_x_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_TAP_CFG, &reg.byte, 1);\n  *val = reg.tap_cfg.tap_x_en;\n\n  return mm_error;\n}\n\n/**\n  * @brief  tap_threshold_x: [set]  Threshold for tap recognition.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of tap_ths in reg TAP_THS_6D\n  *\n  */\nint32_t lsm6dsm_tap_threshold_x_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_TAP_THS_6D, &reg.byte, 1);\n  reg.tap_ths_6d.tap_ths = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_TAP_THS_6D, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  tap_threshold_x: [get]  Threshold for tap recognition.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of tap_ths in reg TAP_THS_6D\n  *\n  */\nint32_t lsm6dsm_tap_threshold_x_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_TAP_THS_6D, &reg.byte, 1);\n  *val = reg.tap_ths_6d.tap_ths;\n\n  return mm_error;\n}\n\n/**\n  * @brief  tap_shock: [set] Maximum duration is the maximum time of an\n  *                          overthreshold signal detection to be recognized\n  *                          as a tap event.\n  *                          The default value of these bits is 00b which\n  *                          corresponds to 4*ODR_XL time.\n  *                          If the SHOCK[1:0] bits are set to a different\n  *                          value, 1LSB corresponds to 8*ODR_XL time.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of shock in reg INT_DUR2\n  *\n  */\nint32_t lsm6dsm_tap_shock_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_INT_DUR2, &reg.byte, 1);\n  reg.int_dur2.shock = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_INT_DUR2, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  tap_shock: [get] Maximum duration is the maximum time of an\n  *                          overthreshold signal detection to be recognized\n  *                          as a tap event.\n  *                          The default value of these bits is 00b which\n  *                          corresponds to 4*ODR_XL time.\n  *                          If the SHOCK[1:0] bits are set to a different\n  *                          value, 1LSB corresponds to 8*ODR_XL time.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of shock in reg INT_DUR2\n  *\n  */\nint32_t lsm6dsm_tap_shock_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_INT_DUR2, &reg.byte, 1);\n  *val = reg.int_dur2.shock;\n\n  return mm_error;\n}\n\n/**\n  * @brief  tap_quiet: [set] Quiet time is the time after the first\n  *                          detected tap in which there must not be\n  *                          any overthreshold event.\n  *                          The default value of these bits is 00b\n  *                          which corresponds to 2*ODR_XL time.\n  *                          If the QUIET[1:0] bits are set to a\n  *                          different value, 1LSB corresponds to\n  *                          4*ODR_XL time.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of quiet in reg INT_DUR2\n  *\n  */\nint32_t lsm6dsm_tap_quiet_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_INT_DUR2, &reg.byte, 1);\n  reg.int_dur2.quiet = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_INT_DUR2, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  tap_quiet: [get] Quiet time is the time after the first\n  *                          detected tap in which there must not be any\n  *                          overthreshold event.\n  *                          The default value of these bits is 00b which\n  *                          corresponds to 2*ODR_XL time.\n  *                          If the QUIET[1:0] bits are set to a different\n  *                          value, 1LSB corresponds to 4*ODR_XL time.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of quiet in reg INT_DUR2\n  *\n  */\nint32_t lsm6dsm_tap_quiet_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_INT_DUR2, &reg.byte, 1);\n  *val = reg.int_dur2.quiet;\n\n  return mm_error;\n}\n\n/**\n  * @brief  tap_dur: [set] When double tap recognition is enabled,\n  *                        this register expresses the maximum time between\n  *                        two consecutive detected taps to determine a double\n  *                        tap event.\n  *                        The default value of these bits is 0000b which\n  *                        corresponds to 16*ODR_XL time.\n  *                        If the DUR[3:0] bits are set to a different value,\n  *                        1LSB corresponds to 32*ODR_XL time.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of dur in reg INT_DUR2\n  *\n  */\nint32_t lsm6dsm_tap_dur_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_INT_DUR2, &reg.byte, 1);\n  reg.int_dur2.dur = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_INT_DUR2, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  tap_dur: [get] When double tap recognition is enabled,\n  *                        this register expresses the maximum time between\n  *                        two consecutive detected taps to determine a\n  *                        double tap event.\n  *                        The default value of these bits is 0000b which\n  *                        corresponds to 16*ODR_XL time.\n  *                        If the DUR[3:0] bits are set to a different value,\n  *                        1LSB corresponds to 32*ODR_XL time.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of dur in reg INT_DUR2\n  *\n  */\nint32_t lsm6dsm_tap_dur_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_INT_DUR2, &reg.byte, 1);\n  *val = reg.int_dur2.dur;\n\n  return mm_error;\n}\n\n/**\n  * @brief  tap_mode: [set]  Single/double-tap event enable/disable.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_single_double_tap_t: change the values of\n  *                                      single_double_tap in reg WAKE_UP_THS\n  *\n  */\nint32_t lsm6dsm_tap_mode_set(lsm6dsm_ctx_t *ctx,\n                             lsm6dsm_single_double_tap_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_WAKE_UP_THS, &reg.byte, 1);\n  reg.wake_up_ths.single_double_tap = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_WAKE_UP_THS, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  tap_mode: [get]  Single/double-tap event enable/disable.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_single_double_tap_t: Get the values of single_double_tap\n  *                                      in reg WAKE_UP_THS\n  *\n  */\nint32_t lsm6dsm_tap_mode_get(lsm6dsm_ctx_t *ctx,\n                             lsm6dsm_single_double_tap_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_WAKE_UP_THS, &reg.byte, 1);\n  *val = (lsm6dsm_single_double_tap_t) reg.wake_up_ths.single_double_tap;\n\n  return mm_error;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup   Six_position_detection(6D/4D)\n  * @brief   This section groups all the functions concerning six\n  *          position detection (6D).\n  * @{\n  */\n\n/**\n  * @brief  6d_feed_data: [set]  LPF2 feed 6D function selection.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_low_pass_on_6d_t: change the values of low_pass_on_6d in\n  *                                   reg CTRL8_XL\n  *\n  */\nint32_t lsm6dsm_6d_feed_data_set(lsm6dsm_ctx_t *ctx,\n                                 lsm6dsm_low_pass_on_6d_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL8_XL, &reg.byte, 1);\n  reg.ctrl8_xl.low_pass_on_6d = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL8_XL, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  6d_feed_data: [get]  LPF2 feed 6D function selection.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_low_pass_on_6d_t: Get the values of low_pass_on_6d in\n  *                                   reg CTRL8_XL\n  *\n  */\nint32_t lsm6dsm_6d_feed_data_get(lsm6dsm_ctx_t *ctx,\n                                 lsm6dsm_low_pass_on_6d_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL8_XL, &reg.byte, 1);\n  *val = (lsm6dsm_low_pass_on_6d_t) reg.ctrl8_xl.low_pass_on_6d;\n\n  return mm_error;\n}\n\n/**\n  * @brief  6d_threshold: [set]  Threshold for 4D/6D function.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_sixd_ths_t: change the values of sixd_ths in reg TAP_THS_6D\n  *\n  */\nint32_t lsm6dsm_6d_threshold_set(lsm6dsm_ctx_t *ctx, lsm6dsm_sixd_ths_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_TAP_THS_6D, &reg.byte, 1);\n  reg.tap_ths_6d.sixd_ths = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_TAP_THS_6D, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  6d_threshold: [get]  Threshold for 4D/6D function.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_sixd_ths_t: Get the values of sixd_ths in reg TAP_THS_6D\n  *\n  */\nint32_t lsm6dsm_6d_threshold_get(lsm6dsm_ctx_t *ctx, lsm6dsm_sixd_ths_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_TAP_THS_6D, &reg.byte, 1);\n  *val = (lsm6dsm_sixd_ths_t) reg.tap_ths_6d.sixd_ths;\n\n  return mm_error;\n}\n\n/**\n  * @brief  4d_mode: [set]  4D orientation detection enable.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of d4d_en in reg TAP_THS_6D\n  *\n  */\nint32_t lsm6dsm_4d_mode_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_TAP_THS_6D, &reg.byte, 1);\n  reg.tap_ths_6d.d4d_en = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_TAP_THS_6D, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  4d_mode: [get]  4D orientation detection enable.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of d4d_en in reg TAP_THS_6D\n  *\n  */\nint32_t lsm6dsm_4d_mode_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_TAP_THS_6D, &reg.byte, 1);\n  *val = reg.tap_ths_6d.d4d_en;\n\n  return mm_error;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  free_fall\n  * @brief   This section group all the functions concerning the free\n  *          fall detection.\n  * @{\n  */\n\n/**\n  * @brief  ff_dur: [set]  Free-fall duration event. 1LSb = 1 / ODR\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of ff_dur in reg WAKE_UP_DUR\n  *\n  */\nint32_t lsm6dsm_ff_dur_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_FREE_FALL, &reg.byte, 1);\n  reg.free_fall.ff_dur = (val & 0x1F);\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_FREE_FALL, &reg.byte, 1);\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_WAKE_UP_DUR, &reg.byte, 1);\n  reg.wake_up_dur.ff_dur = (val & 0x20) >> 5;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_WAKE_UP_DUR, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  ff_dur: [get]  Free-fall duration event. 1LSb = 1 / ODR\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of ff_dur in reg WAKE_UP_DUR\n  *\n  */\nint32_t lsm6dsm_ff_dur_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg[2];\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_WAKE_UP_DUR, &reg[0].byte, 2);\n  *val = (reg[0].wake_up_dur.ff_dur << 5) + reg[1].free_fall.ff_dur;\n\n  return mm_error;\n}\n\n/**\n  * @brief  ff_threshold: [set]  Free fall threshold setting.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_ff_ths_t: change the values of ff_ths in reg FREE_FALL\n  *\n  */\nint32_t lsm6dsm_ff_threshold_set(lsm6dsm_ctx_t *ctx, lsm6dsm_ff_ths_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_FREE_FALL, &reg.byte, 1);\n  reg.free_fall.ff_ths = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_FREE_FALL, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  ff_threshold: [get]  Free fall threshold setting.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_ff_ths_t: Get the values of ff_ths in reg FREE_FALL\n  *\n  */\nint32_t lsm6dsm_ff_threshold_get(lsm6dsm_ctx_t *ctx, lsm6dsm_ff_ths_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_FREE_FALL, &reg.byte, 1);\n  *val = (lsm6dsm_ff_ths_t) reg.free_fall.ff_ths;\n\n  return mm_error;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  fifo\n  * @brief   This section group all the functions concerning the fifo usage\n  * @{\n  */\n\n/**\n  * @brief  fifo_watermark: [set]  FIFO watermark level selection.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of fth in reg FIFO_CTRL1\n  *\n  */\nint32_t lsm6dsm_fifo_watermark_set(lsm6dsm_ctx_t *ctx, uint16_t val)\n{\n  lsm6dsm_reg_t reg[2];\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_FIFO_CTRL2, &reg[1].byte, 1);\n  reg[0].fifo_ctrl1.fth = 0x00FF & val;\n  reg[1].fifo_ctrl2.fth = ( 0x0700 & val ) >> 8;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_FIFO_CTRL1, &reg[0].byte, 2);\n\n  return mm_error;\n}\n\n/**\n  * @brief  fifo_watermark: [get]  FIFO watermark level selection.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of fth in reg FIFO_CTRL1\n  *\n  */\nint32_t lsm6dsm_fifo_watermark_get(lsm6dsm_ctx_t *ctx, uint16_t *val)\n{\n  lsm6dsm_reg_t reg[2];\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_FIFO_CTRL1, &reg[0].byte, 2);\n  *val = (reg[1].fifo_ctrl2.fth << 8) + reg[0].fifo_ctrl1.fth;\n\n  return mm_error;\n}\n\n/**\n  * @brief  lsm6dsm_fifo_data_level_get: [get]  FIFO data level.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: get the values of diff_fifo in reg  FIFO_STATUS1 and\n  *                  FIFO_STATUS2(diff_fifo), it is recommended to set the\n  *                  BDU bit\n  *\n  */\nint32_t lsm6dsm_fifo_data_level_get(lsm6dsm_ctx_t *ctx, uint16_t *val)\n{\n  lsm6dsm_reg_t reg[2];\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_FIFO_STATUS1, &reg[0].byte, 2);\n  *val = (reg[1].fifo_status2.diff_fifo << 8) + reg[0].fifo_status1.diff_fifo;\n\n  return mm_error;\n}\n\n/**\n  * @brief  lsm6dsm_fifo_wtm_flag: [get]  FIFO watermark.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: get the values of watermark in reg  FIFO_STATUS2 and\n  *\n  */\nint32_t lsm6dsm_fifo_wtm_flag_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_FIFO_STATUS2, &reg.byte, 1);\n  *val = reg.fifo_status2.waterm;\n\n  return mm_error;\n}\n\n/**\n  * @brief  lsm6dsm_fifo_pattern_get: [get]  FIFO pattern.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: get the values of fifo_pattern in reg  FIFO_STATUS3 and\n  *                  FIFO_STATUS4, it is recommended to set the BDU bit\n  *\n  */\nint32_t lsm6dsm_fifo_pattern_get(lsm6dsm_ctx_t *ctx, uint16_t *val)\n{\n  lsm6dsm_reg_t reg[2];\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_FIFO_STATUS3, &reg[0].byte, 2);\n  *val = (reg[1].fifo_status4.fifo_pattern << 8) +\n          reg[0].fifo_status3.fifo_pattern;\n\n  return mm_error;\n}\n\n/**\n  * @brief  fifo_temp_batch: [set]  batching of temperature data\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of fifo_temp_en in reg FIFO_CTRL2\n  *\n  */\nint32_t lsm6dsm_fifo_temp_batch_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_FIFO_CTRL2, &reg.byte, 1);\n  reg.fifo_ctrl2.fifo_temp_en = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_FIFO_CTRL2, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  fifo_temp_batch: [get]  batching of temperature data\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of fifo_temp_en in reg FIFO_CTRL2\n  *\n  */\nint32_t lsm6dsm_fifo_temp_batch_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_FIFO_CTRL2, &reg.byte, 1);\n  *val = reg.fifo_ctrl2.fifo_temp_en;\n\n  return mm_error;\n}\n\n/**\n  * @brief  fifo_write_trigger: [set]  trigger signal for FIFO write operation\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_trigger_fifo_t: act on FIFO_CTRL2(timer_pedo_fifo_drdy)\n  *                                 and MASTER_CONFIG(data_valid_sel_fifo)\n  *\n  */\nint32_t lsm6dsm_fifo_write_trigger_set(lsm6dsm_ctx_t *ctx,\n                                       lsm6dsm_trigger_fifo_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_FIFO_CTRL2, &reg.byte, 1);\n  reg.fifo_ctrl2.timer_pedo_fifo_drdy = val & 0x01;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_FIFO_CTRL2, &reg.byte, 1);\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_MASTER_CONFIG, &reg.byte, 1);\n  reg.master_config.data_valid_sel_fifo = ( val & 0x02 ) > 1;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_MASTER_CONFIG, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  fifo_write_trigger: [get]  trigger signal for FIFO write operation\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_trigger_fifo_t: act on FIFO_CTRL2(timer_pedo_fifo_drdy)\n  *                                 and MASTER_CONFIG(data_valid_sel_fifo)\n  *\n  */\nint32_t lsm6dsm_fifo_write_trigger_get(lsm6dsm_ctx_t *ctx,\n                                       lsm6dsm_trigger_fifo_t *val)\n{\n  lsm6dsm_reg_t reg[2];\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_FIFO_CTRL2, &reg[0].byte, 1);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_MASTER_CONFIG, &reg[1].byte, 1);\n  *val =\n  (lsm6dsm_trigger_fifo_t) ( ( reg[1].fifo_ctrl2.timer_pedo_fifo_drdy << 1 ) +\n                              reg[0].fifo_ctrl2. timer_pedo_fifo_drdy );\n\n  return mm_error;\n}\n\n/**\n  * @brief   fifo_pedo_and_timestamp_batch: [set] Enable pedometer step\n  *                                               counter and timestamp as 4th\n  *                                               FIFO data set.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of timer_pedo_fifo_en in\n  *                      reg FIFO_CTRL2\n  *\n  */\nint32_t lsm6dsm_fifo_pedo_and_timestamp_batch_set(lsm6dsm_ctx_t *ctx,\n                                                  uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_FIFO_CTRL2, &reg.byte, 1);\n  reg.fifo_ctrl2.timer_pedo_fifo_en = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_FIFO_CTRL2, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief   fifo_pedo_and_timestamp_batch: [get] Enable pedometer step\n  *                                               counter and timestamp as 4th\n  *                                               FIFO data set.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of timer_pedo_fifo_en in reg FIFO_CTRL2\n  *\n  */\nint32_t lsm6dsm_fifo_pedo_and_timestamp_batch_get(lsm6dsm_ctx_t *ctx,\n                                                  uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_FIFO_CTRL2, &reg.byte, 1);\n  *val = reg.fifo_ctrl2.timer_pedo_fifo_en;\n\n  return mm_error;\n}\n\n/**\n  * @brief  fifo_xl_batch: [set] Selects Batching Data Rate (writing\n  *                              frequency in FIFO) for accelerometer data.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_dec_fifo_xl_t: change the values of dec_fifo_xl in\n  *                                reg FIFO_CTRL3\n  *\n  */\nint32_t lsm6dsm_fifo_xl_batch_set(lsm6dsm_ctx_t *ctx,\n                                  lsm6dsm_dec_fifo_xl_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_FIFO_CTRL3, &reg.byte, 1);\n  reg.fifo_ctrl3.dec_fifo_xl = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_FIFO_CTRL3, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  fifo_xl_batch: [get] Selects Batching Data Rate (writing\n  *                              frequency in FIFO) for accelerometer data.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_dec_fifo_xl_t: Get the values of dec_fifo_xl in\n  *                                reg FIFO_CTRL3\n  *\n  */\nint32_t lsm6dsm_fifo_xl_batch_get(lsm6dsm_ctx_t *ctx,\n                                  lsm6dsm_dec_fifo_xl_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_FIFO_CTRL3, &reg.byte, 1);\n  *val = (lsm6dsm_dec_fifo_xl_t) reg.fifo_ctrl3.dec_fifo_xl;\n\n  return mm_error;\n}\n\n/**\n  * @brief  fifo_gy_batch: [set] Selects Batching Data Rate (writing\n  *                              frequency in FIFO) for gyroscope data.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_dec_fifo_gyro_t: change the values of dec_fifo_gyro\n  *                                  in reg FIFO_CTRL3\n  *\n  */\nint32_t lsm6dsm_fifo_gy_batch_set(lsm6dsm_ctx_t *ctx,\n                                  lsm6dsm_dec_fifo_gyro_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_FIFO_CTRL3, &reg.byte, 1);\n  reg.fifo_ctrl3.dec_fifo_gyro = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_FIFO_CTRL3, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  fifo_gy_batch: [get] Selects Batching Data Rate (writing\n  *                              frequency in FIFO) for gyroscope data.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_dec_fifo_gyro_t: Get the values of dec_fifo_gyro in\n  *                                  reg FIFO_CTRL3\n  *\n  */\nint32_t lsm6dsm_fifo_gy_batch_get(lsm6dsm_ctx_t *ctx,\n                                  lsm6dsm_dec_fifo_gyro_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_FIFO_CTRL3, &reg.byte, 1);\n  *val = (lsm6dsm_dec_fifo_gyro_t) reg.fifo_ctrl3.dec_fifo_gyro;\n\n  return mm_error;\n}\n\n/**\n  * @brief   fifo_dataset_3_batch: [set] Selects Batching Data Rate (writing\n  *                                      frequency in FIFO) for third data set.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_dec_ds3_fifo_t: change the values of dec_ds3_fifo in\n  *                                 reg FIFO_CTRL4\n  *\n  */\nint32_t lsm6dsm_fifo_dataset_3_batch_set(lsm6dsm_ctx_t *ctx,\n                                         lsm6dsm_dec_ds3_fifo_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_FIFO_CTRL4, &reg.byte, 1);\n  reg.fifo_ctrl4.dec_ds3_fifo = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_FIFO_CTRL4, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief   fifo_dataset_3_batch: [get] Selects Batching Data Rate\n  *                                      (writing frequency in FIFO) for\n  *                                      third data set.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_dec_ds3_fifo_t: Get the values of dec_ds3_fifo in\n  *                                 reg FIFO_CTRL4\n  *\n  */\nint32_t lsm6dsm_fifo_dataset_3_batch_get(lsm6dsm_ctx_t *ctx,\n                                         lsm6dsm_dec_ds3_fifo_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_FIFO_CTRL4, &reg.byte, 1);\n  *val = (lsm6dsm_dec_ds3_fifo_t) reg.fifo_ctrl4.dec_ds3_fifo;\n\n  return mm_error;\n}\n\n/**\n  * @brief   fifo_dataset_4_batch: [set] Selects Batching Data Rate\n  *                                      (writing frequency in FIFO)\n  *                                      for fourth data set.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_dec_ds4_fifo_t: change the values of dec_ds4_fifo in\n  *                                 reg FIFO_CTRL4\n  *\n  */\nint32_t lsm6dsm_fifo_dataset_4_batch_set(lsm6dsm_ctx_t *ctx,\n                                         lsm6dsm_dec_ds4_fifo_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_FIFO_CTRL4, &reg.byte, 1);\n  reg.fifo_ctrl4.dec_ds4_fifo = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_FIFO_CTRL4, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief   fifo_dataset_4_batch: [get] Selects Batching Data Rate\n  *                                      (writing frequency in FIFO) for\n  *                                      fourth data set.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_dec_ds4_fifo_t: Get the values of dec_ds4_fifo in\n  *                                 reg FIFO_CTRL4\n  *\n  */\nint32_t lsm6dsm_fifo_dataset_4_batch_get(lsm6dsm_ctx_t *ctx,\n                                         lsm6dsm_dec_ds4_fifo_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_FIFO_CTRL4, &reg.byte, 1);\n  *val = (lsm6dsm_dec_ds4_fifo_t) reg.fifo_ctrl4.dec_ds4_fifo;\n\n  return mm_error;\n}\n\n/**\n  * @brief   fifo_xl_gy_8bit_format: [set]  8-bit data storage in FIFO.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of only_high_data in reg FIFO_CTRL4\n  *\n  */\nint32_t lsm6dsm_fifo_xl_gy_8bit_format_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_FIFO_CTRL4, &reg.byte, 1);\n  reg.fifo_ctrl4.only_high_data = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_FIFO_CTRL4, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief   fifo_xl_gy_8bit_format: [get]  8-bit data storage in FIFO.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of only_high_data in reg FIFO_CTRL4\n  *\n  */\nint32_t lsm6dsm_fifo_xl_gy_8bit_format_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_FIFO_CTRL4, &reg.byte, 1);\n  *val = reg.fifo_ctrl4.only_high_data;\n\n  return mm_error;\n}\n\n/**\n  * @brief  fifo_stop_on_wtm: [set] Sensing chain FIFO stop values\n  *                                 memorization at threshold level.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of stop_on_fth in reg FIFO_CTRL4\n  *\n  */\nint32_t lsm6dsm_fifo_stop_on_wtm_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_FIFO_CTRL4, &reg.byte, 1);\n  reg.fifo_ctrl4.stop_on_fth = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_FIFO_CTRL4, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  fifo_stop_on_wtm: [get] Sensing chain FIFO stop values\n  *                                 memorization at threshold level.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of stop_on_fth in reg FIFO_CTRL4\n  *\n  */\nint32_t lsm6dsm_fifo_stop_on_wtm_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_FIFO_CTRL4, &reg.byte, 1);\n  *val = reg.fifo_ctrl4.stop_on_fth;\n\n  return mm_error;\n}\n\n/**\n  * @brief  fifo_mode: [set]  FIFO mode selection.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_fifo_mode_t: change the values of fifo_mode in\n  *                              reg FIFO_CTRL5\n  *\n  */\nint32_t lsm6dsm_fifo_mode_set(lsm6dsm_ctx_t *ctx, lsm6dsm_fifo_mode_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_FIFO_CTRL5, &reg.byte, 1);\n  reg.fifo_ctrl5.fifo_mode = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_FIFO_CTRL5, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  fifo_mode: [get]  FIFO mode selection.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_fifo_mode_t: Get the values of fifo_mode in reg FIFO_CTRL5\n  *\n  */\nint32_t lsm6dsm_fifo_mode_get(lsm6dsm_ctx_t *ctx, lsm6dsm_fifo_mode_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_FIFO_CTRL5, &reg.byte, 1);\n  *val = (lsm6dsm_fifo_mode_t) reg.fifo_ctrl5.fifo_mode;\n\n  return mm_error;\n}\n\n/**\n  * @brief  fifo_data_rate: [set]  FIFO ODR selection, setting FIFO_MODE also.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_odr_fifo_t: change the values of odr_fifo in reg FIFO_CTRL5\n  *\n  */\nint32_t lsm6dsm_fifo_data_rate_set(lsm6dsm_ctx_t *ctx, lsm6dsm_odr_fifo_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_FIFO_CTRL5, &reg.byte, 1);\n  reg.fifo_ctrl5.odr_fifo = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_FIFO_CTRL5, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  fifo_data_rate: [get]  FIFO ODR selection, setting FIFO_MODE also.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_odr_fifo_t: Get the values of odr_fifo in reg FIFO_CTRL5\n  *\n  */\nint32_t lsm6dsm_fifo_data_rate_get(lsm6dsm_ctx_t *ctx, lsm6dsm_odr_fifo_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_FIFO_CTRL5, &reg.byte, 1);\n  *val = (lsm6dsm_odr_fifo_t) reg.fifo_ctrl5.odr_fifo;\n\n  return mm_error;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  DEN_functionality\n  * @brief   This section groups all the functions concerning DEN\n  *          functionality.\n  * @{\n  */\n\n/**\n  * @brief  den_polarity: [set]  DEN active level configuration.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_den_lh_t: change the values of den_lh in reg CTRL5_C\n  *\n  */\n int32_t lsm6dsm_den_polarity_set(lsm6dsm_ctx_t *ctx, lsm6dsm_den_lh_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL5_C, &reg.byte, 1);\n  reg.ctrl5_c.den_lh = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL5_C, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  den_polarity: [get]  DEN active level configuration.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_den_lh_t: Get the values of den_lh in reg CTRL5_C\n  *\n  */\nint32_t lsm6dsm_den_polarity_get(lsm6dsm_ctx_t *ctx, lsm6dsm_den_lh_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL5_C, &reg.byte, 1);\n  *val = (lsm6dsm_den_lh_t) reg.ctrl5_c.den_lh;\n\n  return mm_error;\n}\n\n/**\n  * @brief  den_mode: [set]  DEN functionality marking mode\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_den_mode_t: change the values of den_mode in reg CTRL6_C\n  *\n  */\nint32_t lsm6dsm_den_mode_set(lsm6dsm_ctx_t *ctx, lsm6dsm_den_mode_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL6_C, &reg.byte, 1);\n  reg.ctrl6_c.den_mode = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL6_C, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  den_mode: [get]  DEN functionality marking mode\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_den_mode_t*: change the values of den_mode in reg CTRL6_C\n  *\n  */\nint32_t lsm6dsm_den_mode_get(lsm6dsm_ctx_t *ctx, lsm6dsm_den_mode_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL6_C, &reg.byte, 1);\n  *val = (lsm6dsm_den_mode_t) reg.ctrl6_c.den_mode;\n\n  return mm_error;\n}\n\n/**\n  * @brief  den_enable: [set] Extend DEN functionality to accelerometer\n  *                           sensor.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_den_xl_g_t: change the values of den_xl_g in reg CTRL9_XL\n  *                             and den_xl_en in CTRL4_C.\n  *\n  */\nint32_t lsm6dsm_den_enable_set(lsm6dsm_ctx_t *ctx, lsm6dsm_den_xl_en_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL9_XL, &reg.byte, 1);\n  reg.ctrl9_xl.den_xl_g = val & 0x01;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL9_XL, &reg.byte, 1);\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL4_C, &reg.byte, 1);\n  reg.ctrl4_c.den_xl_en = val & 0x02;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL4_C, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  den_enable: [get] Extend DEN functionality to accelerometer\n  *                           sensor.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_den_xl_g_t: Get the values of den_xl_g in reg CTRL9_XL\n  *                             and den_xl_en in CTRL4_C.\n  *\n  */\nint32_t lsm6dsm_den_enable_get(lsm6dsm_ctx_t *ctx, lsm6dsm_den_xl_en_t *val)\n{\n  lsm6dsm_reg_t reg[2];\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL4_C, &reg[0].byte, 1);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL9_XL, &reg[1].byte, 1);\n  *val = (lsm6dsm_den_xl_en_t) ( ( reg[0].ctrl4_c.den_xl_en << 1) +\n                                 reg[1].ctrl9_xl.den_xl_g );\n\n  return mm_error;\n}\n\n/**\n  * @brief  den_mark_axis_z: [set]  DEN value stored in LSB of Z-axis.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of den_z in reg CTRL9_XL\n  *\n  */\nint32_t lsm6dsm_den_mark_axis_z_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL9_XL, &reg.byte, 1);\n  reg.ctrl9_xl.den_z = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL9_XL, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  den_mark_axis_z: [get]  DEN value stored in LSB of Z-axis.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of den_z in reg CTRL9_XL\n  *\n  */\nint32_t lsm6dsm_den_mark_axis_z_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL9_XL, &reg.byte, 1);\n  *val = reg.ctrl9_xl.den_z;\n\n  return mm_error;\n}\n\n/**\n  * @brief  den_mark_axis_y: [set]  DEN value stored in LSB of Y-axis.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of den_y in reg CTRL9_XL\n  *\n  */\nint32_t lsm6dsm_den_mark_axis_y_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL9_XL, &reg.byte, 1);\n  reg.ctrl9_xl.den_y = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL9_XL, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  den_mark_axis_y: [get]  DEN value stored in LSB of Y-axis.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of den_y in reg CTRL9_XL\n  *\n  */\nint32_t lsm6dsm_den_mark_axis_y_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL9_XL, &reg.byte, 1);\n  *val = reg.ctrl9_xl.den_y;\n\n  return mm_error;\n}\n\n/**\n  * @brief  den_mark_axis_x: [set]  DEN value stored in LSB of X-axis.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of den_x in reg CTRL9_XL\n  *\n  */\nint32_t lsm6dsm_den_mark_axis_x_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL9_XL, &reg.byte, 1);\n  reg.ctrl9_xl.den_x = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL9_XL, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  den_mark_axis_x: [get]  DEN value stored in LSB of X-axis.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of den_x in reg CTRL9_XL\n  *\n  */\nint32_t lsm6dsm_den_mark_axis_x_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL9_XL, &reg.byte, 1);\n  *val = reg.ctrl9_xl.den_x;\n\n  return mm_error;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  Pedometer\n  * @brief   This section groups all the functions that manage pedometer.\n  * @{\n  */\n\n/**\n  * @brief  pedo_step_reset: [set]  Reset pedometer step counter.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of pedo_rst_step in reg CTRL10_C\n  *\n  */\nint32_t lsm6dsm_pedo_step_reset_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL10_C, &reg.byte, 1);\n  reg.ctrl10_c.pedo_rst_step = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL10_C, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  pedo_step_reset: [get]  Reset pedometer step counter.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of pedo_rst_step in reg CTRL10_C\n  *\n  */\nint32_t lsm6dsm_pedo_step_reset_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL10_C, &reg.byte, 1);\n  *val = reg.ctrl10_c.pedo_rst_step;\n\n  return mm_error;\n}\n\n/**\n  * @brief  pedo_sens: [set]  Enable pedometer algorithm.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of pedo_en in reg CTRL10_C\n  *\n  */\nint32_t lsm6dsm_pedo_sens_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL10_C, &reg.byte, 1);\n  reg.ctrl10_c.pedo_en = val;\n  if (val) {\n    reg.ctrl10_c.func_en = val;\n  }\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL10_C, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  pedo_sens: [get]  Enable pedometer algorithm.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of pedo_en in reg CTRL10_C\n  *\n  */\nint32_t lsm6dsm_pedo_sens_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL10_C, &reg.byte, 1);\n  *val = reg.ctrl10_c.pedo_en;\n\n  return mm_error;\n}\n\n/**\n  * @brief  pedo_threshold: [set] Minimum threshold to detect a peak.\n  *                               Default is 10h.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of ths_min in reg\n  *                      CONFIG_PEDO_THS_MIN\n  *\n  */\nint32_t lsm6dsm_pedo_threshold_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_A);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CONFIG_PEDO_THS_MIN, &reg.byte, 1);\n  reg. config_pedo_ths_min.ths_min = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CONFIG_PEDO_THS_MIN, &reg.byte, 1);\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @brief  pedo_threshold: [get] Minimum threshold to detect a peak.\n  *                               Default is 10h.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of ths_min in reg  CONFIG_PEDO_THS_MIN\n  *\n  */\nint32_t lsm6dsm_pedo_threshold_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_A);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CONFIG_PEDO_THS_MIN, &reg.byte, 1);\n  *val = reg. config_pedo_ths_min.ths_min;\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @brief  pedo_full_scale: [set]  Pedometer data range.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_pedo_fs_t: change the values of pedo_fs in\n  *                            reg CONFIG_PEDO_THS_MIN\n  *\n  */\nint32_t lsm6dsm_pedo_full_scale_set(lsm6dsm_ctx_t *ctx, lsm6dsm_pedo_fs_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_A);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CONFIG_PEDO_THS_MIN, &reg.byte, 1);\n  reg. config_pedo_ths_min.pedo_fs = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CONFIG_PEDO_THS_MIN, &reg.byte, 1);\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @brief  pedo_full_scale: [get]  Pedometer data range.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_pedo_fs_t: Get the values of pedo_fs in\n  *                            reg CONFIG_PEDO_THS_MIN\n  *\n  */\nint32_t lsm6dsm_pedo_full_scale_get(lsm6dsm_ctx_t *ctx, lsm6dsm_pedo_fs_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_A);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CONFIG_PEDO_THS_MIN, &reg.byte, 1);\n  *val = (lsm6dsm_pedo_fs_t) reg. config_pedo_ths_min.pedo_fs;\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @brief   pedo_debounce_steps: [set] Pedometer debounce\n  *                                     configuration register (r/w).\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of deb_step in reg PEDO_DEB_REG\n  *\n  */\nint32_t lsm6dsm_pedo_debounce_steps_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_A);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_PEDO_DEB_REG, &reg.byte, 1);\n  reg.pedo_deb_reg.deb_step = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_PEDO_DEB_REG, &reg.byte, 1);\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @brief   pedo_debounce_steps: [get] Pedometer debounce configuration\n  *                                     register (r/w).\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of deb_step in reg PEDO_DEB_REG\n  *\n  */\nint32_t lsm6dsm_pedo_debounce_steps_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_A);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_PEDO_DEB_REG, &reg.byte, 1);\n  *val = reg.pedo_deb_reg.deb_step;\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @brief  pedo_timeout: [set] Debounce time. If the time between two\n  *                             consecutive steps is greater than\n  *                             DEB_TIME*80ms, the debouncer is reactivated.\n  *                             Default value: 01101\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of deb_time in reg PEDO_DEB_REG\n  *\n  */\nint32_t lsm6dsm_pedo_timeout_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_A);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_PEDO_DEB_REG, &reg.byte, 1);\n  reg.pedo_deb_reg.deb_time = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_PEDO_DEB_REG, &reg.byte, 1);\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @brief  pedo_timeout: [get] Debounce time. If the time between two\n  *                             consecutive steps is greater than\n  *                             DEB_TIME*80ms, the debouncer is reactivated.\n  *                             Default value: 01101\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of deb_time in reg PEDO_DEB_REG\n  *\n  */\nint32_t lsm6dsm_pedo_timeout_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_A);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_PEDO_DEB_REG, &reg.byte, 1);\n  *val = reg.pedo_deb_reg.deb_time;\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @brief  pedo_steps_period: [set] Time period register for step\n  *                                  detection on delta time (r/w).\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that contains data to write\n  *\n  */\nint32_t lsm6dsm_pedo_steps_period_set(lsm6dsm_ctx_t *ctx, uint8_t *buff)\n{\n  int32_t mm_error;\n\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_A);\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_STEP_COUNT_DELTA, buff, 1);\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @brief  pedo_steps_period: [get] Time period register for step\n  *                                  detection on delta time (r/w).\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lsm6dsm_pedo_steps_period_get(lsm6dsm_ctx_t *ctx, uint8_t *buff)\n{\n  int32_t mm_error;\n\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_A);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_STEP_COUNT_DELTA, buff, 1);\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  significant_motion\n  * @brief   This section groups all the functions that manage the\n  *          significant motion detection.\n  * @{\n  */\n\n/**\n  * @brief  motion_sens: [set]  Enable significant motion detection function.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of sign_motion_en in reg CTRL10_C\n  *\n  */\nint32_t lsm6dsm_motion_sens_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL10_C, &reg.byte, 1);\n  reg.ctrl10_c.sign_motion_en = val;\n  if (val) {\n    reg.ctrl10_c.func_en = val;\n  }\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL10_C, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  motion_sens: [get]  Enable significant motion detection function.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of sign_motion_en in reg CTRL10_C\n  *\n  */\nint32_t lsm6dsm_motion_sens_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL10_C, &reg.byte, 1);\n  *val = reg.ctrl10_c.sign_motion_en;\n\n  return mm_error;\n}\n\n/**\n  * @brief  motion_threshold: [set]  Significant motion threshold.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that store significant motion threshold.\n  *\n  */\nint32_t lsm6dsm_motion_threshold_set(lsm6dsm_ctx_t *ctx, uint8_t *buff)\n{\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_A);\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_SM_THS, buff, 1);\n  mm_error = lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @brief  motion_threshold: [get]  Significant motion threshold.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that store significant motion threshold.\n  *\n  */\nint32_t lsm6dsm_motion_threshold_get(lsm6dsm_ctx_t *ctx, uint8_t *buff)\n{\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_A);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_SM_THS, buff, 1);\n  mm_error = lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  tilt_detection\n  * @brief   This section groups all the functions that manage the tilt\n  *          event detection.\n  * @{\n  */\n\n/**\n  * @brief  tilt_sens: [set]  Enable tilt calculation.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of tilt_en in reg CTRL10_C\n  *\n  */\nint32_t lsm6dsm_tilt_sens_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL10_C, &reg.byte, 1);\n  reg.ctrl10_c.tilt_en = val;\n  if (val) {\n    reg.ctrl10_c.func_en = val;\n  }\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL10_C, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  tilt_sens: [get]  Enable tilt calculation.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of tilt_en in reg CTRL10_C\n  *\n  */\nint32_t lsm6dsm_tilt_sens_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL10_C, &reg.byte, 1);\n  *val = reg.ctrl10_c.tilt_en;\n\n  return mm_error;\n}\n\n/**\n  * @brief  wrist_tilt: [set]  Enable tilt calculation.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of tilt_en in reg CTRL10_C\n  *\n  */\nint32_t lsm6dsm_wrist_tilt_sens_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL10_C, &reg.byte, 1);\n  reg.ctrl10_c.wrist_tilt_en = val;\n  if (val) {\n    reg.ctrl10_c.func_en = val;\n  }\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL10_C, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  wrist_tilt: [get]  Enable tilt calculation.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of tilt_en in reg CTRL10_C\n  *\n  */\nint32_t lsm6dsm_wrist_tilt_sens_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL10_C, &reg.byte, 1);\n  *val = reg.ctrl10_c.wrist_tilt_en;\n\n  return mm_error;\n}\n\n/**\n  * @brief  tilt_latency: [set] Absolute Wrist Tilt latency register (r/w).\n  *                             Absolute wrist tilt latency parameters.\n  *                             1 LSB = 40 ms. Default value: 0Fh (600 ms).\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that contains data to write\n  *\n  */\nint32_t lsm6dsm_tilt_latency_set(lsm6dsm_ctx_t *ctx, uint8_t *buff)\n{\n  int32_t mm_error;\n\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_B);\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_A_WRIST_TILT_LAT, buff, 1);\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @brief  tilt_latency: [get] Absolute Wrist Tilt latency register (r/w).\n  *                             Absolute wrist tilt latency parameters.\n  *                             1 LSB = 40 ms. Default value: 0Fh (600 ms).\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lsm6dsm_tilt_latency_get(lsm6dsm_ctx_t *ctx, uint8_t *buff)\n{\n  int32_t mm_error;\n\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_B);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_A_WRIST_TILT_LAT, buff, 1);\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @brief  tilt_threshold: [set] Absolute Wrist Tilt threshold register(r/w).\n  *                               Absolute wrist tilt threshold parameters.\n  *                               1 LSB = 15.625 mg.\n  *                               Default value: 20h (500 mg).\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that contains data to write\n  *\n  */\nint32_t lsm6dsm_tilt_threshold_set(lsm6dsm_ctx_t *ctx, uint8_t *buff)\n{\n  int32_t mm_error;\n\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_B);\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_A_WRIST_TILT_THS, buff, 1);\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @brief  tilt_threshold: [get] Absolute Wrist Tilt threshold register(r/w).\n  *                               Absolute wrist tilt threshold parameters.\n  *                               1 LSB = 15.625 mg.\n  *                               Default value: 20h (500 mg).\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lsm6dsm_tilt_threshold_get(lsm6dsm_ctx_t *ctx, uint8_t *buff)\n{\n  int32_t mm_error;\n\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_B);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_A_WRIST_TILT_THS, buff, 1);\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @brief  tilt_src: [set]  Absolute Wrist Tilt mask register (r/w).\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_a_wrist_tilt_mask: registers A_WRIST_TILT_MASK\n  *\n  */\nint32_t lsm6dsm_tilt_src_set(lsm6dsm_ctx_t *ctx,\n                             lsm6dsm_a_wrist_tilt_mask_t *val)\n{\n  int32_t mm_error;\n\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_B);\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_A_WRIST_TILT_MASK,\n\t\t  \t       (uint8_t*) val, 1);\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @brief  tilt_src: [get]  Absolute Wrist Tilt mask register (r/w).\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_a_wrist_tilt_mask: registers A_WRIST_TILT_MASK\n  *\n  */\nint32_t lsm6dsm_tilt_src_get(lsm6dsm_ctx_t *ctx,\n                             lsm6dsm_a_wrist_tilt_mask_t *val)\n{\n  int32_t mm_error;\n\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_B);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_A_WRIST_TILT_MASK,\n                              (uint8_t*) val, 1);\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup   magnetometer_sensor\n  * @brief   This section groups all the functions that manage additional\n  *          magnetometer sensor.\n  * @{\n  */\n\n/**\n  * @brief  mag_soft_iron: [set] Enable soft-iron correction algorithm for\n  *                              magnetometer.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of soft_en in reg CTRL9_XL\n  *\n  */\nint32_t lsm6dsm_mag_soft_iron_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL9_XL, &reg.byte, 1);\n  reg.ctrl9_xl.soft_en = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL9_XL, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  mag_soft_iron: [get] Enable soft-iron correction algorithm\n  *                              for magnetometer.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of soft_en in reg CTRL9_XL\n  *\n  */\nint32_t lsm6dsm_mag_soft_iron_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL9_XL, &reg.byte, 1);\n  *val = reg.ctrl9_xl.soft_en;\n\n  return mm_error;\n}\n\n/**\n  * @brief  mag_hard_iron: [set] Enable hard-iron correction algorithm\n  *                              for magnetometer.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of iron_en in reg MASTER_CONFIG\n  *\n  */\nint32_t lsm6dsm_mag_hard_iron_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_MASTER_CONFIG, &reg.byte, 1);\n  reg.master_config.iron_en = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_MASTER_CONFIG, &reg.byte, 1);\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL10_C, &reg.byte, 1);\n  if (val) {\n    reg.ctrl10_c.func_en = val;\n  }\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL10_C, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  mag_hard_iron: [get] Enable hard-iron correction algorithm\n  *                              for magnetometer.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of iron_en in reg MASTER_CONFIG\n  *\n  */\nint32_t lsm6dsm_mag_hard_iron_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_MASTER_CONFIG, &reg.byte, 1);\n  *val = reg.master_config.iron_en;\n\n  return mm_error;\n}\n\n/**\n  * @brief  mag_soft_iron_mat: [set] 3x3 soft iron matrix. Value are\n  *                                  expressed in sign-module format.\n  *                                  (Es. SVVVVVVVb where S is the sign 0/+\n  *                                  1/- and V is the value).\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that contains data to write\n  *\n  */\nint32_t lsm6dsm_mag_soft_iron_mat_set(lsm6dsm_ctx_t *ctx, uint8_t *buff)\n{\n  int32_t mm_error;\n\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_A);\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_MAG_SI_XX, buff, 9);\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @brief  mag_soft_iron_mat: [get] 3x3 soft iron matrix. Value are\n  *                                  expressed in sign-module format.\n  *                                  (Es. SVVVVVVVb where S is the sign 0/+\n  *                                  1/- and V is the value).\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lsm6dsm_mag_soft_iron_mat_get(lsm6dsm_ctx_t *ctx, uint8_t *buff)\n{\n  int32_t mm_error;\n\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_A);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_MAG_SI_XX, buff, 9);\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @brief  mag_offset: [set] Offset for hard-iron compensation\n  *                           register (r/w). The value is expressed as\n  *                           a 16-bit word in twos complement.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that contains data to write\n  *\n  */\nint32_t lsm6dsm_mag_offset_set(lsm6dsm_ctx_t *ctx, uint8_t *buff)\n{\n  int32_t mm_error;\n\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_A);\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_MAG_OFFX_L, buff, 6);\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @brief  mag_offset: [get] Offset for hard-iron compensation register(r/w).\n  *                           The value is expressed as a 16-bit word in\n  *                           twos complement.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lsm6dsm_mag_offset_get(lsm6dsm_ctx_t *ctx, uint8_t *buff)\n{\n  int32_t mm_error;\n\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_A);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_MAG_OFFX_L, buff, 6);\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  Sensor_hub\n  * @brief   This section groups all the functions that manage the sensor\n  *          hub functionality.\n  * @{\n  */\n\n/**\n  * @brief  func_en: [set] Enable function.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values func_en\n  *\n  */\nint32_t lsm6dsm_func_en_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_CTRL10_C, &reg.byte, 1);\n  reg.ctrl10_c.func_en = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_CTRL10_C, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  sh_sync_sens_frame: [set] Sensor synchronization time frame\n  *                                   with the step of 500 ms and full range\n  *                                   of 5 s. Unsigned 8-bit.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of tph in reg SENSOR_SYNC_TIME_FRAME\n  *\n  */\nint32_t lsm6dsm_sh_sync_sens_frame_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_SENSOR_SYNC_TIME_FRAME,\n                              &reg.byte, 1);\n  reg. sensor_sync_time_frame.tph = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_SENSOR_SYNC_TIME_FRAME,\n                               &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  sh_sync_sens_frame: [get] Sensor synchronization time frame with\n  *                                   the step of 500 ms and full range of 5s.\n  *                                   Unsigned 8-bit.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of tph in reg  SENSOR_SYNC_TIME_FRAME\n  *\n  */\nint32_t lsm6dsm_sh_sync_sens_frame_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_SENSOR_SYNC_TIME_FRAME,\n                              &reg.byte, 1);\n  *val = reg. sensor_sync_time_frame.tph;\n\n  return mm_error;\n}\n\n/**\n  * @brief  sh_sync_sens_ratio: [set] Resolution ratio of error code for\n  *                                   sensor synchronization\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_rr_t: change the values of rr in reg  SENSOR_SYNC_RES_RATIO\n  *\n  */\nint32_t lsm6dsm_sh_sync_sens_ratio_set(lsm6dsm_ctx_t *ctx, lsm6dsm_rr_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_SENSOR_SYNC_RES_RATIO,\n                              &reg.byte, 1);\n  reg. sensor_sync_res_ratio.rr = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_SENSOR_SYNC_RES_RATIO,\n                               &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  sh_sync_sens_ratio: [get] Resolution ratio of error code\n  *                                   for sensor synchronization\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_rr_t: Get the values of rr in reg  SENSOR_SYNC_RES_RATIO\n  *\n  */\nint32_t lsm6dsm_sh_sync_sens_ratio_get(lsm6dsm_ctx_t *ctx, lsm6dsm_rr_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_SENSOR_SYNC_RES_RATIO,\n                              &reg.byte, 1);\n  *val = (lsm6dsm_rr_t) reg. sensor_sync_res_ratio.rr;\n\n  return mm_error;\n}\n\n/**\n  * @brief  sh_master: [set]  Sensor hub I2C master enable.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of master_on in reg MASTER_CONFIG\n  *\n  */\nint32_t lsm6dsm_sh_master_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_MASTER_CONFIG, &reg.byte, 1);\n  reg.master_config.master_on = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_MASTER_CONFIG, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  sh_master: [get]  Sensor hub I2C master enable.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of master_on in reg MASTER_CONFIG\n  *\n  */\nint32_t lsm6dsm_sh_master_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_MASTER_CONFIG, &reg.byte, 1);\n  *val = reg.master_config.master_on;\n\n  return mm_error;\n}\n\n/**\n  * @brief  sh_pass_through: [set]  I2C interface pass-through.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of pass_through_mode in\n  *                      reg MASTER_CONFIG\n  *\n  */\nint32_t lsm6dsm_sh_pass_through_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_MASTER_CONFIG, &reg.byte, 1);\n  reg.master_config.pass_through_mode = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_MASTER_CONFIG, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  sh_pass_through: [get]  I2C interface pass-through.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of pass_through_mode in\n  *                  reg MASTER_CONFIG\n  *\n  */\nint32_t lsm6dsm_sh_pass_through_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_MASTER_CONFIG, &reg.byte, 1);\n  *val = reg.master_config.pass_through_mode;\n\n  return mm_error;\n}\n\n/**\n  * @brief  sh_pin_mode: [set]  Master I2C pull-up enable/disable.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_pull_up_en_t: change the values of pull_up_en in\n  *                               reg MASTER_CONFIG\n  *\n  */\nint32_t lsm6dsm_sh_pin_mode_set(lsm6dsm_ctx_t *ctx, lsm6dsm_pull_up_en_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_MASTER_CONFIG, &reg.byte, 1);\n  reg.master_config.pull_up_en = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_MASTER_CONFIG, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  sh_pin_mode: [get]  Master I2C pull-up enable/disable.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_pull_up_en_t: Get the values of pull_up_en in\n  *                               reg MASTER_CONFIG\n  *\n  */\nint32_t lsm6dsm_sh_pin_mode_get(lsm6dsm_ctx_t *ctx, lsm6dsm_pull_up_en_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_MASTER_CONFIG, &reg.byte, 1);\n  *val = (lsm6dsm_pull_up_en_t) reg.master_config.pull_up_en;\n\n  return mm_error;\n}\n\n/**\n  * @brief  sh_syncro_mode: [set]  Sensor hub trigger signal selection.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_start_config_t: change the values of start_config in\n  *                                 reg MASTER_CONFIG\n  *\n  */\nint32_t lsm6dsm_sh_syncro_mode_set(lsm6dsm_ctx_t *ctx,\n                                   lsm6dsm_start_config_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_MASTER_CONFIG, &reg.byte, 1);\n  reg.master_config.start_config = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_MASTER_CONFIG, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  sh_syncro_mode: [get] Sensor hub trigger signal selection.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_start_config_t: Get the values of start_config in\n  *                                 reg MASTER_CONFIG\n  *\n  */\nint32_t lsm6dsm_sh_syncro_mode_get(lsm6dsm_ctx_t *ctx,\n                                   lsm6dsm_start_config_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_MASTER_CONFIG, &reg.byte, 1);\n  *val = (lsm6dsm_start_config_t) reg.master_config.start_config;\n\n  return mm_error;\n}\n\n/**\n  * @brief  sh_drdy_on_int1: [set] Manage the Master DRDY signal on INT1 pad.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of drdy_on_int1 in\n  *                      reg MASTER_CONFIG\n  *\n  */\nint32_t lsm6dsm_sh_drdy_on_int1_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_MASTER_CONFIG, &reg.byte, 1);\n  reg.master_config.drdy_on_int1 = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_MASTER_CONFIG, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  sh_drdy_on_int1: [get]  Manage the Master DRDY signal on INT1 pad.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of drdy_on_int1 in reg MASTER_CONFIG\n  *\n  */\nint32_t lsm6dsm_sh_drdy_on_int1_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_MASTER_CONFIG, &reg.byte, 1);\n  *val = reg.master_config.drdy_on_int1;\n\n  return mm_error;\n}\n\n/**\n  * @brief  sh_read_data_raw: [get]  Sensor hub output registers.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_: union of registers from SENSORHUB1_REG to\n  *\n  */\nint32_t lsm6dsm_sh_read_data_raw_get(lsm6dsm_ctx_t *ctx,\n                                     lsm6dsm_emb_sh_read_t *val)\n{\n  int32_t mm_error;\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_SENSORHUB1_REG,\n                              &(val->byte[0]), 12);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_SENSORHUB13_REG,\n                              &(val->byte[12]), 6);\n\n  return mm_error;\n}\n\n/**\n  * @brief  sh_cmd_sens_sync: [set] Master command code used for stamping\n  *                                 for sensor sync.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of master_cmd_code in\n  *                      reg MASTER_CMD_CODE\n  *\n  */\nint32_t lsm6dsm_sh_cmd_sens_sync_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_MASTER_CMD_CODE, &reg.byte, 1);\n  reg.master_cmd_code.master_cmd_code = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_MASTER_CMD_CODE, &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  sh_cmd_sens_sync: [get] Master command code used for stamping\n  *                                 for sensor sync.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of master_cmd_code in\n  *                  reg MASTER_CMD_CODE\n  *\n  */\nint32_t lsm6dsm_sh_cmd_sens_sync_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_MASTER_CMD_CODE, &reg.byte, 1);\n  *val = reg.master_cmd_code.master_cmd_code;\n\n  return mm_error;\n}\n\n/**\n  * @brief  sh_spi_sync_error: [set] Error code used for sensor\n  *                                  synchronization.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of error_code in\n  *                      reg SENS_SYNC_SPI_ERROR_CODE\n  *\n  */\nint32_t lsm6dsm_sh_spi_sync_error_set(lsm6dsm_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_SENS_SYNC_SPI_ERROR_CODE,\n                              &reg.byte, 1);\n  reg. sens_sync_spi_error_code.error_code = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_SENS_SYNC_SPI_ERROR_CODE,\n                               &reg.byte, 1);\n\n  return mm_error;\n}\n\n/**\n  * @brief  sh_spi_sync_error: [get] Error code used for sensor\n  *                                  synchronization.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of error_code in\n  *                  reg SENS_SYNC_SPI_ERROR_CODE\n  *\n  */\nint32_t lsm6dsm_sh_spi_sync_error_get(lsm6dsm_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_SENS_SYNC_SPI_ERROR_CODE,\n                              &reg.byte, 1);\n  *val = reg. sens_sync_spi_error_code.error_code;\n\n  return mm_error;\n}\n\n/**\n  * @brief   sh_num_of_dev_connected: [set] Number of external sensors to\n  *                                         be read by the sensor hub.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_aux_sens_on_t: change the values of aux_sens_on in\n  *                                reg SLAVE0_CONFIG\n  *\n  */\nint32_t lsm6dsm_sh_num_of_dev_connected_set(lsm6dsm_ctx_t *ctx,\n                                            lsm6dsm_aux_sens_on_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_A);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_SLAVE0_CONFIG, &reg.byte, 1);\n  reg.slave0_config.aux_sens_on = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_SLAVE0_CONFIG, &reg.byte, 1);\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @brief   sh_num_of_dev_connected: [get] Number of external sensors to\n  *                                         be read by the sensor hub.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_aux_sens_on_t: Get the values of aux_sens_on in\n  *                                reg SLAVE0_CONFIG\n  *\n  */\nint32_t lsm6dsm_sh_num_of_dev_connected_get(lsm6dsm_ctx_t *ctx,\n                                            lsm6dsm_aux_sens_on_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_A);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_SLAVE0_CONFIG, &reg.byte, 1);\n  *val = (lsm6dsm_aux_sens_on_t) reg.slave0_config.aux_sens_on;\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @brief  sh_cfg_write: Configure slave 0 for perform a write.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_sh_cfg_write_t: a structure that contain\n  *                      - uint8_t slv_add;    8 bit i2c device address\n  *                      - uint8_t slv_subadd; 8 bit register device address\n  *                      - uint8_t slv_data;   8 bit data to write\n  *\n  */\nint32_t lsm6dsm_sh_cfg_write(lsm6dsm_ctx_t *ctx, lsm6dsm_sh_cfg_write_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_A);\n  reg.byte = val->slv0_add;\n  reg.slv0_add.rw_0 = 0;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_SLV0_ADD, &reg.byte, 1);\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_SLV0_SUBADD,\n                               &(val->slv0_subadd), 1);\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_DATAWRITE_SRC_MODE_SUB_SLV0,\n                              &(val->slv0_data), 1);\n  mm_error = lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @brief  sh_slv0_cfg_read: [get] Configure slave 0 for perform a write/read.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_sh_cfg_read_t: a structure that contain\n  *                      - uint8_t slv_add;    8 bit i2c device address\n  *                      - uint8_t slv_subadd; 8 bit register device address\n  *                      - uint8_t slv_len;    num of bit to read\n  *\n  */\nint32_t lsm6dsm_sh_slv0_cfg_read(lsm6dsm_ctx_t *ctx,\n                                 lsm6dsm_sh_cfg_read_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_A);\n  reg.byte = val->slv_add;\n  reg.slv0_add.rw_0 = 1;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_SLV0_ADD, &reg.byte, 1);\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_SLV0_SUBADD,\n                               &(val->slv_subadd), 1);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_SLAVE0_CONFIG, &reg.byte, 1);\n  reg.slave0_config.slave0_numop = val->slv_len;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_SLAVE0_CONFIG, &reg.byte, 1);\n  mm_error = lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @brief  sh_slv1_cfg_read: [get] Configure slave 0 for perform a write/read.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_sh_cfg_read_t: a structure that contain\n  *                      - uint8_t slv_add;    8 bit i2c device address\n  *                      - uint8_t slv_subadd; 8 bit register device address\n  *                      - uint8_t slv_len;    num of bit to read\n  *\n  */\nint32_t lsm6dsm_sh_slv1_cfg_read(lsm6dsm_ctx_t *ctx,\n                                 lsm6dsm_sh_cfg_read_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_A);\n  reg.byte = val->slv_add;\n  reg.slv1_add.r_1 = 1;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_SLV1_ADD, &reg.byte, 1);\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_SLV1_SUBADD,\n                               &(val->slv_subadd), 1);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_SLAVE1_CONFIG, &reg.byte, 1);\n  reg.slave1_config.slave1_numop = val->slv_len;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_SLAVE1_CONFIG, &reg.byte, 1);\n  mm_error = lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @brief  sh_slv2_cfg_read: [get] Configure slave 0 for perform a write/read.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_sh_cfg_read_t: a structure that contain\n  *                      - uint8_t slv_add;    8 bit i2c device address\n  *                      - uint8_t slv_subadd; 8 bit register device address\n  *                      - uint8_t slv_len;    num of bit to read\n  *\n  */\nint32_t lsm6dsm_sh_slv2_cfg_read(lsm6dsm_ctx_t *ctx,\n                                 lsm6dsm_sh_cfg_read_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_A);\n  reg.byte = val->slv_add;\n  reg.slv2_add.r_2 = 1;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_SLV2_ADD, &reg.byte, 1);\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_SLV2_SUBADD,\n                               &(val->slv_subadd), 1);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_SLAVE2_CONFIG, &reg.byte, 1);\n  reg.slave2_config.slave2_numop = val->slv_len;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_SLAVE2_CONFIG, &reg.byte, 1);\n  mm_error = lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @brief  sh_slv3_cfg_read: [get] Configure slave 0 for perform a write/read.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_sh_cfg_read_t: a structure that contain\n  *                      - uint8_t slv_add;    8 bit i2c device address\n  *                      - uint8_t slv_subadd; 8 bit register device address\n  *                      - uint8_t slv_len;    num of bit to read\n  *\n  */\nint32_t lsm6dsm_sh_slv3_cfg_read(lsm6dsm_ctx_t *ctx,\n                                 lsm6dsm_sh_cfg_read_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  mm_error = lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_A);\n  reg.byte = val->slv_add;\n  reg.slv3_add.r_3 = 1;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_SLV3_ADD, &reg.byte, 1);\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_SLV3_SUBADD,\n                               &(val->slv_subadd), 1);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_SLAVE3_CONFIG, &reg.byte, 1);\n  reg.slave3_config.slave3_numop = val->slv_len;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_SLAVE3_CONFIG, &reg.byte, 1);\n  mm_error = lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @brief  sh_slave_0_dec: [set] Decimation of read operation on Slave 0\n  *                               starting from the sensor hub trigger.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_slave0_rate_t: change the values of slave0_rate in\n  *                                reg SLAVE0_CONFIG\n  *\n  */\nint32_t lsm6dsm_sh_slave_0_dec_set(lsm6dsm_ctx_t *ctx,\n                                   lsm6dsm_slave0_rate_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_A);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_SLAVE0_CONFIG, &reg.byte, 1);\n  reg.slave0_config.slave0_rate = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_SLAVE0_CONFIG, &reg.byte, 1);\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @brief  sh_slave_0_dec: [get] Decimation of read operation on Slave 0\n  *                               starting from the sensor hub trigger.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_slave0_rate_t: Get the values of slave0_rate in\n  *                                reg SLAVE0_CONFIG\n  *\n  */\nint32_t lsm6dsm_sh_slave_0_dec_get(lsm6dsm_ctx_t *ctx,\n                                   lsm6dsm_slave0_rate_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_A);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_SLAVE0_CONFIG, &reg.byte, 1);\n  *val = (lsm6dsm_slave0_rate_t) reg.slave0_config.slave0_rate;\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @brief  sh_write_mode: [set] Slave 0 write operation is performed only\n  *                              at the first sensor hub cycle.\n  *                              This is effective if the Aux_sens_on[1:0]\n  *                              field in SLAVE0_CONFIG (04h) is set to a\n  *                              value other than 00.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_write_once_t: change the values of write_once in\n  *                               reg SLAVE1_CONFIG\n  *\n  */\nint32_t lsm6dsm_sh_write_mode_set(lsm6dsm_ctx_t *ctx, lsm6dsm_write_once_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_A);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_SLAVE1_CONFIG, &reg.byte, 1);\n  reg.slave1_config.write_once = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_SLAVE1_CONFIG, &reg.byte, 1);\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @brief  sh_write_mode: [get] Slave 0 write operation is performed only\n  *                              at the first sensor hub cycle.\n  *                              This is effective if the Aux_sens_on[1:0]\n  *                              field in SLAVE0_CONFIG (04h) is set to a\n  *                              value other than 00\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_write_once_t: Get the values of write_once in\n  *                               reg SLAVE1_CONFIG\n  *\n  */\nint32_t lsm6dsm_sh_write_mode_get(lsm6dsm_ctx_t *ctx,\n                                  lsm6dsm_write_once_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_A);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_SLAVE1_CONFIG, &reg.byte, 1);\n  *val = (lsm6dsm_write_once_t) reg.slave1_config.write_once;\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @brief  sh_slave_1_dec: [set] Decimation of read operation on Slave 1\n  *                               starting from the sensor hub trigger.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_slave1_rate_t: change the values of slave1_rate in\n  *                                reg SLAVE1_CONFIG\n  *\n  */\nint32_t lsm6dsm_sh_slave_1_dec_set(lsm6dsm_ctx_t *ctx,\n                                   lsm6dsm_slave1_rate_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_A);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_SLAVE1_CONFIG, &reg.byte, 1);\n  reg.slave1_config.slave1_rate = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_SLAVE1_CONFIG, &reg.byte, 1);\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @brief  sh_slave_1_dec: [get] Decimation of read operation on Slave 1\n  *                               starting from the sensor hub trigger.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_slave1_rate_t: Get the values of slave1_rate in\n  *                                reg SLAVE1_CONFIG\n  *\n  */\nint32_t lsm6dsm_sh_slave_1_dec_get(lsm6dsm_ctx_t *ctx,\n                                   lsm6dsm_slave1_rate_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_A);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_SLAVE1_CONFIG, &reg.byte, 1);\n  *val = (lsm6dsm_slave1_rate_t) reg.slave1_config.slave1_rate;\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @brief  sh_slave_2_dec: [set] Decimation of read operation on Slave 2\n  *                               starting from the sensor hub trigger.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_slave2_rate_t: change the values of slave2_rate in\n  *                                reg SLAVE2_CONFIG\n  *\n  */\nint32_t lsm6dsm_sh_slave_2_dec_set(lsm6dsm_ctx_t *ctx,\n                                   lsm6dsm_slave2_rate_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_A);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_SLAVE2_CONFIG, &reg.byte, 1);\n  reg.slave2_config.slave2_rate = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_SLAVE2_CONFIG, &reg.byte, 1);\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @brief  sh_slave_2_dec: [get] Decimation of read operation on Slave 2\n  *                               starting from the sensor hub trigger.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_slave2_rate_t: Get the values of slave2_rate in\n  *                                reg SLAVE2_CONFIG\n  *\n  */\nint32_t lsm6dsm_sh_slave_2_dec_get(lsm6dsm_ctx_t *ctx,\n                                   lsm6dsm_slave2_rate_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_A);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_SLAVE2_CONFIG, &reg.byte, 1);\n  *val = (lsm6dsm_slave2_rate_t) reg.slave2_config.slave2_rate;\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @brief  sh_slave_3_dec: [set] Decimation of read operation on\n  *                               Slave 3 starting from the sensor hub trigger.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_slave3_rate_t: change the values of slave3_rate in\n  *                                reg SLAVE3_CONFIG\n  *\n  */\nint32_t lsm6dsm_sh_slave_3_dec_set(lsm6dsm_ctx_t *ctx,\n                                   lsm6dsm_slave3_rate_t val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_A);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_SLAVE3_CONFIG, &reg.byte, 1);\n  reg.slave3_config.slave3_rate = val;\n  mm_error = lsm6dsm_write_reg(ctx, LSM6DSM_SLAVE3_CONFIG, &reg.byte, 1);\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/**\n  * @brief  sh_slave_3_dec: [get] Decimation of read operation on Slave 3\n  *                               starting from the sensor hub trigger.\n  *\n  * @param  lsm6dsm_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsm_slave3_rate_t: Get the values of slave3_rate in\n  *                                reg SLAVE3_CONFIG\n  *\n  */\nint32_t lsm6dsm_sh_slave_3_dec_get(lsm6dsm_ctx_t *ctx,\n                                   lsm6dsm_slave3_rate_t *val)\n{\n  lsm6dsm_reg_t reg;\n  int32_t mm_error;\n\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_BANK_A);\n  mm_error = lsm6dsm_read_reg(ctx, LSM6DSM_SLAVE3_CONFIG, &reg.byte, 1);\n  *val = (lsm6dsm_slave3_rate_t) reg.slave3_config.slave3_rate;\n  lsm6dsm_mem_bank_set(ctx, LSM6DSM_USER_BANK);\n\n  return mm_error;\n}\n\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\n"
              }
            }
          },
          "md5": "edbf3de396d10f840c270f01caa5e82f"
        },
        "lsm6dsl": {
          "libName": "lsm6dsl",
          "manufacturer": "STMicroelectronics",
          "description": "3D Inertial Module",
          "type": "Accelerometer Gyroscope",
          "icon": "",
          "image": "",
          "version": "",
          "eelVersion": "3",
          "shoppingCartLinks": {
            "digikey": {
              "links": {
                "info": "https://www.digikey.com/product-detail/en/stmicroelectronics/LSM6DSLTR/497-16705-1-ND/6192805"
              },
              "cartData": {
                "part": "497-16705-1-ND",
                "partid": "6192805",
                "source": "dkstudio",
                "qty": "1"
              }
            }
          },
          "requires": [
            "embedded",
            "i2c",
            "gpio",
            "fpmath"
          ],
          "elements": [
            {
              "name": "EmbeddedLSM6DSL",
              "type": "EmbeddedLSM6DSL",
              "icon": "EmbeddedGyroscope.svg",
              "defaultAbility": "xAcceleration",
              "defaultTrigger": "xAccelerationRead",
              "hidden": false,
              "helpPageHref": "https://developer.atmosphereiot.com/documents/elements/stmicroelectronicslsm6dslelement.html",
              "abilities": [
                {
                  "name": "setup",
                  "hidden": true,
                  "code": "    ATMO_LSM6DSL_Config_t config;\r\n    config.i2cInstance = ATMO_PROPERTY(undefined, i2cInstance);\r\n    config.i2cAddress = ATMO_PROPERTY(undefined, i2cAddress);\r\n    config.accelOdr = ATMO_PROPERTY(undefined, accelOdr);\r\n    config.gyroOdr = ATMO_PROPERTY(undefined, gyroOdr);\r\n    config.accelFullScale = ATMO_PROPERTY(undefined, accelFullScale);\r\n    config.gyroFullScale = ATMO_PROPERTY(undefined, gyroFullScale);\r\n    return ATMO_LSM6DSL_Init(&config) == ATMO_LSM6DSL_Status_Success ? ATMO_Status_Success : ATMO_Status_Fail;"
                },
                {
                  "name": "xAcceleration",
                  "triggers": [
                    "xAccelerationRead"
                  ],
                  "code": "    ATMO_LSM6DSL_AccelData_t accelData;\r\n    if(ATMO_LSM6DSL_GetAccelData(&accelData) != ATMO_LSM6DSL_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, accelData.x);\r\n    return ATMO_Status_Success;"
                },
                {
                  "name": "yAcceleration",
                  "triggers": [
                    "yAccelerationRead"
                  ],
                  "code": "    ATMO_LSM6DSL_AccelData_t accelData;\r\n    if(ATMO_LSM6DSL_GetAccelData(&accelData) != ATMO_LSM6DSL_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, accelData.y);\r\n    return ATMO_Status_Success;"
                },
                {
                  "name": "zAcceleration",
                  "triggers": [
                    "zAccelerationRead"
                  ],
                  "code": "    ATMO_LSM6DSL_AccelData_t accelData;\r\n    if(ATMO_LSM6DSL_GetAccelData(&accelData) != ATMO_LSM6DSL_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, accelData.z);\r\n    return ATMO_Status_Success;"
                },
                {
                  "name": "acceleration",
                  "triggers": [
                    "accelerationRead"
                  ],
                  "code": "    ATMO_LSM6DSL_AccelData_t accelData;\r\n    ATMO_3dFloatVector_t vec;\r\n    if(ATMO_LSM6DSL_GetAccelData(&accelData) != ATMO_LSM6DSL_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    vec.x = accelData.x;\r\n    vec.y = accelData.y;\r\n    vec.z = accelData.z;\r\n\r\n    ATMO_CreateValue3dVectorFloat(out, &vec);\r\n    return ATMO_Status_Success;"
                },
                {
                  "name": "angularRate",
                  "triggers": [
                    "angularRateRead"
                  ],
                  "code": "    ATMO_LSM6DSL_GyroData_t gyroData;\r\n    ATMO_3dFloatVector_t vec;\r\n    if(ATMO_LSM6DSL_GetGyroData(&gyroData) != ATMO_LSM6DSL_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    \r\n    vec.x = gyroData.x;\r\n    vec.y = gyroData.y;\r\n    vec.z = gyroData.z;\r\n\r\n    ATMO_CreateValue3dVectorFloat(out, &vec);\r\n    return ATMO_Status_Success;"
                },
                {
                  "name": "xAngularRate",
                  "triggers": [
                    "xAngularRateRead"
                  ],
                  "code": "\r\n    ATMO_LSM6DSL_GyroData_t gyroData;\r\n    if(ATMO_LSM6DSL_GetGyroData(&gyroData) != ATMO_LSM6DSL_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, gyroData.x);\r\n    return ATMO_Status_Success;"
                },
                {
                  "name": "yAngularRate",
                  "triggers": [
                    "yAngularRateRead"
                  ],
                  "code": "\r\n    ATMO_LSM6DSL_GyroData_t gyroData;\r\n    if(ATMO_LSM6DSL_GetGyroData(&gyroData) != ATMO_LSM6DSL_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, gyroData.y);\r\n    return ATMO_Status_Success;"
                },
                {
                  "name": "zAngularRate",
                  "triggers": [
                    "zAngularRateRead"
                  ],
                  "code": "\r\n    ATMO_LSM6DSL_GyroData_t gyroData;\r\n    if(ATMO_LSM6DSL_GetGyroData(&gyroData) != ATMO_LSM6DSL_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, gyroData.z);\r\n    return ATMO_Status_Success;"
                },
                {
                  "name": "temperature",
                  "triggers": [
                    "temperatureRead"
                  ],
                  "code": "    float temperature = 0;\r\n    if(ATMO_LSM6DSL_GetTempData(&temperature) != ATMO_LSM6DSL_Status_Success)\r\n    {\r\n        return ATMO_Status_Fail;\r\n    }\r\n    ATMO_CreateValueFloat(out, temperature);\r\n    return ATMO_Status_Success;"
                }
              ],
              "properties": [
                {
                  "name": "i2cInstance",
                  "input": "number",
                  "value": "0"
                },
                {
                  "name": "i2cAddress",
                  "input": "select",
                  "inputOptions": [
                    "0x6B",
                    "0x6A"
                  ],
                  "value": "0x6A"
                },
                {
                  "name": "accelOdr",
                  "input": "select",
                  "inputOptions": [
                    "LSM6DSL_XL_ODR_OFF",
                    "LSM6DSL_XL_ODR_12Hz5",
                    "LSM6DSL_XL_ODR_26Hz",
                    "LSM6DSL_XL_ODR_52Hz",
                    "LSM6DSL_XL_ODR_104Hz",
                    "LSM6DSL_XL_ODR_208Hz",
                    "LSM6DSL_XL_ODR_416Hz",
                    "LSM6DSL_XL_ODR_833Hz",
                    "LSM6DSL_XL_ODR_1k66Hz",
                    "LSM6DSL_XL_ODR_3k33Hz",
                    "LSM6DSL_XL_ODR_6k66Hz",
                    "LSM6DSL_XL_ODR_1Hz6"
                  ],
                  "value": "LSM6DSL_XL_ODR_12Hz5"
                },
                {
                  "name": "gyroOdr",
                  "input": "select",
                  "inputOptions": [
                    "LSM6DSL_GY_ODR_OFF",
                    "LSM6DSL_GY_ODR_12Hz5",
                    "LSM6DSL_GY_ODR_26Hz",
                    "LSM6DSL_GY_ODR_52Hz",
                    "LSM6DSL_GY_ODR_104Hz",
                    "LSM6DSL_GY_ODR_208Hz",
                    "LSM6DSL_GY_ODR_416Hz",
                    "LSM6DSL_GY_ODR_833Hz",
                    "LSM6DSL_GY_ODR_1k66Hz",
                    "LSM6DSL_GY_ODR_3k33Hz",
                    "LSM6DSL_GY_ODR_6k66Hz"
                  ],
                  "value": "LSM6DSL_GY_ODR_12Hz5"
                },
                {
                  "name": "accelFullScale",
                  "input": "select",
                  "inputOptions": [
                    "LSM6DSL_2g",
                    "LSM6DSL_16g",
                    "LSM6DSL_4g",
                    "LSM6DSL_8g"
                  ],
                  "value": "LSM6DSL_2g"
                },
                {
                  "name": "gyroFullScale",
                  "input": "select",
                  "inputOptions": [
                    "LSM6DSL_250dps",
                    "LSM6DSL_125dps",
                    "LSM6DSL_500dps",
                    "LSM6DSL_1000dps",
                    "LSM6DSL_2000dps"
                  ],
                  "value": "LSM6DSL_2000dps"
                }
              ],
              "triggers": [],
              "variables": [],
              "language": {
                "en-US": {
                  "EmbeddedLSM6DSL": "LSM6DSL Inertial",
                  "xAcceleration": "Read X Acceleration (mg)",
                  "yAcceleration": "Read Y Acceleration (mg)",
                  "zAcceleration": "Read Z Acceleration (mg)",
                  "xAngularRate": "Read X Angular Rate (mdps)",
                  "yAngularRate": "Read Y Angular Rate (mdps)",
                  "zAngularRate": "Read Z Angular Rate (mdps)",
                  "xAccelerationRead": "X Acceleration Read",
                  "yAccelerationRead": "Y Acceleration Read",
                  "zAccelerationRead": "Z Acceleration Read",
                  "xAngularRateRead": "X Angular Rate Read",
                  "yAngularRateRead": "Y Angular Rate Read",
                  "zAngularRateRead": "Z Angular Rate Read",
                  "acceleration": "Read Acceleration",
                  "accelerationRead": "Acceleration Read",
                  "i2cAddress": "I2C Address",
                  "i2cInstance": "I2C Instance",
                  "angularRate": "Angular Rate",
                  "angularRateRead": "Angular Rate Read",
                  "temperature": "Read Temperature (C)",
                  "temperatureRead": "Temperature Read",
                  "accelOdr": "Accelerometer Output Data Rate",
                  "gyroOdr": "Gyroscope Output Data Rate",
                  "accelFullScale": "Accelerometer Full Scale",
                  "gyroFullScale": "Gyroscope Full Scale",
                  "LSM6DSL_XL_ODR_OFF": "Power Off",
                  "LSM6DSL_XL_ODR_12Hz5": "12.5 Hz",
                  "LSM6DSL_XL_ODR_26Hz": "26 Hz",
                  "LSM6DSL_XL_ODR_52Hz": "52 Hz",
                  "LSM6DSL_XL_ODR_104Hz": "104 Hz",
                  "LSM6DSL_XL_ODR_208Hz": "208 Hz",
                  "LSM6DSL_XL_ODR_416Hz": "416 Hz",
                  "LSM6DSL_XL_ODR_833Hz": "833 Hz",
                  "LSM6DSL_XL_ODR_1k66Hz": "1.66 kHz",
                  "LSM6DSL_XL_ODR_3k33Hz": "3.33 kHz",
                  "LSM6DSL_XL_ODR_6k66Hz": "6.66 kHz",
                  "LSM6DSL_XL_ODR_1Hz6": "1.6 Hz",
                  "LSM6DSL_GY_ODR_OFF": "Power Off",
                  "LSM6DSL_GY_ODR_12Hz5": "12.5 Hz",
                  "LSM6DSL_GY_ODR_26Hz": "26 Hz",
                  "LSM6DSL_GY_ODR_52Hz": "52 Hz",
                  "LSM6DSL_GY_ODR_104Hz": "104 Hz",
                  "LSM6DSL_GY_ODR_208Hz": "208 Hz",
                  "LSM6DSL_GY_ODR_416Hz": "416 Hz",
                  "LSM6DSL_GY_ODR_833Hz": "833 Hz",
                  "LSM6DSL_GY_ODR_1k66Hz": "1.66 kHz",
                  "LSM6DSL_GY_ODR_3k33Hz": "3.33 kHz",
                  "LSM6DSL_GY_ODR_6k66Hz": "6.66 kHz",
                  "LSM6DSL_2g": "2 g",
                  "LSM6DSL_16g": "16 g",
                  "LSM6DSL_4g": "4 g",
                  "LSM6DSL_8g": "8 g",
                  "LSM6DSL_250dps": "250 dps",
                  "LSM6DSL_125dps": "125 dps",
                  "LSM6DSL_500dps": "500 dps",
                  "LSM6DSL_1000dps": "1000 dps",
                  "LSM6DSL_2000dps": "2000 dps"
                }
              }
            }
          ],
          "files": {
            "common": {
              "headers": {
                "lsm6dsl.h": "/**\r\n ******************************************************************************\r\n * @file    lsm6dsl.h\r\n * @author\r\n * @version\r\n * @date\r\n * @brief   Atmosphere API - lsm6dsl header file\r\n ******************************************************************************\r\n * @attention\r\n *\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *   1. Redistributions of source code must retain the above copyright notice,\r\n *      this list of conditions and the following disclaimer.\r\n *   2. Redistributions in binary form must reproduce the above copyright notice,\r\n *      this list of conditions and the following disclaimer in the documentation\r\n *      and/or other materials provided with the distribution.\r\n *   3. Neither the name of Atmosphere IoT Corp. nor the names of its contributors\r\n *      may be used to endorse or promote products derived from this software\r\n *      without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n ******************************************************************************\r\n */\r\n#ifndef _ATMO_LSM6DSL_H_\r\n#define _ATMO_LSM6DSL_H_\r\n\r\n#include \"../app_src/atmosphere_platform.h\"\r\n\r\ntypedef struct {\r\n    ATMO_DriverInstanceHandle_t i2cInstance;\r\n    uint8_t i2cAddress;\r\n    uint8_t accelOdr;\r\n    uint8_t gyroOdr;\r\n    uint8_t accelFullScale;\r\n    uint8_t gyroFullScale;\r\n}ATMO_LSM6DSL_Config_t;\r\n\r\ntypedef enum {\r\n    ATMO_LSM6DSL_Status_Success = 0 ,\r\n    ATMO_LSM6DSL_Status_Fail\r\n} ATMO_LSM6DSL_Status_t;\r\n\r\ntypedef struct {\r\n    float x;\r\n    float y;\r\n    float z;\r\n} ATMO_LSM6DSL_AccelData_t;\r\n\r\ntypedef ATMO_LSM6DSL_AccelData_t ATMO_LSM6DSL_GyroData_t;\r\n\r\nATMO_LSM6DSL_Status_t ATMO_LSM6DSL_Init(ATMO_LSM6DSL_Config_t *config);\r\n\r\n/**\r\n * @brief Get acceleration data. Each axis is in mg\r\n * \r\n * @param data \r\n * @return ATMO_LSM6DSL_Status_t \r\n */\r\nATMO_LSM6DSL_Status_t ATMO_LSM6DSL_GetAccelData(ATMO_LSM6DSL_AccelData_t *data);\r\n\r\n/**\r\n * @brief Get gyroscope data. Each axis is in mdps\r\n * \r\n * @param data \r\n * @return ATMO_LSM6DSL_Status_t \r\n */\r\nATMO_LSM6DSL_Status_t ATMO_LSM6DSL_GetGyroData(ATMO_LSM6DSL_GyroData_t *data);\r\n\r\n/**\r\n * @brief Get temperature data in degrees C\r\n * \r\n * @param tempC \r\n * @return ATMO_LSM6DSL_Status_t \r\n */\r\nATMO_LSM6DSL_Status_t ATMO_LSM6DSL_GetTempData(float *tempC);\r\n\r\n#endif",
                "lsm6dsl_reg.h": "/*\n ******************************************************************************\n * @file    lsm6dsl_reg.h\n * @author  MEMS Software Solution Team\n * @brief   This file contains all the functions prototypes for the\n *          lsm6dsl_reg.c driver.\n ******************************************************************************\n * @attention\n *\n * <h2><center>&copy; COPYRIGHT(c) 2018 STMicroelectronics</center></h2>\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *   1. Redistributions of source code must retain the above copyright notice,\n *      this list of conditions and the following disclaimer.\n *   2. Redistributions in binary form must reproduce the above copyright notice,\n *      this list of conditions and the following disclaimer in the documentation\n *      and/or other materials provided with the distribution.\n *   3. Neither the name of STMicroelectronics nor the names of its contributors\n *      may be used to endorse or promote products derived from this software\n *      without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n/* Define to prevent recursive inclusion -------------------------------------*/\n#ifndef LSM6DSL_DRIVER_H\n#define LSM6DSL_DRIVER_H\n\n#ifdef __cplusplus\n  extern \"C\" {\n#endif\n\n/* Includes ------------------------------------------------------------------*/\n#include <stdint.h>\n\n/** @addtogroup lsm6dsl\n * @{\n */\n\n#ifndef __MEMS_SHARED__TYPES\n#define __MEMS_SHARED__TYPES\n\n/** @defgroup ST_MEMS_common_types\n  * @{\n  */\n\ntypedef union{\n\tint16_t i16bit[3];\n\tuint8_t u8bit[6];\n} axis3bit16_t;\n\ntypedef union{\n\tint16_t i16bit;\n\tuint8_t u8bit[2];\n} axis1bit16_t;\n\ntypedef union{\n\tint32_t i32bit[3];\n\tuint8_t u8bit[12];\n} axis3bit32_t;\n\ntypedef union{\n\tint32_t i32bit;\n\tuint8_t u8bit[4];\n} axis1bit32_t;\n\ntypedef struct {\n   uint8_t bit0       : 1;\n   uint8_t bit1       : 1;\n   uint8_t bit2       : 1;\n   uint8_t bit3       : 1;\n   uint8_t bit4       : 1;\n   uint8_t bit5       : 1;\n   uint8_t bit6       : 1;\n   uint8_t bit7       : 1;\n} bitwise_t;\n\n#define PROPERTY_DISABLE                (0)\n#define PROPERTY_ENABLE                 (1)\n\n#endif /* MEMS_SHARED_TYPES*/\n\n/**\n  * @}\n  */\n\n/** @defgroup lsm6dsl_interface\n  * @{\n  */\n\ntypedef int32_t (*lsm6dsl_write_ptr)(void *, uint8_t, uint8_t*, uint16_t);\ntypedef int32_t (*lsm6dsl_read_ptr) (void *, uint8_t, uint8_t*, uint16_t);\n\ntypedef struct {\n  /** Component mandatory fields **/\n  lsm6dsl_write_ptr  write_reg;\n  lsm6dsl_read_ptr   read_reg;\n  /** Customizable optional pointer **/\n  void *handle;\n} lsm6dsl_ctx_t;\n\n/**\n  * @}\n  */\n\n/** @defgroup lsm6dsl_Infos\n  * @{\n  */\n\n/** I2C Device Address 8 bit format  if SA0=0 -> D5 if SA0=1 -> D7 **/\n#define LSM6DSL_I2C_ADD_L     0xD5\n#define LSM6DSL_I2C_ADD_H     0xD7\n\n/** Device Identification (Who am I) **/\n#define LSM6DSL_ID            0x6AU\n\n/**\n  * @}\n  */\n\n/**\n  * @defgroup lsm6dsl_Sensitivity\n  * @{\n  */\n\n#define LSM6DSL_FROM_FS_2g_TO_mg(lsb)    (float)(lsb *  61.0f) / 1000.0f\n#define LSM6DSL_FROM_FS_4g_TO_mg(lsb)    (float)(lsb * 122.0f) / 1000.0f\n#define LSM6DSL_FROM_FS_8g_TO_mg(lsb)    (float)(lsb * 244.0f) / 1000.0f\n#define LSM6DSL_FROM_FS_16g_TO_mg(lsb)   (float)(lsb * 488.0f) / 1000.0f\n\n#define LSM6DSL_FROM_FS_125dps_TO_mdps(lsb)  (float)(lsb *  4375.0f ) / 1000.0f\n#define LSM6DSL_FROM_FS_250dps_TO_mdps(lsb)  (float)(lsb *  8750.0f ) / 1000.0f\n#define LSM6DSL_FROM_FS_500dps_TO_mdps(lsb)  (float)(lsb * 17500.0f ) / 1000.0f\n#define LSM6DSL_FROM_FS_1000dps_TO_mdps(lsb) (float)(lsb *     35.0f)\n#define LSM6DSL_FROM_FS_2000dps_TO_mdps(lsb) (float)(lsb *     70.0f)\n\n\n#define LSM6DSL_FROM_LSB_TO_degC(lsb)   ((float)((int16_t)lsb>>8)*1.0f + 25.0f)\n\n/**\n  * @}\n  */\n\n#define LSM6DSL_FUNC_CFG_ACCESS              0x01\ntypedef struct {\n  uint8_t not_used_01              : 5;\n  uint8_t func_cfg_en              : 3;  /* func_cfg_en + func_cfg_en_b */\n} lsm6dsl_func_cfg_access_t;\n\n#define LSM6DSL_SENSOR_SYNC_TIME_FRAME       0x04\ntypedef struct {\n  uint8_t tph                      : 4;\n  uint8_t not_used_01              : 4;\n} lsm6dsl_sensor_sync_time_frame_t;\n\n#define LSM6DSL_SENSOR_SYNC_RES_RATIO        0x05\ntypedef struct {\n  uint8_t rr                       : 2;\n  uint8_t not_used_01              : 6;\n} lsm6dsl_sensor_sync_res_ratio_t;\n\n#define LSM6DSL_FIFO_CTRL1                   0x06\ntypedef struct {\n  uint8_t fth                      : 8;  /* + FIFO_CTRL2(fth) */\n} lsm6dsl_fifo_ctrl1_t;\n\n#define LSM6DSL_FIFO_CTRL2                   0x07\ntypedef struct {\n  uint8_t fth                      : 3;  /* + FIFO_CTRL1(fth) */\n  uint8_t fifo_temp_en             : 1;\n  uint8_t not_used_01              : 2;\n  uint8_t  timer_pedo_fifo_drdy    : 1;\n  uint8_t timer_pedo_fifo_en       : 1;\n} lsm6dsl_fifo_ctrl2_t;\n\n#define LSM6DSL_FIFO_CTRL3                   0x08\ntypedef struct {\n  uint8_t dec_fifo_xl              : 3;\n  uint8_t dec_fifo_gyro            : 3;\n  uint8_t not_used_01              : 2;\n} lsm6dsl_fifo_ctrl3_t;\n\n#define LSM6DSL_FIFO_CTRL4                   0x09\ntypedef struct {\n  uint8_t dec_ds3_fifo             : 3;\n  uint8_t dec_ds4_fifo             : 3;\n  uint8_t only_high_data           : 1;\n  uint8_t stop_on_fth              : 1;\n} lsm6dsl_fifo_ctrl4_t;\n\n#define LSM6DSL_FIFO_CTRL5                   0x0A\ntypedef struct {\n  uint8_t fifo_mode                : 3;\n  uint8_t odr_fifo                 : 4;\n  uint8_t not_used_01              : 1;\n} lsm6dsl_fifo_ctrl5_t;\n\n#define LSM6DSL_DRDY_PULSE_CFG_G             0x0B\ntypedef struct {\n  uint8_t int2_wrist_tilt          : 1;\n  uint8_t not_used_01              : 6;\n  uint8_t drdy_pulsed              : 1;\n} lsm6dsl_drdy_pulse_cfg_g_t;\n\n#define LSM6DSL_INT1_CTRL                    0x0D\ntypedef struct {\n  uint8_t int1_drdy_xl             : 1;\n  uint8_t int1_drdy_g              : 1;\n  uint8_t int1_boot                : 1;\n  uint8_t int1_fth                 : 1;\n  uint8_t int1_fifo_ovr            : 1;\n  uint8_t int1_full_flag           : 1;\n  uint8_t int1_sign_mot            : 1;\n  uint8_t int1_step_detector       : 1;\n} lsm6dsl_int1_ctrl_t;\n\n#define LSM6DSL_INT2_CTRL                    0x0E\ntypedef struct {\n  uint8_t int2_drdy_xl             : 1;\n  uint8_t int2_drdy_g              : 1;\n  uint8_t int2_drdy_temp           : 1;\n  uint8_t int2_fth                 : 1;\n  uint8_t int2_fifo_ovr            : 1;\n  uint8_t int2_full_flag           : 1;\n  uint8_t int2_step_count_ov       : 1;\n  uint8_t int2_step_delta          : 1;\n} lsm6dsl_int2_ctrl_t;\n\n#define LSM6DSL_WHO_AM_I                     0x0F\n#define LSM6DSL_CTRL1_XL                     0x10\ntypedef struct {\n  uint8_t bw0_xl                   : 1;\n  uint8_t lpf1_bw_sel              : 1;\n  uint8_t fs_xl                    : 2;\n  uint8_t odr_xl                   : 4;\n} lsm6dsl_ctrl1_xl_t;\n\n#define LSM6DSL_CTRL2_G                      0x11\ntypedef struct {\n  uint8_t not_used_01              : 1;\n  uint8_t fs_g                     : 3;  /* fs_g + fs_125 */\n  uint8_t odr_g                    : 4;\n} lsm6dsl_ctrl2_g_t;\n\n#define LSM6DSL_CTRL3_C                      0x12\ntypedef struct {\n  uint8_t sw_reset                 : 1;\n  uint8_t ble                      : 1;\n  uint8_t if_inc                   : 1;\n  uint8_t sim                      : 1;\n  uint8_t pp_od                    : 1;\n  uint8_t h_lactive                : 1;\n  uint8_t bdu                      : 1;\n  uint8_t boot                     : 1;\n} lsm6dsl_ctrl3_c_t;\n\n#define LSM6DSL_CTRL4_C                      0x13\ntypedef struct {\n  uint8_t not_used_01              : 1;\n  uint8_t lpf1_sel_g               : 1;\n  uint8_t i2c_disable              : 1;\n  uint8_t drdy_mask                : 1;\n  uint8_t den_drdy_int1            : 1;\n  uint8_t int2_on_int1             : 1;\n  uint8_t sleep                    : 1;\n  uint8_t den_xl_en                : 1;\n} lsm6dsl_ctrl4_c_t;\n\n#define LSM6DSL_CTRL5_C                      0x14\ntypedef struct {\n  uint8_t st_xl                    : 2;\n  uint8_t st_g                     : 2;\n  uint8_t den_lh                   : 1;\n  uint8_t rounding                 : 3;\n} lsm6dsl_ctrl5_c_t;\n\n#define LSM6DSL_CTRL6_C                      0x15\ntypedef struct {\n  uint8_t ftype                    : 2;\n  uint8_t not_used_01              : 1;\n  uint8_t usr_off_w                : 1;\n  uint8_t xl_hm_mode               : 1;\n  uint8_t den_mode                 : 3;  /* trig_en + lvl_en + lvl2_en */\n} lsm6dsl_ctrl6_c_t;\n\n#define LSM6DSL_CTRL7_G                      0x16\ntypedef struct {\n  uint8_t not_used_01              : 2;\n  uint8_t rounding_status          : 1;\n  uint8_t not_used_02              : 1;\n  uint8_t hpm_g                    : 2;\n  uint8_t hp_en_g                  : 1;\n  uint8_t g_hm_mode                : 1;\n} lsm6dsl_ctrl7_g_t;\n\n#define LSM6DSL_CTRL8_XL                     0x17\ntypedef struct {\n  uint8_t low_pass_on_6d           : 1;\n  uint8_t not_used_01              : 1;\n  uint8_t hp_slope_xl_en           : 1;\n  uint8_t input_composite          : 1;\n  uint8_t hp_ref_mode              : 1;\n  uint8_t hpcf_xl                  : 2;\n  uint8_t lpf2_xl_en               : 1;\n} lsm6dsl_ctrl8_xl_t;\n\n#define LSM6DSL_CTRL9_XL                     0x18\ntypedef struct {\n  uint8_t not_used_01              : 2;\n  uint8_t soft_en                  : 1;\n  uint8_t not_used_02              : 1;\n  uint8_t den_xl_g                 : 1;\n  uint8_t den_z                    : 1;\n  uint8_t den_y                    : 1;\n  uint8_t den_x                    : 1;\n} lsm6dsl_ctrl9_xl_t;\n\n#define LSM6DSL_CTRL10_C                     0x19\ntypedef struct {\n  uint8_t sign_motion_en           : 1;\n  uint8_t pedo_rst_step            : 1;\n  uint8_t func_en                  : 1;\n  uint8_t tilt_en                  : 1;\n  uint8_t pedo_en                  : 1;\n  uint8_t timer_en                 : 1;\n  uint8_t not_used_01              : 1;\n  uint8_t wrist_tilt_en            : 1;\n} lsm6dsl_ctrl10_c_t;\n\n#define LSM6DSL_MASTER_CONFIG                0x1A\ntypedef struct {\n  uint8_t master_on                : 1;\n  uint8_t iron_en                  : 1;\n  uint8_t pass_through_mode        : 1;\n  uint8_t pull_up_en               : 1;\n  uint8_t start_config             : 1;\n  uint8_t not_used_01              : 1;\n  uint8_t  data_valid_sel_fifo     : 1;\n  uint8_t drdy_on_int1             : 1;\n} lsm6dsl_master_config_t;\n\n#define LSM6DSL_WAKE_UP_SRC                  0x1B\ntypedef struct {\n  uint8_t z_wu                     : 1;\n  uint8_t y_wu                     : 1;\n  uint8_t x_wu                     : 1;\n  uint8_t wu_ia                    : 1;\n  uint8_t sleep_state_ia           : 1;\n  uint8_t ff_ia                    : 1;\n  uint8_t not_used_01              : 2;\n} lsm6dsl_wake_up_src_t;\n\n#define LSM6DSL_TAP_SRC                      0x1C\ntypedef struct {\n  uint8_t z_tap                    : 1;\n  uint8_t y_tap                    : 1;\n  uint8_t x_tap                    : 1;\n  uint8_t tap_sign                 : 1;\n  uint8_t double_tap               : 1;\n  uint8_t single_tap               : 1;\n  uint8_t tap_ia                   : 1;\n  uint8_t not_used_01              : 1;\n} lsm6dsl_tap_src_t;\n\n#define LSM6DSL_D6D_SRC                      0x1D\ntypedef struct {\n  uint8_t xl                       : 1;\n  uint8_t xh                       : 1;\n  uint8_t yl                       : 1;\n  uint8_t yh                       : 1;\n  uint8_t zl                       : 1;\n  uint8_t zh                       : 1;\n  uint8_t d6d_ia                   : 1;\n  uint8_t den_drdy                 : 1;\n} lsm6dsl_d6d_src_t;\n\n#define LSM6DSL_STATUS_REG                   0x1E\ntypedef struct {\n  uint8_t xlda                     : 1;\n  uint8_t gda                      : 1;\n  uint8_t tda                      : 1;\n  uint8_t not_used_01              : 5;\n} lsm6dsl_status_reg_t;\n\n#define LSM6DSL_OUT_TEMP_L                   0x20\n#define LSM6DSL_OUT_TEMP_H                   0x21\n#define LSM6DSL_OUTX_L_G                     0x22\n#define LSM6DSL_OUTX_H_G                     0x23\n#define LSM6DSL_OUTY_L_G                     0x24\n#define LSM6DSL_OUTY_H_G                     0x25\n#define LSM6DSL_OUTZ_L_G                     0x26\n#define LSM6DSL_OUTZ_H_G                     0x27\n#define LSM6DSL_OUTX_L_XL                    0x28\n#define LSM6DSL_OUTX_H_XL                    0x29\n#define LSM6DSL_OUTY_L_XL                    0x2A\n#define LSM6DSL_OUTY_H_XL                    0x2B\n#define LSM6DSL_OUTZ_L_XL                    0x2C\n#define LSM6DSL_OUTZ_H_XL                    0x2D\n#define LSM6DSL_SENSORHUB1_REG               0x2E\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsl_sensorhub1_reg_t;\n\n#define LSM6DSL_SENSORHUB2_REG               0x2F\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsl_sensorhub2_reg_t;\n\n#define LSM6DSL_SENSORHUB3_REG               0x30\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsl_sensorhub3_reg_t;\n\n#define LSM6DSL_SENSORHUB4_REG               0x31\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsl_sensorhub4_reg_t;\n\n#define LSM6DSL_SENSORHUB5_REG               0x32\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsl_sensorhub5_reg_t;\n\n#define LSM6DSL_SENSORHUB6_REG               0x33\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsl_sensorhub6_reg_t;\n\n#define LSM6DSL_SENSORHUB7_REG               0x34\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsl_sensorhub7_reg_t;\n\n#define LSM6DSL_SENSORHUB8_REG               0x35\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsl_sensorhub8_reg_t;\n\n#define LSM6DSL_SENSORHUB9_REG               0x36\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsl_sensorhub9_reg_t;\n\n#define LSM6DSL_SENSORHUB10_REG              0x37\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsl_sensorhub10_reg_t;\n\n#define LSM6DSL_SENSORHUB11_REG              0x38\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsl_sensorhub11_reg_t;\n\n#define LSM6DSL_SENSORHUB12_REG              0x39\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsl_sensorhub12_reg_t;\n\n#define LSM6DSL_FIFO_STATUS1                 0x3A\ntypedef struct {\n  uint8_t diff_fifo                : 8;  /* + FIFO_STATUS2(diff_fifo) */\n} lsm6dsl_fifo_status1_t;\n\n#define LSM6DSL_FIFO_STATUS2                 0x3B\ntypedef struct {\n  uint8_t diff_fifo                : 3;  /* + FIFO_STATUS1(diff_fifo) */\n  uint8_t not_used_01              : 1;\n  uint8_t fifo_empty               : 1;\n  uint8_t fifo_full_smart          : 1;\n  uint8_t over_run                 : 1;\n  uint8_t waterm                   : 1;\n} lsm6dsl_fifo_status2_t;\n\n#define LSM6DSL_FIFO_STATUS3                 0x3C\ntypedef struct {\n  uint8_t fifo_pattern             : 8;  /* + FIFO_STATUS4(fifo_pattern) */\n} lsm6dsl_fifo_status3_t;\n\n#define LSM6DSL_FIFO_STATUS4                 0x3D\ntypedef struct {\n  uint8_t fifo_pattern             : 2;  /* + FIFO_STATUS3(fifo_pattern) */\n  uint8_t not_used_01              : 6;\n} lsm6dsl_fifo_status4_t;\n\n#define LSM6DSL_FIFO_DATA_OUT_L              0x3E\n#define LSM6DSL_FIFO_DATA_OUT_H              0x3F\n#define LSM6DSL_TIMESTAMP0_REG               0x40\n#define LSM6DSL_TIMESTAMP1_REG               0x41\n#define LSM6DSL_TIMESTAMP2_REG               0x42\n#define LSM6DSL_STEP_TIMESTAMP_L             0x49\n#define LSM6DSL_STEP_TIMESTAMP_H             0x4A\n#define LSM6DSL_STEP_COUNTER_L               0x4B\n#define LSM6DSL_STEP_COUNTER_H               0x4C\n\n#define LSM6DSL_SENSORHUB13_REG              0x4D\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsl_sensorhub13_reg_t;\n\n#define LSM6DSL_SENSORHUB14_REG              0x4E\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsl_sensorhub14_reg_t;\n\n#define LSM6DSL_SENSORHUB15_REG              0x4F\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsl_sensorhub15_reg_t;\n\n#define LSM6DSL_SENSORHUB16_REG              0x50\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsl_sensorhub16_reg_t;\n\n#define LSM6DSL_SENSORHUB17_REG              0x51\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsl_sensorhub17_reg_t;\n\n#define LSM6DSL_SENSORHUB18_REG              0x52\ntypedef struct {\n  uint8_t bit0                     : 1;\n  uint8_t bit1                     : 1;\n  uint8_t bit2                     : 1;\n  uint8_t bit3                     : 1;\n  uint8_t bit4                     : 1;\n  uint8_t bit5                     : 1;\n  uint8_t bit6                     : 1;\n  uint8_t bit7                     : 1;\n} lsm6dsl_sensorhub18_reg_t;\n\n#define LSM6DSL_FUNC_SRC1                    0x53\ntypedef struct {\n  uint8_t sensorhub_end_op         : 1;\n  uint8_t si_end_op                : 1;\n  uint8_t hi_fail                  : 1;\n  uint8_t step_overflow            : 1;\n  uint8_t step_detected            : 1;\n  uint8_t tilt_ia                  : 1;\n  uint8_t sign_motion_ia           : 1;\n  uint8_t  step_count_delta_ia     : 1;\n} lsm6dsl_func_src1_t;\n\n#define LSM6DSL_FUNC_SRC2                    0x54\ntypedef struct {\n  uint8_t wrist_tilt_ia            : 1;\n  uint8_t not_used_01              : 2;\n  uint8_t slave0_nack              : 1;\n  uint8_t slave1_nack              : 1;\n  uint8_t slave2_nack              : 1;\n  uint8_t slave3_nack              : 1;\n  uint8_t not_used_02              : 1;\n} lsm6dsl_func_src2_t;\n\n#define LSM6DSL_WRIST_TILT_IA                0x55\ntypedef struct {\n  uint8_t not_used_01              : 2;\n  uint8_t wrist_tilt_ia_zneg       : 1;\n  uint8_t wrist_tilt_ia_zpos       : 1;\n  uint8_t wrist_tilt_ia_yneg       : 1;\n  uint8_t wrist_tilt_ia_ypos       : 1;\n  uint8_t wrist_tilt_ia_xneg       : 1;\n  uint8_t wrist_tilt_ia_xpos       : 1;\n} lsm6dsl_wrist_tilt_ia_t;\n\n#define LSM6DSL_TAP_CFG                      0x58\ntypedef struct {\n  uint8_t lir                      : 1;\n  uint8_t tap_z_en                 : 1;\n  uint8_t tap_y_en                 : 1;\n  uint8_t tap_x_en                 : 1;\n  uint8_t slope_fds                : 1;\n  uint8_t inact_en                 : 2;\n  uint8_t interrupts_enable        : 1;\n} lsm6dsl_tap_cfg_t;\n\n#define LSM6DSL_TAP_THS_6D                   0x59\ntypedef struct {\n  uint8_t tap_ths                  : 5;\n  uint8_t sixd_ths                 : 2;\n  uint8_t d4d_en                   : 1;\n} lsm6dsl_tap_ths_6d_t;\n\n#define LSM6DSL_INT_DUR2                     0x5A\ntypedef struct {\n  uint8_t shock                    : 2;\n  uint8_t quiet                    : 2;\n  uint8_t dur                      : 4;\n} lsm6dsl_int_dur2_t;\n\n#define LSM6DSL_WAKE_UP_THS                  0x5B\ntypedef struct {\n  uint8_t wk_ths                   : 6;\n  uint8_t not_used_01              : 1;\n  uint8_t single_double_tap        : 1;\n} lsm6dsl_wake_up_ths_t;\n\n#define LSM6DSL_WAKE_UP_DUR                  0x5C\ntypedef struct {\n  uint8_t sleep_dur                : 4;\n  uint8_t timer_hr                 : 1;\n  uint8_t wake_dur                 : 2;\n  uint8_t ff_dur                   : 1;\n} lsm6dsl_wake_up_dur_t;\n\n#define LSM6DSL_FREE_FALL                    0x5D\ntypedef struct {\n  uint8_t ff_ths                   : 3;\n  uint8_t ff_dur                   : 5;\n} lsm6dsl_free_fall_t;\n\n#define LSM6DSL_MD1_CFG                      0x5E\ntypedef struct {\n  uint8_t int1_timer               : 1;\n  uint8_t int1_tilt                : 1;\n  uint8_t int1_6d                  : 1;\n  uint8_t int1_double_tap          : 1;\n  uint8_t int1_ff                  : 1;\n  uint8_t int1_wu                  : 1;\n  uint8_t int1_single_tap          : 1;\n  uint8_t int1_inact_state         : 1;\n} lsm6dsl_md1_cfg_t;\n\n#define LSM6DSL_MD2_CFG                      0x5F\ntypedef struct {\n  uint8_t int2_iron                : 1;\n  uint8_t int2_tilt                : 1;\n  uint8_t int2_6d                  : 1;\n  uint8_t int2_double_tap          : 1;\n  uint8_t int2_ff                  : 1;\n  uint8_t int2_wu                  : 1;\n  uint8_t int2_single_tap          : 1;\n  uint8_t int2_inact_state         : 1;\n} lsm6dsl_md2_cfg_t;\n\n#define LSM6DSL_MASTER_CMD_CODE              0x60\ntypedef struct {\n  uint8_t master_cmd_code          : 8;\n} lsm6dsl_master_cmd_code_t;\n\n#define LSM6DSL_SENS_SYNC_SPI_ERROR_CODE     0x61\ntypedef struct {\n  uint8_t error_code               : 8;\n} lsm6dsl_sens_sync_spi_error_code_t;\n\n#define LSM6DSL_OUT_MAG_RAW_X_L              0x66\n#define LSM6DSL_OUT_MAG_RAW_X_H              0x67\n#define LSM6DSL_OUT_MAG_RAW_Y_L              0x68\n#define LSM6DSL_OUT_MAG_RAW_Y_H              0x69\n#define LSM6DSL_OUT_MAG_RAW_Z_L              0x6A\n#define LSM6DSL_OUT_MAG_RAW_Z_H              0x6B\n#define LSM6DSL_X_OFS_USR                    0x73\n#define LSM6DSL_Y_OFS_USR                    0x74\n#define LSM6DSL_Z_OFS_USR                    0x75\n#define LSM6DSL_SLV0_ADD                     0x02\ntypedef struct {\n  uint8_t rw_0                     : 1;\n  uint8_t slave0_add               : 7;\n} lsm6dsl_slv0_add_t;\n\n#define LSM6DSL_SLV0_SUBADD                  0x03\ntypedef struct {\n  uint8_t slave0_reg               : 8;\n} lsm6dsl_slv0_subadd_t;\n\n#define LSM6DSL_SLAVE0_CONFIG                0x04\ntypedef struct {\n  uint8_t slave0_numop             : 3;\n  uint8_t src_mode                 : 1;\n  uint8_t aux_sens_on              : 2;\n  uint8_t slave0_rate              : 2;\n} lsm6dsl_slave0_config_t;\n\n#define LSM6DSL_SLV1_ADD                     0x05\ntypedef struct {\n  uint8_t r_1                      : 1;\n  uint8_t slave1_add               : 7;\n} lsm6dsl_slv1_add_t;\n\n#define LSM6DSL_SLV1_SUBADD                  0x06\ntypedef struct {\n  uint8_t slave1_reg               : 8;\n} lsm6dsl_slv1_subadd_t;\n\n#define LSM6DSL_SLAVE1_CONFIG                0x07\ntypedef struct {\n  uint8_t slave1_numop             : 3;\n  uint8_t not_used_01              : 2;\n  uint8_t write_once               : 1;\n  uint8_t slave1_rate              : 2;\n} lsm6dsl_slave1_config_t;\n\n#define LSM6DSL_SLV2_ADD                     0x08\ntypedef struct {\n  uint8_t r_2                      : 1;\n  uint8_t slave2_add               : 7;\n} lsm6dsl_slv2_add_t;\n\n#define LSM6DSL_SLV2_SUBADD                  0x09\ntypedef struct {\n  uint8_t slave2_reg               : 8;\n} lsm6dsl_slv2_subadd_t;\n\n#define LSM6DSL_SLAVE2_CONFIG                0x0A\ntypedef struct {\n  uint8_t slave2_numop             : 3;\n  uint8_t not_used_01              : 3;\n  uint8_t slave2_rate              : 2;\n} lsm6dsl_slave2_config_t;\n\n#define LSM6DSL_SLV3_ADD                     0x0B\ntypedef struct {\n  uint8_t r_3                      : 1;\n  uint8_t slave3_add               : 7;\n} lsm6dsl_slv3_add_t;\n\n#define LSM6DSL_SLV3_SUBADD                  0x0C\ntypedef struct {\n  uint8_t slave3_reg               : 8;\n} lsm6dsl_slv3_subadd_t;\n\n#define LSM6DSL_SLAVE3_CONFIG                0x0D\ntypedef struct {\n  uint8_t slave3_numop             : 3;\n  uint8_t not_used_01              : 3;\n  uint8_t slave3_rate              : 2;\n} lsm6dsl_slave3_config_t;\n\n#define LSM6DSL_DATAWRITE_SRC_MODE_SUB_SLV0  0x0E\ntypedef struct {\n  uint8_t slave_dataw              : 8;\n} lsm6dsl_datawrite_src_mode_sub_slv0_t;\n\n#define LSM6DSL_CONFIG_PEDO_THS_MIN          0x0F\ntypedef struct {\n  uint8_t ths_min                  : 5;\n  uint8_t not_used_01              : 2;\n  uint8_t pedo_fs                  : 1;\n} lsm6dsl_config_pedo_ths_min_t;\n\n#define LSM6DSL_SM_THS                       0x13\n#define LSM6DSL_PEDO_DEB_REG                 0x14\ntypedef struct {\n  uint8_t deb_step      : 3;\n  uint8_t deb_time      : 5;\n} lsm6dsl_pedo_deb_reg_t;\n\n#define LSM6DSL_STEP_COUNT_DELTA             0x15\n#define LSM6DSL_MAG_SI_XX                    0x24\n#define LSM6DSL_MAG_SI_XY                    0x25\n#define LSM6DSL_MAG_SI_XZ                    0x26\n#define LSM6DSL_MAG_SI_YX                    0x27\n#define LSM6DSL_MAG_SI_YY                    0x28\n#define LSM6DSL_MAG_SI_YZ                    0x29\n#define LSM6DSL_MAG_SI_ZX                    0x2A\n#define LSM6DSL_MAG_SI_ZY                    0x2B\n#define LSM6DSL_MAG_SI_ZZ                    0x2C\n#define LSM6DSL_MAG_OFFX_L                   0x2D\n#define LSM6DSL_MAG_OFFX_H                   0x2E\n#define LSM6DSL_MAG_OFFY_L                   0x2F\n#define LSM6DSL_MAG_OFFY_H                   0x30\n#define LSM6DSL_MAG_OFFZ_L                   0x31\n#define LSM6DSL_MAG_OFFZ_H                   0x32\n#define LSM6DSL_A_WRIST_TILT_LAT             0x50\n#define LSM6DSL_A_WRIST_TILT_THS             0x54\n#define LSM6DSL_A_WRIST_TILT_MASK            0x59\ntypedef struct {\n  uint8_t not_used_01              : 2;\n  uint8_t  wrist_tilt_mask_zneg    : 1;\n  uint8_t  wrist_tilt_mask_zpos    : 1;\n  uint8_t  wrist_tilt_mask_yneg    : 1;\n  uint8_t  wrist_tilt_mask_ypos    : 1;\n  uint8_t  wrist_tilt_mask_xneg    : 1;\n  uint8_t  wrist_tilt_mask_xpos    : 1;\n} lsm6dsl_a_wrist_tilt_mask_t;\n\ntypedef union{\n  lsm6dsl_func_cfg_access_t                  func_cfg_access;\n  lsm6dsl_sensor_sync_time_frame_t           sensor_sync_time_frame;\n  lsm6dsl_sensor_sync_res_ratio_t            sensor_sync_res_ratio;\n  lsm6dsl_fifo_ctrl1_t                       fifo_ctrl1;\n  lsm6dsl_fifo_ctrl2_t                       fifo_ctrl2;\n  lsm6dsl_fifo_ctrl3_t                       fifo_ctrl3;\n  lsm6dsl_fifo_ctrl4_t                       fifo_ctrl4;\n  lsm6dsl_fifo_ctrl5_t                       fifo_ctrl5;\n  lsm6dsl_drdy_pulse_cfg_g_t                 drdy_pulse_cfg_g;\n  lsm6dsl_int1_ctrl_t                        int1_ctrl;\n  lsm6dsl_int2_ctrl_t                        int2_ctrl;\n  lsm6dsl_ctrl1_xl_t                         ctrl1_xl;\n  lsm6dsl_ctrl2_g_t                          ctrl2_g;\n  lsm6dsl_ctrl3_c_t                          ctrl3_c;\n  lsm6dsl_ctrl4_c_t                          ctrl4_c;\n  lsm6dsl_ctrl5_c_t                          ctrl5_c;\n  lsm6dsl_ctrl6_c_t                          ctrl6_c;\n  lsm6dsl_ctrl7_g_t                          ctrl7_g;\n  lsm6dsl_ctrl8_xl_t                         ctrl8_xl;\n  lsm6dsl_ctrl9_xl_t                         ctrl9_xl;\n  lsm6dsl_ctrl10_c_t                         ctrl10_c;\n  lsm6dsl_master_config_t                    master_config;\n  lsm6dsl_wake_up_src_t                      wake_up_src;\n  lsm6dsl_tap_src_t                          tap_src;\n  lsm6dsl_d6d_src_t                          d6d_src;\n  lsm6dsl_status_reg_t                       status_reg;\n  lsm6dsl_sensorhub1_reg_t                   sensorhub1_reg;\n  lsm6dsl_sensorhub2_reg_t                   sensorhub2_reg;\n  lsm6dsl_sensorhub3_reg_t                   sensorhub3_reg;\n  lsm6dsl_sensorhub4_reg_t                   sensorhub4_reg;\n  lsm6dsl_sensorhub5_reg_t                   sensorhub5_reg;\n  lsm6dsl_sensorhub6_reg_t                   sensorhub6_reg;\n  lsm6dsl_sensorhub7_reg_t                   sensorhub7_reg;\n  lsm6dsl_sensorhub8_reg_t                   sensorhub8_reg;\n  lsm6dsl_sensorhub9_reg_t                   sensorhub9_reg;\n  lsm6dsl_sensorhub10_reg_t                  sensorhub10_reg;\n  lsm6dsl_sensorhub11_reg_t                  sensorhub11_reg;\n  lsm6dsl_sensorhub12_reg_t                  sensorhub12_reg;\n  lsm6dsl_fifo_status1_t                     fifo_status1;\n  lsm6dsl_fifo_status2_t                     fifo_status2;\n  lsm6dsl_fifo_status3_t                     fifo_status3;\n  lsm6dsl_fifo_status4_t                     fifo_status4;\n  lsm6dsl_sensorhub13_reg_t                  sensorhub13_reg;\n  lsm6dsl_sensorhub14_reg_t                  sensorhub14_reg;\n  lsm6dsl_sensorhub15_reg_t                  sensorhub15_reg;\n  lsm6dsl_sensorhub16_reg_t                  sensorhub16_reg;\n  lsm6dsl_sensorhub17_reg_t                  sensorhub17_reg;\n  lsm6dsl_sensorhub18_reg_t                  sensorhub18_reg;\n  lsm6dsl_func_src1_t                        func_src1;\n  lsm6dsl_func_src2_t                        func_src2;\n  lsm6dsl_wrist_tilt_ia_t                    wrist_tilt_ia;\n  lsm6dsl_tap_cfg_t                          tap_cfg;\n  lsm6dsl_tap_ths_6d_t                       tap_ths_6d;\n  lsm6dsl_int_dur2_t                         int_dur2;\n  lsm6dsl_wake_up_ths_t                      wake_up_ths;\n  lsm6dsl_wake_up_dur_t                      wake_up_dur;\n  lsm6dsl_free_fall_t                        free_fall;\n  lsm6dsl_md1_cfg_t                          md1_cfg;\n  lsm6dsl_md2_cfg_t                          md2_cfg;\n  lsm6dsl_master_cmd_code_t                  master_cmd_code;\n  lsm6dsl_sens_sync_spi_error_code_t         sens_sync_spi_error_code;\n  lsm6dsl_slv0_add_t                         slv0_add;\n  lsm6dsl_slv0_subadd_t                      slv0_subadd;\n  lsm6dsl_slave0_config_t                    slave0_config;\n  lsm6dsl_slv1_add_t                         slv1_add;\n  lsm6dsl_slv1_subadd_t                      slv1_subadd;\n  lsm6dsl_slave1_config_t                    slave1_config;\n  lsm6dsl_slv2_add_t                         slv2_add;\n  lsm6dsl_slv2_subadd_t                      slv2_subadd;\n  lsm6dsl_slave2_config_t                    slave2_config;\n  lsm6dsl_slv3_add_t                         slv3_add;\n  lsm6dsl_slv3_subadd_t                      slv3_subadd;\n  lsm6dsl_slave3_config_t                    slave3_config;\n  lsm6dsl_datawrite_src_mode_sub_slv0_t      datawrite_src_mode_sub_slv0;\n  lsm6dsl_config_pedo_ths_min_t              config_pedo_ths_min;\n  lsm6dsl_pedo_deb_reg_t                     pedo_deb_reg;\n  lsm6dsl_a_wrist_tilt_mask_t                a_wrist_tilt_mask;\n  bitwise_t                                  bitwise;\n  uint8_t                                    byte;\n} lsm6dsl_reg_t;\nint32_t lsm6dsl_read_reg(lsm6dsl_ctx_t *ctx, uint8_t reg, uint8_t* data,\n                         uint16_t len);\nint32_t lsm6dsl_write_reg(lsm6dsl_ctx_t *ctx, uint8_t reg, uint8_t* data,\n                          uint16_t len);\n\ntypedef enum {\n  LSM6DSL_2g       = 0,\n  LSM6DSL_16g      = 1,\n  LSM6DSL_4g       = 2,\n  LSM6DSL_8g       = 3,\n  LSM6DSL_XL_FS_ND = 4,  /* ERROR CODE */\n} lsm6dsl_fs_xl_t;\nint32_t lsm6dsl_xl_full_scale_set(lsm6dsl_ctx_t *ctx, lsm6dsl_fs_xl_t val);\nint32_t lsm6dsl_xl_full_scale_get(lsm6dsl_ctx_t *ctx, lsm6dsl_fs_xl_t *val);\n\ntypedef enum {\n  LSM6DSL_XL_ODR_OFF      =  0,\n  LSM6DSL_XL_ODR_12Hz5    =  1,\n  LSM6DSL_XL_ODR_26Hz     =  2,\n  LSM6DSL_XL_ODR_52Hz     =  3,\n  LSM6DSL_XL_ODR_104Hz    =  4,\n  LSM6DSL_XL_ODR_208Hz    =  5,\n  LSM6DSL_XL_ODR_416Hz    =  6,\n  LSM6DSL_XL_ODR_833Hz    =  7,\n  LSM6DSL_XL_ODR_1k66Hz   =  8,\n  LSM6DSL_XL_ODR_3k33Hz   =  9,\n  LSM6DSL_XL_ODR_6k66Hz   = 10,\n  LSM6DSL_XL_ODR_1Hz6     = 11,\n  LSM6DSL_XL_ODR_ND       = 12,  /* ERROR CODE */\n} lsm6dsl_odr_xl_t;\nint32_t lsm6dsl_xl_data_rate_set(lsm6dsl_ctx_t *ctx, lsm6dsl_odr_xl_t val);\nint32_t lsm6dsl_xl_data_rate_get(lsm6dsl_ctx_t *ctx, lsm6dsl_odr_xl_t *val);\n\ntypedef enum {\n  LSM6DSL_250dps     = 0,\n  LSM6DSL_125dps     = 1,\n  LSM6DSL_500dps     = 2,\n  LSM6DSL_1000dps    = 4,\n  LSM6DSL_2000dps    = 6,\n  LSM6DSL_GY_FS_ND   = 7,    /* ERROR CODE */\n} lsm6dsl_fs_g_t;\nint32_t lsm6dsl_gy_full_scale_set(lsm6dsl_ctx_t *ctx, lsm6dsl_fs_g_t val);\nint32_t lsm6dsl_gy_full_scale_get(lsm6dsl_ctx_t *ctx, lsm6dsl_fs_g_t *val);\n\ntypedef enum {\n  LSM6DSL_GY_ODR_OFF    =  0,\n  LSM6DSL_GY_ODR_12Hz5  =  1,\n  LSM6DSL_GY_ODR_26Hz   =  2,\n  LSM6DSL_GY_ODR_52Hz   =  3,\n  LSM6DSL_GY_ODR_104Hz  =  4,\n  LSM6DSL_GY_ODR_208Hz  =  5,\n  LSM6DSL_GY_ODR_416Hz  =  6,\n  LSM6DSL_GY_ODR_833Hz  =  7,\n  LSM6DSL_GY_ODR_1k66Hz =  8,\n  LSM6DSL_GY_ODR_3k33Hz =  9,\n  LSM6DSL_GY_ODR_6k66Hz = 10,\n  LSM6DSL_GY_ODR_ND     = 11,    /* ERROR CODE */\n} lsm6dsl_odr_g_t;\nint32_t lsm6dsl_gy_data_rate_set(lsm6dsl_ctx_t *ctx, lsm6dsl_odr_g_t val);\nint32_t lsm6dsl_gy_data_rate_get(lsm6dsl_ctx_t *ctx, lsm6dsl_odr_g_t *val);\n\nint32_t lsm6dsl_block_data_update_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_block_data_update_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSL_LSb_1mg   = 0,\n  LSM6DSL_LSb_16mg  = 1,\n  LSM6DSL_WEIGHT_ND = 2,\n} lsm6dsl_usr_off_w_t;\nint32_t lsm6dsl_xl_offset_weight_set(lsm6dsl_ctx_t *ctx,\n                                     lsm6dsl_usr_off_w_t val);\nint32_t lsm6dsl_xl_offset_weight_get(lsm6dsl_ctx_t *ctx,\n                                     lsm6dsl_usr_off_w_t *val);\n\ntypedef enum {\n  LSM6DSL_XL_HIGH_PERFORMANCE  = 0,\n  LSM6DSL_XL_NORMAL            = 1,\n  LSM6DSL_XL_PW_MODE_ND        = 2,    /* ERROR CODE */\n} lsm6dsl_xl_hm_mode_t;\nint32_t lsm6dsl_xl_power_mode_set(lsm6dsl_ctx_t *ctx,\n                                  lsm6dsl_xl_hm_mode_t val);\nint32_t lsm6dsl_xl_power_mode_get(lsm6dsl_ctx_t *ctx,\n                                  lsm6dsl_xl_hm_mode_t *val);\n\ntypedef enum {\n  LSM6DSL_STAT_RND_DISABLE  = 0,\n  LSM6DSL_STAT_RND_ENABLE   = 1,\n  LSM6DSL_STAT_RND_ND       = 2,    /* ERROR CODE */\n} lsm6dsl_rounding_status_t;\nint32_t lsm6dsl_rounding_on_status_set(lsm6dsl_ctx_t *ctx,\n                                       lsm6dsl_rounding_status_t val);\nint32_t lsm6dsl_rounding_on_status_get(lsm6dsl_ctx_t *ctx,\n                                       lsm6dsl_rounding_status_t *val);\n\ntypedef enum {\n  LSM6DSL_GY_HIGH_PERFORMANCE  = 0,\n  LSM6DSL_GY_NORMAL            = 1,\n  LSM6DSL_GY_PW_MODE_ND        = 2,    /* ERROR CODE */\n} lsm6dsl_g_hm_mode_t;\nint32_t lsm6dsl_gy_power_mode_set(lsm6dsl_ctx_t *ctx,\n                                  lsm6dsl_g_hm_mode_t val);\nint32_t lsm6dsl_gy_power_mode_get(lsm6dsl_ctx_t *ctx,\n                                  lsm6dsl_g_hm_mode_t *val);\n\ntypedef union {\n  struct {\n  lsm6dsl_wake_up_src_t        wake_up_src;\n  lsm6dsl_tap_src_t            tap_src;\n  lsm6dsl_d6d_src_t            d6d_src;\n  lsm6dsl_status_reg_t         status_reg;\n  lsm6dsl_func_src1_t          func_src1;\n  lsm6dsl_func_src2_t          func_src2;\n  lsm6dsl_wrist_tilt_ia_t      wrist_tilt_ia;\n  lsm6dsl_a_wrist_tilt_mask_t  a_wrist_tilt_mask;\n  } reg;\n  uint8_t byte[8];\n} lsm6dsl_all_sources_t;\nint32_t lsm6dsl_all_sources_get(lsm6dsl_ctx_t *ctx,\n                                lsm6dsl_all_sources_t *val);\n\nint32_t lsm6dsl_status_reg_get(lsm6dsl_ctx_t *ctx, lsm6dsl_status_reg_t *val);\n\nint32_t lsm6dsl_xl_flag_data_ready_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsl_gy_flag_data_ready_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsl_temp_flag_data_ready_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsl_xl_usr_offset_set(lsm6dsl_ctx_t *ctx, uint8_t *buff);\nint32_t lsm6dsl_xl_usr_offset_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);\nint32_t lsm6dsl_timestamp_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_timestamp_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSL_LSB_6ms4    = 0,\n  LSM6DSL_LSB_25us    = 1,\n  LSM6DSL_TS_RES_ND   = 2,    /* ERROR CODE */\n} lsm6dsl_timer_hr_t;\nint32_t lsm6dsl_timestamp_res_set(lsm6dsl_ctx_t *ctx, lsm6dsl_timer_hr_t val);\nint32_t lsm6dsl_timestamp_res_get(lsm6dsl_ctx_t *ctx, lsm6dsl_timer_hr_t *val);\n\ntypedef enum {\n  LSM6DSL_ROUND_DISABLE            = 0,\n  LSM6DSL_ROUND_XL                 = 1,\n  LSM6DSL_ROUND_GY                 = 2,\n  LSM6DSL_ROUND_GY_XL              = 3,\n  LSM6DSL_ROUND_SH1_TO_SH6         = 4,\n  LSM6DSL_ROUND_XL_SH1_TO_SH6      = 5,\n  LSM6DSL_ROUND_GY_XL_SH1_TO_SH12  = 6,\n  LSM6DSL_ROUND_GY_XL_SH1_TO_SH6   = 7,\n  LSM6DSL_ROUND_OUT_ND             = 8,    /* ERROR CODE */\n} lsm6dsl_rounding_t;\nint32_t lsm6dsl_rounding_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_rounding_t val);\nint32_t lsm6dsl_rounding_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_rounding_t *val);\n\nint32_t lsm6dsl_temperature_raw_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);\nint32_t lsm6dsl_angular_rate_raw_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);\nint32_t lsm6dsl_acceleration_raw_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);\n\nint32_t lsm6dsl_mag_calibrated_raw_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);\n\nint32_t lsm6dsl_fifo_raw_data_get(lsm6dsl_ctx_t *ctx, uint8_t *buffer,\n                                  uint8_t len);\n\ntypedef enum {\n  LSM6DSL_USER_BANK   = 0,\n  LSM6DSL_BANK_A      = 4,\n  LSM6DSL_BANK_B      = 5,\n  LSM6DSL_BANK_ND     = 6,    /* ERROR CODE */\n} lsm6dsl_func_cfg_en_t;\nint32_t lsm6dsl_mem_bank_set(lsm6dsl_ctx_t *ctx, lsm6dsl_func_cfg_en_t val);\nint32_t lsm6dsl_mem_bank_get(lsm6dsl_ctx_t *ctx, lsm6dsl_func_cfg_en_t *val);\n\ntypedef enum {\n  LSM6DSL_DRDY_LATCHED    = 0,\n  LSM6DSL_DRDY_PULSED     = 1,\n  LSM6DSL_DRDY_ND         = 2,  /* ERROR CODE */\n} lsm6dsl_drdy_pulsed_g_t;\nint32_t lsm6dsl_data_ready_mode_set(lsm6dsl_ctx_t *ctx,\n                                    lsm6dsl_drdy_pulsed_g_t val);\nint32_t lsm6dsl_data_ready_mode_get(lsm6dsl_ctx_t *ctx,\n                                    lsm6dsl_drdy_pulsed_g_t *val);\n\nint32_t lsm6dsl_device_id_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);\nint32_t lsm6dsl_reset_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_reset_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSL_LSB_AT_LOW_ADD  = 0,\n  LSM6DSL_MSB_AT_LOW_ADD  = 1,\n  LSM6DSL_DATA_FMT_ND     = 2,    /* ERROR CODE */\n} lsm6dsl_ble_t;\nint32_t lsm6dsl_data_format_set(lsm6dsl_ctx_t *ctx, lsm6dsl_ble_t val);\nint32_t lsm6dsl_data_format_get(lsm6dsl_ctx_t *ctx, lsm6dsl_ble_t *val);\n\nint32_t lsm6dsl_auto_increment_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_auto_increment_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsl_boot_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_boot_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSL_XL_ST_DISABLE    = 0,\n  LSM6DSL_XL_ST_POSITIVE   = 1,\n  LSM6DSL_XL_ST_NEGATIVE   = 2,\n  LSM6DSL_XL_ST_ND         = 3,    /* ERROR CODE */\n} lsm6dsl_st_xl_t;\nint32_t lsm6dsl_xl_self_test_set(lsm6dsl_ctx_t *ctx, lsm6dsl_st_xl_t val);\nint32_t lsm6dsl_xl_self_test_get(lsm6dsl_ctx_t *ctx, lsm6dsl_st_xl_t *val);\n\ntypedef enum {\n  LSM6DSL_GY_ST_DISABLE    = 0,\n  LSM6DSL_GY_ST_POSITIVE   = 1,\n  LSM6DSL_GY_ST_NEGATIVE   = 3,\n  LSM6DSL_GY_ST_ND         = 4,    /* ERROR CODE */\n} lsm6dsl_st_g_t;\nint32_t lsm6dsl_gy_self_test_set(lsm6dsl_ctx_t *ctx, lsm6dsl_st_g_t val);\nint32_t lsm6dsl_gy_self_test_get(lsm6dsl_ctx_t *ctx, lsm6dsl_st_g_t *val);\n\nint32_t lsm6dsl_filter_settling_mask_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_filter_settling_mask_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSL_USE_SLOPE    = 0,\n  LSM6DSL_USE_HPF      = 1,\n  LSM6DSL_HP_PATH_ND   = 2,    /* ERROR CODE */\n} lsm6dsl_slope_fds_t;\nint32_t lsm6dsl_xl_hp_path_internal_set(lsm6dsl_ctx_t *ctx,\n                                        lsm6dsl_slope_fds_t val);\nint32_t lsm6dsl_xl_hp_path_internal_get(lsm6dsl_ctx_t *ctx,\n                                        lsm6dsl_slope_fds_t *val);\n\ntypedef enum {\n  LSM6DSL_XL_ANA_BW_1k5Hz = 0,\n  LSM6DSL_XL_ANA_BW_400Hz = 1,\n  LSM6DSL_XL_ANA_BW_ND    = 2,    /* ERROR CODE */\n} lsm6dsl_bw0_xl_t;\nint32_t lsm6dsl_xl_filter_analog_set(lsm6dsl_ctx_t *ctx,\n                                     lsm6dsl_bw0_xl_t val);\nint32_t lsm6dsl_xl_filter_analog_get(lsm6dsl_ctx_t *ctx,\n                                     lsm6dsl_bw0_xl_t *val);\n\ntypedef enum {\n  LSM6DSL_XL_LP1_ODR_DIV_2 = 0,\n  LSM6DSL_XL_LP1_ODR_DIV_4 = 1,\n  LSM6DSL_XL_LP1_NA        = 2,  /* ERROR CODE */\n} lsm6dsl_lpf1_bw_sel_t;\nint32_t lsm6dsl_xl_lp1_bandwidth_set(lsm6dsl_ctx_t *ctx,\n                                     lsm6dsl_lpf1_bw_sel_t val);\nint32_t lsm6dsl_xl_lp1_bandwidth_get(lsm6dsl_ctx_t *ctx,\n                                     lsm6dsl_lpf1_bw_sel_t *val);\n\ntypedef enum {\n  LSM6DSL_XL_LOW_LAT_LP_ODR_DIV_50     = 0x00,\n  LSM6DSL_XL_LOW_LAT_LP_ODR_DIV_100    = 0x01,\n  LSM6DSL_XL_LOW_LAT_LP_ODR_DIV_9      = 0x02,\n  LSM6DSL_XL_LOW_LAT_LP_ODR_DIV_400    = 0x03,\n  LSM6DSL_XL_LOW_NOISE_LP_ODR_DIV_50   = 0x10,\n  LSM6DSL_XL_LOW_NOISE_LP_ODR_DIV_100  = 0x11,\n  LSM6DSL_XL_LOW_NOISE_LP_ODR_DIV_9    = 0x12,\n  LSM6DSL_XL_LOW_NOISE_LP_ODR_DIV_400  = 0x13,\n  LSM6DSL_XL_LP_NA                     = 0x20, /* ERROR CODE */\n} lsm6dsl_input_composite_t;\nint32_t lsm6dsl_xl_lp2_bandwidth_set(lsm6dsl_ctx_t *ctx,\n                                     lsm6dsl_input_composite_t val);\nint32_t lsm6dsl_xl_lp2_bandwidth_get(lsm6dsl_ctx_t *ctx,\n                                     lsm6dsl_input_composite_t *val);\n\nint32_t lsm6dsl_xl_reference_mode_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_xl_reference_mode_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSL_XL_HP_ODR_DIV_4      = 0x00, /* Slope filter */\n  LSM6DSL_XL_HP_ODR_DIV_100    = 0x01,\n  LSM6DSL_XL_HP_ODR_DIV_9      = 0x02,\n  LSM6DSL_XL_HP_ODR_DIV_400    = 0x03,\n  LSM6DSL_XL_HP_NA             = 0x10, /* ERROR CODE */\n} lsm6dsl_hpcf_xl_t;\nint32_t lsm6dsl_xl_hp_bandwidth_set(lsm6dsl_ctx_t *ctx,\n                                    lsm6dsl_hpcf_xl_t val);\nint32_t lsm6dsl_xl_hp_bandwidth_get(lsm6dsl_ctx_t *ctx,\n                                    lsm6dsl_hpcf_xl_t *val);\n\ntypedef enum {\n  LSM6DSL_LP2_ONLY                    = 0x00,\n\n  LSM6DSL_HP_16mHz_LP2                = 0x80,\n  LSM6DSL_HP_65mHz_LP2                = 0x90,\n  LSM6DSL_HP_260mHz_LP2               = 0xA0,\n  LSM6DSL_HP_1Hz04_LP2                = 0xB0,\n\n  LSM6DSL_HP_DISABLE_LP1_LIGHT        = 0x0A,\n  LSM6DSL_HP_DISABLE_LP1_NORMAL       = 0x09,\n  LSM6DSL_HP_DISABLE_LP_STRONG        = 0x08,\n  LSM6DSL_HP_DISABLE_LP1_AGGRESSIVE   = 0x0B,\n\n  LSM6DSL_HP_16mHz_LP1_LIGHT          = 0x8A,\n  LSM6DSL_HP_65mHz_LP1_NORMAL         = 0x99,\n  LSM6DSL_HP_260mHz_LP1_STRONG        = 0xA8,\n  LSM6DSL_HP_1Hz04_LP1_AGGRESSIVE     = 0xBB,\n\n  LSM6DSL_HP_GY_BAND_NA               = 0xFF,    /* ERROR CODE */\n} lsm6dsl_lpf1_sel_g_t;\nint32_t lsm6dsl_gy_band_pass_set(lsm6dsl_ctx_t *ctx,\n                                    lsm6dsl_lpf1_sel_g_t val);\nint32_t lsm6dsl_gy_band_pass_get(lsm6dsl_ctx_t *ctx,\n                                    lsm6dsl_lpf1_sel_g_t *val);\n\ntypedef enum {\n  LSM6DSL_SPI_4_WIRE  = 0,\n  LSM6DSL_SPI_3_WIRE  = 1,\n  LSM6DSL_SPI_MODE_ND = 2,    /* ERROR CODE */\n} lsm6dsl_sim_t;\nint32_t lsm6dsl_spi_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_sim_t val);\nint32_t lsm6dsl_spi_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_sim_t *val);\n\ntypedef enum {\n  LSM6DSL_I2C_ENABLE   = 0,\n  LSM6DSL_I2C_DISABLE  = 1,\n  LSM6DSL_I2C_MODE_ND  = 2,    /* ERROR CODE */\n} lsm6dsl_i2c_disable_t;\nint32_t lsm6dsl_i2c_interface_set(lsm6dsl_ctx_t *ctx,\n                                  lsm6dsl_i2c_disable_t val);\nint32_t lsm6dsl_i2c_interface_get(lsm6dsl_ctx_t *ctx,\n                                  lsm6dsl_i2c_disable_t *val);\n\ntypedef struct {\n  uint8_t int1_drdy_xl             : 1;\n  uint8_t int1_drdy_g              : 1;\n  uint8_t int1_boot                : 1;\n  uint8_t int1_fth                 : 1;\n  uint8_t int1_fifo_ovr            : 1;\n  uint8_t int1_full_flag           : 1;\n  uint8_t int1_sign_mot            : 1;\n  uint8_t int1_step_detector       : 1;\n  uint8_t int1_timer               : 1;\n  uint8_t int1_tilt                : 1;\n  uint8_t int1_6d                  : 1;\n  uint8_t int1_double_tap          : 1;\n  uint8_t int1_ff                  : 1;\n  uint8_t int1_wu                  : 1;\n  uint8_t int1_single_tap          : 1;\n  uint8_t int1_inact_state         : 1;\n  uint8_t den_drdy_int1            : 1;\n  uint8_t drdy_on_int1             : 1;\n} lsm6dsl_int1_route_t;\nint32_t lsm6dsl_pin_int1_route_set(lsm6dsl_ctx_t *ctx,\n                                   lsm6dsl_int1_route_t val);\nint32_t lsm6dsl_pin_int1_route_get(lsm6dsl_ctx_t *ctx,\n                                   lsm6dsl_int1_route_t *val);\n\ntypedef struct{\n  uint8_t int2_drdy_xl             : 1;\n  uint8_t int2_drdy_g              : 1;\n  uint8_t int2_drdy_temp           : 1;\n  uint8_t int2_fth                 : 1;\n  uint8_t int2_fifo_ovr            : 1;\n  uint8_t int2_full_flag           : 1;\n  uint8_t int2_step_count_ov       : 1;\n  uint8_t int2_step_delta          : 1;\n  uint8_t int2_iron                : 1;\n  uint8_t int2_tilt                : 1;\n  uint8_t int2_6d                  : 1;\n  uint8_t int2_double_tap          : 1;\n  uint8_t int2_ff                  : 1;\n  uint8_t int2_wu                  : 1;\n  uint8_t int2_single_tap          : 1;\n  uint8_t int2_inact_state         : 1;\n  uint8_t int2_wrist_tilt          : 1;\n} lsm6dsl_int2_route_t;\nint32_t lsm6dsl_pin_int2_route_set(lsm6dsl_ctx_t *ctx,\n                                   lsm6dsl_int2_route_t val);\nint32_t lsm6dsl_pin_int2_route_get(lsm6dsl_ctx_t *ctx,\n                                   lsm6dsl_int2_route_t *val);\n\ntypedef enum {\n  LSM6DSL_PUSH_PULL   = 0,\n  LSM6DSL_OPEN_DRAIN  = 1,\n  LSM6DSL_PIN_MODE_ND = 2,    /* ERROR CODE */\n} lsm6dsl_pp_od_t;\nint32_t lsm6dsl_pin_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_pp_od_t val);\nint32_t lsm6dsl_pin_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_pp_od_t *val);\n\ntypedef enum {\n  LSM6DSL_ACTIVE_HIGH   = 0,\n  LSM6DSL_ACTIVE_LOW    = 1,\n  LSM6DSL_POLARITY_ND   = 2,    /* ERROR CODE */\n} lsm6dsl_h_lactive_t;\nint32_t lsm6dsl_pin_polarity_set(lsm6dsl_ctx_t *ctx, lsm6dsl_h_lactive_t val);\nint32_t lsm6dsl_pin_polarity_get(lsm6dsl_ctx_t *ctx, lsm6dsl_h_lactive_t *val);\n\nint32_t lsm6dsl_all_on_int1_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_all_on_int1_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSL_INT_PULSED   = 0,\n  LSM6DSL_INT_LATCHED  = 1,\n  LSM6DSL_INT_MODE     = 2,    /* ERROR CODE */\n} lsm6dsl_lir_t;\nint32_t lsm6dsl_int_notification_set(lsm6dsl_ctx_t *ctx, lsm6dsl_lir_t val);\nint32_t lsm6dsl_int_notification_get(lsm6dsl_ctx_t *ctx, lsm6dsl_lir_t *val);\n\nint32_t lsm6dsl_wkup_threshold_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_wkup_threshold_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsl_wkup_dur_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_wkup_dur_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsl_gy_sleep_mode_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_gy_sleep_mode_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSL_PROPERTY_DISABLE          = 0,\n  LSM6DSL_XL_12Hz5_GY_NOT_AFFECTED  = 1,\n  LSM6DSL_XL_12Hz5_GY_SLEEP         = 2,\n  LSM6DSL_XL_12Hz5_GY_PD            = 3,\n  LSM6DSL_ACT_MODE_ND               = 4,    /* ERROR CODE */\n} lsm6dsl_inact_en_t;\nint32_t lsm6dsl_act_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_inact_en_t val);\nint32_t lsm6dsl_act_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_inact_en_t *val);\n\nint32_t lsm6dsl_act_sleep_dur_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_act_sleep_dur_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsl_tap_src_get(lsm6dsl_ctx_t *ctx, lsm6dsl_tap_src_t *val);\n\nint32_t lsm6dsl_tap_detection_on_z_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_tap_detection_on_z_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsl_tap_detection_on_y_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_tap_detection_on_y_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsl_tap_detection_on_x_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_tap_detection_on_x_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsl_tap_threshold_x_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_tap_threshold_x_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsl_tap_shock_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_tap_shock_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsl_tap_quiet_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_tap_quiet_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsl_tap_dur_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_tap_dur_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSL_ONLY_SINGLE          = 0,\n  LSM6DSL_BOTH_SINGLE_DOUBLE   = 1,\n  LSM6DSL_TAP_MODE_ND          = 2,    /* ERROR CODE */\n} lsm6dsl_single_double_tap_t;\nint32_t lsm6dsl_tap_mode_set(lsm6dsl_ctx_t *ctx,\n                             lsm6dsl_single_double_tap_t val);\nint32_t lsm6dsl_tap_mode_get(lsm6dsl_ctx_t *ctx,\n                             lsm6dsl_single_double_tap_t *val);\n\ntypedef enum {\n  LSM6DSL_ODR_DIV_2_FEED      = 0,\n  LSM6DSL_LPF2_FEED           = 1,\n  LSM6DSL_6D_FEED_ND          = 2,    /* ERROR CODE */\n} lsm6dsl_low_pass_on_6d_t;\nint32_t lsm6dsl_6d_feed_data_set(lsm6dsl_ctx_t *ctx,\n                                 lsm6dsl_low_pass_on_6d_t val);\nint32_t lsm6dsl_6d_feed_data_get(lsm6dsl_ctx_t *ctx,\n                                 lsm6dsl_low_pass_on_6d_t *val);\n\ntypedef enum {\n  LSM6DSL_DEG_80      = 0,\n  LSM6DSL_DEG_70      = 1,\n  LSM6DSL_DEG_60      = 2,\n  LSM6DSL_DEG_50      = 3,\n  LSM6DSL_6D_TH_ND    = 4,    /* ERROR CODE */\n} lsm6dsl_sixd_ths_t;\nint32_t lsm6dsl_6d_threshold_set(lsm6dsl_ctx_t *ctx, lsm6dsl_sixd_ths_t val);\nint32_t lsm6dsl_6d_threshold_get(lsm6dsl_ctx_t *ctx, lsm6dsl_sixd_ths_t *val);\n\nint32_t lsm6dsl_4d_mode_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_4d_mode_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsl_ff_dur_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_ff_dur_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSL_FF_TSH_156mg = 0,\n  LSM6DSL_FF_TSH_219mg = 1,\n  LSM6DSL_FF_TSH_250mg = 2,\n  LSM6DSL_FF_TSH_312mg = 3,\n  LSM6DSL_FF_TSH_344mg = 4,\n  LSM6DSL_FF_TSH_406mg = 5,\n  LSM6DSL_FF_TSH_469mg = 6,\n  LSM6DSL_FF_TSH_500mg = 7,\n  LSM6DSL_FF_TSH_ND    = 8,    /* ERROR CODE */\n} lsm6dsl_ff_ths_t;\nint32_t lsm6dsl_ff_threshold_set(lsm6dsl_ctx_t *ctx, lsm6dsl_ff_ths_t val);\nint32_t lsm6dsl_ff_threshold_get(lsm6dsl_ctx_t *ctx, lsm6dsl_ff_ths_t *val);\n\nint32_t lsm6dsl_fifo_watermark_set(lsm6dsl_ctx_t *ctx, uint16_t val);\nint32_t lsm6dsl_fifo_watermark_get(lsm6dsl_ctx_t *ctx, uint16_t *val);\n\nint32_t lsm6dsl_fifo_data_level_get(lsm6dsl_ctx_t *ctx, uint16_t *val);\n\nint32_t lsm6dsl_fifo_wtm_flag_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsl_fifo_pattern_get(lsm6dsl_ctx_t *ctx, uint16_t *val);\n\nint32_t lsm6dsl_fifo_temp_batch_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_fifo_temp_batch_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSL_TRG_XL_GY_DRDY     = 0,\n  LSM6DSL_TRG_STEP_DETECT    = 1,\n  LSM6DSL_TRG_SH_DRDY        = 2,\n  LSM6DSL_TRG_SH_ND          = 3,    /* ERROR CODE */\n} lsm6dsl_trigger_fifo_t;\nint32_t lsm6dsl_fifo_write_trigger_set(lsm6dsl_ctx_t *ctx,\n                                       lsm6dsl_trigger_fifo_t val);\nint32_t lsm6dsl_fifo_write_trigger_get(lsm6dsl_ctx_t *ctx,\n                                       lsm6dsl_trigger_fifo_t *val);\n\nint32_t lsm6dsl_fifo_pedo_and_timestamp_batch_set(lsm6dsl_ctx_t *ctx,\n                                                  uint8_t val);\nint32_t lsm6dsl_fifo_pedo_and_timestamp_batch_get(lsm6dsl_ctx_t *ctx,\n                                                  uint8_t *val);\n\ntypedef enum {\n  LSM6DSL_FIFO_XL_DISABLE  = 0,\n  LSM6DSL_FIFO_XL_NO_DEC   = 1,\n  LSM6DSL_FIFO_XL_DEC_2    = 2,\n  LSM6DSL_FIFO_XL_DEC_3    = 3,\n  LSM6DSL_FIFO_XL_DEC_4    = 4,\n  LSM6DSL_FIFO_XL_DEC_8    = 5,\n  LSM6DSL_FIFO_XL_DEC_16   = 6,\n  LSM6DSL_FIFO_XL_DEC_32   = 7,\n  LSM6DSL_FIFO_XL_DEC_ND   = 8,    /* ERROR CODE */\n} lsm6dsl_dec_fifo_xl_t;\nint32_t lsm6dsl_fifo_xl_batch_set(lsm6dsl_ctx_t *ctx,\n                                  lsm6dsl_dec_fifo_xl_t val);\nint32_t lsm6dsl_fifo_xl_batch_get(lsm6dsl_ctx_t *ctx,\n                                  lsm6dsl_dec_fifo_xl_t *val);\n\ntypedef enum {\n  LSM6DSL_FIFO_GY_DISABLE = 0,\n  LSM6DSL_FIFO_GY_NO_DEC  = 1,\n  LSM6DSL_FIFO_GY_DEC_2   = 2,\n  LSM6DSL_FIFO_GY_DEC_3   = 3,\n  LSM6DSL_FIFO_GY_DEC_4   = 4,\n  LSM6DSL_FIFO_GY_DEC_8   = 5,\n  LSM6DSL_FIFO_GY_DEC_16  = 6,\n  LSM6DSL_FIFO_GY_DEC_32  = 7,\n  LSM6DSL_FIFO_GY_DEC_ND  = 8,    /* ERROR CODE */\n} lsm6dsl_dec_fifo_gyro_t;\nint32_t lsm6dsl_fifo_gy_batch_set(lsm6dsl_ctx_t *ctx,\n                                  lsm6dsl_dec_fifo_gyro_t val);\nint32_t lsm6dsl_fifo_gy_batch_get(lsm6dsl_ctx_t *ctx,\n                                  lsm6dsl_dec_fifo_gyro_t *val);\n\ntypedef enum {\n  LSM6DSL_FIFO_DS3_DISABLE   = 0,\n  LSM6DSL_FIFO_DS3_NO_DEC    = 1,\n  LSM6DSL_FIFO_DS3_DEC_2     = 2,\n  LSM6DSL_FIFO_DS3_DEC_3     = 3,\n  LSM6DSL_FIFO_DS3_DEC_4     = 4,\n  LSM6DSL_FIFO_DS3_DEC_8     = 5,\n  LSM6DSL_FIFO_DS3_DEC_16    = 6,\n  LSM6DSL_FIFO_DS3_DEC_32    = 7,\n  LSM6DSL_FIFO_DS3_DEC_ND    = 8,    /* ERROR CODE */\n} lsm6dsl_dec_ds3_fifo_t;\nint32_t lsm6dsl_fifo_dataset_3_batch_set(lsm6dsl_ctx_t *ctx,\n                                         lsm6dsl_dec_ds3_fifo_t val);\nint32_t lsm6dsl_fifo_dataset_3_batch_get(lsm6dsl_ctx_t *ctx,\n                                         lsm6dsl_dec_ds3_fifo_t *val);\n\ntypedef enum {\n  LSM6DSL_FIFO_DS4_DISABLE  = 0,\n  LSM6DSL_FIFO_DS4_NO_DEC   = 1,\n  LSM6DSL_FIFO_DS4_DEC_2    = 2,\n  LSM6DSL_FIFO_DS4_DEC_3    = 3,\n  LSM6DSL_FIFO_DS4_DEC_4    = 4,\n  LSM6DSL_FIFO_DS4_DEC_8    = 5,\n  LSM6DSL_FIFO_DS4_DEC_16   = 6,\n  LSM6DSL_FIFO_DS4_DEC_32   = 7,\n  LSM6DSL_FIFO_DS4_DEC_ND   = 8,    /* ERROR CODE */\n} lsm6dsl_dec_ds4_fifo_t;\nint32_t lsm6dsl_fifo_dataset_4_batch_set(lsm6dsl_ctx_t *ctx,\n                                         lsm6dsl_dec_ds4_fifo_t val);\nint32_t lsm6dsl_fifo_dataset_4_batch_get(lsm6dsl_ctx_t *ctx,\n                                         lsm6dsl_dec_ds4_fifo_t *val);\n\nint32_t lsm6dsl_fifo_xl_gy_8bit_format_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_fifo_xl_gy_8bit_format_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsl_fifo_stop_on_wtm_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_fifo_stop_on_wtm_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSL_BYPASS_MODE           = 0,\n  LSM6DSL_FIFO_MODE             = 1,\n  LSM6DSL_STREAM_TO_FIFO_MODE   = 3,\n  LSM6DSL_BYPASS_TO_STREAM_MODE = 4,\n  LSM6DSL_STREAM_MODE           = 6,\n  LSM6DSL_FIFO_MODE_ND          = 8,    /* ERROR CODE */\n} lsm6dsl_fifo_mode_t;\nint32_t lsm6dsl_fifo_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_fifo_mode_t val);\nint32_t lsm6dsl_fifo_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_fifo_mode_t *val);\n\ntypedef enum {\n  LSM6DSL_FIFO_DISABLE   =  0,\n  LSM6DSL_FIFO_12Hz5     =  1,\n  LSM6DSL_FIFO_26Hz      =  2,\n  LSM6DSL_FIFO_52Hz      =  3,\n  LSM6DSL_FIFO_104Hz     =  4,\n  LSM6DSL_FIFO_208Hz     =  5,\n  LSM6DSL_FIFO_416Hz     =  6,\n  LSM6DSL_FIFO_833Hz     =  7,\n  LSM6DSL_FIFO_1k66Hz    =  8,\n  LSM6DSL_FIFO_3k33Hz    =  9,\n  LSM6DSL_FIFO_6k66Hz    = 10,\n  LSM6DSL_FIFO_RATE_ND   = 11,    /* ERROR CODE */\n} lsm6dsl_odr_fifo_t;\nint32_t lsm6dsl_fifo_data_rate_set(lsm6dsl_ctx_t *ctx,\n                                   lsm6dsl_odr_fifo_t val);\nint32_t lsm6dsl_fifo_data_rate_get(lsm6dsl_ctx_t *ctx,\n                                   lsm6dsl_odr_fifo_t *val);\n\ntypedef enum {\n  LSM6DSL_DEN_ACT_LOW    = 0,\n  LSM6DSL_DEN_ACT_HIGH   = 1,\n  LSM6DSL_DEN_POL_ND     = 2,    /* ERROR CODE */\n} lsm6dsl_den_lh_t;\nint32_t lsm6dsl_den_polarity_set(lsm6dsl_ctx_t *ctx, lsm6dsl_den_lh_t val);\nint32_t lsm6dsl_den_polarity_get(lsm6dsl_ctx_t *ctx, lsm6dsl_den_lh_t *val);\n\ntypedef enum {\n  LSM6DSL_DEN_DISABLE    = 0,\n  LSM6DSL_LEVEL_FIFO     = 6,\n  LSM6DSL_LEVEL_LETCHED  = 3,\n  LSM6DSL_LEVEL_TRIGGER  = 2,\n  LSM6DSL_EDGE_TRIGGER   = 4,\n  LSM6DSL_DEN_MODE_ND    = 5,    /* ERROR CODE */\n} lsm6dsl_den_mode_t;\nint32_t lsm6dsl_den_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_den_mode_t val);\nint32_t lsm6dsl_den_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_den_mode_t *val);\n\ntypedef enum {\n  LSM6DSL_STAMP_IN_GY_DATA     = 0,\n  LSM6DSL_STAMP_IN_XL_DATA     = 1,\n  LSM6DSL_STAMP_IN_GY_XL_DATA  = 2,\n  LSM6DSL_DEN_STAMP_ND         = 3,    /* ERROR CODE */\n} lsm6dsl_den_xl_en_t;\nint32_t lsm6dsl_den_enable_set(lsm6dsl_ctx_t *ctx, lsm6dsl_den_xl_en_t val);\nint32_t lsm6dsl_den_enable_get(lsm6dsl_ctx_t *ctx, lsm6dsl_den_xl_en_t *val);\n\nint32_t lsm6dsl_den_mark_axis_z_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_den_mark_axis_z_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsl_den_mark_axis_y_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_den_mark_axis_y_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsl_den_mark_axis_x_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_den_mark_axis_x_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsl_pedo_step_reset_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_pedo_step_reset_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsl_pedo_sens_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_pedo_sens_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsl_pedo_threshold_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_pedo_threshold_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSL_PEDO_AT_2g = 0,\n  LSM6DSL_PEDO_AT_4g = 1,\n  LSM6DSL_PEDO_FS_ND = 2,    /* ERROR CODE */\n} lsm6dsl_pedo_fs_t;\nint32_t lsm6dsl_pedo_full_scale_set(lsm6dsl_ctx_t *ctx,\n                                    lsm6dsl_pedo_fs_t val);\nint32_t lsm6dsl_pedo_full_scale_get(lsm6dsl_ctx_t *ctx,\n                                    lsm6dsl_pedo_fs_t *val);\n\nint32_t lsm6dsl_pedo_debounce_steps_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_pedo_debounce_steps_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsl_pedo_timeout_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_pedo_timeout_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsl_pedo_steps_period_set(lsm6dsl_ctx_t *ctx, uint8_t *buff);\nint32_t lsm6dsl_pedo_steps_period_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);\n\nint32_t lsm6dsl_motion_sens_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_motion_sens_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsl_motion_threshold_set(lsm6dsl_ctx_t *ctx, uint8_t *buff);\nint32_t lsm6dsl_motion_threshold_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);\n\nint32_t lsm6dsl_tilt_sens_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_tilt_sens_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsl_wrist_tilt_sens_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_wrist_tilt_sens_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsl_tilt_latency_set(lsm6dsl_ctx_t *ctx, uint8_t *buff);\nint32_t lsm6dsl_tilt_latency_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);\n\nint32_t lsm6dsl_tilt_threshold_set(lsm6dsl_ctx_t *ctx, uint8_t *buff);\nint32_t lsm6dsl_tilt_threshold_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);\n\nint32_t lsm6dsl_tilt_src_set(lsm6dsl_ctx_t *ctx,\n                             lsm6dsl_a_wrist_tilt_mask_t *val);\nint32_t lsm6dsl_tilt_src_get(lsm6dsl_ctx_t *ctx,\n                             lsm6dsl_a_wrist_tilt_mask_t *val);\n\nint32_t lsm6dsl_mag_soft_iron_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_mag_soft_iron_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsl_mag_hard_iron_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_mag_hard_iron_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsl_mag_soft_iron_mat_set(lsm6dsl_ctx_t *ctx, uint8_t *buff);\nint32_t lsm6dsl_mag_soft_iron_mat_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);\n\nint32_t lsm6dsl_mag_offset_set(lsm6dsl_ctx_t *ctx, uint8_t *buff);\nint32_t lsm6dsl_mag_offset_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);\n\nint32_t lsm6dsl_func_en_set(lsm6dsl_ctx_t *ctx, uint8_t val);\n\nint32_t lsm6dsl_sh_sync_sens_frame_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_sh_sync_sens_frame_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSL_RES_RATIO_2_11  = 0,\n  LSM6DSL_RES_RATIO_2_12  = 1,\n  LSM6DSL_RES_RATIO_2_13  = 2,\n  LSM6DSL_RES_RATIO_2_14  = 3,\n  LSM6DSL_RES_RATIO_ND    = 4,    /* ERROR CODE */\n} lsm6dsl_rr_t;\nint32_t lsm6dsl_sh_sync_sens_ratio_set(lsm6dsl_ctx_t *ctx, lsm6dsl_rr_t val);\nint32_t lsm6dsl_sh_sync_sens_ratio_get(lsm6dsl_ctx_t *ctx, lsm6dsl_rr_t *val);\n\nint32_t lsm6dsl_sh_master_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_sh_master_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsl_sh_pass_through_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_sh_pass_through_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSL_EXT_PULL_UP       = 0,\n  LSM6DSL_INTERNAL_PULL_UP  = 1,\n  LSM6DSL_SH_PIN_MODE       = 2,    /* ERROR CODE */\n} lsm6dsl_pull_up_en_t;\nint32_t lsm6dsl_sh_pin_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_pull_up_en_t val);\nint32_t lsm6dsl_sh_pin_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_pull_up_en_t *val);\n\ntypedef enum {\n  LSM6DSL_XL_GY_DRDY        = 0,\n  LSM6DSL_EXT_ON_INT2_PIN   = 1,\n  LSM6DSL_SH_SYNCRO_ND      = 2,    /* ERROR CODE */\n} lsm6dsl_start_config_t;\nint32_t lsm6dsl_sh_syncro_mode_set(lsm6dsl_ctx_t *ctx,\n                                   lsm6dsl_start_config_t val);\nint32_t lsm6dsl_sh_syncro_mode_get(lsm6dsl_ctx_t *ctx,\n                                   lsm6dsl_start_config_t *val);\n\nint32_t lsm6dsl_sh_drdy_on_int1_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_sh_drdy_on_int1_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\ntypedef union {\n  struct {\n    lsm6dsl_sensorhub1_reg_t   sh_byte_1;\n    lsm6dsl_sensorhub2_reg_t   sh_byte_2;\n    lsm6dsl_sensorhub3_reg_t   sh_byte_3;\n    lsm6dsl_sensorhub4_reg_t   sh_byte_4;\n    lsm6dsl_sensorhub5_reg_t   sh_byte_5;\n    lsm6dsl_sensorhub6_reg_t   sh_byte_6;\n    lsm6dsl_sensorhub7_reg_t   sh_byte_7;\n    lsm6dsl_sensorhub8_reg_t   sh_byte_8;\n    lsm6dsl_sensorhub9_reg_t   sh_byte_9;\n    lsm6dsl_sensorhub10_reg_t  sh_byte_10;\n    lsm6dsl_sensorhub11_reg_t  sh_byte_11;\n    lsm6dsl_sensorhub12_reg_t  sh_byte_12;\n    lsm6dsl_sensorhub13_reg_t  sh_byte_13;\n    lsm6dsl_sensorhub14_reg_t  sh_byte_14;\n    lsm6dsl_sensorhub15_reg_t  sh_byte_15;\n    lsm6dsl_sensorhub16_reg_t  sh_byte_16;\n    lsm6dsl_sensorhub17_reg_t  sh_byte_17;\n    lsm6dsl_sensorhub18_reg_t  sh_byte_18;\n  } reg;\n  uint8_t byte[18];\n} lsm6dsl_emb_sh_read_t;\nint32_t lsm6dsl_sh_read_data_raw_get(lsm6dsl_ctx_t *ctx,\n                                     lsm6dsl_emb_sh_read_t *val);\n\nint32_t lsm6dsl_sh_cmd_sens_sync_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_sh_cmd_sens_sync_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\nint32_t lsm6dsl_sh_spi_sync_error_set(lsm6dsl_ctx_t *ctx, uint8_t val);\nint32_t lsm6dsl_sh_spi_sync_error_get(lsm6dsl_ctx_t *ctx, uint8_t *val);\n\ntypedef enum {\n  LSM6DSL_SLV_0        = 0,\n  LSM6DSL_SLV_0_1      = 1,\n  LSM6DSL_SLV_0_1_2    = 2,\n  LSM6DSL_SLV_0_1_2_3  = 3,\n  LSM6DSL_SLV_EN_ND    = 4,    /* ERROR CODE */\n} lsm6dsl_aux_sens_on_t;\nint32_t lsm6dsl_sh_num_of_dev_connected_set(lsm6dsl_ctx_t *ctx,\n                                            lsm6dsl_aux_sens_on_t val);\nint32_t lsm6dsl_sh_num_of_dev_connected_get(lsm6dsl_ctx_t *ctx,\n                                            lsm6dsl_aux_sens_on_t *val);\n\ntypedef struct{\n  uint8_t   slv0_add;\n  uint8_t   slv0_subadd;\n  uint8_t   slv0_data;\n} lsm6dsl_sh_cfg_write_t;\nint32_t lsm6dsl_sh_cfg_write(lsm6dsl_ctx_t *ctx, lsm6dsl_sh_cfg_write_t *val);\n\ntypedef struct{\n  uint8_t   slv_add;\n  uint8_t   slv_subadd;\n  uint8_t   slv_len;\n} lsm6dsl_sh_cfg_read_t;\nint32_t lsm6dsl_sh_slv0_cfg_read(lsm6dsl_ctx_t *ctx,\n                                 lsm6dsl_sh_cfg_read_t *val);\nint32_t lsm6dsl_sh_slv1_cfg_read(lsm6dsl_ctx_t *ctx,\n                                 lsm6dsl_sh_cfg_read_t *val);\nint32_t lsm6dsl_sh_slv2_cfg_read(lsm6dsl_ctx_t *ctx,\n                                 lsm6dsl_sh_cfg_read_t *val);\nint32_t lsm6dsl_sh_slv3_cfg_read(lsm6dsl_ctx_t *ctx,\n                                 lsm6dsl_sh_cfg_read_t *val);\n\ntypedef enum {\n  LSM6DSL_SL0_NO_DEC   = 0,\n  LSM6DSL_SL0_DEC_2    = 1,\n  LSM6DSL_SL0_DEC_4    = 2,\n  LSM6DSL_SL0_DEC_8    = 3,\n  LSM6DSL_SL0_DEC_ND   = 4,    /* ERROR CODE */\n} lsm6dsl_slave0_rate_t;\nint32_t lsm6dsl_sh_slave_0_dec_set(lsm6dsl_ctx_t *ctx,\n                                   lsm6dsl_slave0_rate_t val);\nint32_t lsm6dsl_sh_slave_0_dec_get(lsm6dsl_ctx_t *ctx,\n                                   lsm6dsl_slave0_rate_t *val);\n\ntypedef enum {\n  LSM6DSL_EACH_SH_CYCLE     = 0,\n  LSM6DSL_ONLY_FIRST_CYCLE  = 1,\n  LSM6DSL_SH_WR_MODE_ND     = 2,    /* ERROR CODE */\n} lsm6dsl_write_once_t;\nint32_t lsm6dsl_sh_write_mode_set(lsm6dsl_ctx_t *ctx,\n                                  lsm6dsl_write_once_t val);\nint32_t lsm6dsl_sh_write_mode_get(lsm6dsl_ctx_t *ctx,\n                                  lsm6dsl_write_once_t *val);\n\ntypedef enum {\n  LSM6DSL_SL1_NO_DEC   = 0,\n  LSM6DSL_SL1_DEC_2    = 1,\n  LSM6DSL_SL1_DEC_4    = 2,\n  LSM6DSL_SL1_DEC_8    = 3,\n  LSM6DSL_SL1_DEC_ND   = 4,    /* ERROR CODE */\n} lsm6dsl_slave1_rate_t;\nint32_t lsm6dsl_sh_slave_1_dec_set(lsm6dsl_ctx_t *ctx,\n                                   lsm6dsl_slave1_rate_t val);\nint32_t lsm6dsl_sh_slave_1_dec_get(lsm6dsl_ctx_t *ctx,\n                                   lsm6dsl_slave1_rate_t *val);\n\ntypedef enum {\n  LSM6DSL_SL2_NO_DEC  = 0,\n  LSM6DSL_SL2_DEC_2   = 1,\n  LSM6DSL_SL2_DEC_4   = 2,\n  LSM6DSL_SL2_DEC_8   = 3,\n  LSM6DSL_SL2_DEC_ND  = 4,    /* ERROR CODE */\n} lsm6dsl_slave2_rate_t;\nint32_t lsm6dsl_sh_slave_2_dec_set(lsm6dsl_ctx_t *ctx,\n                                   lsm6dsl_slave2_rate_t val);\nint32_t lsm6dsl_sh_slave_2_dec_get(lsm6dsl_ctx_t *ctx,\n                                   lsm6dsl_slave2_rate_t *val);\n\ntypedef enum {\n  LSM6DSL_SL3_NO_DEC  = 0,\n  LSM6DSL_SL3_DEC_2   = 1,\n  LSM6DSL_SL3_DEC_4   = 2,\n  LSM6DSL_SL3_DEC_8   = 3,\n  LSM6DSL_SL3_DEC_ND  = 4,    /* ERROR CODE */\n} lsm6dsl_slave3_rate_t;\nint32_t lsm6dsl_sh_slave_3_dec_set(lsm6dsl_ctx_t *ctx,\n                                   lsm6dsl_slave3_rate_t val);\nint32_t lsm6dsl_sh_slave_3_dec_get(lsm6dsl_ctx_t *ctx,\n                                   lsm6dsl_slave3_rate_t *val);\n\n/**\n  * @}\n  */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* LSM6DSL_DRIVER_H */\n\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\n"
              },
              "objects": {
                "lsm6dsl.c": "#include \"lsm6dsl.h\"\r\n#include \"lsm6dsl_reg.h\"\r\n\r\nstatic ATMO_LSM6DSL_Config_t _LSM6DSL_PrivConfig;\r\nstatic lsm6dsl_ctx_t _LSM6DSL_AccelCtx;\r\n\r\nstatic int32_t _ATMO_LSM6DSL_PlatformWrite(void *handle, uint8_t Reg, uint8_t *Bufp,\r\n                              uint16_t len)\r\n{\r\n    uint8_t i2cAddress = *((uint8_t*)handle);\r\n    ATMO_I2C_Status_t status = ATMO_I2C_MasterWrite(_LSM6DSL_PrivConfig.i2cInstance, i2cAddress,\r\n    &Reg, 1, Bufp, len, 1000);\r\n  \r\n    return (status == ATMO_I2C_Status_Success) ? 0 : 1;\r\n}\r\n\r\nstatic int32_t _ATMO_LSM6DSL_PlatformRead(void *handle, uint8_t Reg, uint8_t *Bufp,\r\n                             uint16_t len)\r\n{\r\n    uint8_t i2cAddress = *((uint8_t*)handle);\r\n    ATMO_I2C_Status_t status = ATMO_I2C_Status_Success;\r\n    uint8_t currentReg = Reg;\r\n\r\n    // Need to do discrete reads or block update doesn't work\r\n    for(unsigned int i = 0; (i < len) && (status == ATMO_I2C_Status_Success); i++)\r\n    {\r\n        status = ATMO_I2C_MasterRead(_LSM6DSL_PrivConfig.i2cInstance, i2cAddress,\r\n            &currentReg, 1, &Bufp[i], 1, 1000);\r\n        currentReg++;\r\n    }\r\n\r\n    return (status == ATMO_I2C_Status_Success) ? 0 : 1;\r\n}\r\n\r\nATMO_LSM6DSL_Status_t ATMO_LSM6DSL_Init(ATMO_LSM6DSL_Config_t *config)\r\n{\r\n    if(config == NULL)\r\n    {\r\n        return ATMO_LSM6DSL_Status_Fail;\r\n    }\r\n\r\n    memcpy(&_LSM6DSL_PrivConfig, config, sizeof(_LSM6DSL_PrivConfig));\r\n\r\n    _LSM6DSL_AccelCtx.write_reg = _ATMO_LSM6DSL_PlatformWrite;\r\n    _LSM6DSL_AccelCtx.read_reg = _ATMO_LSM6DSL_PlatformRead;\r\n    _LSM6DSL_AccelCtx.handle = (void*)&_LSM6DSL_PrivConfig.i2cAddress;  \r\n    \r\n    /*\r\n   *  Check device ID\r\n   */\r\n    uint8_t whoamI = 0;\r\n    lsm6dsl_device_id_get(&_LSM6DSL_AccelCtx, &whoamI);\r\n    if ( whoamI != LSM6DSL_ID )\r\n    {\r\n        ATMO_PLATFORM_DebugPrint(\"LSM6DSL: Bad WhoAmI Rcv %02X Expect %02X\\r\\n\", whoamI, LSM6DSL_ID);\r\n        return ATMO_LSM6DSL_Status_Fail;\r\n    }\r\n\r\n    /*\r\n    *  Restore default configuration\r\n    */\r\n   uint8_t rst = 0;\r\n    lsm6dsl_reset_set(&_LSM6DSL_AccelCtx, PROPERTY_ENABLE);\r\n    do {\r\n        lsm6dsl_reset_get(&_LSM6DSL_AccelCtx, &rst);\r\n    } while (rst);\r\n\r\n\r\n    // Enable block data update\r\n    lsm6dsl_block_data_update_set(&_LSM6DSL_AccelCtx, PROPERTY_ENABLE);\r\n    /*\r\n    * Set Output Data Rate\r\n    */\r\n    lsm6dsl_xl_data_rate_set(&_LSM6DSL_AccelCtx, config->accelOdr);\r\n    lsm6dsl_gy_data_rate_set(&_LSM6DSL_AccelCtx, config->gyroOdr);\r\n    /*\r\n    * Set full scale\r\n    */  \r\n    lsm6dsl_xl_full_scale_set(&_LSM6DSL_AccelCtx, config->accelFullScale);\r\n    lsm6dsl_gy_full_scale_set(&_LSM6DSL_AccelCtx, config->gyroFullScale);\r\n\r\n    /*\r\n    * Configure filtering chain(No aux interface)\r\n    */  \r\n    /* Accelerometer - analog filter */\r\n    lsm6dsl_xl_filter_analog_set(&_LSM6DSL_AccelCtx, LSM6DSL_XL_ANA_BW_400Hz);\r\n\r\n    /* Accelerometer - LPF1 path ( LPF2 not used )*/\r\n    //lsm6dsl_xl_lp1_bandwidth_set(&dev_ctx, LSM6DSL_XL_LP1_ODR_DIV_4);\r\n\r\n    /* Accelerometer - LPF1 + LPF2 path */   \r\n    lsm6dsl_xl_lp2_bandwidth_set(&_LSM6DSL_AccelCtx, LSM6DSL_XL_LOW_NOISE_LP_ODR_DIV_100);\r\n\r\n    /* Accelerometer - High Pass / Slope path */\r\n    //lsm6dsl_xl_reference_mode_set(&dev_ctx, PROPERTY_DISABLE);\r\n    //lsm6dsl_xl_hp_bandwidth_set(&dev_ctx, LSM6DSL_XL_HP_ODR_DIV_100);\r\n\r\n    /* Gyroscope - filtering chain */\r\n    lsm6dsl_gy_band_pass_set(&_LSM6DSL_AccelCtx, LSM6DSL_HP_260mHz_LP1_STRONG);\r\n\r\n    return ATMO_LSM6DSL_Status_Success;\r\n}\r\n\r\n/**\r\n * @brief Get acceleration data. Each axis is in mg\r\n * \r\n * @param data \r\n * @return ATMO_LSM6DSL_Status_t \r\n */\r\nATMO_LSM6DSL_Status_t ATMO_LSM6DSL_GetAccelData(ATMO_LSM6DSL_AccelData_t *data)\r\n{\r\n    uint8_t rawData[6] = {0};\r\n    lsm6dsl_acceleration_raw_get(&_LSM6DSL_AccelCtx, rawData);\r\n\r\n    int16_t rawDataInt[3] = {0};\r\n    rawDataInt[0] = (rawData[1] << 8) | rawData[0];\r\n    rawDataInt[1] = (rawData[3] << 8) | rawData[2];\r\n    rawDataInt[2] = (rawData[5] << 8) | rawData[4];\r\n\r\n    switch(_LSM6DSL_PrivConfig.accelFullScale)\r\n    {\r\n        case LSM6DSL_2g:\r\n        {\r\n            data->x = LSM6DSL_FROM_FS_2g_TO_mg( rawDataInt[0] );\r\n            data->y = LSM6DSL_FROM_FS_2g_TO_mg( rawDataInt[1] );\r\n            data->z = LSM6DSL_FROM_FS_2g_TO_mg( rawDataInt[2] );\r\n            break;\r\n        }\r\n        case LSM6DSL_4g:\r\n        {\r\n            data->x = LSM6DSL_FROM_FS_4g_TO_mg( rawDataInt[0] );\r\n            data->y = LSM6DSL_FROM_FS_4g_TO_mg( rawDataInt[1] );\r\n            data->z = LSM6DSL_FROM_FS_4g_TO_mg( rawDataInt[2] );\r\n            break;\r\n        }\r\n        case LSM6DSL_8g:\r\n        {\r\n            data->x = LSM6DSL_FROM_FS_8g_TO_mg( rawDataInt[0] );\r\n            data->y = LSM6DSL_FROM_FS_8g_TO_mg( rawDataInt[1] );\r\n            data->z = LSM6DSL_FROM_FS_8g_TO_mg( rawDataInt[2] );\r\n            break;\r\n        }\r\n        case LSM6DSL_16g:\r\n        {\r\n            data->x = LSM6DSL_FROM_FS_16g_TO_mg( rawDataInt[0] );\r\n            data->y = LSM6DSL_FROM_FS_16g_TO_mg( rawDataInt[1] );\r\n            data->z = LSM6DSL_FROM_FS_16g_TO_mg( rawDataInt[2] );\r\n            break;\r\n        }\r\n        default:\r\n        {\r\n            memset(data, 0, sizeof(ATMO_LSM6DSL_AccelData_t));\r\n            return ATMO_LSM6DSL_Status_Fail;\r\n            break;\r\n        }\r\n\r\n    }\r\n\r\n    return ATMO_LSM6DSL_Status_Success;\r\n}\r\n\r\n/**\r\n * @brief Get magnetometer data. Each axis is in mdps\r\n * \r\n * @param data \r\n * @return ATMO_LSM6DSL_Status_t \r\n */\r\nATMO_LSM6DSL_Status_t ATMO_LSM6DSL_GetGyroData(ATMO_LSM6DSL_GyroData_t *data)\r\n{\r\n    uint8_t rawData[6] = {0};\r\n    lsm6dsl_angular_rate_raw_get(&_LSM6DSL_AccelCtx, rawData);\r\n\r\n    int16_t rawDataInt[3] = {0};\r\n    rawDataInt[0] = (rawData[1] << 8) | rawData[0];\r\n    rawDataInt[1] = (rawData[3] << 8) | rawData[2];\r\n    rawDataInt[2] = (rawData[5] << 8) | rawData[4];\r\n\r\n    switch(_LSM6DSL_PrivConfig.gyroFullScale)\r\n    {\r\n        case LSM6DSL_250dps:\r\n        {\r\n            data->x = LSM6DSL_FROM_FS_250dps_TO_mdps(rawData[0]);\r\n            data->y = LSM6DSL_FROM_FS_250dps_TO_mdps(rawData[1]);\r\n            data->z = LSM6DSL_FROM_FS_250dps_TO_mdps(rawData[2]);\r\n            break;\r\n        }\r\n        case LSM6DSL_125dps:\r\n        {\r\n            data->x = LSM6DSL_FROM_FS_125dps_TO_mdps(rawData[0]);\r\n            data->y = LSM6DSL_FROM_FS_125dps_TO_mdps(rawData[1]);\r\n            data->z = LSM6DSL_FROM_FS_125dps_TO_mdps(rawData[2]);\r\n            break;\r\n        }\r\n        case LSM6DSL_500dps:\r\n        {\r\n            data->x = LSM6DSL_FROM_FS_500dps_TO_mdps(rawData[0]);\r\n            data->y = LSM6DSL_FROM_FS_500dps_TO_mdps(rawData[1]);\r\n            data->z = LSM6DSL_FROM_FS_500dps_TO_mdps(rawData[2]);\r\n            break;\r\n        }\r\n        case LSM6DSL_1000dps:\r\n        {\r\n            data->x = LSM6DSL_FROM_FS_1000dps_TO_mdps(rawData[0]);\r\n            data->y = LSM6DSL_FROM_FS_1000dps_TO_mdps(rawData[1]);\r\n            data->z = LSM6DSL_FROM_FS_1000dps_TO_mdps(rawData[2]);\r\n            break;\r\n        }\r\n        case LSM6DSL_2000dps:\r\n        {\r\n            data->x = LSM6DSL_FROM_FS_2000dps_TO_mdps(rawData[0]);\r\n            data->y = LSM6DSL_FROM_FS_2000dps_TO_mdps(rawData[1]);\r\n            data->z = LSM6DSL_FROM_FS_2000dps_TO_mdps(rawData[2]);\r\n            break;\r\n        }\r\n        default:\r\n        {\r\n            data->x = 0;\r\n            data->y = 0;\r\n            data->z = 0;\r\n            return ATMO_LSM6DSL_Status_Fail;\r\n        }\r\n    }\r\n\r\n    return ATMO_LSM6DSL_Status_Success;\r\n}\r\n\r\n/**\r\n * @brief Get temperature data in degrees C\r\n * \r\n * @param data \r\n * @return ATMO_LSM6DSL_Status_t \r\n */\r\nATMO_LSM6DSL_Status_t ATMO_LSM6DSL_GetTempData(float *tempC)\r\n{\r\n    uint8_t rawData[2] = {0};\r\n    lsm6dsl_temperature_raw_get(&_LSM6DSL_AccelCtx, rawData);\r\n\r\n    int16_t tempDataInt = (rawData[1] << 8) | rawData[0];\r\n    *tempC = LSM6DSL_FROM_LSB_TO_degC( tempDataInt );\r\n    return ATMO_LSM6DSL_Status_Success;\r\n}",
                "lsm6dsl_reg.c": "/*\n ******************************************************************************\n * @file    lsm6dsl_reg.c\n * @author  MEMS Software Solution Team\n * @brief   LSM6DSL driver file\n ******************************************************************************\n * @attention\n *\n * <h2><center>&copy; COPYRIGHT(c) 2018 STMicroelectronics</center></h2>\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *   1. Redistributions of source code must retain the above copyright notice,\n *      this list of conditions and the following disclaimer.\n *   2. Redistributions in binary form must reproduce the above copyright notice,\n *      this list of conditions and the following disclaimer in the documentation\n *      and/or other materials provided with the distribution.\n *   3. Neither the name of STMicroelectronics nor the names of its contributors\n *      may be used to endorse or promote products derived from this software\n *      without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n#include \"lsm6dsl_reg.h\"\n\n/**\n  * @addtogroup  lsm6dsl\n  * @brief  This file provides a set of functions needed to drive the\n  *         lsm6dsl enanced inertial module.\n  * @{\n  */\n\n/**\n  * @addtogroup  interfaces_functions\n  * @brief  This section provide a set of functions used to read and write\n  *         a generic register of the device.\n  * @{\n  */\n\n/**\n  * @brief  Read generic device register\n  *\n  * @param  lsm6dsl_ctx_t* ctx: read / write interface definitions\n  * @param  uint8_t reg: register to read\n  * @param  uint8_t* data: pointer to buffer that store the data read\n  * @param  uint16_t len: number of consecutive register to read\n  *\n  */\nint32_t lsm6dsl_read_reg(lsm6dsl_ctx_t* ctx, uint8_t reg, uint8_t* data,\n                         uint16_t len)\n{\n  int32_t ret;\n  ret = ctx->read_reg(ctx->handle, reg, data, len);\n  return ret;\n}\n\n/**\n  * @brief  Write generic device register\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t reg: register to write\n  * @param  uint8_t* data: pointer to data to write in register reg\n  * @param  uint16_t len: number of consecutive register to write\n  *\n*/\nint32_t lsm6dsl_write_reg(lsm6dsl_ctx_t* ctx, uint8_t reg, uint8_t* data,\n                          uint16_t len)\n{\n  int32_t ret;\n  ret = ctx->write_reg(ctx->handle, reg, data, len);\n  return ret;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  data_generation_c\n  * @brief   This section groups all the functions concerning data generation\n  * @{\n  */\n\n/**\n  * @brief  xl_full_scale: [set]  Accelerometer full-scale selection.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_fs_xl_t: change the values of fs_xl in reg CTRL1_XL\n  *\n  */\nint32_t lsm6dsl_xl_full_scale_set(lsm6dsl_ctx_t *ctx, lsm6dsl_fs_xl_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL1_XL, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl1_xl.fs_xl = (uint8_t) val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL1_XL, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  xl_full_scale: [get]  Accelerometer full-scale selection.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_fs_xl_t: Get the values of fs_xl in reg CTRL1_XL\n  *\n  */\nint32_t lsm6dsl_xl_full_scale_get(lsm6dsl_ctx_t *ctx, lsm6dsl_fs_xl_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL1_XL, &reg.byte, 1);\n  switch (reg.ctrl1_xl.fs_xl) {\n    case LSM6DSL_2g:\n      *val = LSM6DSL_2g;\n      break;\n    case LSM6DSL_16g:\n      *val = LSM6DSL_16g;\n      break;\n    case LSM6DSL_4g:\n      *val = LSM6DSL_4g;\n      break;\n    case LSM6DSL_8g:\n      *val = LSM6DSL_8g;\n      break;\n    default:\n      *val = LSM6DSL_XL_FS_ND;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  xl_data_rate: [set]  Accelerometer data rate selection.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_odr_xl_t: change the values of odr_xl in reg CTRL1_XL\n  *\n  */\nint32_t lsm6dsl_xl_data_rate_set(lsm6dsl_ctx_t *ctx, lsm6dsl_odr_xl_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL1_XL, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl1_xl.odr_xl = (uint8_t) val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL1_XL, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  xl_data_rate: [get]  Accelerometer data rate selection.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_odr_xl_t: Get the values of odr_xl in reg CTRL1_XL\n  *\n  */\nint32_t lsm6dsl_xl_data_rate_get(lsm6dsl_ctx_t *ctx, lsm6dsl_odr_xl_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL1_XL, &reg.byte, 1);\n  switch (reg.ctrl1_xl.odr_xl) {\n    case LSM6DSL_XL_ODR_OFF:\n      *val = LSM6DSL_XL_ODR_OFF;\n      break;\n    case LSM6DSL_XL_ODR_12Hz5:\n      *val = LSM6DSL_XL_ODR_12Hz5;\n      break;\n    case LSM6DSL_XL_ODR_26Hz:\n      *val = LSM6DSL_XL_ODR_26Hz;\n      break;\n    case LSM6DSL_XL_ODR_52Hz:\n      *val = LSM6DSL_XL_ODR_52Hz;\n      break;\n    case LSM6DSL_XL_ODR_104Hz:\n      *val = LSM6DSL_XL_ODR_104Hz;\n      break;\n    case LSM6DSL_XL_ODR_208Hz:\n      *val = LSM6DSL_XL_ODR_208Hz;\n      break;\n    case LSM6DSL_XL_ODR_416Hz:\n      *val = LSM6DSL_XL_ODR_416Hz;\n      break;\n    case LSM6DSL_XL_ODR_833Hz:\n      *val = LSM6DSL_XL_ODR_833Hz;\n      break;\n    case LSM6DSL_XL_ODR_1k66Hz:\n      *val = LSM6DSL_XL_ODR_1k66Hz;\n      break;\n    case LSM6DSL_XL_ODR_3k33Hz:\n      *val = LSM6DSL_XL_ODR_3k33Hz;\n      break;\n    case LSM6DSL_XL_ODR_6k66Hz:\n      *val = LSM6DSL_XL_ODR_6k66Hz;\n      break;\n    case LSM6DSL_XL_ODR_1Hz6:\n      *val = LSM6DSL_XL_ODR_1Hz6;\n      break;\n    default:\n      *val = LSM6DSL_XL_ODR_ND;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  gy_full_scale: [set]  Gyroscope chain full-scale selection.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_fs_g_t: change the values of fs_g in reg CTRL2_G\n  *\n  */\nint32_t lsm6dsl_gy_full_scale_set(lsm6dsl_ctx_t *ctx, lsm6dsl_fs_g_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL2_G, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl2_g.fs_g = (uint8_t) val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL2_G, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  gy_full_scale: [get]  Gyroscope chain full-scale selection.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_fs_g_t: Get the values of fs_g in reg CTRL2_G\n  *\n  */\nint32_t lsm6dsl_gy_full_scale_get(lsm6dsl_ctx_t *ctx, lsm6dsl_fs_g_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL2_G, &reg.byte, 1);\n  switch (reg.ctrl2_g.fs_g) {\n    case LSM6DSL_250dps:\n      *val = LSM6DSL_250dps;\n      break;\n    case LSM6DSL_125dps:\n      *val = LSM6DSL_125dps;\n      break;\n    case LSM6DSL_500dps:\n      *val = LSM6DSL_500dps;\n      break;\n    case LSM6DSL_1000dps:\n      *val = LSM6DSL_1000dps;\n      break;\n    case LSM6DSL_2000dps:\n      *val = LSM6DSL_2000dps;\n      break;\n    default:\n      *val = LSM6DSL_GY_FS_ND;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  gy_data_rate: [set]  Gyroscope data rate selection.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_odr_g_t: change the values of odr_g in reg CTRL2_G\n  *\n  */\nint32_t lsm6dsl_gy_data_rate_set(lsm6dsl_ctx_t *ctx, lsm6dsl_odr_g_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL2_G, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl2_g.odr_g = (uint8_t) val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL2_G, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  gy_data_rate: [get]  Gyroscope data rate selection.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_odr_g_t: Get the values of odr_g in reg CTRL2_G\n  *\n  */\nint32_t lsm6dsl_gy_data_rate_get(lsm6dsl_ctx_t *ctx, lsm6dsl_odr_g_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL2_G, &reg.byte, 1);\n  switch (reg.ctrl2_g.odr_g) {\n    case LSM6DSL_GY_ODR_OFF:\n      *val = LSM6DSL_GY_ODR_OFF;\n      break;\n    case LSM6DSL_GY_ODR_12Hz5:\n      *val = LSM6DSL_GY_ODR_12Hz5;\n      break;\n    case LSM6DSL_GY_ODR_26Hz:\n      *val = LSM6DSL_GY_ODR_26Hz;\n      break;\n    case LSM6DSL_GY_ODR_52Hz:\n      *val = LSM6DSL_GY_ODR_52Hz;\n      break;\n    case LSM6DSL_GY_ODR_104Hz:\n      *val = LSM6DSL_GY_ODR_104Hz;\n      break;\n    case LSM6DSL_GY_ODR_208Hz:\n      *val = LSM6DSL_GY_ODR_208Hz;\n      break;\n    case LSM6DSL_GY_ODR_416Hz:\n      *val = LSM6DSL_GY_ODR_416Hz;\n      break;\n    case LSM6DSL_GY_ODR_833Hz:\n      *val = LSM6DSL_GY_ODR_833Hz;\n      break;\n    case LSM6DSL_GY_ODR_1k66Hz:\n      *val = LSM6DSL_GY_ODR_1k66Hz;\n      break;\n    case LSM6DSL_GY_ODR_3k33Hz:\n      *val = LSM6DSL_GY_ODR_3k33Hz;\n      break;\n    case LSM6DSL_GY_ODR_6k66Hz:\n      *val = LSM6DSL_GY_ODR_6k66Hz;\n      break;\n    default:\n      *val = LSM6DSL_GY_ODR_ND;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  block_data_update: [set] Blockdataupdate.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of bdu in reg CTRL3_C\n  *\n  */\nint32_t lsm6dsl_block_data_update_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL3_C, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl3_c.bdu = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL3_C, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  block_data_update: [get] Blockdataupdate.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of bdu in reg CTRL3_C\n  *\n  */\nint32_t lsm6dsl_block_data_update_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL3_C, &reg.byte, 1);\n  *val = reg.ctrl3_c.bdu;\n\n  return ret;\n}\n\n/**\n  * @brief  xl_offset_weight: [set] Weight of XL user offset bits of\n  *                                 registers X_OFS_USR(73h), Y_OFS_USR(74h),\n  *                                 Z_OFS_USR (75h)\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_usr_off_w_t: change the values of usr_off_w in reg CTRL6_C\n  *\n  */\nint32_t lsm6dsl_xl_offset_weight_set(lsm6dsl_ctx_t *ctx,\n                                     lsm6dsl_usr_off_w_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL6_C, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl6_c.usr_off_w = (uint8_t) val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL6_C, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  xl_offset_weight: [get] Weight of XL user offset bits of\n  *                                 registers X_OFS_USR(73h), Y_OFS_USR(74h),\n  *                                 Z_OFS_USR(75h)\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_usr_off_w_t: Get the values of usr_off_w in reg CTRL6_C\n  *\n  */\nint32_t lsm6dsl_xl_offset_weight_get(lsm6dsl_ctx_t *ctx,\n                                     lsm6dsl_usr_off_w_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL6_C, &reg.byte, 1);\n  switch (reg.ctrl6_c.usr_off_w) {\n    case LSM6DSL_LSb_1mg:\n      *val = LSM6DSL_LSb_1mg;\n      break;\n    case LSM6DSL_LSb_16mg:\n      *val = LSM6DSL_LSb_16mg;\n      break;\n    default:\n      *val = LSM6DSL_WEIGHT_ND;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  xl_power_mode: [set] High-performance operating mode\n  *                              for accelerometer\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_xl_hm_mode_t: change the values of xl_hm_mode\n  *                               in reg CTRL6_C\n  *\n  */\nint32_t lsm6dsl_xl_power_mode_set(lsm6dsl_ctx_t *ctx,\n                                  lsm6dsl_xl_hm_mode_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL6_C, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl6_c.xl_hm_mode = (uint8_t) val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL6_C, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  xl_power_mode: [get] High-performance operating mode\n  *                              for accelerometer\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_xl_hm_mode_t: Get the values of xl_hm_mode in reg CTRL6_C\n  *\n  */\nint32_t lsm6dsl_xl_power_mode_get(lsm6dsl_ctx_t *ctx,\n                                  lsm6dsl_xl_hm_mode_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL6_C, &reg.byte, 1);\n  switch (reg.ctrl6_c.xl_hm_mode) {\n    case LSM6DSL_XL_HIGH_PERFORMANCE:\n      *val = LSM6DSL_XL_HIGH_PERFORMANCE;\n      break;\n    case LSM6DSL_XL_NORMAL:\n      *val = LSM6DSL_XL_NORMAL;\n      break;\n    default:\n      *val = LSM6DSL_XL_PW_MODE_ND;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  rounding_on_status: [set] Source register rounding function\n  *                                   on WAKE_UP_SRC (1Bh), TAP_SRC (1Ch),\n  *                                   D6D_SRC (1Dh), STATUS_REG (1Eh) and\n  *                                   FUNC_SRC1 (53h) registers in the\n  *                                   primary interface\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_rounding_status_t: change the values of rounding_status\n  *                                    in reg CTRL7_G\n  *\n  */\nint32_t lsm6dsl_rounding_on_status_set(lsm6dsl_ctx_t *ctx,\n                                       lsm6dsl_rounding_status_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL7_G, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl7_g.rounding_status = (uint8_t) val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL7_G, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  rounding_on_status: [get] Source register rounding function\n  *                                   on WAKE_UP_SRC (1Bh), TAP_SRC (1Ch),\n  *                                   D6D_SRC (1Dh), STATUS_REG (1Eh) and\n  *                                   FUNC_SRC1 (53h) registers in the\n  *                                   primary interface\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_rounding_status_t: Get the values of rounding_status\n  *                                    in reg CTRL7_G\n  *\n  */\nint32_t lsm6dsl_rounding_on_status_get(lsm6dsl_ctx_t *ctx,\n                                       lsm6dsl_rounding_status_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL7_G, &reg.byte, 1);\n  switch (reg.ctrl7_g.rounding_status) {\n    case LSM6DSL_STAT_RND_DISABLE:\n      *val = LSM6DSL_STAT_RND_DISABLE;\n      break;\n    case LSM6DSL_STAT_RND_ENABLE:\n      *val = LSM6DSL_STAT_RND_ENABLE;\n      break;\n    default:\n      *val = LSM6DSL_STAT_RND_ND;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  gy_power_mode: [set] High-performance operating mode\n  *                              disable for gyroscope.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_g_hm_mode_t: change the values of g_hm_mode in reg CTRL7_G\n  *\n  */\nint32_t lsm6dsl_gy_power_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_g_hm_mode_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL7_G, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl7_g.g_hm_mode = (uint8_t) val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL7_G, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  gy_power_mode: [get] High-performance operating mode\n  *                              disable for gyroscope.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_g_hm_mode_t: Get the values of g_hm_mode in reg CTRL7_G\n  *\n  */\nint32_t lsm6dsl_gy_power_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_g_hm_mode_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL7_G, &reg.byte, 1);\n  switch (reg.ctrl7_g.g_hm_mode) {\n    case LSM6DSL_GY_HIGH_PERFORMANCE:\n      *val = LSM6DSL_GY_HIGH_PERFORMANCE;\n      break;\n    case LSM6DSL_GY_NORMAL:\n      *val = LSM6DSL_GY_NORMAL;\n      break;\n    default:\n      *val = LSM6DSL_GY_PW_MODE_ND;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  all_sources: [get] Read all the interrupt/status flag of\n  *                            the device.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_all_sources: WAKE_UP_SRC, TAP_SRC, D6D_SRC, STATUS_REG,\n  *                              FUNC_SRC1, FUNC_SRC2, WRIST_TILT_IA,\n  *                              A_WRIST_TILT_Mask\n  *\n  */\nint32_t lsm6dsl_all_sources_get(lsm6dsl_ctx_t *ctx, lsm6dsl_all_sources_t *val)\n{\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_WAKE_UP_SRC, &(val->byte[0]), 4);\n  if(ret == 0){\n    ret = lsm6dsl_read_reg(ctx, LSM6DSL_FUNC_SRC1, &(val->byte[4]), 3);\n    if(ret == 0){\n      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_B);\n      if(ret == 0){\n        ret = lsm6dsl_read_reg(ctx, LSM6DSL_A_WRIST_TILT_MASK,\n                                      &(val->byte[7]), 1);\n        if(ret == 0){\n          ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n        }\n      }\n    }\n  }\n  return ret;\n}\n\n/**\n  * @brief  status_reg: [get] The STATUS_REG register is read by the\n  *                           primary interface\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  status_reg_t: registers STATUS_REG\n  *\n  */\nint32_t lsm6dsl_status_reg_get(lsm6dsl_ctx_t *ctx, lsm6dsl_status_reg_t *val)\n{\n  return lsm6dsl_read_reg(ctx, LSM6DSL_STATUS_REG, (uint8_t*) val, 1);\n}\n\n/**\n  * @brief  xl_flag_data_ready: [get]  Accelerometer new data available.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of xlda in reg STATUS_REG\n  *\n  */\nint32_t lsm6dsl_xl_flag_data_ready_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_STATUS_REG, &reg.byte, 1);\n  *val = reg.status_reg.xlda;\n\n  return ret;\n}\n\n/**\n  * @brief  gy_flag_data_ready: [get]  Gyroscope new data available.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of gda in reg STATUS_REG\n  *\n  */\nint32_t lsm6dsl_gy_flag_data_ready_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_STATUS_REG, &reg.byte, 1);\n  *val = reg.status_reg.gda;\n\n  return ret;\n}\n\n/**\n  * @brief   temp_flag_data_ready: [get]  Temperature new data available.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of tda in reg STATUS_REG\n  *\n  */\nint32_t lsm6dsl_temp_flag_data_ready_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_STATUS_REG, &reg.byte, 1);\n  *val = reg.status_reg.tda;\n\n  return ret;\n}\n\n/**\n  * @brief  xl_usr_offset: [set] Accelerometer axis user offset correction\n  *                              expressed in twos complement, weight\n  *                              depends on USR_OFF_W in CTRL6_C.\n  *                              The value must be in the range [-127 127].\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that contains data to write\n  *\n  */\nint32_t lsm6dsl_xl_usr_offset_set(lsm6dsl_ctx_t *ctx, uint8_t *buff)\n{\n  return lsm6dsl_write_reg(ctx, LSM6DSL_X_OFS_USR, buff, 3);\n}\n\n/**\n  * @brief  xl_usr_offset: [get] Accelerometer axis user offset correction\n  *                              expressed in twos complement, weight\n  *                              depends on USR_OFF_W in CTRL6_C.\n  *                              The value must be in the range [-127 127].\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lsm6dsl_xl_usr_offset_get(lsm6dsl_ctx_t *ctx, uint8_t *buff)\n{\n  return lsm6dsl_read_reg(ctx, LSM6DSL_X_OFS_USR, buff, 3);\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  Timestamp\n  * @brief   This section groups all the functions that manage the\n  *          timestamp generation.\n  * @{\n  */\n\n/**\n  * @brief  timestamp: [set] Enable timestamp count. The count is saved in\n  *                          TIMESTAMP0_REG (40h), TIMESTAMP1_REG (41h)\n  *                          and TIMESTAMP2_REG (42h).\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of timer_en in reg CTRL10_C\n  *\n  */\nint32_t lsm6dsl_timestamp_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL10_C, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl10_c.timer_en = val;\n    if ( val != 0x00U) {\n      reg.ctrl10_c.func_en = val;\n      ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL10_C, &reg.byte, 1);\n    }\n  }\n  return ret;\n}\n\n/**\n  * @brief  timestamp: [get] Enable timestamp count. The count is saved\n  *                          in TIMESTAMP0_REG (40h), TIMESTAMP1_REG (41h)\n  *                          and TIMESTAMP2_REG (42h).\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of timer_en in reg CTRL10_C\n  *\n  */\nint32_t lsm6dsl_timestamp_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL10_C, &reg.byte, 1);\n  *val = reg.ctrl10_c.timer_en;\n\n  return ret;\n}\n\n/**\n  * @brief  timestamp_res: [set] Timestamp register resolution setting.\n  *                              Configuration of this bit affects\n  *                              TIMESTAMP0_REG(40h), TIMESTAMP1_REG(41h),\n  *                              TIMESTAMP2_REG(42h), STEP_TIMESTAMP_L(49h),\n  *                              STEP_TIMESTAMP_H(4Ah) and\n  *                              STEP_COUNT_DELTA(15h) registers.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_timer_hr_t: change the values of timer_hr in\n  *                             reg WAKE_UP_DUR\n  *\n  */\nint32_t lsm6dsl_timestamp_res_set(lsm6dsl_ctx_t *ctx, lsm6dsl_timer_hr_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_WAKE_UP_DUR, &reg.byte, 1);\n  if(ret == 0){\n    reg.wake_up_dur.timer_hr = (uint8_t) val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_WAKE_UP_DUR, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  timestamp_res: [get] Timestamp register resolution setting.\n  *                              Configuration of this bit affects\n  *                              TIMESTAMP0_REG(40h), TIMESTAMP1_REG(41h),\n  *                              TIMESTAMP2_REG(42h), STEP_TIMESTAMP_L(49h),\n  *                              STEP_TIMESTAMP_H(4Ah) and\n  *                              STEP_COUNT_DELTA(15h) registers.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_timer_hr_t: Get the values of timer_hr in reg WAKE_UP_DUR\n  *\n  */\nint32_t lsm6dsl_timestamp_res_get(lsm6dsl_ctx_t *ctx, lsm6dsl_timer_hr_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_WAKE_UP_DUR, &reg.byte, 1);\n  switch (reg.wake_up_dur.timer_hr) {\n    case LSM6DSL_LSB_6ms4:\n      *val = LSM6DSL_LSB_6ms4;\n      break;\n    case LSM6DSL_LSB_25us:\n      *val = LSM6DSL_LSB_25us;\n      break;\n    default:\n      *val = LSM6DSL_TS_RES_ND;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  Dataoutput\n  * @brief   This section groups all the data output functions.\n  * @{\n  */\n\n/**\n  * @brief  rounding_mode: [set] Circular burst-mode (rounding) read from\n  *                              output registers through the primary interface.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_rounding_t: change the values of rounding in reg CTRL5_C\n  *\n  */\nint32_t lsm6dsl_rounding_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_rounding_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL5_C, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl5_c.rounding = (uint8_t) val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL5_C, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  rounding_mode: [get] Circular burst-mode (rounding) read from\n  *                              output registers through the primary\n  *                              interface.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_rounding_t: Get the values of rounding in reg CTRL5_C\n  *\n  */\nint32_t lsm6dsl_rounding_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_rounding_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL5_C, &reg.byte, 1);\n  switch (reg.ctrl5_c.rounding) {\n    case LSM6DSL_ROUND_DISABLE:\n      *val = LSM6DSL_ROUND_DISABLE;\n      break;\n    case LSM6DSL_ROUND_XL:\n      *val = LSM6DSL_ROUND_XL;\n      break;\n    case LSM6DSL_ROUND_GY:\n      *val = LSM6DSL_ROUND_GY;\n      break;\n    case LSM6DSL_ROUND_GY_XL:\n      *val = LSM6DSL_ROUND_GY_XL;\n      break;\n    case LSM6DSL_ROUND_SH1_TO_SH6:\n      *val = LSM6DSL_ROUND_SH1_TO_SH6;\n      break;\n    case LSM6DSL_ROUND_XL_SH1_TO_SH6:\n      *val = LSM6DSL_ROUND_XL_SH1_TO_SH6;\n      break;\n    case LSM6DSL_ROUND_GY_XL_SH1_TO_SH12:\n      *val = LSM6DSL_ROUND_GY_XL_SH1_TO_SH12;\n      break;\n    case LSM6DSL_ROUND_GY_XL_SH1_TO_SH6:\n      *val = LSM6DSL_ROUND_GY_XL_SH1_TO_SH6;\n      break;\n    default:\n      *val = LSM6DSL_ROUND_OUT_ND;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  temperature_raw: [get] Temperature data output register (r).\n  *                                L and H registers together express a 16-bit\n  *                                word in twos complement.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lsm6dsl_temperature_raw_get(lsm6dsl_ctx_t *ctx, uint8_t *buff)\n{\n  return lsm6dsl_read_reg(ctx, LSM6DSL_OUT_TEMP_L, buff, 2);\n}\n\n/**\n  * @brief  angular_rate_raw: [get] Angular rate sensor. The value is\n  *                                 expressed as a 16-bit word in\n  *                                 twos complement.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lsm6dsl_angular_rate_raw_get(lsm6dsl_ctx_t *ctx, uint8_t *buff)\n{\n  return lsm6dsl_read_reg(ctx, LSM6DSL_OUTX_L_G, buff, 6);\n}\n\n/**\n  * @brief  acceleration_raw: [get] Linear acceleration output register.\n  *                                 The value is expressed as a 16-bit word\n  *                                 in twos complement.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lsm6dsl_acceleration_raw_get(lsm6dsl_ctx_t *ctx, uint8_t *buff)\n{\n  return lsm6dsl_read_reg(ctx, LSM6DSL_OUTX_L_XL, buff, 6);\n}\n\n/**\n  * @brief  mag_calibrated_raw: [get]  External magnetometer raw data\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lsm6dsl_mag_calibrated_raw_get(lsm6dsl_ctx_t *ctx, uint8_t *buff)\n{\n  return lsm6dsl_read_reg(ctx, LSM6DSL_OUT_MAG_RAW_X_L, buff, 6);\n}\n\n/**\n  * @brief   fifo_raw_data: [get]  read data in FIFO.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t *: data buffer to store FIFO data.\n  * @param  uint8_t : number of data to read from FIFO.\n  *\n  */\nint32_t lsm6dsl_fifo_raw_data_get(lsm6dsl_ctx_t *ctx, uint8_t *buffer,\n                                  uint8_t len)\n{\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_DATA_OUT_L, buffer, len);\n\n  return ret;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  common\n  * @brief   This section groups common usefull functions.\n  * @{\n  */\n\n/**\n  * @brief  mem_bank: [set] Enable access to the embedded\n  *                         functions/sensor hub configuration registers\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_func_cfg_en_t: change the values of func_cfg_en in\n  *                                reg FUNC_CFG_ACCESS\n  *\n  */\nint32_t lsm6dsl_mem_bank_set(lsm6dsl_ctx_t *ctx, lsm6dsl_func_cfg_en_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FUNC_CFG_ACCESS, &reg.byte, 1);\n  if(ret == 0){\n    reg.func_cfg_access.func_cfg_en = (uint8_t) val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_FUNC_CFG_ACCESS, &reg.byte, 1);\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  mem_bank: [get] Enable access to the embedded functions/sensor\n  *                         hub configuration registers\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_func_cfg_en_t: Get the values of func_cfg_en in\n  *                                reg FUNC_CFG_ACCESS\n  *\n  */\nint32_t lsm6dsl_mem_bank_get(lsm6dsl_ctx_t *ctx, lsm6dsl_func_cfg_en_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FUNC_CFG_ACCESS, &reg.byte, 1);\n  switch (reg.func_cfg_access.func_cfg_en) {\n    case LSM6DSL_USER_BANK:\n      *val = LSM6DSL_USER_BANK;\n      break;\n    case LSM6DSL_BANK_B:\n      *val = LSM6DSL_BANK_B;\n      break;\n    default:\n      *val = LSM6DSL_BANK_ND;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  data_ready_mode: [set]  data-ready pulsed / letched mode\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_drdy_pulsed_t: change the values of drdy_pulsed in\n  *                                reg DRDY_PULSE_CFG\n  *\n  */\nint32_t lsm6dsl_data_ready_mode_set(lsm6dsl_ctx_t *ctx,\n                                    lsm6dsl_drdy_pulsed_g_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_DRDY_PULSE_CFG_G, &reg.byte, 1);\n  if(ret == 0){\n    reg.drdy_pulse_cfg_g.drdy_pulsed = (uint8_t) val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_DRDY_PULSE_CFG_G, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  data_ready_mode: [get]  data-ready pulsed / letched mode\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_drdy_pulsed_t: Get the values of drdy_pulsed\n  *                                in reg DRDY_PULSE_CFG\n  *\n  */\nint32_t lsm6dsl_data_ready_mode_get(lsm6dsl_ctx_t *ctx,\n                                    lsm6dsl_drdy_pulsed_g_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_DRDY_PULSE_CFG_G, &reg.byte, 1);\n  switch (reg.drdy_pulse_cfg_g.drdy_pulsed) {\n    case LSM6DSL_DRDY_LATCHED:\n      *val = LSM6DSL_DRDY_LATCHED;\n      break;\n    case LSM6DSL_DRDY_PULSED:\n      *val = LSM6DSL_DRDY_PULSED;\n      break;\n    default:\n      *val = LSM6DSL_DRDY_ND;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  device_id: [get] DeviceWhoamI.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lsm6dsl_device_id_get(lsm6dsl_ctx_t *ctx, uint8_t *buff)\n{\n  return lsm6dsl_read_reg(ctx, LSM6DSL_WHO_AM_I, buff, 1);\n}\n\n/**\n  * @brief  reset: [set] Software reset. Restore the default\n  *                      values in user registers\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of sw_reset in reg CTRL3_C\n  *\n  */\nint32_t lsm6dsl_reset_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL3_C, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl3_c.sw_reset = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL3_C, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  reset: [get] Software reset. Restore the default\n  *                      values in user registers\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of sw_reset in reg CTRL3_C\n  *\n  */\nint32_t lsm6dsl_reset_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL3_C, &reg.byte, 1);\n  *val = reg.ctrl3_c.sw_reset;\n\n  return ret;\n}\n\n/**\n  * @brief  data_format: [set]  Big/Little Endian Data selection.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_ble_t: change the values of ble in reg CTRL3_C\n  *\n  */\nint32_t lsm6dsl_data_format_set(lsm6dsl_ctx_t *ctx, lsm6dsl_ble_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL3_C, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl3_c.ble = (uint8_t) val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL3_C, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  data_format: [get]  Big/Little Endian Data selection.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_ble_t: Get the values of ble in reg CTRL3_C\n  *\n  */\nint32_t lsm6dsl_data_format_get(lsm6dsl_ctx_t *ctx, lsm6dsl_ble_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL3_C, &reg.byte, 1);\n  switch (reg.ctrl3_c.ble) {\n    case LSM6DSL_LSB_AT_LOW_ADD:\n      *val = LSM6DSL_LSB_AT_LOW_ADD;\n      break;\n    case LSM6DSL_MSB_AT_LOW_ADD:\n      *val = LSM6DSL_MSB_AT_LOW_ADD;\n      break;\n    default:\n      *val = LSM6DSL_DATA_FMT_ND;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  auto_increment: [set] Register address automatically incremented\n  *                               during a multiple byte access with a\n  *                               serial interface.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of if_inc in reg CTRL3_C\n  *\n  */\nint32_t lsm6dsl_auto_increment_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL3_C, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl3_c.if_inc = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL3_C, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  auto_increment: [get] Register address automatically incremented\n  *                               during a multiple byte access with a\n  *                               serial interface.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of if_inc in reg CTRL3_C\n  *\n  */\nint32_t lsm6dsl_auto_increment_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL3_C, &reg.byte, 1);\n  *val = reg.ctrl3_c.if_inc;\n\n  return ret;\n}\n\n/**\n  * @brief  boot: [set] Reboot memory content. Reload the calibration\n  *                     parameters.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of boot in reg CTRL3_C\n  *\n  */\nint32_t lsm6dsl_boot_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL3_C, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl3_c.boot = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL3_C, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  boot: [get] Reboot memory content. Reload the calibration\n  *                     parameters.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of boot in reg CTRL3_C\n  *\n  */\nint32_t lsm6dsl_boot_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL3_C, &reg.byte, 1);\n  *val = reg.ctrl3_c.boot;\n\n  return ret;\n}\n\n/**\n  * @brief  xl_self_test: [set]  Linear acceleration sensor self-test enable.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_st_xl_t: change the values of st_xl in reg CTRL5_C\n  *\n  */\nint32_t lsm6dsl_xl_self_test_set(lsm6dsl_ctx_t *ctx, lsm6dsl_st_xl_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL5_C, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl5_c.st_xl = (uint8_t) val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL5_C, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  xl_self_test: [get]  Linear acceleration sensor self-test enable.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_st_xl_t: Get the values of st_xl in reg CTRL5_C\n  *\n  */\nint32_t lsm6dsl_xl_self_test_get(lsm6dsl_ctx_t *ctx, lsm6dsl_st_xl_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL5_C, &reg.byte, 1);\n  switch (reg.ctrl5_c.st_xl) {\n    case LSM6DSL_XL_ST_DISABLE:\n      *val = LSM6DSL_XL_ST_DISABLE;\n      break;\n    case LSM6DSL_XL_ST_POSITIVE:\n      *val = LSM6DSL_XL_ST_POSITIVE;\n      break;\n    case LSM6DSL_XL_ST_NEGATIVE:\n      *val = LSM6DSL_XL_ST_NEGATIVE;\n      break;\n    default:\n      *val = LSM6DSL_XL_ST_ND;\n      break;\n  }\n  return ret;\n}\n\n/**\n  * @brief  gy_self_test: [set]  Angular rate sensor self-test enable.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_st_g_t: change the values of st_g in reg CTRL5_C\n  *\n  */\nint32_t lsm6dsl_gy_self_test_set(lsm6dsl_ctx_t *ctx, lsm6dsl_st_g_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL5_C, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl5_c.st_g = (uint8_t) val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL5_C, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  gy_self_test: [get]  Angular rate sensor self-test enable.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_st_g_t: Get the values of st_g in reg CTRL5_C\n  *\n  */\nint32_t lsm6dsl_gy_self_test_get(lsm6dsl_ctx_t *ctx, lsm6dsl_st_g_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL5_C, &reg.byte, 1);\n  switch (reg.ctrl5_c.st_g) {\n    case LSM6DSL_GY_ST_DISABLE:\n      *val = LSM6DSL_GY_ST_DISABLE;\n      break;\n    case LSM6DSL_GY_ST_POSITIVE:\n      *val = LSM6DSL_GY_ST_POSITIVE;\n      break;\n    case LSM6DSL_GY_ST_NEGATIVE:\n      *val = LSM6DSL_GY_ST_NEGATIVE;\n      break;\n    default:\n      *val = LSM6DSL_GY_ST_ND;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  filters\n  * @brief   This section group all the functions concerning the filters\n  *          configuration that impact both accelerometer and gyro.\n  * @{\n  */\n\n/**\n  * @brief   filter_settling_mask: [set] Mask DRDY on pin (both XL & Gyro)\n  *                                      until filter settling ends\n  *                                      (XL and Gyro independently masked).\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of drdy_mask in reg CTRL4_C\n  *\n  */\nint32_t lsm6dsl_filter_settling_mask_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL4_C, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl4_c.drdy_mask = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL4_C, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief   filter_settling_mask: [get] Mask DRDY on pin (both XL & Gyro)\n  *                                      until filter settling ends\n  *                                      (XL and Gyro independently masked).\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of drdy_mask in reg CTRL4_C\n  *\n  */\nint32_t lsm6dsl_filter_settling_mask_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL4_C, &reg.byte, 1);\n  *val = reg.ctrl4_c.drdy_mask;\n\n  return ret;\n}\n\n/**\n  * @brief   xl_hp_path_internal: [set] HPF or SLOPE filter selection on\n  *                                     wake-up and Activity/Inactivity\n  *                                     functions.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_slope_fds_t: change the values of slope_fds in reg TAP_CFG\n  *\n  */\nint32_t lsm6dsl_xl_hp_path_internal_set(lsm6dsl_ctx_t *ctx,\n                                        lsm6dsl_slope_fds_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_CFG, &reg.byte, 1);\n  if(ret == 0){\n    reg.tap_cfg.slope_fds = (uint8_t) val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_TAP_CFG, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief   xl_hp_path_internal: [get] HPF or SLOPE filter selection on\n  *                                     wake-up and Activity/Inactivity\n  *                                     functions.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_slope_fds_t: Get the values of slope_fds in reg TAP_CFG\n  *\n  */\nint32_t lsm6dsl_xl_hp_path_internal_get(lsm6dsl_ctx_t *ctx,\n                                        lsm6dsl_slope_fds_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_CFG, &reg.byte, 1);\n  switch (reg.tap_cfg.slope_fds) {\n    case LSM6DSL_USE_SLOPE:\n      *val = LSM6DSL_USE_SLOPE;\n      break;\n    case LSM6DSL_USE_HPF:\n      *val = LSM6DSL_USE_HPF;\n      break;\n    default:\n      *val = LSM6DSL_HP_PATH_ND;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup   accelerometer_filters\n  * @brief   This section group all the functions concerning the filters\n  *          configuration that impact accelerometer in every mode.\n  * @{\n  */\n\n/**\n  * @brief  xl_filter_analog: [set] Accelerometer analog chain bandwidth\n  *                                 selection (only for accelerometer\n  *                                 ODR  1.67 kHz).\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_bw0_xl_t: change the values of bw0_xl in reg CTRL1_XL\n  *\n  */\nint32_t lsm6dsl_xl_filter_analog_set(lsm6dsl_ctx_t *ctx, lsm6dsl_bw0_xl_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL1_XL, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl1_xl.bw0_xl = (uint8_t) val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL1_XL, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  xl_filter_analog: [get] Accelerometer analog chain bandwidth\n  *                                 selection (only for accelerometer\n  *                                 ODR  1.67 kHz).\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_bw0_xl_t: Get the values of bw0_xl in reg CTRL1_XL\n  *\n  */\nint32_t lsm6dsl_xl_filter_analog_get(lsm6dsl_ctx_t *ctx,\n                                     lsm6dsl_bw0_xl_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL1_XL, &reg.byte, 1);\n  switch (reg.ctrl1_xl.bw0_xl) {\n    case LSM6DSL_XL_ANA_BW_1k5Hz:\n      *val = LSM6DSL_XL_ANA_BW_1k5Hz;\n      break;\n    case LSM6DSL_XL_ANA_BW_400Hz:\n      *val = LSM6DSL_XL_ANA_BW_400Hz;\n      break;\n    default:\n      *val = LSM6DSL_XL_ANA_BW_ND;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup   accelerometer_filters\n  * @brief   This section group all the functions concerning the filters\n  *          configuration that impact accelerometer.\n  * @{\n  */\n\n/**\n  * @brief  xl_lp1_bandwidth: [set] Accelerometer digital LPF (LPF1)\n  *                                 bandwidth selection LPF2 is not used.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_lpf1_bw_sel_t: change the values of lpf1_bw_sel in\n  *                                reg CTRL1_XL\n  *\n  */\nint32_t lsm6dsl_xl_lp1_bandwidth_set(lsm6dsl_ctx_t *ctx,\n                                     lsm6dsl_lpf1_bw_sel_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL1_XL, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl1_xl.lpf1_bw_sel = (uint8_t) val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL1_XL, &reg.byte, 1);\n    if(ret == 0){\n      ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL8_XL, &reg.byte, 1);\n      if(ret == 0){\n        reg.ctrl8_xl.lpf2_xl_en = 0;\n        reg.ctrl8_xl.hp_slope_xl_en = 0;\n        ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL8_XL, &reg.byte, 1);\n      }\n    }\n  }\n  return ret;\n}\n\n/**\n  * @brief  xl_lp1_bandwidth: [get] Accelerometer digital LPF (LPF1)\n  *                                 bandwidth selection LPF2 is not used.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_lpf1_bw_sel_t: Get the values of lpf1_bw_sel in\n  *                                reg CTRL1_XL\n  *\n  */\nint32_t lsm6dsl_xl_lp1_bandwidth_get(lsm6dsl_ctx_t *ctx,\n                                     lsm6dsl_lpf1_bw_sel_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL8_XL, &reg.byte, 1);\n  if(ret == 0){\n    if ((reg.ctrl8_xl.lpf2_xl_en != 0x00U) ||\n        (reg.ctrl8_xl.hp_slope_xl_en != 0x00U)){\n      *val = LSM6DSL_XL_LP1_NA;\n    }\n    else{\n      ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL1_XL, &reg.byte, 1);\n      switch ( reg.ctrl1_xl.lpf1_bw_sel) {\n        case LSM6DSL_XL_LP1_ODR_DIV_2:\n          *val = LSM6DSL_XL_LP1_ODR_DIV_2;\n          break;\n        case LSM6DSL_XL_LP1_ODR_DIV_4:\n          *val = LSM6DSL_XL_LP1_ODR_DIV_4;\n          break;\n        default:\n          *val = LSM6DSL_XL_LP1_NA;\n          break;\n      }\n    }\n  }\n  return ret;\n}\n\n/**\n  * @brief  xl_lp2_bandwidth: [set] LPF2onoutputs\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_input_composite_t: change the values of\n  *                                    input_composite in reg CTRL8_XL\n  *\n  */\nint32_t lsm6dsl_xl_lp2_bandwidth_set(lsm6dsl_ctx_t *ctx,\n                                     lsm6dsl_input_composite_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL8_XL, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl8_xl.input_composite = ( (uint8_t) val & 0x10U ) >> 4;\n    reg.ctrl8_xl.hpcf_xl = (uint8_t) val & 0x03U;\n    reg.ctrl8_xl.lpf2_xl_en = 1;\n    reg.ctrl8_xl.hp_slope_xl_en = 0;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL8_XL, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  xl_lp2_bandwidth: [get] LPF2onoutputs\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_input_composite_t: Get the values of\n  *                                    input_composite in reg CTRL8_XL\n  *\n  */\nint32_t lsm6dsl_xl_lp2_bandwidth_get(lsm6dsl_ctx_t *ctx,\n                                     lsm6dsl_input_composite_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL8_XL, &reg.byte, 1);\n  if(ret == 0){\n    if ((reg.ctrl8_xl.lpf2_xl_en == 0x00U) ||\n        (reg.ctrl8_xl.hp_slope_xl_en != 0x00U)){\n      *val = LSM6DSL_XL_LP_NA;\n    }\n    else{\n      switch ((reg.ctrl8_xl.input_composite << 4) + reg.ctrl8_xl.hpcf_xl) {\n        case LSM6DSL_XL_LOW_LAT_LP_ODR_DIV_50:\n          *val = LSM6DSL_XL_LOW_LAT_LP_ODR_DIV_50;\n          break;\n        case LSM6DSL_XL_LOW_LAT_LP_ODR_DIV_100:\n          *val = LSM6DSL_XL_LOW_LAT_LP_ODR_DIV_100;\n          break;\n        case LSM6DSL_XL_LOW_LAT_LP_ODR_DIV_9:\n          *val = LSM6DSL_XL_LOW_LAT_LP_ODR_DIV_9;\n          break;\n        case LSM6DSL_XL_LOW_LAT_LP_ODR_DIV_400:\n          *val = LSM6DSL_XL_LOW_LAT_LP_ODR_DIV_400;\n          break;\n        case LSM6DSL_XL_LOW_NOISE_LP_ODR_DIV_50:\n          *val = LSM6DSL_XL_LOW_NOISE_LP_ODR_DIV_50;\n          break;\n        case LSM6DSL_XL_LOW_NOISE_LP_ODR_DIV_100:\n          *val = LSM6DSL_XL_LOW_NOISE_LP_ODR_DIV_100;\n          break;\n        case LSM6DSL_XL_LOW_NOISE_LP_ODR_DIV_9:\n          *val = LSM6DSL_XL_LOW_NOISE_LP_ODR_DIV_9;\n          break;\n        case LSM6DSL_XL_LOW_NOISE_LP_ODR_DIV_400:\n          *val = LSM6DSL_XL_LOW_NOISE_LP_ODR_DIV_400;\n          break;\n        default:\n          *val = LSM6DSL_XL_LP_NA;\n          break;\n      }\n    }\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  xl_reference_mode: [set]  Enable HP filter reference mode.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of hp_ref_mode in reg CTRL8_XL\n  *\n  */\nint32_t lsm6dsl_xl_reference_mode_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL8_XL, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl8_xl.hp_ref_mode = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL8_XL, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  xl_reference_mode: [get]  Enable HP filter reference mode.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of hp_ref_mode in reg CTRL8_XL\n  *\n  */\nint32_t lsm6dsl_xl_reference_mode_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL8_XL, &reg.byte, 1);\n  *val = reg.ctrl8_xl.hp_ref_mode;\n\n  return ret;\n}\n\n/**\n  * @brief  xl_hp_bandwidth: [set]  High pass/Slope on outputs.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_hpcf_xl_t: change the values of hpcf_xl in reg CTRL8_XL\n  *\n  */\nint32_t lsm6dsl_xl_hp_bandwidth_set(lsm6dsl_ctx_t *ctx, lsm6dsl_hpcf_xl_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL8_XL, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl8_xl.input_composite = 0;\n    reg.ctrl8_xl.hpcf_xl = (uint8_t)val & 0x03U;\n    reg.ctrl8_xl.hp_slope_xl_en = 1;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL8_XL, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  xl_hp_bandwidth: [get]  High pass/Slope on outputs.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_hpcf_xl_t: Get the values of hpcf_xl in reg CTRL8_XL\n  *\n  */\nint32_t lsm6dsl_xl_hp_bandwidth_get(lsm6dsl_ctx_t *ctx, lsm6dsl_hpcf_xl_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL8_XL, &reg.byte, 1);\n  if (reg.ctrl8_xl.hp_slope_xl_en == 0x00U){\n    *val = LSM6DSL_XL_HP_NA;\n  }\n  switch (reg.ctrl8_xl.hpcf_xl) {\n    case LSM6DSL_XL_HP_ODR_DIV_4:\n      *val = LSM6DSL_XL_HP_ODR_DIV_4;\n      break;\n    case LSM6DSL_XL_HP_ODR_DIV_100:\n      *val = LSM6DSL_XL_HP_ODR_DIV_100;\n      break;\n    case LSM6DSL_XL_HP_ODR_DIV_9:\n      *val = LSM6DSL_XL_HP_ODR_DIV_9;\n      break;\n    case LSM6DSL_XL_HP_ODR_DIV_400:\n      *val = LSM6DSL_XL_HP_ODR_DIV_400;\n      break;\n    default:\n      *val = LSM6DSL_XL_HP_NA;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup   gyroscope_filters\n  * @brief   This section group all the functions concerning the filters\n  *          configuration that impact gyroscope.\n  * @{\n  */\n\n/**\n  * @brief  gy_band_pass: [set] Gyroscope low pass path bandwidth.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_lpf1_sel_g_t: gyroscope filtering chain configuration.\n  *\n  */\nint32_t lsm6dsl_gy_band_pass_set(lsm6dsl_ctx_t *ctx, lsm6dsl_lpf1_sel_g_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL7_G, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl7_g.hpm_g  =  ( (uint8_t)val & 0x30U ) >> 4;\n    reg.ctrl7_g.hp_en_g = ( (uint8_t)val & 0x80U ) >> 7;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL7_G, &reg.byte, 1);\n    if(ret == 0){\n      ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL6_C, &reg.byte, 1);\n      if(ret == 0){\n        reg.ctrl6_c.ftype = (uint8_t)val & 0x03U;\n        ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL6_C, &reg.byte, 1);\n        if(ret == 0){\n          ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL4_C, &reg.byte, 1);\n          if(ret == 0){\n            reg.ctrl4_c.lpf1_sel_g = ( (uint8_t)val & 0x08U ) >> 3;\n            ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL4_C, &reg.byte, 1);\n          }\n        }\n      }\n    }\n  }\n  return ret;\n}\n\n/**\n  * @brief  gy_band_pass: [get] Gyroscope low pass path bandwidth.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_lpf1_sel_g_t: gyroscope filtering chain\n  *\n  */\nint32_t lsm6dsl_gy_band_pass_get(lsm6dsl_ctx_t *ctx, lsm6dsl_lpf1_sel_g_t *val)\n{\n  lsm6dsl_reg_t reg[3];\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL6_C, &reg[0].byte, 1);\n  if(ret == 0){\n    ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL4_C, &reg[1].byte, 1);\n    if(ret == 0){\n      ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL7_G, &reg[2].byte, 1);\n\n      switch ( ( reg[2].ctrl7_g.hp_en_g << 7 ) + ( reg[2].ctrl7_g.hpm_g << 4 ) +\n               ( reg[1].ctrl4_c.lpf1_sel_g << 3) + reg[0].ctrl6_c.ftype ) {\n        case LSM6DSL_HP_16mHz_LP2:\n          *val = LSM6DSL_HP_16mHz_LP2;\n          break;\n        case LSM6DSL_HP_65mHz_LP2:\n          *val = LSM6DSL_HP_65mHz_LP2;\n          break;\n        case LSM6DSL_HP_260mHz_LP2:\n          *val = LSM6DSL_HP_260mHz_LP2;\n          break;\n        case LSM6DSL_HP_1Hz04_LP2:\n          *val = LSM6DSL_HP_1Hz04_LP2;\n          break;\n        case LSM6DSL_HP_DISABLE_LP1_LIGHT:\n          *val = LSM6DSL_HP_DISABLE_LP1_LIGHT;\n          break;\n        case LSM6DSL_HP_DISABLE_LP1_NORMAL:\n          *val = LSM6DSL_HP_DISABLE_LP1_NORMAL;\n          break;\n        case LSM6DSL_HP_DISABLE_LP_STRONG:\n          *val = LSM6DSL_HP_DISABLE_LP_STRONG;\n          break;\n        case LSM6DSL_HP_DISABLE_LP1_AGGRESSIVE:\n          *val = LSM6DSL_HP_DISABLE_LP1_AGGRESSIVE;\n          break;\n        case LSM6DSL_HP_16mHz_LP1_LIGHT:\n          *val = LSM6DSL_HP_16mHz_LP1_LIGHT;\n          break;\n        case LSM6DSL_HP_65mHz_LP1_NORMAL:\n          *val = LSM6DSL_HP_65mHz_LP1_NORMAL;\n          break;\n        case LSM6DSL_HP_260mHz_LP1_STRONG:\n          *val = LSM6DSL_HP_260mHz_LP1_STRONG;\n          break;\n        case LSM6DSL_HP_1Hz04_LP1_AGGRESSIVE:\n          *val = LSM6DSL_HP_1Hz04_LP1_AGGRESSIVE;\n          break;\n        default:\n          *val = LSM6DSL_HP_GY_BAND_NA;\n          break;\n      }\n    }\n  }\n\n  return ret;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup   serial_interface\n  * @brief   This section groups all the functions concerning serial\n  *          interface management\n  * @{\n  */\n\n/**\n  * @brief  spi_mode: [set]  SPI Serial Interface Mode selection.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_sim_t: change the values of sim in reg CTRL3_C\n  *\n  */\nint32_t lsm6dsl_spi_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_sim_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL3_C, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl3_c.sim = (uint8_t) val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL3_C, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  spi_mode: [get]  SPI Serial Interface Mode selection.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_sim_t: Get the values of sim in reg CTRL3_C\n  *\n  */\nint32_t lsm6dsl_spi_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_sim_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL3_C, &reg.byte, 1);\n  switch (reg.ctrl3_c.sim) {\n    case LSM6DSL_SPI_4_WIRE:\n      *val = LSM6DSL_SPI_4_WIRE;\n      break;\n    case LSM6DSL_SPI_3_WIRE:\n      *val = LSM6DSL_SPI_3_WIRE;\n      break;\n    default:\n      *val = LSM6DSL_SPI_MODE_ND;\n      break;\n  }\n  return ret;\n}\n\n/**\n  * @brief  i2c_interface: [set]  Disable / Enable I2C interface.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_i2c_disable_t: change the values of i2c_disable in\n  *                                reg CTRL4_C\n  *\n  */\nint32_t lsm6dsl_i2c_interface_set(lsm6dsl_ctx_t *ctx,\n                                  lsm6dsl_i2c_disable_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL4_C, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl4_c.i2c_disable = (uint8_t)val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL4_C, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  i2c_interface: [get]  Disable / Enable I2C interface.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_i2c_disable_t: Get the values of i2c_disable in\n  *                                reg CTRL4_C\n  *\n  */\nint32_t lsm6dsl_i2c_interface_get(lsm6dsl_ctx_t *ctx,\n                                  lsm6dsl_i2c_disable_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL4_C, &reg.byte, 1);\n  switch (reg.ctrl4_c.i2c_disable) {\n    case LSM6DSL_I2C_ENABLE:\n      *val = LSM6DSL_I2C_ENABLE;\n      break;\n    case LSM6DSL_I2C_DISABLE:\n      *val = LSM6DSL_I2C_DISABLE;\n      break;\n    default:\n      *val = LSM6DSL_I2C_MODE_ND;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  interrupt_pins\n  * @brief   This section groups all the functions that manage interrup pins\n  * @{\n  */\n\n/**\n  * @brief  pin_int1_route: [set] Select the signal that need to route on\n  *                               int1 pad\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_int1_ctrl: configure INT1_CTRL, MD1_CFG,\n  *                            CTRL4_C(den_drdy_int1),\n  *                            MASTER_CONFIG(drdy_on_int1)\n  *\n  */\nint32_t lsm6dsl_pin_int1_route_set(lsm6dsl_ctx_t *ctx,\n                                   lsm6dsl_int1_route_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_INT1_CTRL, &reg.byte, 1);\n  if(ret == 0){\n    reg.int1_ctrl.int1_drdy_xl        = val.int1_drdy_xl;\n    reg.int1_ctrl.int1_drdy_g         = val.int1_drdy_g;\n    reg.int1_ctrl.int1_boot           = val.int1_boot;\n    reg.int1_ctrl.int1_fth            = val.int1_fth;\n    reg.int1_ctrl.int1_fifo_ovr       = val.int1_fifo_ovr;\n    reg.int1_ctrl.int1_full_flag      = val.int1_full_flag;\n    reg.int1_ctrl.int1_sign_mot       = val.int1_sign_mot;\n    reg.int1_ctrl.int1_step_detector  = val.int1_step_detector;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_INT1_CTRL, &reg.byte, 1);\n    if(ret == 0){\n      ret = lsm6dsl_read_reg(ctx, LSM6DSL_MD1_CFG, &reg.byte, 1);\n      if(ret == 0){\n        reg.md1_cfg.int1_timer           = val.int1_timer;\n        reg.md1_cfg.int1_tilt            = val.int1_tilt;\n        reg.md1_cfg.int1_6d              = val.int1_6d;\n        reg.md1_cfg.int1_double_tap      = val.int1_double_tap;\n        reg.md1_cfg.int1_ff              = val.int1_ff;\n        reg.md1_cfg.int1_wu              = val.int1_wu;\n        reg.md1_cfg.int1_single_tap      = val.int1_single_tap;\n        reg.md1_cfg.int1_inact_state     = val.int1_inact_state;\n        ret = lsm6dsl_write_reg(ctx, LSM6DSL_MD1_CFG, &reg.byte, 1);\n        if(ret == 0){\n          ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL4_C, &reg.byte, 1);\n          if(ret == 0){\n            reg.ctrl4_c.den_drdy_int1 = val.den_drdy_int1;\n            ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL4_C, &reg.byte, 1);\n            if(ret == 0){\n              ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CONFIG,\n                                     &reg.byte, 1);\n              if(ret == 0){\n                reg.master_config.drdy_on_int1   = val.den_drdy_int1;\n                ret = lsm6dsl_write_reg(ctx, LSM6DSL_MASTER_CONFIG,\n                                        &reg.byte, 1);\n                if(ret == 0){\n                  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_CFG, &reg.byte, 1);\n                  if ((val.int1_6d != 0x00U) ||\n                      (val.int1_ff != 0x00U) ||\n                      (val.int1_wu != 0x00U) ||\n                      (val.int1_single_tap != 0x00U) ||\n                      (val.int1_double_tap != 0x00U) ||\n                      (val.int1_inact_state != 0x00U) ){\n                    reg.tap_cfg.interrupts_enable = PROPERTY_ENABLE;\n                  }\n                  else{\n                    reg.tap_cfg.interrupts_enable = PROPERTY_DISABLE;\n                  }\n                  ret = lsm6dsl_write_reg(ctx, LSM6DSL_TAP_CFG, &reg.byte, 1);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  pin_int1_route: [get] Select the signal that need to route on\n  *                               int1 pad\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_int1_route_t: read INT1_CTRL, MD1_CFG,\n  *                               CTRL4_C(den_drdy_int1),\n  *                               MASTER_CONFIG(drdy_on_int1)\n  *\n  */\nint32_t lsm6dsl_pin_int1_route_get(lsm6dsl_ctx_t *ctx,\n                                   lsm6dsl_int1_route_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_INT1_CTRL, &reg.byte, 1);\n  if(ret == 0){\n    val->int1_drdy_xl       = reg.int1_ctrl.int1_drdy_xl;\n    val->int1_drdy_g        = reg.int1_ctrl.int1_drdy_g;\n    val->int1_boot          = reg.int1_ctrl.int1_boot;\n    val->int1_fth           = reg.int1_ctrl.int1_fth;\n    val->int1_fifo_ovr      = reg.int1_ctrl.int1_fifo_ovr;\n    val->int1_full_flag     = reg.int1_ctrl.int1_full_flag;\n    val->int1_sign_mot      = reg.int1_ctrl.int1_sign_mot;\n    val->int1_step_detector = reg.int1_ctrl.int1_step_detector ;\n\n    ret = lsm6dsl_read_reg(ctx, LSM6DSL_MD1_CFG, &reg.byte, 1);\n    if(ret == 0){\n    val->int1_timer       = reg.md1_cfg.int1_timer;\n    val->int1_tilt        = reg.md1_cfg.int1_tilt;\n    val->int1_6d          = reg.md1_cfg.int1_6d;\n    val->int1_double_tap  = reg.md1_cfg.int1_double_tap;\n    val->int1_ff          = reg.md1_cfg.int1_ff;\n    val->int1_wu          = reg.md1_cfg.int1_wu;\n    val->int1_single_tap  = reg.md1_cfg.int1_single_tap;\n    val->int1_inact_state = reg.md1_cfg.int1_inact_state;\n\n    ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL4_C, &reg.byte, 1);\n      if(ret == 0){\n        val->den_drdy_int1 = reg.ctrl4_c.den_drdy_int1;\n        ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CONFIG, &reg.byte, 1);\n        val->den_drdy_int1 = reg.master_config.drdy_on_int1;\n      }\n    }\n  }\n  return ret;\n}\n\n/**\n  * @brief  pin_int2_route: [set] Select the signal that need to route on\n  *                               int2 pad\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_int2_route_t: INT2_CTRL, DRDY_PULSE_CFG(int2_wrist_tilt),\n  *                               MD2_CFG\n  *\n  */\nint32_t lsm6dsl_pin_int2_route_set(lsm6dsl_ctx_t *ctx,\n                                   lsm6dsl_int2_route_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_INT2_CTRL, &reg.byte, 1);\n  if(ret == 0){\n    reg.int2_ctrl.int2_drdy_xl        = val.int2_drdy_xl;\n    reg.int2_ctrl.int2_drdy_g         = val.int2_drdy_g;\n    reg.int2_ctrl.int2_drdy_temp      = val.int2_drdy_temp;\n    reg.int2_ctrl.int2_fth            = val.int2_fth;\n    reg.int2_ctrl.int2_fifo_ovr       = val.int2_fifo_ovr;\n    reg.int2_ctrl.int2_full_flag      = val.int2_full_flag;\n    reg.int2_ctrl.int2_step_count_ov  = val.int2_step_count_ov;\n    reg.int2_ctrl.int2_step_delta     = val.int2_step_delta;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_INT2_CTRL, &reg.byte, 1);\n    if(ret == 0){\n      ret = lsm6dsl_read_reg(ctx, LSM6DSL_MD2_CFG, &reg.byte, 1);\n      if(ret == 0){\n        reg.md2_cfg.int2_iron              = val.int2_iron;\n        reg.md2_cfg.int2_tilt              = val.int2_tilt;\n        reg.md2_cfg.int2_6d                = val.int2_6d;\n        reg.md2_cfg.int2_double_tap        = val.int2_double_tap;\n        reg.md2_cfg.int2_ff                = val.int2_ff;\n        reg.md2_cfg.int2_wu                = val.int2_wu;\n        reg.md2_cfg.int2_single_tap        = val.int2_single_tap;\n        reg.md2_cfg.int2_inact_state       = val.int2_inact_state;\n        ret = lsm6dsl_write_reg(ctx, LSM6DSL_MD2_CFG, &reg.byte, 1);\n        if(ret == 0){\n          ret = lsm6dsl_read_reg(ctx, LSM6DSL_DRDY_PULSE_CFG_G,\n                                 &reg.byte, 1);\n          if(ret == 0){\n            reg.drdy_pulse_cfg_g.int2_wrist_tilt = val.int2_wrist_tilt;\n            ret = lsm6dsl_write_reg(ctx, LSM6DSL_DRDY_PULSE_CFG_G,\n                                    &reg.byte, 1);\n            if(ret == 0){\n              ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_CFG, &reg.byte, 1);\n              if(ret == 0){\n                if ( (val.int2_6d != 0x00U) ||\n                     (val.int2_ff != 0x00U) ||\n                     (val.int2_wu != 0x00U) ||\n                     (val.int2_single_tap != 0x00U) ||\n                     (val.int2_double_tap != 0x00U) ||\n                     (val.int2_inact_state!= 0x00U) ){\n                  reg.tap_cfg.interrupts_enable = PROPERTY_ENABLE;\n                }\n                else{\n                  reg.tap_cfg.interrupts_enable = PROPERTY_DISABLE;\n                }\n                ret = lsm6dsl_write_reg(ctx, LSM6DSL_TAP_CFG, &reg.byte, 1);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  pin_int2_route: [get] Select the signal that need to route on\n  *                               int2 pad\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_int2_route_t: INT2_CTRL, DRDY_PULSE_CFG(int2_wrist_tilt),\n  *                               MD2_CFG\n  *\n  */\nint32_t lsm6dsl_pin_int2_route_get(lsm6dsl_ctx_t *ctx,\n                                   lsm6dsl_int2_route_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_INT2_CTRL, &reg.byte, 1);\n  if(ret == 0){\n    val->int2_drdy_xl         = reg.int2_ctrl.int2_drdy_xl;\n    val->int2_drdy_g          = reg.int2_ctrl.int2_drdy_g;\n    val->int2_drdy_temp       = reg.int2_ctrl.int2_drdy_temp;\n    val->int2_fth             = reg.int2_ctrl.int2_fth;\n    val->int2_fifo_ovr        = reg.int2_ctrl.int2_fifo_ovr;\n    val->int2_full_flag       = reg.int2_ctrl.int2_full_flag;\n    val->int2_step_count_ov   = reg.int2_ctrl.int2_step_count_ov;\n    val->int2_step_delta      = reg.int2_ctrl.int2_step_delta;\n\n    ret = lsm6dsl_read_reg(ctx, LSM6DSL_MD2_CFG, &reg.byte, 1);\n    if(ret == 0){\n      val->int2_iron           = reg.md2_cfg.int2_iron;\n      val->int2_tilt           = reg.md2_cfg.int2_tilt;\n      val->int2_6d             = reg.md2_cfg.int2_6d;\n      val->int2_double_tap     = reg.md2_cfg.int2_double_tap;\n      val->int2_ff             = reg.md2_cfg.int2_ff;\n      val->int2_wu             = reg.md2_cfg.int2_wu;\n      val->int2_single_tap     = reg.md2_cfg.int2_single_tap;\n      val->int2_inact_state    = reg.md2_cfg.int2_inact_state;\n\n      ret = lsm6dsl_read_reg(ctx, LSM6DSL_DRDY_PULSE_CFG_G, &reg.byte, 1);\n      val->int2_wrist_tilt = reg.drdy_pulse_cfg_g.int2_wrist_tilt;\n    }\n  }\n  return ret;\n}\n\n/**\n  * @brief  pin_mode: [set]  Push-pull/open drain selection on interrupt pads.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_pp_od_t: change the values of pp_od in reg CTRL3_C\n  *\n  */\nint32_t lsm6dsl_pin_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_pp_od_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL3_C, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl3_c.pp_od = (uint8_t) val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL3_C, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  pin_mode: [get]  Push-pull/open drain selection on interrupt pads.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_pp_od_t: Get the values of pp_od in reg CTRL3_C\n  *\n  */\nint32_t lsm6dsl_pin_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_pp_od_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL3_C, &reg.byte, 1);\n  switch (reg.ctrl3_c.pp_od) {\n    case LSM6DSL_PUSH_PULL:\n      *val = LSM6DSL_PUSH_PULL;\n      break;\n    case LSM6DSL_OPEN_DRAIN:\n      *val = LSM6DSL_OPEN_DRAIN;\n      break;\n    default:\n      *val = LSM6DSL_PIN_MODE_ND;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  pin_polarity: [set]  Interrupt active-high/low.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_h_lactive_t: change the values of h_lactive in reg CTRL3_C\n  *\n  */\nint32_t lsm6dsl_pin_polarity_set(lsm6dsl_ctx_t *ctx, lsm6dsl_h_lactive_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL3_C, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl3_c.h_lactive = (uint8_t) val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL3_C, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  pin_polarity: [get]  Interrupt active-high/low.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_h_lactive_t: Get the values of h_lactive in reg CTRL3_C\n  *\n  */\nint32_t lsm6dsl_pin_polarity_get(lsm6dsl_ctx_t *ctx, lsm6dsl_h_lactive_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL3_C, &reg.byte, 1);\n  switch (reg.ctrl3_c.h_lactive) {\n    case LSM6DSL_ACTIVE_HIGH:\n      *val = LSM6DSL_ACTIVE_HIGH;\n      break;\n    case LSM6DSL_ACTIVE_LOW:\n      *val = LSM6DSL_ACTIVE_LOW;\n      break;\n    default:\n      *val = LSM6DSL_POLARITY_ND;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  all_on_int1: [set] All interrupt signals become available on\n  *                            INT1 pin.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of int2_on_int1 in reg CTRL4_C\n  *\n  */\nint32_t lsm6dsl_all_on_int1_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL4_C, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl4_c.int2_on_int1 = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL4_C, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  all_on_int1: [get] All interrupt signals become available on\n  *                            INT1 pin.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of int2_on_int1 in reg CTRL4_C\n  *\n  */\nint32_t lsm6dsl_all_on_int1_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL4_C, &reg.byte, 1);\n  *val = reg.ctrl4_c.int2_on_int1;\n\n  return ret;\n}\n\n/**\n  * @brief  int_notification: [set]  Latched/pulsed interrupt.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_lir_t: change the values of lir in reg TAP_CFG\n  *\n  */\nint32_t lsm6dsl_int_notification_set(lsm6dsl_ctx_t *ctx, lsm6dsl_lir_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_CFG, &reg.byte, 1);\n  if(ret == 0){\n    reg.tap_cfg.lir = (uint8_t) val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_TAP_CFG, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  int_notification: [get]  Latched/pulsed interrupt.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_lir_t: Get the values of lir in reg TAP_CFG\n  *\n  */\nint32_t lsm6dsl_int_notification_get(lsm6dsl_ctx_t *ctx, lsm6dsl_lir_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_CFG, &reg.byte, 1);\n  switch (reg.tap_cfg.lir) {\n    case LSM6DSL_INT_PULSED:\n      *val = LSM6DSL_INT_PULSED;\n      break;\n    case LSM6DSL_INT_LATCHED:\n      *val = LSM6DSL_INT_LATCHED;\n      break;\n    default:\n      *val = LSM6DSL_INT_MODE;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  Wake_Up_event\n  * @brief   This section groups all the functions that manage the Wake Up\n  *          event generation.\n  * @{\n  */\n\n/**\n  * @brief  wkup_threshold: [set]  Threshold for wakeup.1 LSB = FS_XL / 64.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of wk_ths in reg WAKE_UP_THS\n  *\n  */\nint32_t lsm6dsl_wkup_threshold_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_WAKE_UP_THS, &reg.byte, 1);\n  if(ret == 0){\n    reg.wake_up_ths.wk_ths = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_WAKE_UP_THS, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  wkup_threshold: [get]  Threshold for wakeup.1 LSB = FS_XL / 64.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of wk_ths in reg WAKE_UP_THS\n  *\n  */\nint32_t lsm6dsl_wkup_threshold_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_WAKE_UP_THS, &reg.byte, 1);\n  *val = reg.wake_up_ths.wk_ths;\n\n  return ret;\n}\n\n/**\n  * @brief  wkup_dur: [set]  Wake up duration event.1LSb = 1 / ODR\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of wake_dur in reg WAKE_UP_DUR\n  *\n  */\nint32_t lsm6dsl_wkup_dur_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_WAKE_UP_DUR, &reg.byte, 1);\n  if(ret == 0){\n    reg.wake_up_dur.wake_dur = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_WAKE_UP_DUR, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  wkup_dur: [get]  Wake up duration event.1LSb = 1 / ODR\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of wake_dur in reg WAKE_UP_DUR\n  *\n  */\nint32_t lsm6dsl_wkup_dur_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_WAKE_UP_DUR, &reg.byte, 1);\n  *val = reg.wake_up_dur.wake_dur;\n\n  return ret;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup   Activity/Inactivity_detection\n  * @brief   This section groups all the functions concerning\n  *          activity/inactivity detection.\n  * @{\n  */\n\n/**\n  * @brief  gy_sleep_mode: [set]  Enables gyroscope Sleep mode.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of sleep in reg CTRL4_C\n  *\n  */\nint32_t lsm6dsl_gy_sleep_mode_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL4_C, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl4_c.sleep = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL4_C, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  gy_sleep_mode: [get]  Enables gyroscope Sleep mode.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of sleep in reg CTRL4_C\n  *\n  */\nint32_t lsm6dsl_gy_sleep_mode_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL4_C, &reg.byte, 1);\n  *val = reg.ctrl4_c.sleep;\n\n  return ret;\n}\n\n/**\n  * @brief  act_mode: [set]  Enable inactivity function.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_inact_en_t: change the values of inact_en in reg TAP_CFG\n  *\n  */\nint32_t lsm6dsl_act_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_inact_en_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_CFG, &reg.byte, 1);\n  if(ret == 0){\n    reg.tap_cfg.inact_en = (uint8_t) val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_TAP_CFG, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  act_mode: [get]  Enable inactivity function.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_inact_en_t: Get the values of inact_en in reg TAP_CFG\n  *\n  */\nint32_t lsm6dsl_act_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_inact_en_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_CFG, &reg.byte, 1);\n  switch (reg.tap_cfg.inact_en) {\n    case LSM6DSL_PROPERTY_DISABLE:\n      *val = LSM6DSL_PROPERTY_DISABLE;\n      break;\n    case LSM6DSL_XL_12Hz5_GY_NOT_AFFECTED:\n      *val = LSM6DSL_XL_12Hz5_GY_NOT_AFFECTED;\n      break;\n    case LSM6DSL_XL_12Hz5_GY_SLEEP:\n      *val = LSM6DSL_XL_12Hz5_GY_SLEEP;\n      break;\n    case LSM6DSL_XL_12Hz5_GY_PD:\n      *val = LSM6DSL_XL_12Hz5_GY_PD;\n      break;\n    default:\n      *val = LSM6DSL_ACT_MODE_ND;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  act_sleep_dur: [set] Duration to go in sleep mode.\n  *                              1 LSb = 512 / ODR\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of sleep_dur in reg WAKE_UP_DUR\n  *\n  */\nint32_t lsm6dsl_act_sleep_dur_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_WAKE_UP_DUR, &reg.byte, 1);\n  if(ret == 0){\n    reg.wake_up_dur.sleep_dur = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_WAKE_UP_DUR, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  act_sleep_dur: [get] Duration to go in sleep mode.\n  *                              1 LSb = 512 / ODR\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of sleep_dur in reg WAKE_UP_DUR\n  *\n  */\nint32_t lsm6dsl_act_sleep_dur_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_WAKE_UP_DUR, &reg.byte, 1);\n  *val = reg.wake_up_dur.sleep_dur;\n\n  return ret;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  tap_generator\n  * @brief   This section groups all the functions that manage the tap and\n  *          double tap event generation.\n  * @{\n  */\n\n/**\n  * @brief  tap_src: [get]  Read the tap / double tap source register.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_: union of registers from TAP_SRC to\n  *\n  */\nint32_t lsm6dsl_tap_src_get(lsm6dsl_ctx_t *ctx, lsm6dsl_tap_src_t *val)\n{\n  return lsm6dsl_read_reg(ctx, LSM6DSL_TAP_SRC, (uint8_t*) val, 1);\n}\n\n/**\n  * @brief  tap_detection_on_z: [set]  Enable Z direction in tap recognition.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of tap_z_en in reg TAP_CFG\n  *\n  */\nint32_t lsm6dsl_tap_detection_on_z_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_CFG, &reg.byte, 1);\n  if(ret == 0){\n    reg.tap_cfg.tap_z_en = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_TAP_CFG, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  tap_detection_on_z: [get]  Enable Z direction in tap recognition.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of tap_z_en in reg TAP_CFG\n  *\n  */\nint32_t lsm6dsl_tap_detection_on_z_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_CFG, &reg.byte, 1);\n  *val = reg.tap_cfg.tap_z_en;\n\n  return ret;\n}\n\n/**\n  * @brief  tap_detection_on_y: [set]  Enable Y direction in tap recognition.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of tap_y_en in reg TAP_CFG\n  *\n  */\nint32_t lsm6dsl_tap_detection_on_y_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_CFG, &reg.byte, 1);\n  if(ret == 0){\n    reg.tap_cfg.tap_y_en = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_TAP_CFG, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  tap_detection_on_y: [get]  Enable Y direction in tap recognition.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of tap_y_en in reg TAP_CFG\n  *\n  */\nint32_t lsm6dsl_tap_detection_on_y_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_CFG, &reg.byte, 1);\n  *val = reg.tap_cfg.tap_y_en;\n\n  return ret;\n}\n\n/**\n  * @brief  tap_detection_on_x: [set]  Enable X direction in tap recognition.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of tap_x_en in reg TAP_CFG\n  *\n  */\nint32_t lsm6dsl_tap_detection_on_x_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_CFG, &reg.byte, 1);\n  if(ret == 0){\n    reg.tap_cfg.tap_x_en = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_TAP_CFG, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  tap_detection_on_x: [get]  Enable X direction in tap recognition.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of tap_x_en in reg TAP_CFG\n  *\n  */\nint32_t lsm6dsl_tap_detection_on_x_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_CFG, &reg.byte, 1);\n  *val = reg.tap_cfg.tap_x_en;\n\n  return ret;\n}\n\n/**\n  * @brief  tap_threshold_x: [set]  Threshold for tap recognition.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of tap_ths in reg TAP_THS_6D\n  *\n  */\nint32_t lsm6dsl_tap_threshold_x_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_THS_6D, &reg.byte, 1);\n  if(ret == 0){\n    reg.tap_ths_6d.tap_ths = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_TAP_THS_6D, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  tap_threshold_x: [get]  Threshold for tap recognition.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of tap_ths in reg TAP_THS_6D\n  *\n  */\nint32_t lsm6dsl_tap_threshold_x_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_THS_6D, &reg.byte, 1);\n  *val = reg.tap_ths_6d.tap_ths;\n\n  return ret;\n}\n\n/**\n  * @brief  tap_shock: [set] Maximum duration is the maximum time of an\n  *                          overthreshold signal detection to be recognized\n  *                          as a tap event.\n  *                          The default value of these bits is 00b which\n  *                          corresponds to 4*ODR_XL time.\n  *                          If the SHOCK[1:0] bits are set to a different\n  *                          value, 1LSB corresponds to 8*ODR_XL time.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of shock in reg INT_DUR2\n  *\n  */\nint32_t lsm6dsl_tap_shock_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_INT_DUR2, &reg.byte, 1);\n  if(ret == 0){\n    reg.int_dur2.shock = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_INT_DUR2, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  tap_shock: [get] Maximum duration is the maximum time of an\n  *                          overthreshold signal detection to be recognized\n  *                          as a tap event.\n  *                          The default value of these bits is 00b which\n  *                          corresponds to 4*ODR_XL time.\n  *                          If the SHOCK[1:0] bits are set to a different\n  *                          value, 1LSB corresponds to 8*ODR_XL time.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of shock in reg INT_DUR2\n  *\n  */\nint32_t lsm6dsl_tap_shock_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_INT_DUR2, &reg.byte, 1);\n  *val = reg.int_dur2.shock;\n\n  return ret;\n}\n\n/**\n  * @brief  tap_quiet: [set] Quiet time is the time after the first\n  *                          detected tap in which there must not be\n  *                          any overthreshold event.\n  *                          The default value of these bits is 00b\n  *                          which corresponds to 2*ODR_XL time.\n  *                          If the QUIET[1:0] bits are set to a\n  *                          different value, 1LSB corresponds to\n  *                          4*ODR_XL time.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of quiet in reg INT_DUR2\n  *\n  */\nint32_t lsm6dsl_tap_quiet_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_INT_DUR2, &reg.byte, 1);\n  if(ret == 0){\n    reg.int_dur2.quiet = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_INT_DUR2, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  tap_quiet: [get] Quiet time is the time after the first\n  *                          detected tap in which there must not be any\n  *                          overthreshold event.\n  *                          The default value of these bits is 00b which\n  *                          corresponds to 2*ODR_XL time.\n  *                          If the QUIET[1:0] bits are set to a different\n  *                          value, 1LSB corresponds to 4*ODR_XL time.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of quiet in reg INT_DUR2\n  *\n  */\nint32_t lsm6dsl_tap_quiet_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_INT_DUR2, &reg.byte, 1);\n  *val = reg.int_dur2.quiet;\n\n  return ret;\n}\n\n/**\n  * @brief  tap_dur: [set] When double tap recognition is enabled,\n  *                        this register expresses the maximum time between\n  *                        two consecutive detected taps to determine a double\n  *                        tap event.\n  *                        The default value of these bits is 0000b which\n  *                        corresponds to 16*ODR_XL time.\n  *                        If the DUR[3:0] bits are set to a different value,\n  *                        1LSB corresponds to 32*ODR_XL time.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of dur in reg INT_DUR2\n  *\n  */\nint32_t lsm6dsl_tap_dur_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_INT_DUR2, &reg.byte, 1);\n  if(ret == 0){\n    reg.int_dur2.dur = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_INT_DUR2, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  tap_dur: [get] When double tap recognition is enabled,\n  *                        this register expresses the maximum time between\n  *                        two consecutive detected taps to determine a\n  *                        double tap event.\n  *                        The default value of these bits is 0000b which\n  *                        corresponds to 16*ODR_XL time.\n  *                        If the DUR[3:0] bits are set to a different value,\n  *                        1LSB corresponds to 32*ODR_XL time.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of dur in reg INT_DUR2\n  *\n  */\nint32_t lsm6dsl_tap_dur_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_INT_DUR2, &reg.byte, 1);\n  *val = reg.int_dur2.dur;\n\n  return ret;\n}\n\n/**\n  * @brief  tap_mode: [set]  Single/double-tap event enable/disable.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_single_double_tap_t: change the values of\n  *                                      single_double_tap in reg WAKE_UP_THS\n  *\n  */\nint32_t lsm6dsl_tap_mode_set(lsm6dsl_ctx_t *ctx,\n                             lsm6dsl_single_double_tap_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_WAKE_UP_THS, &reg.byte, 1);\n  if(ret == 0){\n    reg.wake_up_ths.single_double_tap = (uint8_t) val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_WAKE_UP_THS, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  tap_mode: [get]  Single/double-tap event enable/disable.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_single_double_tap_t: Get the values of single_double_tap\n  *                                      in reg WAKE_UP_THS\n  *\n  */\nint32_t lsm6dsl_tap_mode_get(lsm6dsl_ctx_t *ctx,\n                             lsm6dsl_single_double_tap_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_WAKE_UP_THS, &reg.byte, 1);\n  switch (reg.wake_up_ths.single_double_tap) {\n    case LSM6DSL_ONLY_SINGLE:\n      *val = LSM6DSL_ONLY_SINGLE;\n      break;\n    case LSM6DSL_BOTH_SINGLE_DOUBLE:\n      *val = LSM6DSL_BOTH_SINGLE_DOUBLE;\n      break;\n    default:\n      *val = LSM6DSL_TAP_MODE_ND;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup   Six_position_detection(6D/4D)\n  * @brief   This section groups all the functions concerning six\n  *          position detection (6D).\n  * @{\n  */\n\n/**\n  * @brief  6d_feed_data: [set]  LPF2 feed 6D function selection.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_low_pass_on_6d_t: change the values of low_pass_on_6d in\n  *                                   reg CTRL8_XL\n  *\n  */\nint32_t lsm6dsl_6d_feed_data_set(lsm6dsl_ctx_t *ctx,\n                                 lsm6dsl_low_pass_on_6d_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL8_XL, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl8_xl.low_pass_on_6d = (uint8_t) val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL8_XL, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  6d_feed_data: [get]  LPF2 feed 6D function selection.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_low_pass_on_6d_t: Get the values of low_pass_on_6d in\n  *                                   reg CTRL8_XL\n  *\n  */\nint32_t lsm6dsl_6d_feed_data_get(lsm6dsl_ctx_t *ctx,\n                                 lsm6dsl_low_pass_on_6d_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL8_XL, &reg.byte, 1);\n  switch (reg.ctrl8_xl.low_pass_on_6d) {\n    case LSM6DSL_ODR_DIV_2_FEED:\n      *val = LSM6DSL_ODR_DIV_2_FEED;\n      break;\n    case LSM6DSL_LPF2_FEED:\n      *val = LSM6DSL_LPF2_FEED;\n      break;\n    default:\n      *val = LSM6DSL_6D_FEED_ND;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  6d_threshold: [set]  Threshold for 4D/6D function.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_sixd_ths_t: change the values of sixd_ths in reg TAP_THS_6D\n  *\n  */\nint32_t lsm6dsl_6d_threshold_set(lsm6dsl_ctx_t *ctx, lsm6dsl_sixd_ths_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_THS_6D, &reg.byte, 1);\n  if(ret == 0){\n    reg.tap_ths_6d.sixd_ths = (uint8_t) val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_TAP_THS_6D, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  6d_threshold: [get]  Threshold for 4D/6D function.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_sixd_ths_t: Get the values of sixd_ths in reg TAP_THS_6D\n  *\n  */\nint32_t lsm6dsl_6d_threshold_get(lsm6dsl_ctx_t *ctx, lsm6dsl_sixd_ths_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_THS_6D, &reg.byte, 1);\n  switch (reg.tap_ths_6d.sixd_ths) {\n    case LSM6DSL_DEG_80:\n      *val = LSM6DSL_DEG_80;\n      break;\n    case LSM6DSL_DEG_70:\n      *val = LSM6DSL_DEG_70;\n      break;\n    case LSM6DSL_DEG_60:\n      *val = LSM6DSL_DEG_60;\n      break;\n    case LSM6DSL_DEG_50:\n      *val = LSM6DSL_DEG_50;\n      break;\n    default:\n      *val = LSM6DSL_6D_TH_ND;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  4d_mode: [set]  4D orientation detection enable.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of d4d_en in reg TAP_THS_6D\n  *\n  */\nint32_t lsm6dsl_4d_mode_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_THS_6D, &reg.byte, 1);\n  if(ret == 0){\n    reg.tap_ths_6d.d4d_en = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_TAP_THS_6D, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  4d_mode: [get]  4D orientation detection enable.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of d4d_en in reg TAP_THS_6D\n  *\n  */\nint32_t lsm6dsl_4d_mode_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_THS_6D, &reg.byte, 1);\n  *val = reg.tap_ths_6d.d4d_en;\n\n  return ret;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  free_fall\n  * @brief   This section group all the functions concerning the free\n  *          fall detection.\n  * @{\n  */\n\n/**\n  * @brief  ff_dur: [set]  Free-fall duration event. 1LSb = 1 / ODR\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of ff_dur in reg WAKE_UP_DUR\n  *\n  */\nint32_t lsm6dsl_ff_dur_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FREE_FALL, &reg.byte, 1);\n  if(ret == 0){\n    reg.free_fall.ff_dur = (val & 0x1FU);\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_FREE_FALL, &reg.byte, 1);\n    if(ret == 0){\n      ret = lsm6dsl_read_reg(ctx, LSM6DSL_WAKE_UP_DUR, &reg.byte, 1);\n      if(ret == 0){\n        reg.wake_up_dur.ff_dur = (val & 0x20U) >> 5;\n        ret = lsm6dsl_write_reg(ctx, LSM6DSL_WAKE_UP_DUR, &reg.byte, 1);\n      }\n    }\n  }\n  return ret;\n}\n\n/**\n  * @brief  ff_dur: [get]  Free-fall duration event. 1LSb = 1 / ODR\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of ff_dur in reg WAKE_UP_DUR\n  *\n  */\nint32_t lsm6dsl_ff_dur_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg[2];\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_WAKE_UP_DUR, &reg[0].byte, 2);\n  *val = (reg[0].wake_up_dur.ff_dur << 5) + reg[1].free_fall.ff_dur;\n\n  return ret;\n}\n\n/**\n  * @brief  ff_threshold: [set]  Free fall threshold setting.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_ff_ths_t: change the values of ff_ths in reg FREE_FALL\n  *\n  */\nint32_t lsm6dsl_ff_threshold_set(lsm6dsl_ctx_t *ctx, lsm6dsl_ff_ths_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FREE_FALL, &reg.byte, 1);\n  if(ret == 0){\n    reg.free_fall.ff_ths = (uint8_t) val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_FREE_FALL, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  ff_threshold: [get]  Free fall threshold setting.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_ff_ths_t: Get the values of ff_ths in reg FREE_FALL\n  *\n  */\nint32_t lsm6dsl_ff_threshold_get(lsm6dsl_ctx_t *ctx, lsm6dsl_ff_ths_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FREE_FALL, &reg.byte, 1);\n  switch (reg.free_fall.ff_ths) {\n    case LSM6DSL_FF_TSH_156mg:\n      *val = LSM6DSL_FF_TSH_156mg;\n      break;\n    case LSM6DSL_FF_TSH_219mg:\n      *val = LSM6DSL_FF_TSH_219mg;\n      break;\n    case LSM6DSL_FF_TSH_250mg:\n      *val = LSM6DSL_FF_TSH_250mg;\n      break;\n    case LSM6DSL_FF_TSH_312mg:\n      *val = LSM6DSL_FF_TSH_312mg;\n      break;\n    case LSM6DSL_FF_TSH_344mg:\n      *val = LSM6DSL_FF_TSH_344mg;\n      break;\n    case LSM6DSL_FF_TSH_406mg:\n      *val = LSM6DSL_FF_TSH_406mg;\n      break;\n    case LSM6DSL_FF_TSH_469mg:\n      *val = LSM6DSL_FF_TSH_469mg;\n      break;\n    case LSM6DSL_FF_TSH_500mg:\n      *val = LSM6DSL_FF_TSH_500mg;\n      break;\n    default:\n      *val = LSM6DSL_FF_TSH_ND;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  fifo\n  * @brief   This section group all the functions concerning the fifo usage\n  * @{\n  */\n\n/**\n  * @brief  fifo_watermark: [set]  FIFO watermark level selection.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of fth in reg FIFO_CTRL1\n  *\n  */\nint32_t lsm6dsl_fifo_watermark_set(lsm6dsl_ctx_t *ctx, uint16_t val)\n{\n  lsm6dsl_reg_t reg[2];\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL2, &reg[1].byte, 1);\n  if(ret == 0){\n    reg[0].fifo_ctrl1.fth = (uint8_t) (0x00FFU & val);\n    reg[1].fifo_ctrl2.fth = (uint8_t) (( 0x0700U & val ) >> 8);\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_FIFO_CTRL1, &reg[0].byte, 2);\n  }\n  return ret;\n}\n\n/**\n  * @brief  fifo_watermark: [get]  FIFO watermark level selection.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of fth in reg FIFO_CTRL1\n  *\n  */\nint32_t lsm6dsl_fifo_watermark_get(lsm6dsl_ctx_t *ctx, uint16_t *val)\n{\n  lsm6dsl_reg_t reg[2];\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL1, &reg[0].byte, 2);\n  *val = ((uint16_t)reg[1].fifo_ctrl2.fth << 8) +\n          (uint16_t)reg[0].fifo_ctrl1.fth;\n\n  return ret;\n}\n\n/**\n  * @brief  lsm6dsl_fifo_data_level_get: [get]  FIFO data level.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: get the values of diff_fifo in reg  FIFO_STATUS1 and\n  *                  FIFO_STATUS2(diff_fifo), it is recommended to set the\n  *                  BDU bit\n  *\n  */\nint32_t lsm6dsl_fifo_data_level_get(lsm6dsl_ctx_t *ctx, uint16_t *val)\n{\n  lsm6dsl_reg_t reg[2];\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_STATUS1, &reg[0].byte, 2);\n  *val = ( (uint16_t) reg[1].fifo_status2.diff_fifo << 8) +\n           (uint16_t) reg[0].fifo_status1.diff_fifo;\n\n  return ret;\n}\n\n/**\n  * @brief  lsm6dsl_fifo_wtm_flag: [get]  FIFO watermark.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: get the values of watermark in reg  FIFO_STATUS2 and\n  *\n  */\nint32_t lsm6dsl_fifo_wtm_flag_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_STATUS2, &reg.byte, 1);\n  *val = reg.fifo_status2.waterm;\n\n  return ret;\n}\n\n/**\n  * @brief  lsm6dsl_fifo_pattern_get: [get]  FIFO pattern.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: get the values of fifo_pattern in reg  FIFO_STATUS3 and\n  *                  FIFO_STATUS4, it is recommended to set the BDU bit\n  *\n  */\nint32_t lsm6dsl_fifo_pattern_get(lsm6dsl_ctx_t *ctx, uint16_t *val)\n{\n  lsm6dsl_reg_t reg[2];\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_STATUS3, &reg[0].byte, 2);\n  *val = ( (uint16_t)reg[1].fifo_status4.fifo_pattern << 8) +\n           reg[0].fifo_status3.fifo_pattern;\n\n  return ret;\n}\n\n/**\n  * @brief  fifo_temp_batch: [set]  batching of temperature data\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of fifo_temp_en in reg FIFO_CTRL2\n  *\n  */\nint32_t lsm6dsl_fifo_temp_batch_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL2, &reg.byte, 1);\n  if(ret == 0){\n    reg.fifo_ctrl2.fifo_temp_en = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_FIFO_CTRL2, &reg.byte, 1);\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  fifo_temp_batch: [get]  batching of temperature data\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of fifo_temp_en in reg FIFO_CTRL2\n  *\n  */\nint32_t lsm6dsl_fifo_temp_batch_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL2, &reg.byte, 1);\n  *val = reg.fifo_ctrl2.fifo_temp_en;\n\n  return ret;\n}\n\n/**\n  * @brief  fifo_write_trigger: [set]  trigger signal for FIFO write operation\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_trigger_fifo_t: act on FIFO_CTRL2(timer_pedo_fifo_drdy)\n  *                                 and MASTER_CONFIG(data_valid_sel_fifo)\n  *\n  */\nint32_t lsm6dsl_fifo_write_trigger_set(lsm6dsl_ctx_t *ctx,\n                                       lsm6dsl_trigger_fifo_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL2, &reg.byte, 1);\n  if(ret == 0){\n    reg.fifo_ctrl2.timer_pedo_fifo_drdy = (uint8_t)val & 0x01U;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_FIFO_CTRL2, &reg.byte, 1);\n    if(ret == 0){\n      ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CONFIG, &reg.byte, 1);\n      if(ret == 0){\n        reg.master_config.data_valid_sel_fifo = (((uint8_t)val & 0x02U) >> 1);\n        ret = lsm6dsl_write_reg(ctx, LSM6DSL_MASTER_CONFIG, &reg.byte, 1);\n      }\n    }\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  fifo_write_trigger: [get]  trigger signal for FIFO write operation\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_trigger_fifo_t: act on FIFO_CTRL2(timer_pedo_fifo_drdy)\n  *                                 and MASTER_CONFIG(data_valid_sel_fifo)\n  *\n  */\nint32_t lsm6dsl_fifo_write_trigger_get(lsm6dsl_ctx_t *ctx,\n                                       lsm6dsl_trigger_fifo_t *val)\n{\n  lsm6dsl_reg_t reg[2];\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL2, &reg[0].byte, 1);\n  if(ret == 0){\n    ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CONFIG, &reg[1].byte, 1);\n\n    switch ( ( reg[1].fifo_ctrl2.timer_pedo_fifo_drdy << 1 ) +\n             reg[0].fifo_ctrl2. timer_pedo_fifo_drdy ) {\n      case LSM6DSL_TRG_XL_GY_DRDY:\n        *val = LSM6DSL_TRG_XL_GY_DRDY;\n        break;\n      case LSM6DSL_TRG_STEP_DETECT:\n        *val = LSM6DSL_TRG_STEP_DETECT;\n        break;\n      case LSM6DSL_TRG_SH_DRDY:\n        *val = LSM6DSL_TRG_SH_DRDY;\n        break;\n      default:\n        *val = LSM6DSL_TRG_SH_ND;\n        break;\n    }\n  }\n\n  return ret;\n}\n\n/**\n  * @brief   fifo_pedo_and_timestamp_batch: [set] Enable pedometer step\n  *                                               counter and timestamp as 4th\n  *                                               FIFO data set.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of timer_pedo_fifo_en in\n  *                      reg FIFO_CTRL2\n  *\n  */\nint32_t lsm6dsl_fifo_pedo_and_timestamp_batch_set(lsm6dsl_ctx_t *ctx,\n                                                  uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL2, &reg.byte, 1);\n  if(ret == 0){\n    reg.fifo_ctrl2.timer_pedo_fifo_en = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_FIFO_CTRL2, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief   fifo_pedo_and_timestamp_batch: [get] Enable pedometer step\n  *                                               counter and timestamp as 4th\n  *                                               FIFO data set.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of timer_pedo_fifo_en in reg FIFO_CTRL2\n  *\n  */\nint32_t lsm6dsl_fifo_pedo_and_timestamp_batch_get(lsm6dsl_ctx_t *ctx,\n                                                  uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL2, &reg.byte, 1);\n  *val = reg.fifo_ctrl2.timer_pedo_fifo_en;\n\n  return ret;\n}\n\n/**\n  * @brief  fifo_xl_batch: [set] Selects Batching Data Rate (writing\n  *                              frequency in FIFO) for accelerometer data.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_dec_fifo_xl_t: change the values of dec_fifo_xl in\n  *                                reg FIFO_CTRL3\n  *\n  */\nint32_t lsm6dsl_fifo_xl_batch_set(lsm6dsl_ctx_t *ctx,\n                                  lsm6dsl_dec_fifo_xl_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL3, &reg.byte, 1);\n  if(ret == 0){\n    reg.fifo_ctrl3.dec_fifo_xl = (uint8_t)val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_FIFO_CTRL3, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  fifo_xl_batch: [get] Selects Batching Data Rate (writing\n  *                              frequency in FIFO) for accelerometer data.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_dec_fifo_xl_t: Get the values of dec_fifo_xl in\n  *                                reg FIFO_CTRL3\n  *\n  */\nint32_t lsm6dsl_fifo_xl_batch_get(lsm6dsl_ctx_t *ctx,\n                                  lsm6dsl_dec_fifo_xl_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL3, &reg.byte, 1);\n  switch (reg.fifo_ctrl3.dec_fifo_xl) {\n    case LSM6DSL_FIFO_XL_DISABLE:\n      *val = LSM6DSL_FIFO_XL_DISABLE;\n      break;\n    case LSM6DSL_FIFO_XL_NO_DEC:\n      *val = LSM6DSL_FIFO_XL_NO_DEC;\n      break;\n    case LSM6DSL_FIFO_XL_DEC_2:\n      *val = LSM6DSL_FIFO_XL_DEC_2;\n      break;\n    case LSM6DSL_FIFO_XL_DEC_3:\n      *val = LSM6DSL_FIFO_XL_DEC_3;\n      break;\n    case LSM6DSL_FIFO_XL_DEC_4:\n      *val = LSM6DSL_FIFO_XL_DEC_4;\n      break;\n    case LSM6DSL_FIFO_XL_DEC_8:\n      *val = LSM6DSL_FIFO_XL_DEC_8;\n      break;\n    case LSM6DSL_FIFO_XL_DEC_16:\n      *val = LSM6DSL_FIFO_XL_DEC_16;\n      break;\n    case LSM6DSL_FIFO_XL_DEC_32:\n      *val = LSM6DSL_FIFO_XL_DEC_32;\n      break;\n    default:\n      *val = LSM6DSL_FIFO_XL_DEC_ND;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  fifo_gy_batch: [set] Selects Batching Data Rate (writing\n  *                              frequency in FIFO) for gyroscope data.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_dec_fifo_gyro_t: change the values of dec_fifo_gyro\n  *                                  in reg FIFO_CTRL3\n  *\n  */\nint32_t lsm6dsl_fifo_gy_batch_set(lsm6dsl_ctx_t *ctx,\n                                  lsm6dsl_dec_fifo_gyro_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL3, &reg.byte, 1);\n  if(ret == 0){\n    reg.fifo_ctrl3.dec_fifo_gyro = (uint8_t)val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_FIFO_CTRL3, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  fifo_gy_batch: [get] Selects Batching Data Rate (writing\n  *                              frequency in FIFO) for gyroscope data.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_dec_fifo_gyro_t: Get the values of dec_fifo_gyro in\n  *                                  reg FIFO_CTRL3\n  *\n  */\nint32_t lsm6dsl_fifo_gy_batch_get(lsm6dsl_ctx_t *ctx,\n                                  lsm6dsl_dec_fifo_gyro_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL3, &reg.byte, 1);\n  switch (reg.fifo_ctrl3.dec_fifo_gyro) {\n    case LSM6DSL_FIFO_GY_DISABLE:\n      *val = LSM6DSL_FIFO_GY_DISABLE;\n      break;\n    case LSM6DSL_FIFO_GY_NO_DEC:\n      *val = LSM6DSL_FIFO_GY_NO_DEC;\n      break;\n    case LSM6DSL_FIFO_GY_DEC_2:\n      *val = LSM6DSL_FIFO_GY_DEC_2;\n      break;\n    case LSM6DSL_FIFO_GY_DEC_3:\n      *val = LSM6DSL_FIFO_GY_DEC_3;\n      break;\n    case LSM6DSL_FIFO_GY_DEC_4:\n      *val = LSM6DSL_FIFO_GY_DEC_4;\n      break;\n    case LSM6DSL_FIFO_GY_DEC_8:\n      *val = LSM6DSL_FIFO_GY_DEC_8;\n      break;\n    case LSM6DSL_FIFO_GY_DEC_16:\n      *val = LSM6DSL_FIFO_GY_DEC_16;\n      break;\n    case LSM6DSL_FIFO_GY_DEC_32:\n      *val = LSM6DSL_FIFO_GY_DEC_32;\n      break;\n    default:\n      *val = LSM6DSL_FIFO_GY_DEC_ND;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @brief   fifo_dataset_3_batch: [set] Selects Batching Data Rate (writing\n  *                                      frequency in FIFO) for third data set.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_dec_ds3_fifo_t: change the values of dec_ds3_fifo in\n  *                                 reg FIFO_CTRL4\n  *\n  */\nint32_t lsm6dsl_fifo_dataset_3_batch_set(lsm6dsl_ctx_t *ctx,\n                                         lsm6dsl_dec_ds3_fifo_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL4, &reg.byte, 1);\n  if(ret == 0){\n    reg.fifo_ctrl4.dec_ds3_fifo = (uint8_t)val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_FIFO_CTRL4, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief   fifo_dataset_3_batch: [get] Selects Batching Data Rate\n  *                                      (writing frequency in FIFO) for\n  *                                      third data set.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_dec_ds3_fifo_t: Get the values of dec_ds3_fifo in\n  *                                 reg FIFO_CTRL4\n  *\n  */\nint32_t lsm6dsl_fifo_dataset_3_batch_get(lsm6dsl_ctx_t *ctx,\n                                         lsm6dsl_dec_ds3_fifo_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL4, &reg.byte, 1);\n  switch (reg.fifo_ctrl4.dec_ds3_fifo) {\n    case LSM6DSL_FIFO_DS3_DISABLE:\n      *val = LSM6DSL_FIFO_DS3_DISABLE;\n      break;\n    case LSM6DSL_FIFO_DS3_NO_DEC:\n      *val = LSM6DSL_FIFO_DS3_NO_DEC;\n      break;\n    case LSM6DSL_FIFO_DS3_DEC_2:\n      *val = LSM6DSL_FIFO_DS3_DEC_2;\n      break;\n    case LSM6DSL_FIFO_DS3_DEC_3:\n      *val = LSM6DSL_FIFO_DS3_DEC_3;\n      break;\n    case LSM6DSL_FIFO_DS3_DEC_4:\n      *val = LSM6DSL_FIFO_DS3_DEC_4;\n      break;\n    case LSM6DSL_FIFO_DS3_DEC_8:\n      *val = LSM6DSL_FIFO_DS3_DEC_8;\n      break;\n    case LSM6DSL_FIFO_DS3_DEC_16:\n      *val = LSM6DSL_FIFO_DS3_DEC_16;\n      break;\n    case LSM6DSL_FIFO_DS3_DEC_32:\n      *val = LSM6DSL_FIFO_DS3_DEC_32;\n      break;\n    default:\n      *val = LSM6DSL_FIFO_DS3_DEC_ND;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @brief   fifo_dataset_4_batch: [set] Selects Batching Data Rate\n  *                                      (writing frequency in FIFO)\n  *                                      for fourth data set.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_dec_ds4_fifo_t: change the values of dec_ds4_fifo in\n  *                                 reg FIFO_CTRL4\n  *\n  */\nint32_t lsm6dsl_fifo_dataset_4_batch_set(lsm6dsl_ctx_t *ctx,\n                                         lsm6dsl_dec_ds4_fifo_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL4, &reg.byte, 1);\n  if(ret == 0){\n    reg.fifo_ctrl4.dec_ds4_fifo = (uint8_t)val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_FIFO_CTRL4, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief   fifo_dataset_4_batch: [get] Selects Batching Data Rate\n  *                                      (writing frequency in FIFO) for\n  *                                      fourth data set.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_dec_ds4_fifo_t: Get the values of dec_ds4_fifo in\n  *                                 reg FIFO_CTRL4\n  *\n  */\nint32_t lsm6dsl_fifo_dataset_4_batch_get(lsm6dsl_ctx_t *ctx,\n                                         lsm6dsl_dec_ds4_fifo_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL4, &reg.byte, 1);\n  switch (reg.fifo_ctrl4.dec_ds4_fifo) {\n    case LSM6DSL_FIFO_DS4_DISABLE:\n      *val = LSM6DSL_FIFO_DS4_DISABLE;\n      break;\n    case LSM6DSL_FIFO_DS4_NO_DEC:\n      *val = LSM6DSL_FIFO_DS4_NO_DEC;\n      break;\n    case LSM6DSL_FIFO_DS4_DEC_2:\n      *val = LSM6DSL_FIFO_DS4_DEC_2;\n      break;\n    case LSM6DSL_FIFO_DS4_DEC_3:\n      *val = LSM6DSL_FIFO_DS4_DEC_3;\n      break;\n    case LSM6DSL_FIFO_DS4_DEC_4:\n      *val = LSM6DSL_FIFO_DS4_DEC_4;\n      break;\n    case LSM6DSL_FIFO_DS4_DEC_8:\n      *val = LSM6DSL_FIFO_DS4_DEC_8;\n      break;\n    case LSM6DSL_FIFO_DS4_DEC_16:\n      *val = LSM6DSL_FIFO_DS4_DEC_16;\n      break;\n    case LSM6DSL_FIFO_DS4_DEC_32:\n      *val = LSM6DSL_FIFO_DS4_DEC_32;\n      break;\n    default:\n      *val = LSM6DSL_FIFO_DS4_DEC_ND;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @brief   fifo_xl_gy_8bit_format: [set]  8-bit data storage in FIFO.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of only_high_data in reg FIFO_CTRL4\n  *\n  */\nint32_t lsm6dsl_fifo_xl_gy_8bit_format_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL4, &reg.byte, 1);\n  if(ret == 0){\n    reg.fifo_ctrl4.only_high_data = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_FIFO_CTRL4, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief   fifo_xl_gy_8bit_format: [get]  8-bit data storage in FIFO.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of only_high_data in reg FIFO_CTRL4\n  *\n  */\nint32_t lsm6dsl_fifo_xl_gy_8bit_format_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL4, &reg.byte, 1);\n  *val = reg.fifo_ctrl4.only_high_data;\n\n  return ret;\n}\n\n/**\n  * @brief  fifo_stop_on_wtm: [set] Sensing chain FIFO stop values\n  *                                 memorization at threshold level.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of stop_on_fth in reg FIFO_CTRL4\n  *\n  */\nint32_t lsm6dsl_fifo_stop_on_wtm_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL4, &reg.byte, 1);\n  if(ret == 0){\n    reg.fifo_ctrl4.stop_on_fth = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_FIFO_CTRL4, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  fifo_stop_on_wtm: [get] Sensing chain FIFO stop values\n  *                                 memorization at threshold level.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of stop_on_fth in reg FIFO_CTRL4\n  *\n  */\nint32_t lsm6dsl_fifo_stop_on_wtm_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL4, &reg.byte, 1);\n  *val = reg.fifo_ctrl4.stop_on_fth;\n\n  return ret;\n}\n\n/**\n  * @brief  fifo_mode: [set]  FIFO mode selection.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_fifo_mode_t: change the values of fifo_mode in\n  *                              reg FIFO_CTRL5\n  *\n  */\nint32_t lsm6dsl_fifo_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_fifo_mode_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL5, &reg.byte, 1);\n  if(ret == 0){\n    reg.fifo_ctrl5.fifo_mode = (uint8_t)val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_FIFO_CTRL5, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  fifo_mode: [get]  FIFO mode selection.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_fifo_mode_t: Get the values of fifo_mode in reg FIFO_CTRL5\n  *\n  */\nint32_t lsm6dsl_fifo_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_fifo_mode_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL5, &reg.byte, 1);\n  switch (reg.fifo_ctrl5.fifo_mode) {\n    case LSM6DSL_BYPASS_MODE:\n      *val = LSM6DSL_BYPASS_MODE;\n      break;\n    case LSM6DSL_FIFO_MODE:\n      *val = LSM6DSL_FIFO_MODE;\n      break;\n    case LSM6DSL_STREAM_TO_FIFO_MODE:\n      *val = LSM6DSL_STREAM_TO_FIFO_MODE;\n      break;\n    case LSM6DSL_BYPASS_TO_STREAM_MODE:\n      *val = LSM6DSL_BYPASS_TO_STREAM_MODE;\n      break;\n    case LSM6DSL_STREAM_MODE:\n      *val = LSM6DSL_STREAM_MODE;\n      break;\n    default:\n      *val = LSM6DSL_FIFO_MODE_ND;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  fifo_data_rate: [set]  FIFO ODR selection, setting FIFO_MODE also.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_odr_fifo_t: change the values of odr_fifo in reg FIFO_CTRL5\n  *\n  */\nint32_t lsm6dsl_fifo_data_rate_set(lsm6dsl_ctx_t *ctx, lsm6dsl_odr_fifo_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL5, &reg.byte, 1);\n  if(ret == 0){\n    reg.fifo_ctrl5.odr_fifo = (uint8_t)val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_FIFO_CTRL5, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  fifo_data_rate: [get]  FIFO ODR selection, setting FIFO_MODE also.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_odr_fifo_t: Get the values of odr_fifo in reg FIFO_CTRL5\n  *\n  */\nint32_t lsm6dsl_fifo_data_rate_get(lsm6dsl_ctx_t *ctx, lsm6dsl_odr_fifo_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL5, &reg.byte, 1);\n  switch (reg.fifo_ctrl5.odr_fifo) {\n    case LSM6DSL_FIFO_DISABLE:\n      *val = LSM6DSL_FIFO_DISABLE;\n      break;\n    case LSM6DSL_FIFO_12Hz5:\n      *val = LSM6DSL_FIFO_12Hz5;\n      break;\n    case LSM6DSL_FIFO_26Hz:\n      *val = LSM6DSL_FIFO_26Hz;\n      break;\n    case LSM6DSL_FIFO_52Hz:\n      *val = LSM6DSL_FIFO_52Hz;\n      break;\n    case LSM6DSL_FIFO_104Hz:\n      *val = LSM6DSL_FIFO_104Hz;\n      break;\n    case LSM6DSL_FIFO_208Hz:\n      *val = LSM6DSL_FIFO_208Hz;\n      break;\n    case LSM6DSL_FIFO_416Hz:\n      *val = LSM6DSL_FIFO_416Hz;\n      break;\n    case LSM6DSL_FIFO_833Hz:\n      *val = LSM6DSL_FIFO_833Hz;\n      break;\n    case LSM6DSL_FIFO_1k66Hz:\n      *val = LSM6DSL_FIFO_1k66Hz;\n      break;\n    case LSM6DSL_FIFO_3k33Hz:\n      *val = LSM6DSL_FIFO_3k33Hz;\n      break;\n    case LSM6DSL_FIFO_6k66Hz:\n      *val = LSM6DSL_FIFO_6k66Hz;\n      break;\n    default:\n      *val = LSM6DSL_FIFO_RATE_ND;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  DEN_functionality\n  * @brief   This section groups all the functions concerning DEN\n  *          functionality.\n  * @{\n  */\n\n/**\n  * @brief  den_polarity: [set]  DEN active level configuration.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_den_lh_t: change the values of den_lh in reg CTRL5_C\n  *\n  */\n int32_t lsm6dsl_den_polarity_set(lsm6dsl_ctx_t *ctx, lsm6dsl_den_lh_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL5_C, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl5_c.den_lh = (uint8_t)val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL5_C, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  den_polarity: [get]  DEN active level configuration.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_den_lh_t: Get the values of den_lh in reg CTRL5_C\n  *\n  */\nint32_t lsm6dsl_den_polarity_get(lsm6dsl_ctx_t *ctx, lsm6dsl_den_lh_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL5_C, &reg.byte, 1);\n  switch (reg.ctrl5_c.den_lh) {\n    case LSM6DSL_DEN_ACT_LOW:\n      *val = LSM6DSL_DEN_ACT_LOW;\n      break;\n    case LSM6DSL_DEN_ACT_HIGH:\n      *val = LSM6DSL_DEN_ACT_HIGH;\n      break;\n    default:\n      *val = LSM6DSL_DEN_POL_ND;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  den_mode: [set]  DEN functionality marking mode\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_den_mode_t: change the values of den_mode in reg CTRL6_C\n  *\n  */\nint32_t lsm6dsl_den_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_den_mode_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL6_C, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl6_c.den_mode = (uint8_t)val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL6_C, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  den_mode: [get]  DEN functionality marking mode\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_den_mode_t*: change the values of den_mode in reg CTRL6_C\n  *\n  */\nint32_t lsm6dsl_den_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_den_mode_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL6_C, &reg.byte, 1);\n  switch (reg.ctrl6_c.den_mode) {\n    case LSM6DSL_DEN_DISABLE:\n      *val = LSM6DSL_DEN_DISABLE;\n      break;\n    case LSM6DSL_LEVEL_LETCHED:\n      *val = LSM6DSL_LEVEL_LETCHED;\n      break;\n    case LSM6DSL_LEVEL_TRIGGER:\n      *val = LSM6DSL_LEVEL_TRIGGER;\n      break;\n    case LSM6DSL_EDGE_TRIGGER:\n      *val = LSM6DSL_EDGE_TRIGGER;\n      break;\n    default:\n      *val = LSM6DSL_DEN_MODE_ND;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  den_enable: [set] Extend DEN functionality to accelerometer\n  *                           sensor.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_den_xl_g_t: change the values of den_xl_g in reg CTRL9_XL\n  *                             and den_xl_en in CTRL4_C.\n  *\n  */\nint32_t lsm6dsl_den_enable_set(lsm6dsl_ctx_t *ctx, lsm6dsl_den_xl_en_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL9_XL, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl9_xl.den_xl_g = (uint8_t)val & 0x01U;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL9_XL, &reg.byte, 1);\n    if(ret == 0){\n      ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL4_C, &reg.byte, 1);\n      if(ret == 0){\n        reg.ctrl4_c.den_xl_en = (uint8_t)val & 0x02U;\n        ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL4_C, &reg.byte, 1);\n      }\n    }\n  }\n  return ret;\n}\n\n/**\n  * @brief  den_enable: [get] Extend DEN functionality to accelerometer\n  *                           sensor.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_den_xl_g_t: Get the values of den_xl_g in reg CTRL9_XL\n  *                             and den_xl_en in CTRL4_C.\n  *\n  */\nint32_t lsm6dsl_den_enable_get(lsm6dsl_ctx_t *ctx, lsm6dsl_den_xl_en_t *val)\n{\n  lsm6dsl_reg_t reg[2];\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL4_C, &reg[0].byte, 1);\n  if(ret == 0){\n    ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL9_XL, &reg[1].byte, 1);\n    switch ( ( reg[0].ctrl4_c.den_xl_en << 1) + reg[1].ctrl9_xl.den_xl_g ) {\n      case LSM6DSL_STAMP_IN_GY_DATA:\n        *val = LSM6DSL_STAMP_IN_GY_DATA;\n        break;\n      case LSM6DSL_STAMP_IN_XL_DATA:\n        *val = LSM6DSL_STAMP_IN_XL_DATA;\n        break;\n      case LSM6DSL_STAMP_IN_GY_XL_DATA:\n        *val = LSM6DSL_STAMP_IN_GY_XL_DATA;\n        break;\n      default:\n        *val = LSM6DSL_DEN_STAMP_ND;\n        break;\n    }\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  den_mark_axis_z: [set]  DEN value stored in LSB of Z-axis.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of den_z in reg CTRL9_XL\n  *\n  */\nint32_t lsm6dsl_den_mark_axis_z_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL9_XL, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl9_xl.den_z = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL9_XL, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  den_mark_axis_z: [get]  DEN value stored in LSB of Z-axis.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of den_z in reg CTRL9_XL\n  *\n  */\nint32_t lsm6dsl_den_mark_axis_z_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL9_XL, &reg.byte, 1);\n  *val = reg.ctrl9_xl.den_z;\n\n  return ret;\n}\n\n/**\n  * @brief  den_mark_axis_y: [set]  DEN value stored in LSB of Y-axis.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of den_y in reg CTRL9_XL\n  *\n  */\nint32_t lsm6dsl_den_mark_axis_y_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL9_XL, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl9_xl.den_y = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL9_XL, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  den_mark_axis_y: [get]  DEN value stored in LSB of Y-axis.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of den_y in reg CTRL9_XL\n  *\n  */\nint32_t lsm6dsl_den_mark_axis_y_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL9_XL, &reg.byte, 1);\n  *val = reg.ctrl9_xl.den_y;\n\n  return ret;\n}\n\n/**\n  * @brief  den_mark_axis_x: [set]  DEN value stored in LSB of X-axis.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of den_x in reg CTRL9_XL\n  *\n  */\nint32_t lsm6dsl_den_mark_axis_x_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL9_XL, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl9_xl.den_x = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL9_XL, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  den_mark_axis_x: [get]  DEN value stored in LSB of X-axis.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of den_x in reg CTRL9_XL\n  *\n  */\nint32_t lsm6dsl_den_mark_axis_x_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL9_XL, &reg.byte, 1);\n  *val = reg.ctrl9_xl.den_x;\n\n  return ret;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  Pedometer\n  * @brief   This section groups all the functions that manage pedometer.\n  * @{\n  */\n\n/**\n  * @brief  pedo_step_reset: [set]  Reset pedometer step counter.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of pedo_rst_step in reg CTRL10_C\n  *\n  */\nint32_t lsm6dsl_pedo_step_reset_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL10_C, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl10_c.pedo_rst_step = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL10_C, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  pedo_step_reset: [get]  Reset pedometer step counter.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of pedo_rst_step in reg CTRL10_C\n  *\n  */\nint32_t lsm6dsl_pedo_step_reset_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL10_C, &reg.byte, 1);\n  *val = reg.ctrl10_c.pedo_rst_step;\n\n  return ret;\n}\n\n/**\n  * @brief  pedo_sens: [set]  Enable pedometer algorithm.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of pedo_en in reg CTRL10_C\n  *\n  */\nint32_t lsm6dsl_pedo_sens_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL10_C, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl10_c.pedo_en = val;\n    if (val != 0x00U) {\n      reg.ctrl10_c.func_en = val;\n    }\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL10_C, &reg.byte, 1);\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  pedo_sens: [get]  Enable pedometer algorithm.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of pedo_en in reg CTRL10_C\n  *\n  */\nint32_t lsm6dsl_pedo_sens_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL10_C, &reg.byte, 1);\n  *val = reg.ctrl10_c.pedo_en;\n\n  return ret;\n}\n\n/**\n  * @brief  pedo_threshold: [set] Minimum threshold to detect a peak.\n  *                               Default is 10h.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of ths_min in reg\n  *                      CONFIG_PEDO_THS_MIN\n  *\n  */\nint32_t lsm6dsl_pedo_threshold_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);\n  if(ret == 0){\n    ret = lsm6dsl_read_reg(ctx, LSM6DSL_CONFIG_PEDO_THS_MIN, &reg.byte, 1);\n      if(ret == 0){\n      reg. config_pedo_ths_min.ths_min = val;\n      ret = lsm6dsl_write_reg(ctx, LSM6DSL_CONFIG_PEDO_THS_MIN, &reg.byte, 1);\n        if(ret == 0){\n          ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n        }\n      }\n    }\n  return ret;\n}\n\n/**\n  * @brief  pedo_threshold: [get] Minimum threshold to detect a peak.\n  *                               Default is 10h.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of ths_min in reg  CONFIG_PEDO_THS_MIN\n  *\n  */\nint32_t lsm6dsl_pedo_threshold_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n    ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);\n    if(ret == 0){\n      ret = lsm6dsl_read_reg(ctx, LSM6DSL_CONFIG_PEDO_THS_MIN, &reg.byte, 1);\n      if(ret == 0){\n        *val = reg. config_pedo_ths_min.ths_min;\n        ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n      }\n    }\n  return ret;\n}\n\n/**\n  * @brief  pedo_full_scale: [set]  Pedometer data range.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_pedo_fs_t: change the values of pedo_fs in\n  *                            reg CONFIG_PEDO_THS_MIN\n  *\n  */\nint32_t lsm6dsl_pedo_full_scale_set(lsm6dsl_ctx_t *ctx, lsm6dsl_pedo_fs_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);\n  if(ret == 0){\n    ret = lsm6dsl_read_reg(ctx, LSM6DSL_CONFIG_PEDO_THS_MIN, &reg.byte, 1);\n    if(ret == 0){\n      reg. config_pedo_ths_min.pedo_fs = (uint8_t) val;\n      ret = lsm6dsl_write_reg(ctx, LSM6DSL_CONFIG_PEDO_THS_MIN, &reg.byte, 1);\n      if(ret == 0){\n        ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n      }\n    }\n  }\n  return ret;\n}\n\n/**\n  * @brief  pedo_full_scale: [get]  Pedometer data range.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_pedo_fs_t: Get the values of pedo_fs in\n  *                            reg CONFIG_PEDO_THS_MIN\n  *\n  */\nint32_t lsm6dsl_pedo_full_scale_get(lsm6dsl_ctx_t *ctx, lsm6dsl_pedo_fs_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);\n  if(ret == 0){\n    ret = lsm6dsl_read_reg(ctx, LSM6DSL_CONFIG_PEDO_THS_MIN, &reg.byte, 1);\n    if(ret == 0){\n      switch (reg.config_pedo_ths_min.pedo_fs) {\n         case LSM6DSL_PEDO_AT_2g:\n          *val = LSM6DSL_PEDO_AT_2g;\n          break;\n        case LSM6DSL_PEDO_AT_4g:\n          *val = LSM6DSL_PEDO_AT_4g;\n          break;\n        default:\n          *val = LSM6DSL_PEDO_FS_ND;\n          break;\n      }\n      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n    }\n  }\n  return ret;\n}\n\n/**\n  * @brief   pedo_debounce_steps: [set] Pedometer debounce\n  *                                     configuration register (r/w).\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of deb_step in reg PEDO_DEB_REG\n  *\n  */\nint32_t lsm6dsl_pedo_debounce_steps_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);\n  if(ret == 0){\n    ret = lsm6dsl_read_reg(ctx, LSM6DSL_PEDO_DEB_REG, &reg.byte, 1);\n    if(ret == 0){\n      reg.pedo_deb_reg.deb_step = val;\n      ret = lsm6dsl_write_reg(ctx, LSM6DSL_PEDO_DEB_REG, &reg.byte, 1);\n        if(ret == 0){\n          ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n        }\n      }\n    }\n  return ret;\n}\n\n/**\n  * @brief   pedo_debounce_steps: [get] Pedometer debounce configuration\n  *                                     register (r/w).\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of deb_step in reg PEDO_DEB_REG\n  *\n  */\nint32_t lsm6dsl_pedo_debounce_steps_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);\n  if(ret == 0){\n    ret = lsm6dsl_read_reg(ctx, LSM6DSL_PEDO_DEB_REG, &reg.byte, 1);\n      if(ret == 0){\n        *val = reg.pedo_deb_reg.deb_step;\n        ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n      }\n    }\n\n  return ret;\n}\n\n/**\n  * @brief  pedo_timeout: [set] Debounce time. If the time between two\n  *                             consecutive steps is greater than\n  *                             DEB_TIME*80ms, the debouncer is reactivated.\n  *                             Default value: 01101\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of deb_time in reg PEDO_DEB_REG\n  *\n  */\nint32_t lsm6dsl_pedo_timeout_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);\n  if(ret == 0){\n    ret = lsm6dsl_read_reg(ctx, LSM6DSL_PEDO_DEB_REG, &reg.byte, 1);\n    if(ret == 0){\n      reg.pedo_deb_reg.deb_time = val;\n      ret = lsm6dsl_write_reg(ctx, LSM6DSL_PEDO_DEB_REG, &reg.byte, 1);\n      if(ret == 0){\n        ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n      }\n    }\n  }\n  return ret;\n}\n\n/**\n  * @brief  pedo_timeout: [get] Debounce time. If the time between two\n  *                             consecutive steps is greater than\n  *                             DEB_TIME*80ms, the debouncer is reactivated.\n  *                             Default value: 01101\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of deb_time in reg PEDO_DEB_REG\n  *\n  */\nint32_t lsm6dsl_pedo_timeout_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);\n  if(ret == 0){\n    ret = lsm6dsl_read_reg(ctx, LSM6DSL_PEDO_DEB_REG, &reg.byte, 1);\n    if(ret == 0){\n      *val = reg.pedo_deb_reg.deb_time;\n      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n    }\n  }\n  return ret;\n}\n\n/**\n  * @brief  pedo_steps_period: [set] Time period register for step\n  *                                  detection on delta time (r/w).\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that contains data to write\n  *\n  */\nint32_t lsm6dsl_pedo_steps_period_set(lsm6dsl_ctx_t *ctx, uint8_t *buff)\n{\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);\n  if(ret == 0){\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_STEP_COUNT_DELTA, buff, 1);\n    if(ret == 0){\n      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n    }\n  }\n  return ret;\n}\n\n/**\n  * @brief  pedo_steps_period: [get] Time period register for step\n  *                                  detection on delta time (r/w).\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lsm6dsl_pedo_steps_period_get(lsm6dsl_ctx_t *ctx, uint8_t *buff)\n{\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);\n  if(ret == 0){\n    ret = lsm6dsl_read_reg(ctx, LSM6DSL_STEP_COUNT_DELTA, buff, 1);\n    if(ret == 0){\n      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n    }\n  }\n  return ret;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  significant_motion\n  * @brief   This section groups all the functions that manage the\n  *          significant motion detection.\n  * @{\n  */\n\n/**\n  * @brief  motion_sens: [set]  Enable significant motion detection function.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of sign_motion_en in reg CTRL10_C\n  *\n  */\nint32_t lsm6dsl_motion_sens_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL10_C, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl10_c.sign_motion_en = val;\n    if (val != 0x00U) {\n      reg.ctrl10_c.func_en = val;\n      ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL10_C, &reg.byte, 1);\n    }\n  }\n  return ret;\n}\n\n/**\n  * @brief  motion_sens: [get]  Enable significant motion detection function.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of sign_motion_en in reg CTRL10_C\n  *\n  */\nint32_t lsm6dsl_motion_sens_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL10_C, &reg.byte, 1);\n  *val = reg.ctrl10_c.sign_motion_en;\n\n  return ret;\n}\n\n/**\n  * @brief  motion_threshold: [set]  Significant motion threshold.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that store significant motion threshold.\n  *\n  */\nint32_t lsm6dsl_motion_threshold_set(lsm6dsl_ctx_t *ctx, uint8_t *buff)\n{\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);\n  if(ret == 0){\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_SM_THS, buff, 1);\n    if(ret == 0){\n      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n    }\n  }\n  return ret;\n}\n\n/**\n  * @brief  motion_threshold: [get]  Significant motion threshold.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that store significant motion threshold.\n  *\n  */\nint32_t lsm6dsl_motion_threshold_get(lsm6dsl_ctx_t *ctx, uint8_t *buff)\n{\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);\n  if(ret == 0){\n    ret = lsm6dsl_read_reg(ctx, LSM6DSL_SM_THS, buff, 1);\n    if(ret == 0){\n      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n    }\n  }\n  return ret;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  tilt_detection\n  * @brief   This section groups all the functions that manage the tilt\n  *          event detection.\n  * @{\n  */\n\n/**\n  * @brief  tilt_sens: [set]  Enable tilt calculation.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of tilt_en in reg CTRL10_C\n  *\n  */\nint32_t lsm6dsl_tilt_sens_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL10_C, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl10_c.tilt_en = val;\n    if (val != 0x00U) {\n      reg.ctrl10_c.func_en = val;\n    }\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL10_C, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  tilt_sens: [get]  Enable tilt calculation.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of tilt_en in reg CTRL10_C\n  *\n  */\nint32_t lsm6dsl_tilt_sens_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL10_C, &reg.byte, 1);\n  *val = reg.ctrl10_c.tilt_en;\n\n  return ret;\n}\n\n/**\n  * @brief  wrist_tilt: [set]  Enable tilt calculation.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of tilt_en in reg CTRL10_C\n  *\n  */\nint32_t lsm6dsl_wrist_tilt_sens_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL10_C, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl10_c.wrist_tilt_en = val;\n    if (val != 0x00U) {\n      reg.ctrl10_c.func_en = val;\n    }\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL10_C, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  wrist_tilt: [get]  Enable tilt calculation.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of tilt_en in reg CTRL10_C\n  *\n  */\nint32_t lsm6dsl_wrist_tilt_sens_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL10_C, &reg.byte, 1);\n  *val = reg.ctrl10_c.wrist_tilt_en;\n\n  return ret;\n}\n\n/**\n  * @brief  tilt_latency: [set] Absolute Wrist Tilt latency register (r/w).\n  *                             Absolute wrist tilt latency parameters.\n  *                             1 LSB = 40 ms. Default value: 0Fh (600 ms).\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that contains data to write\n  *\n  */\nint32_t lsm6dsl_tilt_latency_set(lsm6dsl_ctx_t *ctx, uint8_t *buff)\n{\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_B);\n  if(ret == 0){\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_A_WRIST_TILT_LAT, buff, 1);\n    if(ret == 0){\n      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n    }\n  }\n  return ret;\n}\n\n/**\n  * @brief  tilt_latency: [get] Absolute Wrist Tilt latency register (r/w).\n  *                             Absolute wrist tilt latency parameters.\n  *                             1 LSB = 40 ms. Default value: 0Fh (600 ms).\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lsm6dsl_tilt_latency_get(lsm6dsl_ctx_t *ctx, uint8_t *buff)\n{\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_B);\n  if(ret == 0){\n    ret = lsm6dsl_read_reg(ctx, LSM6DSL_A_WRIST_TILT_LAT, buff, 1);\n    if(ret == 0){\n      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n    }\n  }\n  return ret;\n}\n\n/**\n  * @brief  tilt_threshold: [set] Absolute Wrist Tilt threshold register(r/w).\n  *                               Absolute wrist tilt threshold parameters.\n  *                               1 LSB = 15.625 mg.\n  *                               Default value: 20h (500 mg).\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that contains data to write\n  *\n  */\nint32_t lsm6dsl_tilt_threshold_set(lsm6dsl_ctx_t *ctx, uint8_t *buff)\n{\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_B);\n  if(ret == 0){\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_A_WRIST_TILT_THS, buff, 1);\n    if(ret == 0){\n      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n    }\n  }\n  return ret;\n}\n\n/**\n  * @brief  tilt_threshold: [get] Absolute Wrist Tilt threshold register(r/w).\n  *                               Absolute wrist tilt threshold parameters.\n  *                               1 LSB = 15.625 mg.\n  *                               Default value: 20h (500 mg).\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lsm6dsl_tilt_threshold_get(lsm6dsl_ctx_t *ctx, uint8_t *buff)\n{\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_B);\n  if(ret == 0){\n    ret = lsm6dsl_read_reg(ctx, LSM6DSL_A_WRIST_TILT_THS, buff, 1);\n    if(ret == 0){\n      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n    }\n  }\n  return ret;\n}\n\n/**\n  * @brief  tilt_src: [set]  Absolute Wrist Tilt mask register (r/w).\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_a_wrist_tilt_mask: registers A_WRIST_TILT_MASK\n  *\n  */\nint32_t lsm6dsl_tilt_src_set(lsm6dsl_ctx_t *ctx,\n                             lsm6dsl_a_wrist_tilt_mask_t *val)\n{\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_B);\n  if(ret == 0){\n    ret = lsm6dsl_read_reg(ctx, LSM6DSL_A_WRIST_TILT_MASK,\n                           (uint8_t*) val, 1);\n    if(ret == 0){\n      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n    }\n  }\n  return ret;\n}\n\n/**\n  * @brief  tilt_src: [get]  Absolute Wrist Tilt mask register (r/w).\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_a_wrist_tilt_mask: registers A_WRIST_TILT_MASK\n  *\n  */\nint32_t lsm6dsl_tilt_src_get(lsm6dsl_ctx_t *ctx,\n                             lsm6dsl_a_wrist_tilt_mask_t *val)\n{\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_B);\n  if(ret == 0){\n    ret = lsm6dsl_read_reg(ctx, LSM6DSL_A_WRIST_TILT_MASK,\n                           (uint8_t*) val, 1);\n    if(ret == 0){\n      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n    }\n  }\n  return ret;\n\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup   magnetometer_sensor\n  * @brief   This section groups all the functions that manage additional\n  *          magnetometer sensor.\n  * @{\n  */\n\n/**\n  * @brief  mag_soft_iron: [set] Enable soft-iron correction algorithm for\n  *                              magnetometer.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of soft_en in reg CTRL9_XL\n  *\n  */\nint32_t lsm6dsl_mag_soft_iron_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL9_XL, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl9_xl.soft_en = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL9_XL, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  mag_soft_iron: [get] Enable soft-iron correction algorithm\n  *                              for magnetometer.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of soft_en in reg CTRL9_XL\n  *\n  */\nint32_t lsm6dsl_mag_soft_iron_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL9_XL, &reg.byte, 1);\n  *val = reg.ctrl9_xl.soft_en;\n\n  return ret;\n}\n\n/**\n  * @brief  mag_hard_iron: [set] Enable hard-iron correction algorithm\n  *                              for magnetometer.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of iron_en in reg MASTER_CONFIG\n  *\n  */\nint32_t lsm6dsl_mag_hard_iron_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CONFIG, &reg.byte, 1);\n  if(ret == 0){\n    reg.master_config.iron_en = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_MASTER_CONFIG, &reg.byte, 1);\n    if(ret == 0){\n      ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL10_C, &reg.byte, 1);\n      if(ret == 0){\n        if (val != 0x00U) {\n          reg.ctrl10_c.func_en = val;\n        }\n        ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL10_C, &reg.byte, 1);\n      }\n    }\n  }\n  return ret;\n}\n\n/**\n  * @brief  mag_hard_iron: [get] Enable hard-iron correction algorithm\n  *                              for magnetometer.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of iron_en in reg MASTER_CONFIG\n  *\n  */\nint32_t lsm6dsl_mag_hard_iron_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CONFIG, &reg.byte, 1);\n  *val = reg.master_config.iron_en;\n\n  return ret;\n}\n\n/**\n  * @brief  mag_soft_iron_mat: [set] 3x3 soft iron matrix. Value are\n  *                                  expressed in sign-module format.\n  *                                  (Es. SVVVVVVVb where S is the sign 0/+\n  *                                  1/- and V is the value).\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that contains data to write\n  *\n  */\nint32_t lsm6dsl_mag_soft_iron_mat_set(lsm6dsl_ctx_t *ctx, uint8_t *buff)\n{\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);\n  if(ret == 0){\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_MAG_SI_XX, buff, 9);\n    if(ret == 0){\n      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n    }\n  }\n  return ret;\n}\n\n/**\n  * @brief  mag_soft_iron_mat: [get] 3x3 soft iron matrix. Value are\n  *                                  expressed in sign-module format.\n  *                                  (Es. SVVVVVVVb where S is the sign 0/+\n  *                                  1/- and V is the value).\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lsm6dsl_mag_soft_iron_mat_get(lsm6dsl_ctx_t *ctx, uint8_t *buff)\n{\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);\n  if(ret == 0){\n    ret = lsm6dsl_read_reg(ctx, LSM6DSL_MAG_SI_XX, buff, 9);\n    if(ret == 0){\n      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n    }\n  }\n  return ret;\n}\n\n/**\n  * @brief  mag_offset: [set] Offset for hard-iron compensation\n  *                           register (r/w). The value is expressed as\n  *                           a 16-bit word in twos complement.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that contains data to write\n  *\n  */\nint32_t lsm6dsl_mag_offset_set(lsm6dsl_ctx_t *ctx, uint8_t *buff)\n{\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);\n  if(ret == 0){\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_MAG_OFFX_L, buff, 6);\n    if(ret == 0){\n      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n    }\n  }\n  return ret;\n}\n\n/**\n  * @brief  mag_offset: [get] Offset for hard-iron compensation register(r/w).\n  *                           The value is expressed as a 16-bit word in\n  *                           twos complement.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t * : buffer that stores data read\n  *\n  */\nint32_t lsm6dsl_mag_offset_get(lsm6dsl_ctx_t *ctx, uint8_t *buff)\n{\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);\n  if(ret == 0){\n    ret = lsm6dsl_read_reg(ctx, LSM6DSL_MAG_OFFX_L, buff, 6);\n    if(ret == 0){\n      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n    }\n  }\n  return ret;\n}\n\n/**\n  * @}\n  */\n\n/**\n  * @addtogroup  Sensor_hub\n  * @brief   This section groups all the functions that manage the sensor\n  *          hub functionality.\n  * @{\n  */\n\n  /**\n  * @brief  func_en: [set] Enable function.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values func_en\n  *\n  */\nint32_t lsm6dsl_func_en_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL10_C, &reg.byte, 1);\n  if(ret == 0){\n    reg.ctrl10_c.func_en = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL10_C, &reg.byte, 1);\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  sh_sync_sens_frame: [set] Sensor synchronization time frame\n  *                                   with the step of 500 ms and full range\n  *                                   of 5 s. Unsigned 8-bit.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of tph in reg SENSOR_SYNC_TIME_FRAME\n  *\n  */\nint32_t lsm6dsl_sh_sync_sens_frame_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_SENSOR_SYNC_TIME_FRAME,\n                              &reg.byte, 1);\n  if(ret == 0){\n    reg. sensor_sync_time_frame.tph = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_SENSOR_SYNC_TIME_FRAME,\n                            &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  sh_sync_sens_frame: [get] Sensor synchronization time frame with\n  *                                   the step of 500 ms and full range of 5s.\n  *                                   Unsigned 8-bit.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of tph in reg  SENSOR_SYNC_TIME_FRAME\n  *\n  */\nint32_t lsm6dsl_sh_sync_sens_frame_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_SENSOR_SYNC_TIME_FRAME,\n                         &reg.byte, 1);\n  *val = reg. sensor_sync_time_frame.tph;\n\n  return ret;\n}\n\n/**\n  * @brief  sh_sync_sens_ratio: [set] Resolution ratio of error code for\n  *                                   sensor synchronization\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_rr_t: change the values of rr in reg  SENSOR_SYNC_RES_RATIO\n  *\n  */\nint32_t lsm6dsl_sh_sync_sens_ratio_set(lsm6dsl_ctx_t *ctx, lsm6dsl_rr_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_SENSOR_SYNC_RES_RATIO,\n                              &reg.byte, 1);\n  if(ret == 0){\n    reg.sensor_sync_res_ratio.rr = (uint8_t) val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_SENSOR_SYNC_RES_RATIO,\n                            &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  sh_sync_sens_ratio: [get] Resolution ratio of error code\n  *                                   for sensor synchronization\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_rr_t: Get the values of rr in reg  SENSOR_SYNC_RES_RATIO\n  *\n  */\nint32_t lsm6dsl_sh_sync_sens_ratio_get(lsm6dsl_ctx_t *ctx, lsm6dsl_rr_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_SENSOR_SYNC_RES_RATIO,\n                              &reg.byte, 1);\n\n  switch (reg. sensor_sync_res_ratio.rr) {\n    case LSM6DSL_RES_RATIO_2_11:\n      *val = LSM6DSL_RES_RATIO_2_11;\n      break;\n    case LSM6DSL_RES_RATIO_2_12:\n      *val = LSM6DSL_RES_RATIO_2_12;\n      break;\n    case LSM6DSL_RES_RATIO_2_13:\n      *val = LSM6DSL_RES_RATIO_2_13;\n      break;\n    case LSM6DSL_RES_RATIO_2_14:\n      *val = LSM6DSL_RES_RATIO_2_14;\n      break;\n    default:\n      *val = LSM6DSL_RES_RATIO_ND;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  sh_master: [set]  Sensor hub I2C master enable.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of master_on in reg MASTER_CONFIG\n  *\n  */\nint32_t lsm6dsl_sh_master_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CONFIG, &reg.byte, 1);\n  if(ret == 0){\n    reg.master_config.master_on = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_MASTER_CONFIG, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  sh_master: [get]  Sensor hub I2C master enable.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of master_on in reg MASTER_CONFIG\n  *\n  */\nint32_t lsm6dsl_sh_master_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CONFIG, &reg.byte, 1);\n  *val = reg.master_config.master_on;\n\n  return ret;\n}\n\n/**\n  * @brief  sh_pass_through: [set]  I2C interface pass-through.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of pass_through_mode in\n  *                      reg MASTER_CONFIG\n  *\n  */\nint32_t lsm6dsl_sh_pass_through_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CONFIG, &reg.byte, 1);\n  if(ret == 0){\n    reg.master_config.pass_through_mode = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_MASTER_CONFIG, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  sh_pass_through: [get]  I2C interface pass-through.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of pass_through_mode in\n  *                  reg MASTER_CONFIG\n  *\n  */\nint32_t lsm6dsl_sh_pass_through_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CONFIG, &reg.byte, 1);\n  *val = reg.master_config.pass_through_mode;\n\n  return ret;\n}\n\n/**\n  * @brief  sh_pin_mode: [set]  Master I2C pull-up enable/disable.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_pull_up_en_t: change the values of pull_up_en in\n  *                               reg MASTER_CONFIG\n  *\n  */\nint32_t lsm6dsl_sh_pin_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_pull_up_en_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CONFIG, &reg.byte, 1);\n  if(ret == 0){\n    reg.master_config.pull_up_en = (uint8_t) val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_MASTER_CONFIG, &reg.byte, 1);\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  sh_pin_mode: [get]  Master I2C pull-up enable/disable.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_pull_up_en_t: Get the values of pull_up_en in\n  *                               reg MASTER_CONFIG\n  *\n  */\nint32_t lsm6dsl_sh_pin_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_pull_up_en_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CONFIG, &reg.byte, 1);\n  switch (reg.master_config.pull_up_en) {\n    case LSM6DSL_EXT_PULL_UP:\n      *val = LSM6DSL_EXT_PULL_UP;\n      break;\n    case LSM6DSL_INTERNAL_PULL_UP:\n      *val = LSM6DSL_INTERNAL_PULL_UP;\n      break;\n    default:\n      *val = LSM6DSL_SH_PIN_MODE;\n      break;\n  }\n  return ret;\n}\n\n/**\n  * @brief  sh_syncro_mode: [set]  Sensor hub trigger signal selection.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_start_config_t: change the values of start_config in\n  *                                 reg MASTER_CONFIG\n  *\n  */\nint32_t lsm6dsl_sh_syncro_mode_set(lsm6dsl_ctx_t *ctx,\n                                   lsm6dsl_start_config_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CONFIG, &reg.byte, 1);\n  if(ret == 0){\n    reg.master_config.start_config = (uint8_t)val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_MASTER_CONFIG, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  sh_syncro_mode: [get] Sensor hub trigger signal selection.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_start_config_t: Get the values of start_config in\n  *                                 reg MASTER_CONFIG\n  *\n  */\nint32_t lsm6dsl_sh_syncro_mode_get(lsm6dsl_ctx_t *ctx,\n                                   lsm6dsl_start_config_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CONFIG, &reg.byte, 1);\n  switch (reg.master_config.start_config) {\n    case LSM6DSL_XL_GY_DRDY:\n      *val = LSM6DSL_XL_GY_DRDY;\n      break;\n    case LSM6DSL_EXT_ON_INT2_PIN:\n      *val = LSM6DSL_EXT_ON_INT2_PIN;\n      break;\n    default:\n      *val = LSM6DSL_SH_SYNCRO_ND;\n      break;\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  sh_drdy_on_int1: [set] Manage the Master DRDY signal on INT1 pad.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of drdy_on_int1 in\n  *                      reg MASTER_CONFIG\n  *\n  */\nint32_t lsm6dsl_sh_drdy_on_int1_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CONFIG, &reg.byte, 1);\n  if(ret == 0){\n    reg.master_config.drdy_on_int1 = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_MASTER_CONFIG, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  sh_drdy_on_int1: [get]  Manage the Master DRDY signal on INT1 pad.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of drdy_on_int1 in reg MASTER_CONFIG\n  *\n  */\nint32_t lsm6dsl_sh_drdy_on_int1_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CONFIG, &reg.byte, 1);\n  *val = reg.master_config.drdy_on_int1;\n\n  return ret;\n}\n\n/**\n  * @brief  sh_read_data_raw: [get]  Sensor hub output registers.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_: union of registers from SENSORHUB1_REG to\n  *\n  */\nint32_t lsm6dsl_sh_read_data_raw_get(lsm6dsl_ctx_t *ctx,\n                                     lsm6dsl_emb_sh_read_t *val)\n{\n  int32_t ret;\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_SENSORHUB1_REG,\n                              &(val->byte[0]), 12);\n  if(ret == 0){\n    ret = lsm6dsl_read_reg(ctx, LSM6DSL_SENSORHUB13_REG,\n                           &(val->byte[12]), 6);\n  }\n  return ret;\n}\n\n/**\n  * @brief  sh_cmd_sens_sync: [set] Master command code used for stamping\n  *                                 for sensor sync.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of master_cmd_code in\n  *                      reg MASTER_CMD_CODE\n  *\n  */\nint32_t lsm6dsl_sh_cmd_sens_sync_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CMD_CODE, &reg.byte, 1);\n  if(ret == 0){\n    reg.master_cmd_code.master_cmd_code = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_MASTER_CMD_CODE, &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  sh_cmd_sens_sync: [get] Master command code used for stamping\n  *                                 for sensor sync.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of master_cmd_code in\n  *                  reg MASTER_CMD_CODE\n  *\n  */\nint32_t lsm6dsl_sh_cmd_sens_sync_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CMD_CODE, &reg.byte, 1);\n  *val = reg.master_cmd_code.master_cmd_code;\n\n  return ret;\n}\n\n/**\n  * @brief  sh_spi_sync_error: [set] Error code used for sensor\n  *                                  synchronization.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t val: change the values of error_code in\n  *                      reg SENS_SYNC_SPI_ERROR_CODE\n  *\n  */\nint32_t lsm6dsl_sh_spi_sync_error_set(lsm6dsl_ctx_t *ctx, uint8_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_SENS_SYNC_SPI_ERROR_CODE,\n                              &reg.byte, 1);\n  if(ret == 0){\n    reg. sens_sync_spi_error_code.error_code = val;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_SENS_SYNC_SPI_ERROR_CODE,\n                            &reg.byte, 1);\n  }\n  return ret;\n}\n\n/**\n  * @brief  sh_spi_sync_error: [get] Error code used for sensor\n  *                                  synchronization.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  uint8_t: change the values of error_code in\n  *                  reg SENS_SYNC_SPI_ERROR_CODE\n  *\n  */\nint32_t lsm6dsl_sh_spi_sync_error_get(lsm6dsl_ctx_t *ctx, uint8_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_read_reg(ctx, LSM6DSL_SENS_SYNC_SPI_ERROR_CODE,\n                              &reg.byte, 1);\n  *val = reg. sens_sync_spi_error_code.error_code;\n\n  return ret;\n}\n\n/**\n  * @brief   sh_num_of_dev_connected: [set] Number of external sensors to\n  *                                         be read by the sensor hub.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_aux_sens_on_t: change the values of aux_sens_on in\n  *                                reg SLAVE0_CONFIG\n  *\n  */\nint32_t lsm6dsl_sh_num_of_dev_connected_set(lsm6dsl_ctx_t *ctx,\n                                            lsm6dsl_aux_sens_on_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);\n  if(ret == 0){\n    ret = lsm6dsl_read_reg(ctx, LSM6DSL_SLAVE0_CONFIG, &reg.byte, 1);\n    if(ret == 0){\n      reg.slave0_config.aux_sens_on = (uint8_t) val;\n      ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLAVE0_CONFIG, &reg.byte, 1);\n      if(ret == 0){\n        ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n      }\n    }\n  }\n  return ret;\n}\n\n/**\n  * @brief   sh_num_of_dev_connected: [get] Number of external sensors to\n  *                                         be read by the sensor hub.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_aux_sens_on_t: Get the values of aux_sens_on in\n  *                                reg SLAVE0_CONFIG\n  *\n  */\nint32_t lsm6dsl_sh_num_of_dev_connected_get(lsm6dsl_ctx_t *ctx,\n                                            lsm6dsl_aux_sens_on_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);\n  if(ret == 0){\n    ret = lsm6dsl_read_reg(ctx, LSM6DSL_SLAVE0_CONFIG, &reg.byte, 1);\n    if(ret == 0){\n      switch (reg.slave0_config.aux_sens_on) {\n        case LSM6DSL_SLV_0:\n          *val = LSM6DSL_SLV_0;\n          break;\n        case LSM6DSL_SLV_0_1:\n          *val = LSM6DSL_SLV_0_1;\n          break;\n        case LSM6DSL_SLV_0_1_2:\n          *val = LSM6DSL_SLV_0_1_2;\n          break;\n        case LSM6DSL_SLV_0_1_2_3:\n          *val = LSM6DSL_SLV_0_1_2_3;\n          break;\n        default:\n          *val = LSM6DSL_SLV_EN_ND;\n          break;\n      }\n      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n    }\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  sh_cfg_write: Configure slave 0 for perform a write.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_sh_cfg_write_t: a structure that contain\n  *                      - uint8_t slv_add;    8 bit i2c device address\n  *                      - uint8_t slv_subadd; 8 bit register device address\n  *                      - uint8_t slv_data;   8 bit data to write\n  *\n  */\nint32_t lsm6dsl_sh_cfg_write(lsm6dsl_ctx_t *ctx, lsm6dsl_sh_cfg_write_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);\n  if(ret == 0){\n    reg.byte = val->slv0_add;\n    reg.slv0_add.rw_0 = 0;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLV0_ADD, &reg.byte, 1);\n    if(ret == 0){\n      ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLV0_SUBADD,\n                                   &(val->slv0_subadd), 1);\n      if(ret == 0){\n        ret = lsm6dsl_write_reg(ctx, LSM6DSL_DATAWRITE_SRC_MODE_SUB_SLV0,\n                                    &(val->slv0_data), 1);\n        if(ret == 0){\n          ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n        }\n      }\n    }\n  }\n  return ret;\n}\n\n/**\n  * @brief  sh_slv0_cfg_read: [get] Configure slave 0 for perform a write/read.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_sh_cfg_read_t: a structure that contain\n  *                      - uint8_t slv_add;    8 bit i2c device address\n  *                      - uint8_t slv_subadd; 8 bit register device address\n  *                      - uint8_t slv_len;    num of bit to read\n  *\n  */\nint32_t lsm6dsl_sh_slv0_cfg_read(lsm6dsl_ctx_t *ctx,\n                                 lsm6dsl_sh_cfg_read_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);\n  if(ret == 0){\n    reg.byte = val->slv_add;\n    reg.slv0_add.rw_0 = 1;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLV0_ADD, &reg.byte, 1);\n    if(ret == 0){\n      ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLV0_SUBADD,\n                                   &(val->slv_subadd), 1);\n      if(ret == 0){\n        ret = lsm6dsl_read_reg(ctx, LSM6DSL_SLAVE0_CONFIG, &reg.byte, 1);\n        reg.slave0_config.slave0_numop = val->slv_len;\n        if(ret == 0){\n          ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLAVE0_CONFIG, &reg.byte, 1);\n          if(ret == 0){\n            ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n          }\n        }\n      }\n    }\n  }\n  return ret;\n}\n\n/**\n  * @brief  sh_slv1_cfg_read: [get] Configure slave 0 for perform a write/read.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_sh_cfg_read_t: a structure that contain\n  *                      - uint8_t slv_add;    8 bit i2c device address\n  *                      - uint8_t slv_subadd; 8 bit register device address\n  *                      - uint8_t slv_len;    num of bit to read\n  *\n  */\nint32_t lsm6dsl_sh_slv1_cfg_read(lsm6dsl_ctx_t *ctx,\n                                 lsm6dsl_sh_cfg_read_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);\n  if(ret == 0){\n    reg.byte = val->slv_add;\n    reg.slv1_add.r_1 = 1;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLV1_ADD, &reg.byte, 1);\n    if(ret == 0){\n      ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLV1_SUBADD,\n                                   &(val->slv_subadd), 1);\n      if(ret == 0){\n        ret = lsm6dsl_read_reg(ctx, LSM6DSL_SLAVE1_CONFIG, &reg.byte, 1);\n        reg.slave1_config.slave1_numop = val->slv_len;\n        if(ret == 0){\n          ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLAVE1_CONFIG, &reg.byte, 1);\n          if(ret == 0){\n            ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n          }\n        }\n      }\n    }\n  }\n  return ret;\n}\n\n/**\n  * @brief  sh_slv2_cfg_read: [get] Configure slave 0 for perform a write/read.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_sh_cfg_read_t: a structure that contain\n  *                      - uint8_t slv_add;    8 bit i2c device address\n  *                      - uint8_t slv_subadd; 8 bit register device address\n  *                      - uint8_t slv_len;    num of bit to read\n  *\n  */\nint32_t lsm6dsl_sh_slv2_cfg_read(lsm6dsl_ctx_t *ctx,\n                                 lsm6dsl_sh_cfg_read_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);\n  if(ret == 0){\n    reg.byte = val->slv_add;\n    reg.slv2_add.r_2 = 1;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLV2_ADD, &reg.byte, 1);\n    if(ret == 0){\n      ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLV2_SUBADD,\n                              &(val->slv_subadd), 1);\n      if(ret == 0){\n        ret = lsm6dsl_read_reg(ctx, LSM6DSL_SLAVE2_CONFIG, &reg.byte, 1);\n        if(ret == 0){\n          reg.slave2_config.slave2_numop = val->slv_len;\n          ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLAVE2_CONFIG, &reg.byte, 1);\n          if(ret == 0){\n            ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n          }\n        }\n      }\n    }\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  sh_slv3_cfg_read: [get] Configure slave 0 for perform a write/read.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_sh_cfg_read_t: a structure that contain\n  *                      - uint8_t slv_add;    8 bit i2c device address\n  *                      - uint8_t slv_subadd; 8 bit register device address\n  *                      - uint8_t slv_len;    num of bit to read\n  *\n  */\nint32_t lsm6dsl_sh_slv3_cfg_read(lsm6dsl_ctx_t *ctx,\n                                 lsm6dsl_sh_cfg_read_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);\n  if(ret == 0){\n    reg.byte = val->slv_add;\n    reg.slv3_add.r_3 = 1;\n    ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLV3_ADD, &reg.byte, 1);\n    if(ret == 0){\n      ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLV3_SUBADD,\n                                   &(val->slv_subadd), 1);\n      if(ret == 0){\n        ret = lsm6dsl_read_reg(ctx, LSM6DSL_SLAVE3_CONFIG, &reg.byte, 1);\n        if(ret == 0){\n          reg.slave3_config.slave3_numop = val->slv_len;\n          ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLAVE3_CONFIG, &reg.byte, 1);\n          if(ret == 0){\n            ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n          }\n        }\n      }\n    }\n  }\n  return ret;\n}\n\n/**\n  * @brief  sh_slave_0_dec: [set] Decimation of read operation on Slave 0\n  *                               starting from the sensor hub trigger.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_slave0_rate_t: change the values of slave0_rate in\n  *                                reg SLAVE0_CONFIG\n  *\n  */\nint32_t lsm6dsl_sh_slave_0_dec_set(lsm6dsl_ctx_t *ctx,\n                                   lsm6dsl_slave0_rate_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);\n  if(ret == 0){\n    ret = lsm6dsl_read_reg(ctx, LSM6DSL_SLAVE0_CONFIG, &reg.byte, 1);\n    if(ret == 0){\n      reg.slave0_config.slave0_rate = (uint8_t) val;\n      ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLAVE0_CONFIG, &reg.byte, 1);\n      if(ret == 0){\n        ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n      }\n    }\n  }\n  return ret;\n}\n\n/**\n  * @brief  sh_slave_0_dec: [get] Decimation of read operation on Slave 0\n  *                               starting from the sensor hub trigger.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_slave0_rate_t: Get the values of slave0_rate in\n  *                                reg SLAVE0_CONFIG\n  *\n  */\nint32_t lsm6dsl_sh_slave_0_dec_get(lsm6dsl_ctx_t *ctx,\n                                   lsm6dsl_slave0_rate_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);\n  if(ret == 0){\n    ret = lsm6dsl_read_reg(ctx, LSM6DSL_SLAVE0_CONFIG, &reg.byte, 1);\n    if(ret == 0){\n      switch (reg.slave0_config.slave0_rate) {\n        case LSM6DSL_SL0_NO_DEC:\n          *val = LSM6DSL_SL0_NO_DEC;\n          break;\n        case LSM6DSL_SL0_DEC_2:\n          *val = LSM6DSL_SL0_DEC_2;\n          break;\n        case LSM6DSL_SL0_DEC_4:\n          *val = LSM6DSL_SL0_DEC_4;\n          break;\n        case LSM6DSL_SL0_DEC_8:\n          *val = LSM6DSL_SL0_DEC_8;\n          break;\n        default:\n          *val = LSM6DSL_SL0_DEC_ND;\n          break;\n      }\n      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n    }\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  sh_write_mode: [set] Slave 0 write operation is performed only\n  *                              at the first sensor hub cycle.\n  *                              This is effective if the Aux_sens_on[1:0]\n  *                              field in SLAVE0_CONFIG (04h) is set to a\n  *                              value other than 00.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_write_once_t: change the values of write_once in\n  *                               reg SLAVE1_CONFIG\n  *\n  */\nint32_t lsm6dsl_sh_write_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_write_once_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);\n  if(ret == 0){\n    ret = lsm6dsl_read_reg(ctx, LSM6DSL_SLAVE1_CONFIG, &reg.byte, 1);\n    reg.slave1_config.write_once = (uint8_t) val;\n    if(ret == 0){\n      ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLAVE1_CONFIG, &reg.byte, 1);\n      if(ret == 0){\n        ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n      }\n    }\n  }\n  return ret;\n}\n\n/**\n  * @brief  sh_write_mode: [get] Slave 0 write operation is performed only\n  *                              at the first sensor hub cycle.\n  *                              This is effective if the Aux_sens_on[1:0]\n  *                              field in SLAVE0_CONFIG (04h) is set to a\n  *                              value other than 00\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_write_once_t: Get the values of write_once in\n  *                               reg SLAVE1_CONFIG\n  *\n  */\nint32_t lsm6dsl_sh_write_mode_get(lsm6dsl_ctx_t *ctx,\n                                  lsm6dsl_write_once_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);\n  if(ret == 0){\n    ret = lsm6dsl_read_reg(ctx, LSM6DSL_SLAVE1_CONFIG, &reg.byte, 1);\n    if(ret == 0){\n      switch (reg.slave1_config.write_once) {\n        case LSM6DSL_EACH_SH_CYCLE:\n          *val = LSM6DSL_EACH_SH_CYCLE;\n          break;\n        case LSM6DSL_ONLY_FIRST_CYCLE:\n          *val = LSM6DSL_ONLY_FIRST_CYCLE;\n          break;\n        default:\n          *val = LSM6DSL_SH_WR_MODE_ND;\n          break;\n      }\n      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n    }\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  sh_slave_1_dec: [set] Decimation of read operation on Slave 1\n  *                               starting from the sensor hub trigger.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_slave1_rate_t: change the values of slave1_rate in\n  *                                reg SLAVE1_CONFIG\n  *\n  */\nint32_t lsm6dsl_sh_slave_1_dec_set(lsm6dsl_ctx_t *ctx,\n                                   lsm6dsl_slave1_rate_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);\n  if(ret == 0){\n    ret = lsm6dsl_read_reg(ctx, LSM6DSL_SLAVE1_CONFIG, &reg.byte, 1);\n    if(ret == 0){\n      reg.slave1_config.slave1_rate = (uint8_t) val;\n      ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLAVE1_CONFIG, &reg.byte, 1);\n      if(ret == 0){\n          ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n      }\n    }\n  }\n  return ret;\n}\n\n/**\n  * @brief  sh_slave_1_dec: [get] Decimation of read operation on Slave 1\n  *                               starting from the sensor hub trigger.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_slave1_rate_t: Get the values of slave1_rate in\n  *                                reg SLAVE1_CONFIG\n  *\n  */\nint32_t lsm6dsl_sh_slave_1_dec_get(lsm6dsl_ctx_t *ctx,\n                                   lsm6dsl_slave1_rate_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);\n  if(ret == 0){\n    ret = lsm6dsl_read_reg(ctx, LSM6DSL_SLAVE1_CONFIG, &reg.byte, 1);\n    if(ret == 0){\n      switch (reg.slave1_config.slave1_rate) {\n        case LSM6DSL_SL1_NO_DEC:\n          *val = LSM6DSL_SL1_NO_DEC;\n          break;\n        case LSM6DSL_SL1_DEC_2:\n          *val = LSM6DSL_SL1_DEC_2;\n          break;\n        case LSM6DSL_SL1_DEC_4:\n          *val = LSM6DSL_SL1_DEC_4;\n          break;\n        case LSM6DSL_SL1_DEC_8:\n          *val = LSM6DSL_SL1_DEC_8;\n          break;\n        default:\n          *val = LSM6DSL_SL1_DEC_ND;\n          break;\n      }\n      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n    }\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  sh_slave_2_dec: [set] Decimation of read operation on Slave 2\n  *                               starting from the sensor hub trigger.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_slave2_rate_t: change the values of slave2_rate in\n  *                                reg SLAVE2_CONFIG\n  *\n  */\nint32_t lsm6dsl_sh_slave_2_dec_set(lsm6dsl_ctx_t *ctx,\n                                   lsm6dsl_slave2_rate_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);\n  if(ret == 0){\n    ret = lsm6dsl_read_reg(ctx, LSM6DSL_SLAVE2_CONFIG, &reg.byte, 1);\n    if(ret == 0){\n      reg.slave2_config.slave2_rate =(uint8_t) val;\n      ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLAVE2_CONFIG, &reg.byte, 1);\n      if(ret == 0){\n        ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n      }\n    }\n  }\n  return ret;\n}\n\n/**\n  * @brief  sh_slave_2_dec: [get] Decimation of read operation on Slave 2\n  *                               starting from the sensor hub trigger.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_slave2_rate_t: Get the values of slave2_rate in\n  *                                reg SLAVE2_CONFIG\n  *\n  */\nint32_t lsm6dsl_sh_slave_2_dec_get(lsm6dsl_ctx_t *ctx,\n                                   lsm6dsl_slave2_rate_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);\n  if(ret == 0){\n    ret = lsm6dsl_read_reg(ctx, LSM6DSL_SLAVE2_CONFIG, &reg.byte, 1);\n    if(ret == 0){\n      switch (reg.slave2_config.slave2_rate) {\n        case LSM6DSL_SL2_NO_DEC:\n          *val = LSM6DSL_SL2_NO_DEC;\n          break;\n        case LSM6DSL_SL2_DEC_2:\n          *val = LSM6DSL_SL2_DEC_2;\n          break;\n        case LSM6DSL_SL2_DEC_4:\n          *val = LSM6DSL_SL2_DEC_4;\n          break;\n        case LSM6DSL_SL2_DEC_8:\n          *val = LSM6DSL_SL2_DEC_8;\n          break;\n        default:\n          *val = LSM6DSL_SL2_DEC_ND;\n          break;\n      }\n      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n    }\n  }\n\n  return ret;\n}\n\n/**\n  * @brief  sh_slave_3_dec: [set] Decimation of read operation on\n  *                               Slave 3 starting from the sensor hub trigger.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_slave3_rate_t: change the values of slave3_rate in\n  *                                reg SLAVE3_CONFIG\n  *\n  */\nint32_t lsm6dsl_sh_slave_3_dec_set(lsm6dsl_ctx_t *ctx,\n                                   lsm6dsl_slave3_rate_t val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);\n  if(ret == 0){\n    ret = lsm6dsl_read_reg(ctx, LSM6DSL_SLAVE3_CONFIG, &reg.byte, 1);\n    reg.slave3_config.slave3_rate = (uint8_t)val;\n    if(ret == 0){\n      ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLAVE3_CONFIG, &reg.byte, 1);\n      if(ret == 0){\n        ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n      }\n    }\n  }\n  return ret;\n}\n\n/**\n  * @brief  sh_slave_3_dec: [get] Decimation of read operation on Slave 3\n  *                               starting from the sensor hub trigger.\n  *\n  * @param  lsm6dsl_ctx_t *ctx: read / write interface definitions\n  * @param  lsm6dsl_slave3_rate_t: Get the values of slave3_rate in\n  *                                reg SLAVE3_CONFIG\n  *\n  */\nint32_t lsm6dsl_sh_slave_3_dec_get(lsm6dsl_ctx_t *ctx,\n                                   lsm6dsl_slave3_rate_t *val)\n{\n  lsm6dsl_reg_t reg;\n  int32_t ret;\n\n  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);\n  if(ret == 0){\n    ret = lsm6dsl_read_reg(ctx, LSM6DSL_SLAVE3_CONFIG, &reg.byte, 1);\n    if(ret == 0){\n      switch (reg.slave3_config.slave3_rate) {\n        case LSM6DSL_SL3_NO_DEC:\n          *val = LSM6DSL_SL3_NO_DEC;\n          break;\n        case LSM6DSL_SL3_DEC_2:\n          *val = LSM6DSL_SL3_DEC_2;\n          break;\n        case LSM6DSL_SL3_DEC_4:\n          *val = LSM6DSL_SL3_DEC_4;\n          break;\n        case LSM6DSL_SL3_DEC_8:\n          *val = LSM6DSL_SL3_DEC_8;\n          break;\n        default:\n          *val = LSM6DSL_SL3_DEC_ND;\n          break;\n      }\n      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);\n    }\n  }\n\n  return ret;\n}\n\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/"
              }
            }
          },
          "md5": "334484c086e31835a9efc6e830bb89b5"
        }
      },
      "drivers": {
        "adc": [],
        "ble": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_BLE_BLE1"
          }
        ],
        "block": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_BLOCK_BLOCK1"
          }
        ],
        "datetime": [],
        "filesytem": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_FILESYSTEM_FILESYSTEM1"
          }
        ],
        "gpio": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_GPIO_GPIO1"
          }
        ],
        "http": [],
        "i2c": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_I2C_I2C1",
            "primary": true
          }
        ],
        "interval": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_INTERVAL_INTERVAL1"
          }
        ],
        "nfc": [],
        "pwm": [],
        "spi": [
          {
            "id": 1,
            "name": "ATMO_DRIVERINSTANCE_SPI_SPI2"
          }
        ],
        "uart": [],
        "wifi": []
      },
      "static": {
        "header": "",
        "footer": "",
        "functions": {
          "ATMO_Setup": {
            "returnType": "void",
            "code": "",
            "arguments": []
          }
        }
      }
    },
    "App View": {
      "type": "app",
      "compilerVersion": "latest",
      "variants": [],
      "meta": {
        "appViewLayouts": {
          "320": {
            "560": true
          },
          "768": {
            "1024": true
          },
          "1024": {
            "1366": true
          }
        }
      },
      "elements": [
        {
          "name": "AnalogMeter",
          "type": "AppUIAnalogMeter",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "320": {
                "560": {
                  "width": 100,
                  "height": 100,
                  "x": 15,
                  "y": 310,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "768": {
                "1024": {
                  "width": 100,
                  "height": 100,
                  "x": 0,
                  "y": 0,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "1366": {
                  "width": 100,
                  "height": 100,
                  "x": 0,
                  "y": 0,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "value": 0,
            "minValue": 0,
            "maxValue": "300"
          },
          "meta": {
            "editorX": 502,
            "editorY": 284,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": []
          }
        },
        {
          "name": "LabelAccel",
          "type": "AppUILabel",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "320": {
                "560": {
                  "width": 100,
                  "height": 100,
                  "x": 10,
                  "y": 260,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "768": {
                "1024": {
                  "width": 100,
                  "height": 100,
                  "x": 0,
                  "y": 0,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "1366": {
                  "width": 100,
                  "height": 100,
                  "x": 150,
                  "y": 320,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "text": "Accelerometer",
            "font": "28px Helvetica",
            "color": "Black",
            "alignment": "left"
          },
          "meta": {
            "editorX": 419,
            "editorY": 44,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": []
          }
        },
        {
          "name": "AccelImage",
          "type": "AppUIImage",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "320": {
                "560": {
                  "width": 200,
                  "height": 25,
                  "x": 10,
                  "y": 260,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "768": {
                "1024": {
                  "width": 100,
                  "height": 100,
                  "x": 0,
                  "y": 0,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "1366": {
                  "width": 100,
                  "height": 100,
                  "x": 0,
                  "y": 0,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "image": "data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/4QBoRXhpZgAASUkqAAgAAAADABIBAwABAAAAAQAAADEBAgAQAAAAMgAAAGmHBAABAAAAQgAAAAAAAABTaG90d2VsbCAwLjI4LjQAAgACoAkAAQAAAD0AAAADoAkAAQAAADYAAAAAAAAA/+ELs2h0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8APD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNC40LjAtRXhpdjIiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIiB4bXA6Q3JlYXRvclRvb2w9IjYuMC4xIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjNFQzBBQzY2MkI4RTExRTJBQ0FBODgyMTUzNkE1RjNGIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjNFQzBBQzY3MkI4RTExRTJBQ0FBODgyMTUzNkE1RjNGIiBleGlmOlBpeGVsWERpbWVuc2lvbj0iNjEiIGV4aWY6UGl4ZWxZRGltZW5zaW9uPSI1NCIgdGlmZjpJbWFnZVdpZHRoPSI2MSIgdGlmZjpJbWFnZUhlaWdodD0iNTQiIHRpZmY6T3JpZW50YXRpb249IjEiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpGQkYzREU1NzJCOEQxMUUyQUNBQTg4MjE1MzZBNUYzRiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpGQkYzREU1ODJCOEQxMUUyQUNBQTg4MjE1MzZBNUYzRiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8P3hwYWNrZXQgZW5kPSJ3Ij8+/+0ARFBob3Rvc2hvcCAzLjAAOEJJTQQEAAAAAAAnHAFaAAMbJUccAgAAAgACHAJBAAhTaG90d2VsbBwCRgAGMC4yOC40AP/bAEMAAwICAwICAwMDAwQDAwQFCAUFBAQFCgcHBggMCgwMCwoLCw0OEhANDhEOCwsQFhARExQVFRUMDxcYFhQYEhQVFP/bAEMBAwQEBQQFCQUFCRQNCw0UFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFP/AABEIADYAPQMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/APZ3ckyQ9ZSw+aoywWOSE8yFgNxpGcSIoXPnk5JFQs4ljWNeZedx71znrtiwHzHWIdSfvCr1rCFVVcbSGZi3rUGnRK4TJAZOc0stx9pOUJ2KpyT0oC5UvZTdhVyw2LnnvzVO8BM5c4ymBj1xVh2N3JG4+QJgYPcZquUa8u5AvA3d+wqkQ2X/ACiRE6kFdh3g9FqndalLbSGO1KmEE4JzzVvU7gW5MERwjgb39Kx/OMIMeWKqSVOPWqSTE3Y1mfaEaP7/APERTIvndCnDclj7VG7CHIUhsjk9qnQCJJnUjATJP1qbD5iZWMhcR/KqJhm9TT4cTiVkGI44vmX1qksgUuqEiFsbm9KWa+aG48yNR5AbaVH8Q96VguhquLu+Bi4QZ4/xpWkSErDH952yzn+VTfaoFjmkht/Lyucn3rOt8PMpPIHJqkiHpsJJMryOjNlZDz68VXDbnYHkDGCPSmMweQ8YGTVqwh3hwRyuBmqWhi5NkpkETPG2NpI5q2sYit5hkGMlVJ/nVFcvuhYKQzD5vSr20LBsJG0yYPvUvc2aImIBOB+4JGSKi6MHAJhZiQKfny8I3ERORikA8pArjcOce1UiLijCW8+ecgACq1ocSSE9AmafcMUjROrHk47U2BCttM3GcBaB9CoUJ6e9OE8luT5R4PXNKfuZ/ClSMsPumlexzu9y3aoblUiGA55DVaAEsUS88bmNFFJ7nUQL+9BV+ig4xT4YtxaVySIxwKKKZBVlYzyljwW4xUi82RI7t/KiimLoVliLHDHqe1bNjpqtESTRRWVR2Ijq9T//2Q==",
            "scaling": "target",
            "pressedData": {
              "x": 0,
              "y": 0
            },
            "releasedData": {
              "x": 0,
              "y": 0
            },
            "overData": {
              "x": 0,
              "y": 0
            },
            "leftData": {
              "x": 0,
              "y": 0
            }
          },
          "meta": {
            "editorX": 509,
            "editorY": 124,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": [],
            "pressed": [],
            "released": [],
            "over": [],
            "imageSet": []
          }
        },
        {
          "name": "LabelAccZ",
          "type": "AppUILabel",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "320": {
                "560": {
                  "width": 150,
                  "height": 100,
                  "x": 180,
                  "y": 420,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "768": {
                "1024": {
                  "width": 100,
                  "height": 100,
                  "x": 0,
                  "y": 0,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "1366": {
                  "width": 100,
                  "height": 100,
                  "x": 40,
                  "y": 90,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "text": "Z",
            "font": "28px Helvetica",
            "color": "yellow",
            "alignment": "left"
          },
          "meta": {
            "editorX": 275,
            "editorY": 246,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": []
          }
        },
        {
          "name": "LabelAccY",
          "type": "AppUILabel",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "320": {
                "560": {
                  "width": 150,
                  "height": 100,
                  "x": 180,
                  "y": 370,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "768": {
                "1024": {
                  "width": 100,
                  "height": 100,
                  "x": 0,
                  "y": 0,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "1366": {
                  "width": 100,
                  "height": 100,
                  "x": 20,
                  "y": 30,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "text": "Y",
            "font": "28px Helvetica",
            "color": "yellow",
            "alignment": "left"
          },
          "meta": {
            "editorX": 251,
            "editorY": 163,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": []
          }
        },
        {
          "name": "LabelAccX",
          "type": "AppUILabel",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "320": {
                "560": {
                  "width": 150,
                  "height": 100,
                  "x": 180,
                  "y": 310,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "768": {
                "1024": {
                  "width": 100,
                  "height": 100,
                  "x": 194,
                  "y": 394,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "1366": {
                  "width": 100,
                  "height": 100,
                  "x": 19,
                  "y": 388,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "text": "X",
            "font": "28px Helvetica",
            "color": "yellow",
            "alignment": "left"
          },
          "meta": {
            "editorX": 260,
            "editorY": 0,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": []
          }
        },
        {
          "name": "AccelReadingsImage",
          "type": "AppUIImage",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "320": {
                "560": {
                  "width": 115,
                  "height": 140,
                  "x": 180,
                  "y": 310,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "768": {
                "1024": {
                  "width": 100,
                  "height": 100,
                  "x": 0,
                  "y": 0,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "1366": {
                  "width": 100,
                  "height": 100,
                  "x": 0,
                  "y": 0,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "image": "data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/4QBoRXhpZgAASUkqAAgAAAADABIBAwABAAAAAQAAADEBAgAQAAAAMgAAAGmHBAABAAAAQgAAAAAAAABTaG90d2VsbCAwLjI4LjQAAgACoAkAAQAAAD0AAAADoAkAAQAAADYAAAAAAAAA/+ELs2h0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8APD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNC40LjAtRXhpdjIiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIiB4bXA6Q3JlYXRvclRvb2w9IjYuMC4xIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjNFQzBBQzY2MkI4RTExRTJBQ0FBODgyMTUzNkE1RjNGIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjNFQzBBQzY3MkI4RTExRTJBQ0FBODgyMTUzNkE1RjNGIiBleGlmOlBpeGVsWERpbWVuc2lvbj0iNjEiIGV4aWY6UGl4ZWxZRGltZW5zaW9uPSI1NCIgdGlmZjpJbWFnZVdpZHRoPSI2MSIgdGlmZjpJbWFnZUhlaWdodD0iNTQiIHRpZmY6T3JpZW50YXRpb249IjEiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpGQkYzREU1NzJCOEQxMUUyQUNBQTg4MjE1MzZBNUYzRiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpGQkYzREU1ODJCOEQxMUUyQUNBQTg4MjE1MzZBNUYzRiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8P3hwYWNrZXQgZW5kPSJ3Ij8+/+0ARFBob3Rvc2hvcCAzLjAAOEJJTQQEAAAAAAAnHAFaAAMbJUccAgAAAgACHAJBAAhTaG90d2VsbBwCRgAGMC4yOC40AP/bAEMAAwICAwICAwMDAwQDAwQFCAUFBAQFCgcHBggMCgwMCwoLCw0OEhANDhEOCwsQFhARExQVFRUMDxcYFhQYEhQVFP/bAEMBAwQEBQQFCQUFCRQNCw0UFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFP/AABEIADYAPQMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/APZ3ckyQ9ZSw+aoywWOSE8yFgNxpGcSIoXPnk5JFQs4ljWNeZedx71znrtiwHzHWIdSfvCr1rCFVVcbSGZi3rUGnRK4TJAZOc0stx9pOUJ2KpyT0oC5UvZTdhVyw2LnnvzVO8BM5c4ymBj1xVh2N3JG4+QJgYPcZquUa8u5AvA3d+wqkQ2X/ACiRE6kFdh3g9FqndalLbSGO1KmEE4JzzVvU7gW5MERwjgb39Kx/OMIMeWKqSVOPWqSTE3Y1mfaEaP7/APERTIvndCnDclj7VG7CHIUhsjk9qnQCJJnUjATJP1qbD5iZWMhcR/KqJhm9TT4cTiVkGI44vmX1qksgUuqEiFsbm9KWa+aG48yNR5AbaVH8Q96VguhquLu+Bi4QZ4/xpWkSErDH952yzn+VTfaoFjmkht/Lyucn3rOt8PMpPIHJqkiHpsJJMryOjNlZDz68VXDbnYHkDGCPSmMweQ8YGTVqwh3hwRyuBmqWhi5NkpkETPG2NpI5q2sYit5hkGMlVJ/nVFcvuhYKQzD5vSr20LBsJG0yYPvUvc2aImIBOB+4JGSKi6MHAJhZiQKfny8I3ERORikA8pArjcOce1UiLijCW8+ecgACq1ocSSE9AmafcMUjROrHk47U2BCttM3GcBaB9CoUJ6e9OE8luT5R4PXNKfuZ/ClSMsPumlexzu9y3aoblUiGA55DVaAEsUS88bmNFFJ7nUQL+9BV+ig4xT4YtxaVySIxwKKKZBVlYzyljwW4xUi82RI7t/KiimLoVliLHDHqe1bNjpqtESTRRWVR2Ijq9T//2Q==",
            "scaling": "target",
            "pressedData": {
              "x": 0,
              "y": 0
            },
            "releasedData": {
              "x": 0,
              "y": 0
            },
            "overData": {
              "x": 0,
              "y": 0
            },
            "leftData": {
              "x": 0,
              "y": 0
            }
          },
          "meta": {
            "editorX": 506,
            "editorY": 212,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": [],
            "pressed": [],
            "released": [],
            "over": [],
            "imageSet": []
          }
        },
        {
          "name": "Label7",
          "type": "AppUILabel",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "320": {
                "560": {
                  "width": 100,
                  "height": 100,
                  "x": 200,
                  "y": 110,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "768": {
                "1024": {
                  "width": 100,
                  "height": 100,
                  "x": 14,
                  "y": 42,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "1366": {
                  "width": 100,
                  "height": 100,
                  "x": 14,
                  "y": 63,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "text": "value + \" mbar\"",
            "font": "28px Helvetica",
            "color": "yellow",
            "alignment": "left"
          },
          "meta": {
            "editorX": 263,
            "editorY": 377,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": []
          }
        },
        {
          "name": "Label9",
          "type": "AppUILabel",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "320": {
                "560": {
                  "width": 100,
                  "height": 100,
                  "x": 200,
                  "y": 180,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "768": {
                "1024": {
                  "width": 100,
                  "height": 100,
                  "x": 16,
                  "y": 173,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "1366": {
                  "width": 100,
                  "height": 100,
                  "x": 16,
                  "y": 173,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "text": "value + \"C\"",
            "font": "28px Helvetica",
            "color": "yellow",
            "alignment": "left"
          },
          "meta": {
            "editorX": 259,
            "editorY": 455,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": []
          }
        },
        {
          "name": "Label8",
          "type": "AppUILabel",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "320": {
                "560": {
                  "width": 110,
                  "height": 19,
                  "x": 10,
                  "y": 180,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "768": {
                "1024": {
                  "width": 252,
                  "height": 0,
                  "x": 5,
                  "y": 110,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "1366": {
                  "width": 252,
                  "height": 0,
                  "x": 5,
                  "y": 110,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "text": "Temperature",
            "font": "28px Helvetica",
            "color": "black",
            "alignment": "left"
          },
          "meta": {
            "editorX": 376,
            "editorY": 456,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": []
          }
        },
        {
          "name": "TempImage",
          "type": "AppUIImage",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "320": {
                "560": {
                  "width": 280,
                  "height": 25,
                  "x": 10,
                  "y": 180,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "768": {
                "1024": {
                  "width": 100,
                  "height": 100,
                  "x": 0,
                  "y": 0,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "1366": {
                  "width": 100,
                  "height": 100,
                  "x": 0,
                  "y": 0,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "image": "data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/4QBoRXhpZgAASUkqAAgAAAADABIBAwABAAAAAQAAADEBAgAQAAAAMgAAAGmHBAABAAAAQgAAAAAAAABTaG90d2VsbCAwLjI4LjQAAgACoAkAAQAAAD0AAAADoAkAAQAAADYAAAAAAAAA/+ELs2h0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8APD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNC40LjAtRXhpdjIiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIiB4bXA6Q3JlYXRvclRvb2w9IjYuMC4xIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjNFQzBBQzY2MkI4RTExRTJBQ0FBODgyMTUzNkE1RjNGIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjNFQzBBQzY3MkI4RTExRTJBQ0FBODgyMTUzNkE1RjNGIiBleGlmOlBpeGVsWERpbWVuc2lvbj0iNjEiIGV4aWY6UGl4ZWxZRGltZW5zaW9uPSI1NCIgdGlmZjpJbWFnZVdpZHRoPSI2MSIgdGlmZjpJbWFnZUhlaWdodD0iNTQiIHRpZmY6T3JpZW50YXRpb249IjEiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpGQkYzREU1NzJCOEQxMUUyQUNBQTg4MjE1MzZBNUYzRiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpGQkYzREU1ODJCOEQxMUUyQUNBQTg4MjE1MzZBNUYzRiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8P3hwYWNrZXQgZW5kPSJ3Ij8+/+0ARFBob3Rvc2hvcCAzLjAAOEJJTQQEAAAAAAAnHAFaAAMbJUccAgAAAgACHAJBAAhTaG90d2VsbBwCRgAGMC4yOC40AP/bAEMAAwICAwICAwMDAwQDAwQFCAUFBAQFCgcHBggMCgwMCwoLCw0OEhANDhEOCwsQFhARExQVFRUMDxcYFhQYEhQVFP/bAEMBAwQEBQQFCQUFCRQNCw0UFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFP/AABEIADYAPQMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/APZ3ckyQ9ZSw+aoywWOSE8yFgNxpGcSIoXPnk5JFQs4ljWNeZedx71znrtiwHzHWIdSfvCr1rCFVVcbSGZi3rUGnRK4TJAZOc0stx9pOUJ2KpyT0oC5UvZTdhVyw2LnnvzVO8BM5c4ymBj1xVh2N3JG4+QJgYPcZquUa8u5AvA3d+wqkQ2X/ACiRE6kFdh3g9FqndalLbSGO1KmEE4JzzVvU7gW5MERwjgb39Kx/OMIMeWKqSVOPWqSTE3Y1mfaEaP7/APERTIvndCnDclj7VG7CHIUhsjk9qnQCJJnUjATJP1qbD5iZWMhcR/KqJhm9TT4cTiVkGI44vmX1qksgUuqEiFsbm9KWa+aG48yNR5AbaVH8Q96VguhquLu+Bi4QZ4/xpWkSErDH952yzn+VTfaoFjmkht/Lyucn3rOt8PMpPIHJqkiHpsJJMryOjNlZDz68VXDbnYHkDGCPSmMweQ8YGTVqwh3hwRyuBmqWhi5NkpkETPG2NpI5q2sYit5hkGMlVJ/nVFcvuhYKQzD5vSr20LBsJG0yYPvUvc2aImIBOB+4JGSKi6MHAJhZiQKfny8I3ERORikA8pArjcOce1UiLijCW8+ecgACq1ocSSE9AmafcMUjROrHk47U2BCttM3GcBaB9CoUJ6e9OE8luT5R4PXNKfuZ/ClSMsPumlexzu9y3aoblUiGA55DVaAEsUS88bmNFFJ7nUQL+9BV+ig4xT4YtxaVySIxwKKKZBVlYzyljwW4xUi82RI7t/KiimLoVliLHDHqe1bNjpqtESTRRWVR2Ijq9T//2Q==",
            "scaling": "target",
            "pressedData": {
              "x": 0,
              "y": 0
            },
            "releasedData": {
              "x": 0,
              "y": 0
            },
            "overData": {
              "x": 0,
              "y": 0
            },
            "leftData": {
              "x": 0,
              "y": 0
            }
          },
          "meta": {
            "editorX": 559,
            "editorY": 458,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": [],
            "pressed": [],
            "released": [],
            "over": [],
            "imageSet": []
          }
        },
        {
          "name": "Label6",
          "type": "AppUILabel",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "320": {
                "560": {
                  "width": 82,
                  "height": 40,
                  "x": 10,
                  "y": 110,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "768": {
                "1024": {
                  "width": 238,
                  "height": 0,
                  "x": 14,
                  "y": 14,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "1366": {
                  "width": 238,
                  "height": 0,
                  "x": 14,
                  "y": 14,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "text": "Pressure",
            "font": "28px Helvetica",
            "color": "black",
            "alignment": "left"
          },
          "meta": {
            "editorX": 378,
            "editorY": 375,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": []
          }
        },
        {
          "name": "PressureName",
          "type": "AppUIImage",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "320": {
                "560": {
                  "width": 280,
                  "height": 25,
                  "x": 10,
                  "y": 110,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "768": {
                "1024": {
                  "width": 100,
                  "height": 100,
                  "x": 0,
                  "y": 0,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "1366": {
                  "width": 100,
                  "height": 100,
                  "x": 0,
                  "y": 0,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "image": "data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/4QBoRXhpZgAASUkqAAgAAAADABIBAwABAAAAAQAAADEBAgAQAAAAMgAAAGmHBAABAAAAQgAAAAAAAABTaG90d2VsbCAwLjI4LjQAAgACoAkAAQAAAD0AAAADoAkAAQAAADYAAAAAAAAA/+ELs2h0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8APD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNC40LjAtRXhpdjIiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIiB4bXA6Q3JlYXRvclRvb2w9IjYuMC4xIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjNFQzBBQzY2MkI4RTExRTJBQ0FBODgyMTUzNkE1RjNGIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjNFQzBBQzY3MkI4RTExRTJBQ0FBODgyMTUzNkE1RjNGIiBleGlmOlBpeGVsWERpbWVuc2lvbj0iNjEiIGV4aWY6UGl4ZWxZRGltZW5zaW9uPSI1NCIgdGlmZjpJbWFnZVdpZHRoPSI2MSIgdGlmZjpJbWFnZUhlaWdodD0iNTQiIHRpZmY6T3JpZW50YXRpb249IjEiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpGQkYzREU1NzJCOEQxMUUyQUNBQTg4MjE1MzZBNUYzRiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpGQkYzREU1ODJCOEQxMUUyQUNBQTg4MjE1MzZBNUYzRiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8P3hwYWNrZXQgZW5kPSJ3Ij8+/+0ARFBob3Rvc2hvcCAzLjAAOEJJTQQEAAAAAAAnHAFaAAMbJUccAgAAAgACHAJBAAhTaG90d2VsbBwCRgAGMC4yOC40AP/bAEMAAwICAwICAwMDAwQDAwQFCAUFBAQFCgcHBggMCgwMCwoLCw0OEhANDhEOCwsQFhARExQVFRUMDxcYFhQYEhQVFP/bAEMBAwQEBQQFCQUFCRQNCw0UFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFP/AABEIADYAPQMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/APZ3ckyQ9ZSw+aoywWOSE8yFgNxpGcSIoXPnk5JFQs4ljWNeZedx71znrtiwHzHWIdSfvCr1rCFVVcbSGZi3rUGnRK4TJAZOc0stx9pOUJ2KpyT0oC5UvZTdhVyw2LnnvzVO8BM5c4ymBj1xVh2N3JG4+QJgYPcZquUa8u5AvA3d+wqkQ2X/ACiRE6kFdh3g9FqndalLbSGO1KmEE4JzzVvU7gW5MERwjgb39Kx/OMIMeWKqSVOPWqSTE3Y1mfaEaP7/APERTIvndCnDclj7VG7CHIUhsjk9qnQCJJnUjATJP1qbD5iZWMhcR/KqJhm9TT4cTiVkGI44vmX1qksgUuqEiFsbm9KWa+aG48yNR5AbaVH8Q96VguhquLu+Bi4QZ4/xpWkSErDH952yzn+VTfaoFjmkht/Lyucn3rOt8PMpPIHJqkiHpsJJMryOjNlZDz68VXDbnYHkDGCPSmMweQ8YGTVqwh3hwRyuBmqWhi5NkpkETPG2NpI5q2sYit5hkGMlVJ/nVFcvuhYKQzD5vSr20LBsJG0yYPvUvc2aImIBOB+4JGSKi6MHAJhZiQKfny8I3ERORikA8pArjcOce1UiLijCW8+ecgACq1ocSSE9AmafcMUjROrHk47U2BCttM3GcBaB9CoUJ6e9OE8luT5R4PXNKfuZ/ClSMsPumlexzu9y3aoblUiGA55DVaAEsUS88bmNFFJ7nUQL+9BV+ig4xT4YtxaVySIxwKKKZBVlYzyljwW4xUi82RI7t/KiimLoVliLHDHqe1bNjpqtESTRRWVR2Ijq9T//2Q==",
            "scaling": "target",
            "pressedData": {
              "x": 0,
              "y": 0
            },
            "releasedData": {
              "x": 0,
              "y": 0
            },
            "overData": {
              "x": 0,
              "y": 0
            },
            "leftData": {
              "x": 0,
              "y": 0
            }
          },
          "meta": {
            "editorX": 555,
            "editorY": 370,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": [],
            "pressed": [],
            "released": [],
            "over": [],
            "imageSet": []
          }
        },
        {
          "name": "PressureChar",
          "type": "AppBLECharacteristicCustom",
          "variants": [
            "app",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "readData": null,
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(PressureChar, instance),\n\t\t&ATMO_VARIABLE(PressureChar, bleServiceHandle), \n\t\tATMO_PROPERTY(PressureChar, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(PressureChar, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(PressureChar, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(PressureChar, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(PressureChar, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(PressureChar, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(PressureChar, writeDataType), ATMO_PROPERTY(PressureChar, readDataType), ATMO_PROPERTY(PressureChar, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(PressureChar, instance),\n\t\t&ATMO_VARIABLE(PressureChar, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(PressureChar, bleServiceHandle), \n\t\tATMO_PROPERTY(PressureChar, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(PressureChar, instance),\n\t\tATMO_VARIABLE(PressureChar, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(PressureChar, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(PressureChar, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(PressureChar, instance),\n\t\tATMO_VARIABLE(PressureChar, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(PressureChar, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "ATMO_DRIVERINSTANCE_BLE_BLE1",
            "bleServiceUuid": "4320a275-934d-4c29-9383-c5a1cbdf60e2",
            "bleCharacteristicUuid": "4320a275-934d-4c29-9383-c5a1cbdf60e7",
            "read": true,
            "write": true,
            "notify": false,
            "readDataType": "ATMO_DATATYPE_INT",
            "writeDataType": "ATMO_DATATYPE_INT",
            "notifyDataType": "ATMO_DATATYPE_INT"
          },
          "meta": {
            "editorX": 134,
            "editorY": 372,
            "lastTrigger": "read"
          },
          "triggers": {
            "triggered": [],
            "read": [
              {
                "mapping": {
                  "text": {
                    "code": "readData"
                  }
                },
                "targetOrder": [
                  "text"
                ],
                "targetElement": "Label7",
                "targetAbility": "setText"
              },
              {
                "mapping": {
                  "value": {
                    "code": "readData"
                  }
                },
                "targetOrder": [
                  "value"
                ],
                "targetElement": "PressureEvent",
                "targetAbility": "send"
              }
            ],
            "written": [],
            "notification": [],
            "indication": [],
            "subscribed": [],
            "unsubscribed": []
          },
          "coupledElementName": "PressureChar",
          "coupledElementPlaneName": "ST SensorTile"
        },
        {
          "name": "TmpChar",
          "type": "AppBLECharacteristicCustom",
          "variants": [
            "app",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "readData": null,
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(TmpChar, instance),\n\t\t&ATMO_VARIABLE(TmpChar, bleServiceHandle), \n\t\tATMO_PROPERTY(TmpChar, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(TmpChar, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(TmpChar, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(TmpChar, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(TmpChar, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(TmpChar, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(TmpChar, writeDataType), ATMO_PROPERTY(TmpChar, readDataType), ATMO_PROPERTY(TmpChar, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(TmpChar, instance),\n\t\t&ATMO_VARIABLE(TmpChar, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(TmpChar, bleServiceHandle), \n\t\tATMO_PROPERTY(TmpChar, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(TmpChar, instance),\n\t\tATMO_VARIABLE(TmpChar, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(TmpChar, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(TmpChar, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(TmpChar, instance),\n\t\tATMO_VARIABLE(TmpChar, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(TmpChar, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "ATMO_DRIVERINSTANCE_BLE_BLE1",
            "bleServiceUuid": "4320a275-934d-4c29-9383-c5a1cbdf60e2",
            "bleCharacteristicUuid": "4320a275-934d-4c29-9383-c5a1cbdf60e8",
            "read": true,
            "write": true,
            "notify": false,
            "readDataType": "ATMO_DATATYPE_FLOAT",
            "writeDataType": "ATMO_DATATYPE_FLOAT",
            "notifyDataType": "ATMO_DATATYPE_FLOAT"
          },
          "meta": {
            "editorX": 134,
            "editorY": 447,
            "lastTrigger": "read"
          },
          "triggers": {
            "triggered": [],
            "read": [
              {
                "mapping": {
                  "text": {
                    "code": "parseFloat(readData).toFixed(2)"
                  }
                },
                "targetOrder": [
                  "text"
                ],
                "targetElement": "Label9",
                "targetAbility": "setText"
              },
              {
                "mapping": {
                  "value": {
                    "code": "readData"
                  }
                },
                "targetOrder": [
                  "value"
                ],
                "targetElement": "TempEvent",
                "targetAbility": "send"
              }
            ],
            "written": [],
            "notification": [],
            "indication": [],
            "subscribed": [],
            "unsubscribed": []
          },
          "coupledElementName": "TmpChar",
          "coupledElementPlaneName": "ST SensorTile"
        },
        {
          "name": "Interval1",
          "type": "AppInterval",
          "variants": [
            "app"
          ],
          "properties": {
            "errorData": null,
            "time": "250",
            "startOnInitialize": true
          },
          "meta": {
            "editorX": 30,
            "editorY": 400,
            "lastTrigger": "interval"
          },
          "triggers": {
            "triggered": [],
            "interval": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "PressureChar",
                "targetAbility": "read"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "TmpChar",
                "targetAbility": "read"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "BLEAccelX",
                "targetAbility": "read"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "BLEAccelY",
                "targetAbility": "read"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "BLEAccelZ",
                "targetAbility": "read"
              }
            ],
            "started": [],
            "paused": []
          }
        },
        {
          "name": "PressureEvent",
          "type": "AppCloudEvent",
          "variants": [
            "app"
          ],
          "properties": {
            "errorData": null
          },
          "meta": {
            "editorX": 465,
            "editorY": 368,
            "lastTrigger": "sent"
          },
          "triggers": {
            "triggered": [],
            "sent": []
          }
        },
        {
          "name": "TempEvent",
          "type": "AppCloudEvent",
          "variants": [
            "app"
          ],
          "properties": {
            "errorData": null
          },
          "meta": {
            "editorX": 471,
            "editorY": 455,
            "lastTrigger": "sent"
          },
          "triggers": {
            "triggered": [],
            "sent": []
          }
        },
        {
          "name": "AccelEvent",
          "type": "AppCloudEvent",
          "variants": [
            "app"
          ],
          "properties": {
            "errorData": null
          },
          "meta": {
            "editorX": 343,
            "editorY": 105,
            "lastTrigger": "sent"
          },
          "triggers": {
            "triggered": [],
            "sent": []
          }
        },
        {
          "name": "Image",
          "type": "AppUIImage",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "320": {
                "560": {
                  "width": 320,
                  "height": 560,
                  "x": 0,
                  "y": 90,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "768": {
                "1024": {
                  "width": 100,
                  "height": 100,
                  "x": 0,
                  "y": 0,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "1366": {
                  "width": 100,
                  "height": 100,
                  "x": 0,
                  "y": 0,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "image": "data:image/jpg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4UyuRXhpZgAATU0AKgAAAAgABgALAAIAAAAmAAAIYgESAAMAAAABAAEAAAExAAIAAAAmAAAIiAEyAAIAAAAUAAAIrodpAAQAAAABAAAIwuocAAcAAAgMAAAAVgAAEUYc6gAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFdpbmRvd3MgUGhvdG8gRWRpdG9yIDEwLjAuMTAwMTEuMTYzODQAV2luZG93cyBQaG90byBFZGl0b3IgMTAuMC4xMDAxMS4xNjM4NAAyMDE5OjAyOjE5IDEwOjQzOjQyAAAGkAMAAgAAABQAABEckAQAAgAAABQAABEwkpEAAgAAAAM0OQAAkpIAAgAAAAM0OQAAoAEAAwAAAAEAAQAA6hwABwAACAwAAAkQAAAAABzqAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMjAxOTowMjoxOSAxMDozOTo0OAAyMDE5OjAyOjE5IDEwOjM5OjQ4AAAAAAYBAwADAAAAAQAGAAABGgAFAAAAAQAAEZQBGwAFAAAAAQAAEZwBKAADAAAAAQACAAACAQAEAAAAAQAAEaQCAgAEAAAAAQAAOwEAAAAAAAAAYAAAAAEAAABgAAAAAf/Y/9sAQwAIBgYHBgUIBwcHCQkICgwUDQwLCwwZEhMPFB0aHx4dGhwcICQuJyAiLCMcHCg3KSwwMTQ0NB8nOT04MjwuMzQy/9sAQwEJCQkMCwwYDQ0YMiEcITIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIy/8AAEQgBAADJAwEhAAIRAQMRAf/EAB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXETIjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/aAAwDAQACEQMRAD8Ay7W7u/tyQmJTEzN84Q8Af41L4guvJ0C7bY3+rIrqlohJnlE07SAMT87Hgegqu7Y4rme4zZ0CZgWihWNZDkmRgTx6YHWtzVDcXNiWuLppPJQtGpVQFIHOBj+tZSdmbxvKNjiw5xnA/IUqSFCCAuf90VVrmak07ocJ3EwmGzeDn7gx+WMUrXEjMWO3J64QD+lJQSdwc29xPtEgGPl/75FAuJFzgryMH5R0qiLDhdyq+8bAxGP9Wv8AhUTOWADAHHtSSsJQSFaVmVVIXC9PlApy3MiwNCNmxuvyDP59acdNgcE1YhHHYUuec4FO5QZ68Dn2o3H0H5UKTQBn/ZFAxn7opAdFotnLfpIxuTbxIuzIUuW6HAGRxwK6S1tb62sFtbPX5LdEyQrM6KfbA3D+XWs3KzNoptE/27xLawvePql0yQr8zo8c2AfYAkDjuKpf8J9qX/Qdn/8AAaP/AOJqk21dIHodFZ3ivKqNHtY9MZJJ9MYrH8batFbWc2mkxmc4DxhvmT6jH6EiuiU0jFLQ814LErkemabkt9786yYjX8Pkx6jgjqhODXQXbF7KcrjJjYfpWc9zopfCziwPlpKswCigAooAKKACigBKKACjFABTqAOz0ZBDpcfylWfLH354P5Yq+X3LWL3OlbDY3RVkY8kKcAHpWbgeg/KvZwUV7PUwqbmn4n12azs4bdcxzSkEsuRgDrXMvcx3IaRlBx0J615k9xq2xQjRJZygAIx0ApZLJIm7juDQKyZtaZdSJpcxexmnZ32i5CZ24HTP9KuWlvcXEUgWC6YmNsKkLMScHAIHb3qXF7mkZLY5OW2mt3Mc8MkTjqrqQR+BqLbiqMQ203aaAF20baADaaUKaADYaCvtQOwm2jbQAbeKTbQIXFKFJIHvQM7Cwythb56bBxVongnHb1xWTOhEbORbyMe9Ufx/WvVoS5aSMZblXxffNe3duzEhljIKkYxzXPiVgm0HiuB6kbDoJmil3KeRUz3ZdSGNAkdhomrarpfh0DTLu5SRzuEKOwRiT3A6nAq0fif4giha3urDTJJFblp7JCw9uRj86FGTV0atJMil+IdxdjF3oOmTNjAZE2ED2CEUkXi3QW4u/DkQf+L5nP8A6GzY/KndrdGbinsNn1nwdM2To06H/YuEx+Xlf1qJZvBk0gDW01urYGSrPt568OP5VV4kJSRpf2P4CeAsmtHfjoIZF/q1VP8AhG/D0yB7fUgwP/XXj/yCf50tGPUQ+C9PlYCDVEX/AK6yon/oe2oZPAk6fcuYpR28meCTP4CTNLlT2HdrdDG8DamsvlfZ7wv/AHRaFj+hNRyeCdSQHfBcqR/es5R/Sk4sakim3hm5jPzyRp/vq6/zWhfD8x4EsDf7r1Dui1Zkv/CKagxwkG8kZG1h0qs/h+5XK+X8w7ZBqVIpwIjoOo/8+c5HqsRNN/se8gnQS20yE54aMg9KfMhcrO1im0U6RHK15DFMkYDxM20g45AB6/hWDcazZCUhXJXqMc5qIps0ukU21ZZlMVtE7yE8AAnP4AVY/sbxD/0B7v8A75/+tXX7R8qXYz3OWvWdrqTfIzsGwWbqcVCKzMhe9JQB6r4Zs4Zrbyprm3to0hUNJORt7DaASMkrurlfGMFrFrMYS482Njl329uOmOveuyjhW8O63ZfmwrTtV5TZ0O58Ob7UXWptFGkTSuPLJ2SfKABkEYwW/KvQXh8HXVklxDq+lskIaSYSeW+QEOflG1mGcdOuDXkVOdyLs0JY+CLHUPEkkcemabcWCBgzCMouRErDkM2CzTA4znEWBgZrevPhd4VjDO+kW0CgMwCXEhJwCeOPTB6ev1rRc9txXZz+nfDPQb59SMlqwjtrhrdJIJcD5AocnLE/fLcdgPenR/C8fZIJLC5uLZpUDvFkErlcgZA5OTj86luaKU2iLVPAcljFbI2tzu1xcJbxpJaEZZu+TjgDJP0NZM3w5uH1NrKHUbOaVbdbhj5J2qrNtGW3dSc/kalTfY1jXa6FNfh5rJgt7mzZXinCmJ4X25DDIJyCV4I6461O/gzx7bOjW1xeZKbkKzBjjj6HuKv2ncnni2UZ7f4kadIImv8AVUZvuqZ8Z+gLegP5VDFr3jmymBuW8/B5FwsUn881SqJrci0bl/UPiBr11PH5vhvTZSqhSGsg+fx/+vWZN4wmcsLjwlpqsx/hsmX+RFXG4SsanhzxhE959km0qeyjYFg9jdTQnjthmIPatzxTrunXmgQmGbUJLjzNnl3c5kCY6sPc9PxqrXWw6Sbmlc88gsE8QeI47SSNPKWJpH2qFPoOR7kVPb6PaCYxx2qMRgYI3c/jW+HgpRuzWaXMzs9F02OxClUQSHj5RgCu68paipuCR8r3mPtLnsTkVEvSoOUXqOKktoxNdwxnozgH86HsNK7PWdItNWXwnq9xbQwfYLlha3M0rYZc44UZ5Pz1y17pVvqXiW3soo5YIVt2k2HLM23PT3OK7pT5MJaL3tf8DdU1Otr3Og0/S/B76cqXmj3ccwOySbzuVOCT2xwB0Izz3rB8V+Go9OfTzpk0lxp92H+y71w+QeVI78kc14saj5tTvr4ZqOlvI9A0nX/Ctr4esLO+8F3W+GJFe4S1R2cjGW3cHk5/OtGy8SeEF0i5t31XU7SaXz/LWV7mNF3ElBhCQAoIX8K05kedOlOG6HaTrfhtr++0+HxbNZWouJHtw80bRlSEJJ85WyS7yH8+ldJo9tNrAa9h8UwTGGaWOBmt4X/drIME7Nv8SZ9MHpzVGeho39h4kfULK4W90ycWRaVYjbvErFkZOodjkAt27+9YUz61o48RaxrUdrL9ojRXS1uSrwxhSFQAx4Y5l65GTQBtXGoao06mLw/e+VF8jrE9s6joP4mzkDcMDjgetXIdbtC/73RdYti53PizkO1sDr5efYcUtOqCxyOt6ppQ8X2t5dyPb2NvZSvE95FPCpeRlUqzMOTtMmAB3Aq62q+EpkWK38V267cDZHcxEEBdo6g9ueO/4Vz1IdkFjCkstK1uyW+t9QhliuVLo0kSZYZ2kYwOmM5I/LpXBa7oflTSiFo1/eLEcQBTuOORz79fanSbTsxWZV8PfaUSWS6llktzzApckZPJIGeDwBV27RZgTgqFzxn9a7Yv3ZP+tzow/wDERD4Us7u41TV5rLi4jRYYyegJ/wAK6uHS00+6uS5G7zD8x7CtaLsrFPVtmhaKstwhDnYvzNt9BV/+29J/6Ctv/wB/xSqbgj57vPIZlaJSuV/1TckfjVJl2MRgioOVjAcHNXdKUPqkPHAOaUthw+JHqiXf2T4f3DyO2JpFSKNT/F5hYtj1wi8+lcFdajdPqTX4eVbxCDHKgAKkdOnSu/FR5cP935HThFzVG7X3OltviHeR6d/pen6bPOW+ZtjxOxP8R24B61JK11f+INORbu3n8k7beO3b5I8/NwOT17k5rwZtqSSR2N2dj6asLCGx0y2skRdkESxgY9BiorrR9LuVY3On2kgxyXhU/wBK7uVW1PLU5LZny5BaW2teOboWtugt7i4k8uBTgbeSq/ToK9vb4NeF2tFiVLmJsAsySdT69KxiuZvUuNVKOsU7tlM/B1YOdP8AE2q2mOV2SHj8iK8w8e/254T1l9Fm8QXN/FJDHIxlO7gMSo+bOMYzWsKbcrMcpU5L3VZnV6PP8VtZ0E3Nle28lvPFsB2RxumR/CQBgjPBrWPiT4mWMKxXfhe3ugmMNEHzxjqcnPSs76bGksPG9lJXXyON8c+KvFGtaNcadf8Ah+5tFmdWY5YrhWJxjH+73/h9+PJxBNJN5SRsXHBGOn19KuDVjKpRnDVrQ0hocqW/mtcKGyuEQ5zk469j3xUUltdI77LpgYzjDMVbIBJ/LFO6ZnY63wwznR1NwZZZCTtLOfkA4H4VLNc8SDrgnJrSK/dyfodFDWXyOn+GkZGjTXJX5rq7ZwfUArj+TVX8YeIv7IuY4bSNZ765BkVTyEBJwfr0qYSs2JuyucrbeJfE9kft07E2zkxsWhG0cdOnXFaP9sWn/QYH/fyT/CpdRsIytucHGi25aNlMhfHKsRtH1qncNvuHbAGT0qznIK09CAF60jKSFXjAzyaT1Kp/EjubnV1tNOhhKlkDsAMZG4cH9SazLW902WW4a6hj3Syk5ZPugAAdB3579q+g4koyp4Cmob3/AENstu5tlyLS9MurphEUSJ9yx7J93zZwOpPHB/MU6xT+yfFlqbMPJLAquBJzlsj2HbNfEUak5VOSR69ab9m0+x7P4W8aatqUcj31sseHIHbIGKr+KfiYulQ3NobKTe9s5WQdASGA/lXcpyvY8hUdEzzX4TWjXfj20SRtywIZu/XFfS1a0rWuLE0FQkqad7BXyd8StS/tb4i6s247Y5/s6fRML/Q1vBpO7M6cXJ6H0b4M+zWnhXTbUTR+YIV3KGGc10fBrKDVrCqO82yvf3Ednp9zdS48uGJpG+gGTXyb+5eaScht92zSzF49yYPzZGM4we3vj1pS3BN8pTtZ5ZLPCRO9yzcu6Z3j+EdsHjrnv05NSSrJOpn8tlAAEZUMxUbsHcR6HnjP60h8rbNeGOaONVDAHHKr0zUF9E1raTM2RtU1tL+CvN/l/wAOdFDTmZ6H4VgmsvB+mmGJWaOESMpOOCGYnp1+bpXlvxDtr3T/ABY8k28LJGhhfplQoH5jFYw3ZnP4Tmm1K5kQpJK7KexaovONaLRGN2xBeSgfw/lSFjIS7d+uBTEMJGevFbnhmREu/mHDuoyegA65pxV5JeZVN2lc9Ourezt4ykaW0kPLJuw4+YnJyK8+NvLdW4uxpymEsXMkb7TtB54BFd2cYtzjHme50YGKjzXNCfTtJa5ggSe+sSULS/aot+CBxgD1Pv2rV8EWsC/EOwszdpdI4OHVcD7jnGD+FfPwm27NfM6KleXK4yPaV00WzERMAM9CPrXF/Ei0S18JXFzKy73eOJD9Wyf0BqluZ02uZX2Mj4KTRJ4q1C4bBxalVP4rXuSalGyqS3UZqufldi8ZH2lVyRLPqcEFrLO7jbEhdvoBk18oWYfWvEVmr/NJe3oZvqzZ/rVynzGmXw5VNvsfRI0a3gvY5AgXb0xW8koEKqGZc8daz1vc4FscH8Rb6/0/wfqLC8dRckQAM3HznBH5ZryK80+bQIbVri4RlafejxzfIo4z91vf9K0g+4O1lfzIofttrqRvYIoZQWJ84Puwinqp9Tjjg5z71biiNnYIJQpuI5CzOMJgtk429/5YxjHNW99CVd7jImWFlbcSuQev5fripNaf7RphjUfPO6Rjj1YVtP4Yr1NIO0Weos8VlpskQUrG37qMAdBgLTNX8PWPiON4tRjVolOUdeGUYB4P4ms4qzG9UeRW/hvTYfiDZ6bJC01pJlijt1I3dce4r1b/AIRbS/8AoF2f/flatkxSsfNuKmiJHAPWqOcSRG6lR9RWpozpCDJMMwqrF19c8f1q6XxpjL+oaox07Za3YEeAPLUY49Kwob66T93HPIsbAqUVjgg9Ritsa1UtfYdOTi9Dat/EeoWssxd1dVX5fNTk9u31Jra8B674fsvEaaxrd5eWl5HcGSIxQiSHaRyGA+b16V5caCg3KJvVqcysfQFl458Kauyra6zpsjt0R5fKYn2DYrifjVew2+l6LDGBH51y8hGQwO1cDp/v1HLqY1G/Zuxx/wAKp5ZvFV9t2jdAxUY2g/MBwPwr17/SwMNCeBwVrCq2qtvI78NZ0Ffc5vxfq8uneF9SlcupaBoxkd3+X+teY+A4v+K70NXZHG/eoXPGPqB6Vvh4udOU+zN5VFSXKuqPpC8kQFNwHJpkUkTMoppnn20PO/jVqEcOkaVY7gvnXRlORxhFPH5sK8VF2Da+W9m7CfGC+OFDE/KcD1/GtqSujOp0RpJHIbl/9FdRE8Y+8qH7mAAMHgjnHOamW+uG8y3lkim/fFt20ZOABg4PT2+tU0roSWlwlOEBByS23P0/yK1tMi+26/oVocEfafOb6IN1a1PsrsjRbHe6xfQFLaON1cu5ZVT5ifmz0/A1q6cTJpoaRjGRkMDjI545+lSyjyy7zD8T9NZMHNxIi5OOrNj/ANCr1Xy77/nrD/3y3+ND3FE+Wc+9OQ+lUcxIzkrt7Vp6coEUpXcWJULt68cnH6VUNHcBl1p+0ttf5jzhuaqmzubZ0kUAnORjnB9wac5JvQEjRHiGYL5d7Ywy+7LtanrdaDdY823ltmPdfmFY2a2K5k9yyND0u7H+hapHuI+65wayNVsrjTbiO2nm8wBd6ANkAH/9VKMruzBxVtDsvC/i7XtDsIbaxvR9lQF1glgSRfm5Poep9a7ix+JOteTHcXXhqCeFs4ltXeIHnBIyNvX3rklZts9GOGaj7jMX4g/EHTde8KHT7a3vYLqSZCyThSu0ZJww98VgfCi18/xpbXjXdpClmylknl2NIDkfJ6kV0UrQovzOSrzc3Kz6XvFgmjVlDsOuUG7+VVra3iNyFWYbv7rcH8q5vNFRlaNjxD43ag3/AAmdlpyOAbezyCegd2P9APzrj7S0lvbsRyTwRszZLSy7fLcdz6A4H5jFdUdIXMm7s0DY6npF8gmmhu43LLBbxzNJ8o+h7bs+vFVXlhdI1jV/NAPnSMSS7E579MDA+uaIvm1QWSRcltz9ihyMcbvz/wDrYrV8G2q6h4uLMzqlpaMSUODljjr9M1rL4i1sjtNYEFq9nDD+8ljclwgG5iR1bHAzn2qzpF8YZWiumiQMMhRklT2yenPP5d6JbDOD8VoIPiPo8g4DXinP1KH+tekfb4f+esf/AH0Klij1PlzBqSJctt5yeBVnOdUfCGoaQFuNVspYcqHUSxnauemc9T/s/n0NbdtFb3lj5VrEkd4cHz4AFY9sFFwPTkfz66JJbhfS6MO/0m7sJQt5DJEn8LFT81UnvWJ2sS4HTfzj8ahoSZbtmiugICNufcf14/CoptFikkO0L7EAqP8ACocuV2Zs6fMrxKreH5nJ8gucdmX+oqpPpd7F80qEqONwOQKoy62ZtLPEI1WMgYOAGGDivR/DurbNGt44Xt3aNCjoZMN6ggc9Cfboa4+W2567ScXKL0OO16FNY+Ii2twCYi+6RSx4XG4j7xx0xwfy6U6fwZp1xbrdQPNbRuiybAd+wbSzdeT/AA9+9ctfFToTSW1ifYxqtt7/APAILTTPEFhHJc6Hr1yscRJRVkeMsAAfu+uTjHtXQ2/xA+JemRuZfJ1GKFtj+ZCkmCAP7uD3rSOLoy0lozmlhqkdVqjgfF2u33iTxFcarf2otp5QqtEqlQu1QOAfpn8apWepvbM3ZmBBfkk8V6EUnFWOV3T1NBNUjt2IjllibGCNx/Hk5/l2q7A7ThCMkvjAx+VJLWw07o6W4TEaJn7oAq/4Ds1lu9WuZJ5I4GdYiEbbu2jJy3UDnsRVPWbZr0R2F6iXEH+g7I1hJymzaCD1b1POOe/NWNGgkCzuZN+BlRsA+bBGTSl8I0cL8Qk8rxZpM3QLeIAf++f8K9Oxbf3o/wDvsVMhI+VMjNPiLLIsifeU7l+oqzA9D0z4teIbGNba5Md5CV2utwobePQ5+v6Cta28U+Ctd2jVdAfT7g8G406QID/wA8UXcSuWMn2Z2g8LtPom7RvFC3dq/wDq7a7YKD7FWyCfqBXneu+EdSspDJqOgtGpH+stgVUn6jK/hxTi1LYmS5dzmhYw8okrJ6LKuCfoRx+eKl0+drYSw3UKOrDAmC7yv19qqUbxHCVmdLokJuHhnM2YbcjlQVJGenTJPJ/CvYU8D6N4gtRckW00TqAu2LG3joe4P45rFXFU1loea+IfCFv4S1KWyWNLu3kAcedFwB6A9fxFZayaMyrFe6fsH3Q8RBwPoef1qW7uzOylGSp80XqWfsmjxzfagtoJyCsc0N15bL7kZ5B9CB/hl6ldX1hO0VtOmoMQwmt8gsAQATvXA7AAAVzVsNGprJfMUK84kMfjhYJlN3p08DZwe4wWBb07Diqd9q1j/wAI19n0+8geRJHb52dJctJwR2PB5BriWClSmmtVdHR9ZjOPZm5eo95rqvJBDLp9tBLOq5DCWYKMnHfG4YqGHw/p92YZNR0hYLu4kEDRpJgLhCxcbeOa51WnSiuSVml/wWbezjNvmRn3vga2NpBcRXkysyGSV5cMAAMjjjnkDrWVo9352oRxBQBGchvYdK9bA4mWI1ktmcVehGi7LqdPdSDb1zgVu+C08vwxHKQAbi6aTn/e/wABXZDUyZ3dsBcRs0oT96gBwOcemarWBFhI8Dn75UqMctz6US2GjhPignlXGny4xtnjc5992f5V6Vvj/wBn8qli6nyj5Z9afjEdWYWJ/trrmI4aMHhSOlX7WNp5ES3ILMflCnFJ6FpuTsbRn1/SkGUmSFRyUO5ce4H9a0tL+I+vaYu2K7Bj64zwPwHH6VEeV6xLnzLSRrp4u0zxAh/tbw0k8h+9c2eYnJ9TgYJ/CozoHhi+mxp2sSWkx4EGpQlc/wDA0z+oFdEZX0ZhKDWqLsGgaxp1s0lsDfwqMmS3l85R9dvQfWtHQPGsuhhmWdhJIwEkbcqcex7/AI0nDqjGU5HeJ4t0TxDZLHqVvBMnULINpU47E8Z/EVzHiXwLo8jw3+nTzwW0r4MQAk2dfmXnkcetZdbSRartLQztQ+DGprB5+lalDeKV3BWGxm/p+tdTp3w5gi8KFpLQf2rKd8pdfmXH8K/496bV1YtybWhi2fg211qS5tx5kU0eCUAB7+hFJafAuzvTP9vufKU8RtDGFfd6ntj/ADxWKg+bQcZu1mZt58BdS0+4FxomtfMucZJjYfTt+tcHK+v6Q11bR3kdxIkrq4l2s6P0Yqf061jXown/ABF8zpo1JR+Bkd14l1K4ge1u7FrdZHyXXIXATG0Z9xnrVPRI4kuHkiZmAwpyPx/pV4ShGjF8juiqtV1JLmWpq30+21lOeinmu806xjXRtKtFYbYYUkkXGQG2559Dkg11Q0M2a2mXTviOBgVGD5h4X8PX+XvWgyC31KG4kb5OVLsclj/IDJPApVBxOC+LMpktIpCjpskULuXGRyc/rXYf2lD6VD2Qup83YqRQpwHOFPU+laGDImQlm8vLqO4Hb+lOtbqazlEsDlHHcUNXQRbTujpbfxfJ5QjuVYEdJIzyPwpjzWeqzjeI9zf8tYz5bN/vLggn6c1z8jg7o7faxqpRkdLpkkFmgjgbYuMFmUk1ckuJpJCqOsq+yL/Kl7Q6I04vRj01660/pKF28Dfj5T7Z6H6UybxnHcuiagba8jHUTxhmP/bQYb9a1p1JGNfDU+9h0d54ZuyzQXF9pUh6IjC4i/mGH61rWV5cRus1rfWl15fyqqysG/74ODn8CK6YtT0Z5dWi46o6Kw8eT2xjgusrKhy0co8vgdyfyrt7Pxtp06qJJUVm6YPy49c1Eo8uxEG47nG+Ndbl0O6t/FeiL5rlvImijO5JPXPp+HtVXT/jX4cv2Datp13Y3IG0yRNvUflg/pWTd9johqg8YfFa1bSF0/wveSXd5d/L5xXBiU8cDH3q4W7+Hus6NpwudTicPMPN4JJXj+I+tCV9wk+U5W9jmTT5QJZHTIyrg8Hv/Om6MCIyFHJJOP0/pTilFOxopNtNmhco05itgMvNKkYHqSQK9dkst9qIMIuANkEQ+ROO/r+PHTiqiVuVYUEN3v2/d5JPf/OK23tWdInVzLIH3R7uAoP+etFVjieZ/Fe4vzLDb3D27wbDJH5aFWX5lBDZJB5xg8dTWr9jvv7rflWd9ELqeJ8047tvOOlaGJEHaN1dCVYcgg4INaVpqsYMaX1nBeRKejgo+P8AfXBP45x6U2CNW6t/C1/B5lheXWnXHeC7XzUP0kQZ/NfxrGls7m2RiUDxgZEsLBl9vmHFJJsb01RNBrcqhUmiSQD+IfI35jj8xW1Z67ECuLqRf9mTII/HOD+lY1KSa0OmjW1tI2pfEGmXUa2+pxpIuMB2Xkf8CHT86zbjSdBu/mstSaFj/Cz7h+uD/Os488PQ2qKFTd6mXd6FfWUInWRZYicB42PH1Bqqt9eWzKfMf5em4dPzrohNSV0cc4Sg7M6PRfGjWKJBdWsNzDySJAcj8fTviur07UvDmoRhkkvLJnBx5BEqgng7lHQY9QKtzaI5U9epu2/h3Ur20zouq2WqWzHcYfNCMfqpOO3euW1LR/s0zRato1zbEnAMkWR+DY6UnFNXRMbxZ0XgTw74d03V01n7Sshgz5cTjPzHgHBOTjnoOD9K9C1zWYNS0trQRrO07GOLYSpDeoPbHc4xwc1mpO9mKe55Nr9tbWjPbJNYXsRU+cSW3F8clcH7ox3xnnPauKhkgM0r28PlRAgKMk/zqou5pE1tBQ6h4u0mFyWCzGY5/wBgFv6V7KRl84AG0nj8KZrEzryDFxIyL8jY6f5965fxV4vk0fWLO30y4kLwgCWGSMBH3YJyevA9PWnNXQN2Ob8T3z67rkWQggn8i2GDkAM+48n3X8q9e2Q/89k/NaytZWBHyqKklQpGucfMM4zWpgQMMBfpUixbvJHTe2OT70N2HFXuRMCrEehqaG7ngZXhlaN16MhwaZJcTULecqL6yjkA4MkB8p8fh8p/EVOtnazoTZ3qbs8Q3A2MfYH7p/Eij1GlfYr3NlPaNi4gZAeQ2Plb6Hofwqvhc8D6UrASx3VxEjJHO6o3BXdwfwqRbtgPmFLlQ+Zvcf8AaLd4mDRjcSPmXjH+eKj+zqcNFLjHTNGwbm3a63fW43vJ5+MfPINzcf7Y+Yfga7nw98TLuKMW93e3HlAcpIouI39sNggfial6bFqz0Z6JbX3g/wAQaarywQQzD+K0IVge5C/e/SueudMtzIyaP4hiuJCzBY7o7HC4BIyeD+JHSoi1Lcck16Hnvie4k0m5SyuoIvtkjb7lEY4C9lODwTjJx2x61radq/hFrSG2uLWWzZzh3IWZP5Bh+Bq5xdtAg0mX9Kg0Ox8a2baZcR3m9XjD28uVUlSeUb5hgA9yOa7u6VyvBGw8N1yB7YqopxtzFLyFklMVq752JGN3Pf1JrynTPEeg6hrlzfa1pyytIvyBZGCg7s568dhj61TSa0FJ2Ookg0fVtIkbTLi0sbi0zOjSN8zkA4UH6HGOc1zH9q67/wA/Fr/4Cr/8TWbutGCZ5hyKbu3GtDAsPCTDGwB/1ZP/AI8f8K2YdMZjpG0EGSbYSF754/H2rnqTsdcKfuORn3+nSx3hUKfmZsY55HUZ9apRQtI+0DsT+VXCacbnLPRsY0ZUcjGaUBg238ea0vcm5Zt9QuLXKxSuisu1lByrD0IPB/GrH2q0uNouLYKw6yW52E+5Xp+QFNaDepG9rHt3W9ysi5xtcbHA9cHj8iahw8bFHRge4IoYDcA0ZZejGgByzyKMZ4qwl0FbDg7h3BpNFJmhFqm3AWQ/8Cp9zq91JLG3m4CoFGD154+vBqVFJluV0UpJHubt5XJZiepqz5azABlyAKpiR3vwr063e61C/MA82ArFHISeMg7vb0r0+pZpHYw/F9ybXwlqsqnDC3ZR+PH9a8J0ext9RMkNxqEFl0w84fb34+VSf0poie5ZuNNl0qdAb+Ga3clRJbTq4OOenUfiBW59iuf7tz/30P8AGh2Yl5nAke9KFpmZr2sHnWG4c+XAxPPu1dzb6SxfQ4xGRJ9oAwFwxPJGM/K2R1P4V52KlY74yXskizqvh0tr9ttjVh5UszLtKMFGwHKegzwO9ZWm+EQ92QlvcXdztL/Z4iEWOM5IaV+gOP4R0HeuXDYhygku3+ZnCjGc3Kfwo6e1+Eup3sCzR2GipG4yo855M/8AAuaq3nwe1uAM40i2lwOtrcnP5NXXFzWqkdSr4R+5OnZHC6t4MutNcpLFcWsmeEuoyoP0YcGudubK4s22zRMuejdj9DXVTrc2ktzHE4NRj7Wi+aP5EQdh71Ol0QpUnAPYjIrc4CV51m2mRBwMbl6mmi3eQAw4kycbVPzZ+nU0DI/lDYdSGHUEVYh2SZ3R+Yqjkj+EULcT2Jn0wGJZYHJDHHqP/wBftis8OwkXBORiqkkiYyudzp/iDRf7C/sttPkju5OCwAlSRu2QRlT2yprI2iNmCkEAnBHQ1DSW3U3voeo/DK28nws82PmuLl3z7DC/0rsjUs0Wxy/j4k+DdRjXq0YP4AgmvGvD9nJe3ccFuZElL5klQ4Cx981S2M57nren6Np0kqyvYW7OjbkYxjII7/rXQZHqPzpS3LjZHzSKM9qZgXbS8aCNkU9YmXk+u7/GvU9IvIrsaMqBMyXAymwkfKrH/VnhvcqRnp9PPxkbanWlekmjrtTjjl1CHy8Oq2F0+NjS7ctEPun54zz3yF/PGvp1tDpnwouLqPb9ovVZ5pO7Mz4x+A4rysCklL0/VnRQjzRS7yRylleah4fuIX0+9kT/AEVbiaOXlSWUYGMdty/ka9Y8Oa3Hqem2/wBouITfNGGliXggkZ6Hrx1x3zXdQkr8rN8zoqSVaMd/6/yLgbS9cgki/wBHu4wSsiMobHbkHp0rg/Enwg06+jkk0dxaStyYH+aJvbH8P4V1OKaujz8PiJ4eeu3VHhfiTwJqGi3jQS2zQTDkRscrJ7o3f6Vx7oyMUdSrA4IIwRXRRqcys9ysXQjC1Sn8Mtv8hOR0NKJCDzzWxxGhDqJcbLlUuFJBxMMnj0YfMB7A10k9jos9lHeaNLd2N6oBMbN5sZPGfmGGHfjDfWnFSb90G4294hE+nXUMf2zbFcAfMy5Q59eOv41Um0aNNFW7juUfLAsAoOM8dQeOvQ11VfZvVb2OOnKpF8slpcng8L6jLGslr5V2m3eVikGSPocE/QVVmM1szLMjxv3R1II/A1wxkmei4tHt3g+1+xeEdMiI5MAkP1b5v61slqRojK1GJbpvs8iB0kQqynoQetUbXw5p2k2Eltp8Ai3ncWJJJPuTzVdhNE0Uf2dwqk7VTBPYkn/6361J5vuKHqK585UUzAR+q/St/RtXkj1HSVLDZDJnDgsM844/GscRT542/rY3oztddz0fRvGltf67bJJISi200Z8yQjaGZDgOPmH3Tyc+grr/AA68XiTQLjwzHeeRNFL9ogL4behzkEA+pz+PTjFeFToSo1OTo1/mduHqKEnbW1pfd/w5X1nw7rUM8jXtsGaeRIY5IRuT68fdGcDnHes9Y0LRXKZM0l23RiC0Y2n+e6qlGUJanuUq1OrTXs9v+B/wDqfBuoWWmaJqczzxx3s5eRFxgkKpx7ZzuNVtI+It3ZwsuogXI3qsajhwvOcnv1GOp4NdCxHKoo4XljryqtaWat6Hdz2Nh4q0RV1CwcRSjIjnXa6H19Qf1rwb4ifDKfSJDcxky2zHEVzjkeiyf0auu/K1NHn4WSlzYab0e3r0PJZ4HhlZJEKurYIPaoMfpXob6o86UXGTi+g9ELK7f3RTobia3bdFIVI9KE7aonR6Ek1210d0o/ednFT2F8LWZWkt4rgKc7JQdp9M4Izz2PFEncIqxs6ReBrtnfWJbCQ9G8vKfTC9B7YxU19omq3UD6ipN9CznfcRyB+Scc85HrzWOzN94nuttELazhgHSONUH4DFKx4pmhE2Mg45qGRvemIpMeCewqv+9/vVRB8+Yo70zEtNp9w2nx3qxEwZKF/f0qortG6spIZTkEdqJLUa0FjleJw6MQw6Gui8NeJLvSNRjvIp2SaAAq2eoB6fqawrU1KJdKr7Oop/1bqfTOheLIPG/ha4Wxljj1BoSrRscAEjr64P6Vy9j4euxevHqNpNZCKBg06x7w8jNtGMcMTu6Dn8a82pF1Gkz18PVhhFUT36eaNPVfDNhZ+HI7uwkluriJfLlMOWUk5LORyVwc1meB1tofEam9tgWMLNEXHKnG4EfVc8+4qJ0lTrx7HdRxUsRgauvva/cIPFOu2kst/FeCVXuDGLZlJB4B49jnHY8V1kHjDStW066j1aBYbbzPIff8yPkE4/T9RVUq91yyOXGZeopToqzR4v8S/AT6NdG5tcyWrDfBJ3ZO6n3Hb2ry3y/kY16+DfPDl7Hm4+0pRrL7S/HZlq3t86XcTEDqFGf6f5P4VSCHyWfsDitJaWPOjK7Y1Bl1+tWCgDZHejoX1Hx8mtvw5CZfE2mwKTiS4QOB3AOTn8qh7Gi3Pfnbio3bAxUo2GMeg9BVWR8mmhMrvgxkE4zxTfK/6aLTIPnilGMdKZkWrPULqwlWSCThc/I4DKQeoKng/iK6SLUvDGt24h1WzewvcqPtVvyhHQkqec9+pB6fL1prfUTMHVNCn01t6MJ7ZiRHMnRh+GR+RNZfNDQI2fD3iS/wDDuox3dlM6Mhzwa+lPBXxP0nxVapbXzRQXhwCr/cc/j0OexrirQ5Jc62PQgvrFHl+1H8V/wDppvDMUTPcaTM1ncFcDDEoSTyxHrgsPxzWRf6f5lz52rWLQTfMv222fBx8+AezfKFHOD82O1VKEZx1OajWnSlzROZl8NPaJJfQSw3FrB+8MqsySKe26NujZxj6fhWfYWlvqT6TpiKXaa7Z7lc+43DH+4g/WvLlScJqJ9NSxar05VV01+5P9T0zxdokGp+Gr2IoPMVPNQ4/iUf4cV8oXumfZ7bUWUDbFJt+gJGPw5717eEXJWlHuj5utLmwa8pfn/wAMaMGllPCTudgZvmYE4YDsfofUkD2Nc8tvjS2buXJ/Acf56VpXdpWPIpVLt+o20tBJdWsbAgSP+lTavYx6fdLFG7MCm47vqaqKvByOpT95IrQD5s11nw8g+0+M7dyMrBG8n6YH86hnRHdHtEj84FQyN0FSjYjdupqozck1SIkyNiPl3cDNN84UEXPnrNOFMgcFZiABkk8CtfTtCe7YeexQHoB1qW7K5SV3Yvy6Jq+jxNPaMbm1P+sULuHT+JPx6jp7VkmK0viSMW0x428lSf6fj+dKM1JA4WZRubOa2fDrlc8MOhpttcTWsvmwuUYdwapxUlZjp1JU5Kcd0eqeDvjRqWkCO11A/aLccYk5x9D1H8q9n0X4j+HNdiVGuVhkccpL938+n54rhvKhKz2PQnQjio+1o/F1X+RZ1fw7Y6vptyulXEdvNcOjtJEdyuVBABAPTBPT2rI8LeHtUtPFP2zUbSKKK3t/KjdHBDMAFBHf7oPJArGdnVU1sOhiFSw86UlZ6/jY6XxNrNppmiXbzTIp8phy3TI7/wCea+fbjTFuvBlxdgkG9vo/KVkOGBkCjDdAeuQMtjHQdeylU5q/MtkrHFX9zB2e7l+SN7VNH+yeGIrU4RwuRHNHjk90cZBPqBlvUivO/sufD8GTjeWIVk6kseh7/qfcU8RO75vM8CF4/gZ0w+xX1qxG0opbkYH+fzqrqd19suhKcfcA4rejK9E9Ckr2kQxn5eK9B+FdtnUtRu+0cSx/99HP/stJnZHc9LJLNgUxzlwB60jQglbjAPeosf4mqM3uVbl0JX1XpVXzjVJGbZ4RU9rBJczpDEMux4FIC6qC0lZCpEiEqxbrnv8AStvS7+JJAJDgUpq8S46M2tMvda1nUxpulWWA/Q9WPv7Cu1m+FGi3Gl+VcXMn9qMSxvIT8u7HTb/EM9+Pauao/ZbGqXOeaeIdA1jwbOIL7yrq0l5V0bIP1HVTWUNNsNUjJ0+4EVw3/LtLwT/unofpweRgGt6c1NXRjONmZFxZ3FnN5c8TIwPORTUuZoJA0UjIR3U1UopqzHTqShLmg7M27DxtrmnsGhu2yOhPWttPiz4n27fth6fxHP8AOuN4GEpaOx6SzO6/eQTfcx9Q8VarrZ26heu8Q+YRjhQfoK6GDxaP7B0vT2b5I7pCyH5o9q5IypPr6YHqTXqUcLThR5Y7nj42tOu79D0jXb+3PhwgHyoWjBCs3nW7DHbuvTHZfrXCSWIj8L6YCjJ5kUZPmYaNsjPX+Hr3wM9AeteXWuonAkpXt5HLeIY/s2rxxsNm2JfvHcOd3T9PT6VhTcyEjGOgxXTQ/go7qcbaDkHFeqfDGHytCvJyOZZ8D3Cgf4mqZ0R3O1DYGaa7cZHU5oKbIQu4jvUVw4jUqOtPqZs53WtUTTrR525bpGufvGuH/wCEk1P/AJ+P/HRTbsSkcjjNdv4SbQmtmtrjda6i4IW5kPByMDaf4T+vvUvYaOamum814b1CLhHKvIFwwbuGHQ89+v1qeCLurBlPRgeDVppLUcdWdJoWtTeG9T8+J0fzIwssYJ2yL12tjGee3tXdyfESyTTJLks7X7HhOw/+t7VxV4Sm1Y6KbUTzDV9auNYummuZCxPTPasd7VWBZTtb2rohFRVjGTu7lhNTuo4hBdKtzCBtVZBkqPY/06c9KY2mQXymSwcB+SYCfmH0HcfTPvitL3M7WMqWGSE4kUrUdAC7jipQ5Koc8itITaE0dhf+IpE0aOJW2yyxYYoTk5HVhyCfc8/SrkWr+VHaRrhVjxgxdCQOcr2Prjn3rixad2jzYxcF6mB4gniuNYlljWIIQoHlfdJ2gk47df8A65rHPLHFb01akj0Yu+pOOFr2LwZD9n8JWIAwXBc/iSf5Yo6m0TogOAPxpNpYnH4UDY+YC0gy332rAvLpUR3kYKo5YnsKqHczkeZa1qr6pfNJk+Snyxr7ev41m5+tS3qNGUMAVeskFyrRtnAGR7VSV2Q9iC7tHgl+Y5DdCahimkgbKN16g9DTaGi+lys4AU7X/u/4UoduxNTYq5OsDuFLDGehHemOChwai/QqwzcDweRUbREnehIYdOadyWhWvGPyXSeZn+I9f/r1FJZRyqXtnB/2D1FUIosjIcMCDUi8CqW5LJnlMmwE52qAKtNes0yHPCjHWipFS3MZU0yU2F5qEUtzAnmKrnccjPAFU41J2j1NDi4xRdNp6LoWmjPlnivcNNtxbadaW46Rwov5CpRujRVWZcYrQhtVtbdrifjAyoNRJ9Ckc1qF6Z5WY9Owrz7xVrO9jYQtwOZSPX0rXZGe7OVpce1ZlGTV/SnxeKv94Yq1uQzaurIXMRVx7g+lY02lOifI4dhyVohGVrM2xEoNqcOpnsjKe4x+YqxDd4wsuSP7w6/j60MxNi2mHk5DAr2INUJpT5hK96xS1Zq3oRqR9DUqk96sgcyqy7WAIqq0JQ7o2PHbPNCYND1YTjbMu73HBFNl0+RYvOiPmRdyOq/X0qyXqVc4OP504GqTJZ2eh/uvC9zJ0JEjA/8AAcf0rnrOAyPGAOvNaV3aMTLD6yl6mzbaaZbqyhx/rrhE59M//Wr2y1s2kIwprm5tDrsdHa6SlrD9pusBQMgGuT13VxdysiNiNTwPWop+9K5UnZWOG8Q6yNOtDsI8+TiMenvXnjMzMWYkknJJ71tIyQ+GKSeZIolLu7BVUdST0Fdr/wAKs8R/884f+/grNysVY8xzVrTm238J/wBsVotyDsYts8bDGJFzkVSks8zCVWZW/i54IrVqzsZp8yuZssUd2hWVDFKpxu7Z579+lZVzaSW7YccdmHQ1LV9Sk7aEUcskJyp4PUdjVlJEm+7w3909/pWbLEORwRT1kK+4qWMeHDdDz6UuTmgYFQxB7joR1pyvLC/mI7I4GA6enuO9NOxLQyaRJ23TRIpPHmRjCn8O1QyWckZBX5lPQ5qhbnRpK1t4TMeCGdMfma1fDugyXV2oEZO2Lpj1IqsRNcq9DLDr4vU7WPwjcWviPw5DJCwEs8rdP7sZP9a9hsdJgsYfNlxlRnntXFzXR1vQ4zxV4i+1SNb27YiXg471wl/ex2tvJcTNhEGTXVSjyxMpu7PNdQv5NRvXuJe/Cr/dHpVWkxo9R+E/hN7mdtfuYQ0UJ22yvwGbu34dvf6V6z/aWn/8/cH/AH2K5qjblobQWh8fg1JCcSqfQ5rrW5znpJ06K/s451+WVlBDjrVH7O8MWJzzuI3HvWkal48r3IlT5Zcy2KlzbLMhVhleo/xqjLDIhEYTzYmIX5uSPXNMDPu9KKktB0P8BP8AKsoxlWIwQR1B61EolJ3JY7g/dlG4evcVKRldysGX1Has2ihtPEpAwwyKBkqkN9w/hTwaljQeWGJI+U+op0LzWbFowu1uGBTch+oPQ+4pxl3JlHsbtsyanHZ2vnI5muo1YIuAuW5FfQNhZ6L4Ulur/UJIbe2jhijVn6lwXJAHUnlelY1E72ZOHTUX6mR4d8bw+NviSphtzDp+l2czQmQ/O7sUUsR246D/ACNXxV4m37rS3bC9GI700rysbbK5wM8uSSTXnniTWPt1z9nhb/R4j1H8TetdUnZGS3MMVteFvD1x4n1+30y3BG85lcD/AFaDq1ZN2Vy0e4+NtVtvBXhKHS9O2xXEqeRbqOqr/E/15/M14h9mP95vzNGHpqSbYVJcuiOMqSL74+tWtyD0Gwt72zsYLuzYyo6BpLdu/uvvWrbvb6ras6qf7ro64Kn0NS+6NEujM25sjbrJ5YLbRkJnvVCJluBwrI46ow5FaRlcxcbEFzbMw+UKWAIGff37HgVn3FqsoUXC4chiHUYKgHHPqORVkmXe6fLaORIuV7OvSqqs8TblYj3FZNFp3J0kjl4OI3/8dP8AhQylDhhipKEyQalWfs4z796LDTLMTBvunNWUBOKzZaLWn7LLVLa+jjUyQyB8Ho2PWtq7utR8Tazm6nd5bhi8jjoigc4HbgYqHq7jWht+EI20HxHrUMe5XSIQkk5PJBPP4VtXEzOxJOSa3pK6uRN9DkfFGs/Z4TZwN++kHzkfwr/ia4nrTk9SUOAycAV9HfDXwrD4P8LPqeohYry6j86dnGPJjAyF/Lk+/wBKxquyLitTyjxLrsnirxNcahJlbdDsgQnhUHT8T1P1qt5Tf3DXTF+zikEaftG2ec06PiQfWpRmeoaVdlbG3J5j2Dj8K2/sy7XMWI5HwSwHX61yqTu0dLSsmUJQMlJwEcD738J96z7rTkmZWIxIpyrDsa3izGSMuQzW0nl3Y4JAWYdG+o7UksCyRkHlWXGR6Gt07mLQ6e0LQrJwy4ww9uMf1rnLzT4xOywHY2cBG6McA4B/HpRbQE7MzHiKsVIKsOqmljuHjGxhvT+6e309KzaLROqrKMxNn1Q/eH+NNxUjFBKnI4NW4bsqQHGR6ipauUmbNqiyJ5meldh8P2t/7euxOV+SykY5PVtygAfTJrLuWX5liTxbr0kJBR5U5H+7n+oqhrOqpptm0rEGQ8Ivqa6aekLmUviPOJppLiZ5ZWLO5ySaaKkZ6N8JfB39v65/al5HnT7Bg2GHEsnZfoOp/D1ruPi34mMVtH4ftZBvn+e5KtyqDop+vX6D3rJLmqJFXtFs8ysbFTHvkJESHexPtzitT7VL/wA+cn5Gt6j94ulG8D//2QD/7AARRHVja3kAAQAEAAAAMgAA/+EzfWh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8APD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4NCjx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4NCgk8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPg0KCQk8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJXaW5kb3dzIFBob3RvIEVkaXRvciAxMC4wLjEwMDExLjE2Mzg0IiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjNFQzBBQzY2MkI4RTExRTJBQ0FBODgyMTUzNkE1RjNGIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjNFQzBBQzY3MkI4RTExRTJBQ0FBODgyMTUzNkE1RjNGIj4NCgkJCTx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZCRjNERTU3MkI4RDExRTJBQ0FBODgyMTUzNkE1RjNGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkZCRjNERTU4MkI4RDExRTJBQ0FBODgyMTUzNkE1RjNGIi8+DQoJCQk8eG1wOkNyZWF0ZURhdGU+MjAxOS0wMi0xOVQxMDozOTo0OC40OTI8L3htcDpDcmVhdGVEYXRlPjwvcmRmOkRlc2NyaXB0aW9uPg0KCTwvcmRmOlJERj4NCjwveDp4bXBtZXRhPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPD94cGFja2V0IGVuZD0ndyc/Pv/tAGRQaG90b3Nob3AgMy4wADhCSU0EBAAAAAAALBwBWgADGyVHHAIAAAIAAhwCNwAIMjAxOTAyMTkcAjwACzEwMzk0OCswMDAwOEJJTQQlAAAAAAAQPZKPGgtz2bMhzBJEo9ub3//bAEMAAwICAwICAwMDAwQDAwQFCAUFBAQFCgcHBggMCgwMCwoLCw0OEhANDhEOCwsQFhARExQVFRUMDxcYFhQYEhQVFP/bAEMBAwQEBQQFCQUFCRQNCw0UFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFP/AABEIAzACgQMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK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",
            "scaling": "targetWidth",
            "pressedData": {
              "x": 0,
              "y": 0
            },
            "releasedData": {
              "x": 0,
              "y": 0
            },
            "overData": {
              "x": 0,
              "y": 0
            },
            "leftData": {
              "x": 0,
              "y": 0
            }
          },
          "meta": {
            "editorX": 506,
            "editorY": 47,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": [],
            "pressed": [],
            "released": [],
            "over": [],
            "imageSet": []
          }
        },
        {
          "name": "Calibrate",
          "type": "AppUIButton",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "320": {
                "560": {
                  "width": 50,
                  "height": 30,
                  "x": 10,
                  "y": 500,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "768": {
                "1024": {
                  "width": 100,
                  "height": 100,
                  "x": 0,
                  "y": 0,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "1366": {
                  "width": 100,
                  "height": 100,
                  "x": 0,
                  "y": 0,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "labelText": "Calibrate",
            "labelFont": "10px Helvetica",
            "labelColor": "black",
            "pressedData": {
              "x": 0,
              "y": 0
            },
            "releasedData": {
              "x": 0,
              "y": 0
            },
            "overData": {
              "x": 0,
              "y": 0
            },
            "leftData": {
              "x": 0,
              "y": 0
            }
          },
          "meta": {
            "editorX": 30,
            "editorY": 0,
            "lastTrigger": "pressed"
          },
          "triggers": {
            "triggered": [],
            "pressed": [
              {
                "mapping": {
                  "value": {
                    "code": "1"
                  }
                },
                "targetOrder": [
                  "value"
                ],
                "targetElement": "Calibrat",
                "targetAbility": "write"
              }
            ],
            "released": [],
            "over": []
          }
        },
        {
          "name": "Calibrat",
          "type": "AppBLECharacteristicCustom",
          "variants": [
            "app",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "readData": null,
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(Calibrat, instance),\n\t\t&ATMO_VARIABLE(Calibrat, bleServiceHandle), \n\t\tATMO_PROPERTY(Calibrat, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(Calibrat, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(Calibrat, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(Calibrat, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(Calibrat, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(Calibrat, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(Calibrat, writeDataType), ATMO_PROPERTY(Calibrat, readDataType), ATMO_PROPERTY(Calibrat, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(Calibrat, instance),\n\t\t&ATMO_VARIABLE(Calibrat, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(Calibrat, bleServiceHandle), \n\t\tATMO_PROPERTY(Calibrat, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(Calibrat, instance),\n\t\tATMO_VARIABLE(Calibrat, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(Calibrat, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(Calibrat, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(Calibrat, instance),\n\t\tATMO_VARIABLE(Calibrat, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(Calibrat, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "ATMO_DRIVERINSTANCE_BLE_BLE1",
            "bleServiceUuid": "ec7b5b0c-37dc-4db1-944c-a7f76cf75f55",
            "bleCharacteristicUuid": "ec7b5b0c-37dc-4db1-944c-a7f76cf75f58",
            "read": true,
            "write": true,
            "notify": false,
            "readDataType": "ATMO_DATATYPE_INT",
            "writeDataType": "ATMO_DATATYPE_INT",
            "notifyDataType": "ATMO_DATATYPE_INT"
          },
          "meta": {
            "editorX": 125,
            "editorY": 0,
            "lastTrigger": "read"
          },
          "triggers": {
            "triggered": [],
            "read": [],
            "written": [],
            "notification": [],
            "indication": [],
            "subscribed": [],
            "unsubscribed": []
          },
          "coupledElementName": "Calibrat",
          "coupledElementPlaneName": "ST SensorTile"
        },
        {
          "name": "BLEAccelX",
          "type": "AppBLECharacteristicCustom",
          "variants": [
            "app",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "readData": null,
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(BLEAccelX, instance),\n\t\t&ATMO_VARIABLE(BLEAccelX, bleServiceHandle), \n\t\tATMO_PROPERTY(BLEAccelX, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(BLEAccelX, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(BLEAccelX, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(BLEAccelX, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(BLEAccelX, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(BLEAccelX, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(BLEAccelX, writeDataType), ATMO_PROPERTY(BLEAccelX, readDataType), ATMO_PROPERTY(BLEAccelX, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(BLEAccelX, instance),\n\t\t&ATMO_VARIABLE(BLEAccelX, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(BLEAccelX, bleServiceHandle), \n\t\tATMO_PROPERTY(BLEAccelX, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(BLEAccelX, instance),\n\t\tATMO_VARIABLE(BLEAccelX, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(BLEAccelX, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(BLEAccelX, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(BLEAccelX, instance),\n\t\tATMO_VARIABLE(BLEAccelX, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(BLEAccelX, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "ATMO_DRIVERINSTANCE_BLE_BLE1",
            "bleServiceUuid": "ec7b5b0c-37dc-4db1-944c-a7f76cf75f55",
            "bleCharacteristicUuid": "ec7b5b0c-37dc-4db1-944c-a7f76cf75f56",
            "read": true,
            "write": true,
            "notify": false,
            "readDataType": "ATMO_DATATYPE_FLOAT",
            "writeDataType": "ATMO_DATATYPE_FLOAT",
            "notifyDataType": "ATMO_DATATYPE_STRING"
          },
          "meta": {
            "editorX": 120,
            "editorY": 136,
            "lastTrigger": "read"
          },
          "triggers": {
            "triggered": [],
            "read": [
              {
                "mapping": {
                  "text": {
                    "code": "\"X: \" + readData.toFixed(2)"
                  }
                },
                "targetOrder": [
                  "text"
                ],
                "targetElement": "LabelAccX",
                "targetAbility": "setText"
              },
              {
                "mapping": {
                  "value": {
                    "code": "readData"
                  }
                },
                "targetOrder": [
                  "value"
                ],
                "targetElement": "AccelEvent",
                "targetAbility": "send"
              }
            ],
            "written": [],
            "notification": [],
            "indication": [],
            "subscribed": [],
            "unsubscribed": []
          },
          "coupledElementName": "BLEAccelX",
          "coupledElementPlaneName": "ST SensorTile"
        },
        {
          "name": "BLEAccelY",
          "type": "AppBLECharacteristicCustom",
          "variants": [
            "app",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "readData": null,
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(BLEAccelY, instance),\n\t\t&ATMO_VARIABLE(BLEAccelY, bleServiceHandle), \n\t\tATMO_PROPERTY(BLEAccelY, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(BLEAccelY, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(BLEAccelY, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(BLEAccelY, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(BLEAccelY, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(BLEAccelY, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(BLEAccelY, writeDataType), ATMO_PROPERTY(BLEAccelY, readDataType), ATMO_PROPERTY(BLEAccelY, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(BLEAccelY, instance),\n\t\t&ATMO_VARIABLE(BLEAccelY, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(BLEAccelY, bleServiceHandle), \n\t\tATMO_PROPERTY(BLEAccelY, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(BLEAccelY, instance),\n\t\tATMO_VARIABLE(BLEAccelY, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(BLEAccelY, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(BLEAccelY, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(BLEAccelY, instance),\n\t\tATMO_VARIABLE(BLEAccelY, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(BLEAccelY, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "ATMO_DRIVERINSTANCE_BLE_BLE1",
            "bleServiceUuid": "ec7b5b0c-37dc-4db1-944c-a7f76cf75f55",
            "bleCharacteristicUuid": "ec7b5b0c-37dc-4db1-944c-a7f76cf75f59",
            "read": true,
            "write": true,
            "notify": false,
            "readDataType": "ATMO_DATATYPE_FLOAT",
            "writeDataType": "ATMO_DATATYPE_FLOAT",
            "notifyDataType": "ATMO_DATATYPE_STRING"
          },
          "meta": {
            "editorX": 122,
            "editorY": 212,
            "lastTrigger": "read"
          },
          "triggers": {
            "triggered": [],
            "read": [
              {
                "mapping": {
                  "text": {
                    "code": "\"Y: \" + readData.toFixed(2)"
                  }
                },
                "targetOrder": [
                  "text"
                ],
                "targetElement": "LabelAccY",
                "targetAbility": "setText"
              },
              {
                "mapping": {
                  "value": {
                    "code": "readData"
                  }
                },
                "targetOrder": [
                  "value"
                ],
                "targetElement": "CloudEvent",
                "targetAbility": "send"
              }
            ],
            "written": [],
            "notification": [],
            "indication": [],
            "subscribed": [],
            "unsubscribed": []
          },
          "coupledElementName": "BLEAccelY",
          "coupledElementPlaneName": "ST SensorTile"
        },
        {
          "name": "BLEAccelZ",
          "type": "AppBLECharacteristicCustom",
          "variants": [
            "app",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "readData": null,
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(BLEAccelZ, instance),\n\t\t&ATMO_VARIABLE(BLEAccelZ, bleServiceHandle), \n\t\tATMO_PROPERTY(BLEAccelZ, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(BLEAccelZ, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(BLEAccelZ, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(BLEAccelZ, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(BLEAccelZ, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(BLEAccelZ, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(BLEAccelZ, writeDataType), ATMO_PROPERTY(BLEAccelZ, readDataType), ATMO_PROPERTY(BLEAccelZ, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(BLEAccelZ, instance),\n\t\t&ATMO_VARIABLE(BLEAccelZ, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(BLEAccelZ, bleServiceHandle), \n\t\tATMO_PROPERTY(BLEAccelZ, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(BLEAccelZ, instance),\n\t\tATMO_VARIABLE(BLEAccelZ, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(BLEAccelZ, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(BLEAccelZ, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(BLEAccelZ, instance),\n\t\tATMO_VARIABLE(BLEAccelZ, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(BLEAccelZ, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "ATMO_DRIVERINSTANCE_BLE_BLE1",
            "bleServiceUuid": "ec7b5b0c-37dc-4db1-944c-a7f76cf75f55",
            "bleCharacteristicUuid": "ec7b5b0c-37dc-4db1-944c-a7f76cf75f5a",
            "read": true,
            "write": true,
            "notify": false,
            "readDataType": "ATMO_DATATYPE_FLOAT",
            "writeDataType": "ATMO_DATATYPE_FLOAT",
            "notifyDataType": "ATMO_DATATYPE_STRING"
          },
          "meta": {
            "editorX": 133,
            "editorY": 291,
            "lastTrigger": "read"
          },
          "triggers": {
            "triggered": [],
            "read": [
              {
                "mapping": {
                  "text": {
                    "code": "\"Z: \" + readData.toFixed(2)"
                  }
                },
                "targetOrder": [
                  "text"
                ],
                "targetElement": "LabelAccZ",
                "targetAbility": "setText"
              },
              {
                "mapping": {
                  "value": {
                    "code": "readData"
                  }
                },
                "targetOrder": [
                  "value"
                ],
                "targetElement": "CloudEvent1",
                "targetAbility": "send"
              },
              {
                "mapping": {
                  "value": {
                    "code": "readData"
                  }
                },
                "targetOrder": [
                  "value"
                ],
                "targetElement": "AnalogMeter",
                "targetAbility": "setValue"
              }
            ],
            "written": [],
            "notification": [],
            "indication": [],
            "subscribed": [],
            "unsubscribed": []
          },
          "coupledElementName": "BLEAccelZ",
          "coupledElementPlaneName": "ST SensorTile"
        },
        {
          "name": "CloudEvent",
          "type": "AppCloudEvent",
          "variants": [
            "app"
          ],
          "properties": {
            "errorData": null
          },
          "meta": {
            "editorX": 346,
            "editorY": 206,
            "lastTrigger": "sent"
          },
          "triggers": {
            "triggered": [],
            "sent": []
          }
        },
        {
          "name": "CloudEvent1",
          "type": "AppCloudEvent",
          "variants": [
            "app"
          ],
          "properties": {
            "errorData": null
          },
          "meta": {
            "editorX": 341,
            "editorY": 306,
            "lastTrigger": "sent"
          },
          "triggers": {
            "triggered": [],
            "sent": []
          }
        },
        {
          "name": "Image1",
          "type": "AppUIImage",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "320": {
                "560": {
                  "width": 325,
                  "height": 90,
                  "x": -5,
                  "y": 0,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "768": {
                "1024": {
                  "width": 100,
                  "height": 100,
                  "x": 0,
                  "y": 0,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "1366": {
                  "width": 100,
                  "height": 100,
                  "x": 0,
                  "y": 0,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUAAAABwCAYAAABvnamzAAAAh3pUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjaVY7RDcQwCEP/meJGIEAMjHOqGqkbdPwjSqte34exLLCg/TwGfSaNhax7IAEuLC3lWyZ4ocxNuM1ZurimtnLyxKSyDDKc7Vm0K7/pisBwc0fHhk2qXXYVjdK6o9nK8438K7mdvnN/dzP9AEKpLCE4XRkWAAAKBmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNC40LjAtRXhpdjIiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iCiAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgZXhpZjpQaXhlbFhEaW1lbnNpb249IjMyMCIKICAgZXhpZjpQaXhlbFlEaW1lbnNpb249IjExMiIKICAgdGlmZjpJbWFnZVdpZHRoPSIzMjAiCiAgIHRpZmY6SW1hZ2VIZWlnaHQ9IjExMiIKICAgdGlmZjpPcmllbnRhdGlvbj0iMSIvPgogPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg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",
            "scaling": "target",
            "pressedData": {
              "x": 0,
              "y": 0
            },
            "releasedData": {
              "x": 0,
              "y": 0
            },
            "overData": {
              "x": 0,
              "y": 0
            },
            "leftData": {
              "x": 0,
              "y": 0
            }
          },
          "meta": {
            "editorX": 606,
            "editorY": 47,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": [],
            "pressed": [],
            "released": [],
            "over": [],
            "imageSet": []
          }
        }
      ]
    },
    "Cloud": {
      "type": "cloud",
      "compilerVersion": "latest",
      "variants": [],
      "meta": {},
      "elements": [
        {
          "name": "PressureEvent",
          "type": "CloudEvent",
          "variants": [
            "cloud"
          ],
          "properties": {
            "errorData": null,
            "value": null
          },
          "meta": {
            "editorX": 100,
            "editorY": 0,
            "lastTrigger": "eventReceived"
          },
          "triggers": {
            "triggered": [],
            "eventReceived": [
              {
                "mapping": {
                  "value": {
                    "code": "value"
                  }
                },
                "targetOrder": [
                  "value"
                ],
                "targetElement": "CloudStorage",
                "targetAbility": "addData"
              }
            ]
          },
          "coupledElementName": "PressureEvent",
          "coupledElementPlaneName": "App View"
        },
        {
          "name": "TempEvent",
          "type": "CloudEvent",
          "variants": [
            "cloud"
          ],
          "properties": {
            "errorData": null,
            "value": null
          },
          "meta": {
            "editorX": 100,
            "editorY": 87,
            "lastTrigger": "eventReceived"
          },
          "triggers": {
            "triggered": [],
            "eventReceived": [
              {
                "mapping": {
                  "value": {
                    "code": "value"
                  }
                },
                "targetOrder": [
                  "value"
                ],
                "targetElement": "CloudStorage1",
                "targetAbility": "addData"
              }
            ]
          },
          "coupledElementName": "TempEvent",
          "coupledElementPlaneName": "App View"
        },
        {
          "name": "CloudStorage",
          "type": "CloudStorage",
          "variants": [
            "cloud"
          ],
          "properties": {
            "errorData": null,
            "value": null
          },
          "meta": {
            "editorX": 234,
            "editorY": 3,
            "lastTrigger": "dataAdded"
          },
          "triggers": {
            "triggered": [],
            "dataAdded": [],
            "dataUpdated": [],
            "dataRemoved": [],
            "dataQueried": []
          }
        },
        {
          "name": "CloudStorage1",
          "type": "CloudStorage",
          "variants": [
            "cloud"
          ],
          "properties": {
            "errorData": null,
            "value": null
          },
          "meta": {
            "editorX": 229,
            "editorY": 90,
            "lastTrigger": "dataAdded"
          },
          "triggers": {
            "triggered": [],
            "dataAdded": [],
            "dataUpdated": [],
            "dataRemoved": [],
            "dataQueried": []
          }
        },
        {
          "name": "AccelEvent",
          "type": "CloudEvent",
          "variants": [
            "cloud"
          ],
          "properties": {
            "errorData": null,
            "value": null
          },
          "meta": {
            "editorX": 105,
            "editorY": 269,
            "lastTrigger": "eventReceived"
          },
          "triggers": {
            "triggered": [],
            "eventReceived": [
              {
                "mapping": {
                  "value": {
                    "code": "value"
                  }
                },
                "targetOrder": [
                  "value"
                ],
                "targetElement": "CloudStorage2",
                "targetAbility": "addData"
              }
            ]
          },
          "coupledElementName": "AccelEvent",
          "coupledElementPlaneName": "App View"
        },
        {
          "name": "CloudStorage2",
          "type": "CloudStorage",
          "variants": [
            "cloud"
          ],
          "properties": {
            "errorData": null,
            "value": null
          },
          "meta": {
            "editorX": 205,
            "editorY": 269,
            "lastTrigger": "dataAdded"
          },
          "triggers": {
            "triggered": [],
            "dataAdded": [],
            "dataUpdated": [],
            "dataRemoved": [],
            "dataQueried": []
          }
        },
        {
          "name": "CloudEvent",
          "type": "CloudEvent",
          "variants": [
            "cloud"
          ],
          "properties": {
            "errorData": null,
            "value": null
          },
          "meta": {
            "editorX": 92,
            "editorY": 373,
            "lastTrigger": "eventReceived"
          },
          "triggers": {
            "triggered": [],
            "eventReceived": [
              {
                "mapping": {
                  "value": {
                    "code": "value"
                  }
                },
                "targetOrder": [
                  "value"
                ],
                "targetElement": "CloudStorage4",
                "targetAbility": "addData"
              }
            ]
          },
          "coupledElementName": "CloudEvent",
          "coupledElementPlaneName": "App View"
        },
        {
          "name": "CloudEvent1",
          "type": "CloudEvent",
          "variants": [
            "cloud"
          ],
          "properties": {
            "errorData": null,
            "value": null
          },
          "meta": {
            "editorX": 98,
            "editorY": 460,
            "lastTrigger": "eventReceived"
          },
          "triggers": {
            "triggered": [],
            "eventReceived": [
              {
                "mapping": {
                  "value": {
                    "code": "value"
                  }
                },
                "targetOrder": [
                  "value"
                ],
                "targetElement": "CloudStorage5",
                "targetAbility": "addData"
              }
            ]
          },
          "coupledElementName": "CloudEvent1",
          "coupledElementPlaneName": "App View"
        },
        {
          "name": "CloudStorage4",
          "type": "CloudStorage",
          "variants": [
            "cloud"
          ],
          "properties": {
            "errorData": null,
            "value": null
          },
          "meta": {
            "editorX": 203,
            "editorY": 361,
            "lastTrigger": "dataAdded"
          },
          "triggers": {
            "triggered": [],
            "dataAdded": [],
            "dataUpdated": [],
            "dataRemoved": [],
            "dataQueried": []
          }
        },
        {
          "name": "CloudStorage5",
          "type": "CloudStorage",
          "variants": [
            "cloud"
          ],
          "properties": {
            "errorData": null,
            "value": null
          },
          "meta": {
            "editorX": 209,
            "editorY": 450,
            "lastTrigger": "dataAdded"
          },
          "triggers": {
            "triggered": [],
            "dataAdded": [],
            "dataUpdated": [],
            "dataRemoved": [],
            "dataQueried": []
          }
        }
      ],
      "layout": {
        "height": 1000,
        "width": 1000,
        "zIndexOrder": []
      }
    }
  }
}